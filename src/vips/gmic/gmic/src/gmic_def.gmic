#@gmic
#
#  File        : update173.gmic
#                ( G'MIC command file )
#
#  Description : Update file for G'MIC commands and filters (for version 1.7.3).
#                ( http://gmic.eu )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#

#@gmic :: Global options
cli_noarg :
-use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -version
-v + -e[] "\n[gmic] No commands, options or data provided (type "$c"'gmic -h'"$n" to get help)." -v -
file_update=${_path_rc}cli_update$_version.gmic
need_update={"Y = date(0); M = date(1); D = date(2); date_current = Y*365 + M*31 + D;
Y = date(0,"$file_update"); M = date(1,"$file_update"); D = date(2,"$file_update"); date_file = Y*365 + M*31 + D;
date_current - date_file>=7"}
-if $need_update
-v + -e[] "[gmic] Update commands..." -v -
-l[] -update
-v + -e[] "\r[gmic] Update commands: "${g}"Success."$n -v -
-onfail
-v + -e[] "\r[gmic] Update commands: "${r}"Failed!"$n -v -
-endl
-endif
-if {{*,u}>0}
-v + -e[] "[gmic] "${c}"Running in demo mode."$n -v - -demo , -e[] ""
-else
-v + -e[] "\n"
-endif -v -
cli_start :
#@gmic debug : (+)
#@gmic : Activate debug mode.
#@gmic : When activated, the G'MIC interpreter becomes very verbose and outputs additionnal log
#@gmic : messages about its internal state on the standard output (stdout).
#@gmic : This option is useful for developers or to report possible bugs of the interpreter.
#@gmic h : eq. to '-help'.
h :
-help $*
#@gmic help : command : (no arg)
#@gmic : Display help (optionally for specified command only) and exit.
#@gmic : (eq. to '-h').
help : -skip ${1=""},${2=1}
-if {!$!} -return -endif
-y -a y
--_help $1,$2 -k[0]
-if {narg(${})} -_help[0] ${},0 -endif
-rm
_help : -skip ${1=""}
-v -1 -use_vt100
-if {!narg("$1")} _is_example=0 -__help ascii -v + -e[] "" -v - -rm -u "" -return -endif
({'"$1"'}) -autocrop. {'-'}
-if {{@100%}==_']'" && "i!=_'['} -l. -s -,{'['} -k[0] -endl -endif
command={t} -rm.
ks0="0" ks1="-k[0]"
-if $2 -__help_header_ascii[] -endif
-r 1,{h+1},1,1,0,0,0,1
-s +,{'"#@gmic "$command" :"'} -s +,{'"#@gmic "$command":"'} -s +,{'"#@gmic "$command"\n"'}
-if {$!==1}
-l[] -m "foo : -"$command
-repeat 16 -uncommand $command -done
-foo -uncommand foo
-onfail ({'${}'}) -s -,{'" (did you mean "'} -if {$!>1} -s[1] -,39 -k[1] misspelling={t} -endif -rm
-endl
-if {narg($misspelling)} misspelling=" (did you mean '"$misspelling"' ?)" -endif
-v + -e[] "\n[gmic] Command '"$command"' has no description"$misspelling". Try 'gmic -h' for global help.\n\n" -v -
-rm -u "" -return
-endif
-rm[0] -a y -s -,10
stopflag=0
_is_example=0
-_document_gmic_header_ascii[] 0
-repeat $! -l[$>] -if {h>7" && "same([{^}],'#@gmic',6)}
-rows 7,100% -autocrop {'" "'}
-if {i!=_':'}
-s -,{'": "'} -autocrop {'" "'} -autocrop {':'} -autocrop {'" "'}
-if {['{0,t}']==['$command']}
-_document_gmic_declaration_ascii
-if $_shortcut
-v + -e[] "\n    "$_gmic_m$_gmic_b"-"$command":"$_gmic_n$_gmic_m" Equivalent to '"$_gmic_b$_shortcutlink0$_gmic_n"'." -v -
-u $_shortcutlink0 -return
-endif
-else stopflag=1
-endif
-else
-rows 1,100%
-if {i==_':'} stopflag=1
-else
_is_tutorial=
-autocrop {'" "'}
-if {i==_'$'}
-rows 1,100% -autocrop {'" "'}
-if {i==_'$'}
-v + -e[] "" -v -
-if {h==1" && "i==_'$'} tuturl=http://gmic.eu/tutorial/_$command.shtml
-else -autocrop {'$'} -autocrop {'" "'} tuturl=http://gmic.eu/tutorial/{0,t}.shtml
-endif
-rm ({'$_gmic_c${_gmic_b}"Tutorial:"$_gmic_n$_gmic_c" "$tuturl'}) -y
_is_tutorial=1
-else
-if $_is_example -i[0] ({'"         "'})
-else -i[0] ({'"\n        "$_gmic_c${_gmic_b}"Example: "$_gmic_n$_gmic_c'}) _is_example=1 -endif
-y[0] -a y
-endif
-endif
-_document_gmic_description_ascii
-endif
-endif
-else stopflag=1 -endif ${ks{$!!=0}} -endl -if $stopflag -break -endif -done
-v + -e[] $_gmic_n"\n" -v - -rm
-u ""
__help :
-m "_help_section : -_help_section_$1 \"$""1\""
-m "_help_paragraph : -_help_paragraph_$1 \"$""1\""
-_help_header_$1[]
-_help_usage[]
-s -,{'__help_end\ :'} -k[0]
-document_gmic $1,"img/",0
-_help_examples[]
-_help_footer_$1[]
_help_usage :
-m "GMIC : -u ${_gmic_g}G\47MIC$_gmic_n"
g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r
-_help_paragraph "    "$c${b}"gmic [-command1 [arg1_1,arg1_2,..]] .. [-commandN [argN_1,argN_2,..]]"$n"
\n
\n    '"${g}"gmic"$n"' is the open-source interpreter of the "${-GMIC}" language, a script-based programming
\n    language dedicated to the design of possibly complex image processing pipelines.
\n    It can be used to convert, manipulate, filter and visualize image datasets made of one
\n    or several 1d/2d or 3d multi-spectral images.
\n
\n    This reference documentation describes the rules and technical aspects of the "${-GMIC}" language.
\n    You may be also interested by our detailed tutorial pages, at: "${r}"http://gmic.eu/tutorial/"$n
-_help_section "Overall context"
-_help_paragraph "  - At any time, "${-GMIC}" manages one list of numbered (and optionally named) pixel-based
\n     images, entirely stored in computer memory.
\n
\n  - The first image of the list has indice '"${g}"0"$n"' and is denoted by '"$c"[0]"$n"'. The second image of
\n     the list is denoted by '"$c"[1]"$n"', the third by '"$c"[2]"$n"' and so on.
\n
\n  - Negative indices are treated in a periodic way: '"$c"[-1]"$n"' refers to the last image of the
\n     list, '"$c"[-2]"$n"' to the penultimate one, etc. Thus, if the list has 4 images, '"$c"[1]"$n"' and '"$c"[-3]"$n"'
\n     both designate the second image of the list.
\n
\n  - A named image may be indicated by '"$c"[name]"$n"', if '"${g}"name"$n"' uses the character set "$g"[a-zA-Z0-9_]"$n"
\n     and does not start with a number. Image names can be set or reassigned at any moment
\n     during the processing pipeline (see commands '"$c"-name"$n"' and '"$c"-input"$n"' for this purpose).
\n
\n  - "${-GMIC}" defines a set of various commands and substitution mechanisms to allow the design
\n     of complex pipelines managing this list of images, in a very flexible way:
\n     You can insert or remove images in the list, rearrange image indices, process images
\n     (individually or grouped), merge image data together, display and output image files, etc.
\n
\n  - Such a pipeline can be written itself as a custom "${-GMIC}" command storable in a user
\n     command file, and can be re-used afterwards in another pipeline if necessary."
-_help_section "Image definition and terminology"
-_help_paragraph "  - In "${-GMIC}", each image is modeled as a 1d, 2d, 3d or 4d array of scalar values, uniformly
\n     discretized on a rectangular/parallelepipedic domain.
\n
\n  - The four dimensions of this array are respectively denoted by:
\n
\n    . '"${g}"width"$n"', the number of image columns (size along the "$g"'x'-axis"$n").
\n    . '"${g}"height"$n"', the number of image rows (size along the "$g"'y'-axis"$n").
\n    . '"${g}"depth"$n"', the number of image slices (size along the "$g"'z'-axis"$n").
\n        The depth is equal to 1 for usual color or grayscale 2d images.
\n    . '"${g}"spectrum"$n"', the number of image channels (size along the "$g"'c'-axis"$n").
\n        The spectrum is respectively equal to 3 and 4 for usual RGB and RGBA color images.
\n
\n  - There are no limitations on the size of each image dimension. For instance, the number of
\n     image slices or channels can be of arbitrary size within the limits of available memory.
\n
\n  - The "${g}"width, height"$n" and "${g}"depth"$n" of an image are considered as spatial dimensions, while the
\n     "${g}"spectrum"$n" has a multi-spectral meaning. Thus, a 4d image in "${-GMIC}" should be most often
\n     regarded as a 3d dataset of multi-spectral voxels. Most of the "${-GMIC}" commands will stick
\n     with this idea (e.g. command '"$c"-blur"$n"' blurs images only along the spatial '"${g}"xyz"$n"'-axes).
\n
\n  - "${-GMIC}" stores all the image data as buffers of '"${g}"float"$n"' values (32 bits,
\n     value range "$g"[-3.4E38,+3.4E38]"$n"). It performs all its image processing operations with
\n     floating point numbers. Each image pixel takes then 32bits/channel (except if double-
\n     precision buffers have been enabled during the compilation of the software, in which case
\n     64bits/channel is the default).
\n
\n  - Considering '"${g}"float"$n"'-valued pixels ensure to keep the numerical precision when executing
\n     image processing pipelines. For image input/output operations, you may want to prescribe
\n     the image datatype to be different than '"${g}"float"$n"' (like '"${g}"bool"$n"', '"${g}"char"$n"', '"${g}"int"$n"', etc...).
\n     This is possible by specifying it as a file option when using I/O commands.
\n     (see section '"${c}"Input/output properties"$n"' to learn more about file options)."
-_help_section "Items of a processing pipeline"
-_help_paragraph "  - In "${-GMIC}", an image processing pipeline is described as a sequence of items separated by
\n     the space character ' '. Such items are interpreted and executed from the left to the
\n     right. For instance, the expression:
\n
\n       "${c}"filename.jpg -blur 3,0 -sharpen 10 -resize 200%,200% -output output.jpg"$n"
\n
\n     defines a valid pipeline composed of nine "${-GMIC}" items.
\n
\n  - Each "${-GMIC}" item is a string that is either a command, a list of command arguments,
\n     a filename, or a special input string.
\n
\n  - Escape characters '"$g"\\"$n"' and double quotes '"$g"\""$n"' can be used to define items containing
\n     spaces or other special characters. For instance, the two strings
\n     '"${c}"single\\ item"$n"' and '"${c}"\"single item\""$n"' define the same single item, with a space in it."
-_help_section "Input data items"
-_help_paragraph "  - If a specified "${-GMIC}" item appears to be an existing filename, the corresponding image
\n     data are loaded and inserted at the end of the image list (which is equivalent to the
\n     use of '"$c"-input filename"$n"').
\n
\n  - Special filenames '"$c"-"$n"' and '"$c"-.ext"$n"' stand for the standard input/output streams, optionally
\n     forced to be in a specific '"${g}"ext"$n"' file format (e.g. '"$c"-.jpg"$n"' or '"$c"-.png"$n"').
\n
\n  - The following special input strings may be used as "${-GMIC}" items to create and insert new
\n     images with prescribed values, at the end of the image list:
\n
\n    . '"$c"[selection]"$n"' or '"$c"[selection]xN"$n"': Insert 1 or N copies of already existing images.
\n       '"${g}"selection"$n"' may represent one or several images
\n       (see section '"${c}"Command items and selections"$n"' to learn more about selections).
\n
\n    . '"${c}"width[%],_height[%],_depth[%],_spectrum[%],_values"$n"': Insert a new image with
\n       specified size and values (adding '"$g"%"$n"' to a dimension means 'percentage of the size
\n       along the same axis, taken from the last image '"$g"[-1]"$n"''). Any specified dimension
\n       can be also written as '"$c"[image]"$n"', and is then set to the size (along the same axis)
\n       of the existing specified image "$g"[image]"$n". '"${g}"values"$n"' can be either a sequence of numbers
\n       separated by commas '"$g","$n"', or a mathematical expression, as e.g. in input item
\n       '"${c}"256,256,1,3,if(c==0,x,if(c==1,y,0))"$n"' which creates a 256x256 RGB color image with a
\n       spatial shading on the red and green channels.
\n       (see section '"${c}"Mathematical expressions"$n"' to learn more about mathematical expressions).
\n
\n    . '"$c"(v1,v2,..)"$n"': Insert a new image from specified prescribed values.
\n       Value separator inside parentheses can be '"$g","$n"' (column separator), '"$g";"$n"' (row separator),
\n       '"$g"/"$n"' (slice separator) or '"$g"^"$n"' (channel separator). For instance, expression
\n       '"$c"(1,2,3;4,5,6;7,8,9)"$n"' creates a 3x3 matrix (scalar image), with values running from 1 to 9.
\n
\n    . '"${c}"0"$n"': Insert a new '"${g}"empty"$n"' image, containing no pixel data. Empty images are used only
\n       in rare occasions.
\n
\n  - Input item '"${c}"name=value"$n"' declares a new local or global variable '"${g}"name"$n"', or assign a new
\n     value to an existing variable. Variable names must use the character set "$g"[a-zA-Z0-9_]"$n" and
\n     cannot start with a number.
\n
\n  - A variable definition is always local to the current command except when it starts by the
\n     underscore character '"${g}"_"$n"'. In that case, it becomes also accessible by any command invoked
\n     outside the current command scope (global variable).
\n
\n  - If a variable name starts with two underscores '"${g}"__"$n"', the global variable is also shared
\n     among different threads and can be read/set by commands running in parallel (see command
\n     '"${c}"-parallel"$n"' for this purpose). Otherwise, it remains local to the thread that defined it.
\n
\n  - Numerical variables can be updated with the use of these special operators:
\n    '"${g}"+="$n"' (addition), '"${g}"-="$n"' (subtraction), '"${g}"*="$n"' (multiplication), '"${g}"/="$n"' (division), '"${g}"%="$n"' (modulo),
\n    '"${g}"&="$n"' (bitwise and), '"${g}"|="$n"' (bitwise or), '"${g}"^="$n"' (power), '"${g}"<<="$n"' and '"${g}">>="$n"' (bitwise left
\n    and right shifts). As in: '"${c}"foo=1 foo+=3"$n"'.
"
-_help_section "Command items and selections"
-_help_paragraph "  - A "${-GMIC}" item starting by a hyphen '"$g"-"$n"' designates a "${g}"command"$n", most of the time. Generally,
\n     commands perform image processing operations on one or several available images of the list.
\n
\n  - Reccurent commands have two equivalent names ("${g}"regular"$n" and "${g}"short"$n"). For instance, command
\n     names '"$c"-resize"$n"' and '"$c"-r"$n"' refer to the same image resizing action.
\n
\n  - A "${-GMIC}" command may have mandatory or optional "${g}"arguments"$n". Command arguments must be
\n     specified in the next item on the command line. Commas '"$g","$n"' are used to separate multiple
\n     arguments of a single command, when required.
\n
\n  - The execution of a "${-GMIC}" command may be restricted only to a "${g}"subset"$n" of the image list, by
\n     appending '"$c"[selection]"$n"' to the command name. Examples of valid syntaxes for '"${g}"selection"$n"' are:
\n
\n    . '"$c"-command[-2]"$n"': Apply command only on the penultimate image "$g"[-2]"$n" of the list.
\n    . '"$c"-command[0,1,3]"$n"': Apply command only on images "$g"[0],[1]"$n" and "$g"[3]"$n".
\n    . '"$c"-command[3-6]"$n"': Apply command only on images "$g"[3]"$n" to "$g"[6]"$n" (i.e, "$g"[3],[4],[5]"$n" and "$g"[6]"$n").
\n    . '"$c"-command[50%-100%]"$n"': Apply command only on the second half of the image list.
\n    . '"$c"-command[0,-4--1]"$n"': Apply command only on the first image and the last four images.
\n    . '"$c"-command[0-9:3]"$n"': Apply command only on images "$g"[0]"$n" to "$g"[9]"$n", with a step of 3
\n                          (i.e. on images "$g"[0], [3], [6]"$n" and "$g"[9]"$n").
\n    . '"$c"-command[0--1:2]"$n"': Apply command only on images of the list with even indices.
\n    . '"$c"-command[0,2-4,50%--1]"$n"': Apply command on images "$g"[0],[2],[3],[4]"$n" and on the second half
\n                             of the image list.
\n    . '"$c"-command[^0,1]"$n"': Apply command on all images except the two first.
\n    . '"$c"-command[name1,name2]"$n"': Apply command on named images '"${g}"name1"$n"' and '"${g}"name2"$n"'.
\n
\n  - Indices in selections are always sorted in increasing order, and duplicate indices are
\n     discarded. For instance, selections '"$c"[3-1,1-3]"$n"' and '"$c"[1,1,1,3,2]"$n"' are both equivalent to
\n     '"$c"[1-3]"$n"'. If you want to repeat a single command multiple times on an image, use a
\n     '"$c"-repeat..-done"$n"' loop instead. Inverting the order of images for a command is achieved by
\n     explicitly inverting  the order of the images in the list, with command '"$c"-reverse[selection]"$n"'.
\n
\n  - Command selections '"$c"[-1]"$n"','"$c"[-2]"$n"' and '"$c"[-3]"$n"' are so often used that they have their own shortcuts,
\n    respectively '"$c"."$n"', '"$c".."$n"' and '"$c"..."$n"'. For instance, command '"$c"-blur.."$n"' is equivalent to '"$c"-blur[-2]"$n"'.
\n    These shortcuts work only for command selections, not for command arguments.
\n
\n  - "${-GMIC}" commands invoked without '"$c"[selection]"$n"' are applied on all images of the list, i.e. the
\n     default selection is '"$c"[0--1]"$n"' (except for command '"$c"-input"$n"' whose default selection is '"$c"[-1]"$n"').
\n
\n  - A "${-GMIC}" command starting with a double hyphen '"$g"--"$n"' (instead of a single hyphen '"$g"-"$n"') does not act
\n     'in-place' but inserts its result as one or several new images at the end of the image list.
\n
\n  - There are two different types of commands that can be run by the "${-GMIC}" interpreter:
\n
\n    . "${g}"Native commands"$n", are the hard-coded functionalities in the interpreter core.
\n       They are thus compiled as binary code and run fast, most of the time.
\n       Omitting an argument when invoking a native command is not permitted, except if all
\n       following arguments are also omitted. For instance, call to '"$c"-plasma 10,,5"$n"' is invalid
\n       but '"$c"-plasma 10"$n"' is correct.
\n    . "${g}"Custom commands"$n", are defined as "${-GMIC}" pipelines of native or custom commands.
\n       They are interpreted by the "${-GMIC}" interpreter, and thus run a bit slower than native commands.
\n       Omitting arguments when invoking a custom command is permitted. For instance,
\n       expressions '"$c"-flower ,,,100,,2"$n"' or '"$c"-flower ,"$n"' are correct.
\n
\n  - Most of the existing commands in "${-GMIC}" are actually defined as "${g}"custom commands"$n".
\n
\n  - A user can easily add its own custom commands to the "${-GMIC}" interpreter (see section
\n     "${c}"'Adding custom commands"$n"' for more details). New native commands cannot be added
\n     (unless you modify the "${-GMIC}" interpreter source code and recompile it, of course!)."
-_help_section "Input/output properties"
-_help_paragraph "  - "${-GMIC}" is able to read/write most of the classical image file formats, including:
\n
\n    . 2d grayscale/color files: "$c".png, .jpeg, .gif, .pnm, .tif, .bmp, .."$n"
\n    . 3d volumetric files: "$c".dcm, .hdr, .nii, .pan, .inr, .pnk, .."$n"
\n    . video files: "$c".mpeg, .avi, .mov, .ogg, .flv, .."$n"
\n    . Generic ascii or binary data files: "$c".gmz, .cimg, .cimgz, .dlm, .asc, .pfm, .raw, .txt, .h."$n"
\n    . 3d object files: "$c".off."$n"
\n
\n  - When dealing with color images, "${-GMIC}" generally reads, writes and displays data using the
\n     usual sRGB color space.
\n
\n  - "${-GMIC}" is able to manage "${g}"3d objects"$n" that may be read from files or generated by "${-GMIC}"
\n     commands. A 3d object is stored as a one-column scalar image containing the object data,
\n     in the following order: "$g"{ magic_number; sizes; vertices; primitives; colors; opacities }"$n".
\n     These 3d representations can be processed as regular images.
\n     (see command '"$c"-split3d"$n"' for accessing each of these 3d object data separately).
\n
\n  - Be aware that usual file formats may be sometimes not adapted to store all the available
\n     image data, since "${-GMIC}" uses float-valued image buffers. For instance, saving an image
\n     that was initially loaded as a 16bits/channel image, as a "$c".jpg"$n" file will result in a
\n     loss of information. Use the "${-GMIC}"-specific file extensions "$c".cimgz"$n" or "$c".gmz"$n" to ensure
\n     that all data precision are preserved when saving images.
\n
\n  - Sometimes, file options may/must be set for file formats:
\n
\n    . "${g}"Video files:"$n" Only sub-frames of an image sequence may be loaded, using the input
\n       expression '"${c}"filename.ext,[first_frame[,last_frame[,step]]]"$n"'.
\n       Set '"${g}"last_frame==-1"$n"' to tell it must be the last frame of the video.
\n       Set '"${g}"step"$n"' to 0 to force an opened video file to be opened/closed.
\n       Output framerate and codec can be also set by using the output expression
\n       '"${c}"filename.avi,_fps,_codec,_keep_open={ 0 | 1 }"$n"'.
\n       '"${g}"codec"$n"' is a 4-char string (see "${r}"http://www.fourcc.org/codecs.php"$n") or '"${g}"0"$n"' for the default codec.
\n       '"${g}"keep_open"$$n"' tells if the output video file must be kept open for appending new frames afterwards.
\n
\n    . "$g".cimg[z] files:"$n" Only crops and sub-images of .cimg files can be loaded, using the input
\n      expressions '"${c}"filename.cimg,N0,N1"$n"', '"${c}"filename.cimg,N0,N1,x0,x1"$n"',
\n      '"${c}"filename.cimg,N0,N1,x0,y0,x1,y1"$n"', '"${c}"filename.cimg,N0,N1,x0,y0,z0,x1,y1,z1"$n"' or
\n      '"${c}"filename.cimg,N0,N1,x0,y0,z0,c0,x1,y1,z1,c1"$n"'.
\n      Specifying '"${g}"-1"$n"' for one coordinates stands for the maximum possible value.
\n      Output expression '"${c}"filename.cimg[z][,datatype]"$n"' can be used to force the output pixel type.
\n      '"${g}"datatype"$n"' can be "$g"{ uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }"$n".
\n
\n    . "$g".raw binary files:"$n" Image dimensions and input pixel type may be specified when loading
\n       "$g".raw"$n" files with input expresssion '"${c}"filename.raw[,datatype][,width][,height[,depth[,dim[,offset]]]]]"$n"'.
\n       If no dimensions are specified, the resulting image is a one-column vector with
\n       maximum possible height. Pixel type can also be specified with the output
\n       expression '"${c}"filename.raw[,datatype]"$n"'.
\n       '"${g}"datatype"$n"' can be "$g"{ uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }"$n".
\n
\n    . "$g".yuv files:"$n" Image dimensions must be specified, and only sub-frames of an image
\n       sequence may be loaded, using the input expression
\n      '"${c}"filename.yuv,width,height[,first_frame[,last_frame[,step]]]"$n"'.
\n
\n    . "$g".tiff files:"$n" Only sub-images of multi-pages tiff files can be loaded, using the input
\n       expression '"${c}"filename.tif,_first_frame,_last_frame,_step"$n"'.
\n       Output expression '"${c}"filename.tiff,_datatype,_compression,_force_multipage,_use_bigtiff"$n"' can be used to
\n       specify the output pixel type, as well as the compression method.
\n       '"${g}"datatype"$n"' can be "$g"{ uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }"$n".
\n       '"${g}"compression"$n"' can be "$g"{ none (default) | lzw | jpeg }"$n".
\n       '"${g}"force_multipage"$n" can be "$g"{ 0=no (default) | 1=yes }"$n".
\n       '"${g}"use_bigtiff"$n" can be "$g"{ 0=no | 1=yes (default) }"$n".
\n
\n    . "$g".gif files:"$n" Animated gif files can be saved, using the input expression
\n      '"${c}"filename.gif,fps>0,nb_loops"$n"'.
\n       Specify '"${g}"nb_loops=0"$n"' to get an infinite number of animation loops (default).
\n
\n    . "$g".jpeg files:"$n" The output quality may be specified (in %), using the output expression
\n       '"${c}"filename.jpg,30"$n"' (here, to get a 30% quality output). '"${g}"100%"$n"' is the default.
\n
\n    . "$g".mnc files:"$n" The output header can set from another file, using the output expression
\n       '"${c}"filename.mnc,header_template.mnc"$n"'.
\n
\n    . "$g".pan, .cpp, .hpp, .c and .h files:"$n" The output datatype can be selected with output expression
\n       '"${c}"filename[,datatype]"$n"'.
\n      '"${g}"datatype"$n"' can be "$g"{ uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }"$n".
\n
\n    . "$g".gmic files:"$n" These filenames are assumed to be "${-GMIC}" custom commands files. Loading
\n       such a file will add the commands it defines to the interpreter. Debug information can be
\n       enabled/disabled by the input expression '"${c}"filename.gmic,add_debug_info={ 0 | 1 }"$n"'.
\n
\n    . Inserting '"${c}"ext:"$n"' on the beginning of a filename (e.g. '"${c}"jpg:filename"$n"') forces "${-GMIC}" to
\n       read/write the file as it would have been done if it had the specified extension '"${g}".ext"$n"'.
\n
\n  - Some input/output formats and options may not be supported, depending on the configuration flags
\n     set during the build of the "${-GMIC}" software."
-_help_section "Substitution rules"
-_help_paragraph "  - "${-GMIC}" items containing '"$g"$"$n"' or '"$g"{}"$n"' are substituted before being interpreted.
\n     Use these substituting expressions to access various data from the interpreter environment.
\n
\n  - '"$c"$name"$n"' and '"$c"${name}"$n"' are both substituted by the value of the specified named "${g}"variable"$n"
\n     (set previously by the item '"${c}"name=value"$n"'). If this variable has not been already set,
\n     the expression is substituted by the highest positive "${g}"indice"$n" of the named image '"${g}"[name]"$n"'.
\n     If no image has this name, the expression is substituted by the value of the
\n     "${g}"OS environment variable"$n" with same name (it may be thus an empty string).
\n     The following reserved variables are predefined by the "${-GMIC}" interpreter:
\n
\n       . '"$c"$!"$n"': The current number of images in the list.
\n       . '"$c"$>"$n"' and '"$c"$<"$n"': The increasing/decreasing indice of the latest (currently running)
\n          '"${c}"repeat..done"$n"' loop.
\n       . '"$c"$/"$n"': The current call stack. Stack items are separated by slashes '"$g"/"$n"'.
\n       . '"$c"$|"$n"': The current value (expressed in seconds) of a millisecond precision timer.
\n       . '"$c"$^"$n"': The current verbosity level.
\n       . '"$c"$_cpus"$n"': The number of computation cores available on your machine.
\n       . '"$c"$_pid"$n"': The current process identifier, as an integer.
\n       . '"$c"$_prerelease"$n"': For pre-releases only, the date of the pre-release as '"${g}"mmddyy"$n"'.
\n          For stable releases, this variable is not defined.
\n       . '"$c"$_version"$n"': A 3-digits number telling about the current version of the "${-GMIC}" interpreter.
\n          (currently '"$g$_version$n"').
\n       . '"$c"$_vt100"$n"': Set to "${g}"1"$n" (default value) if colored text output is allowed on the console.
\n       . '"$c"$_path_rc"$n"': The path to the "${-GMIC}" folder used to store resources and configuration files
\n         (its value is OS-dependent).
\n       . '"$c"$_path_user"$n"': The path to the "${-GMIC}" user file "${g}".gmic"$n" or "${g}"user.gmic"$n" (its value is OS-dependent).
\n
\n  - '"$c"${\"command line\"}"$n"' is substituted by the "${g}"status value"$n" set by the execution of the
\n     specified command line (see command '"$c"-status"$n"' to learn more about status).
\n     Expression '"$c"${}"$n"' thus stands for the "${g}"current status value"$n".
\n
\n  - '"$c"{``string}"$n"' (starting with two backquotes) is substituted by a "${g}"double-quoted version"$n" of the specified string.
\n
\n  - '"$c"{/string}"$n"' is substituted by the "${g}"escaped version"$n" of the specified string.
\n
\n  - '"$c"{'string'}"$n"' (between single quotes) is substituted by the "${g}"sequence of ascii codes"$n" that compose
\n     the specified string, separated by commas '"$g","$n"'. For instance, item '"$c"{'foo'}"$n"' is substituted
\n     by '"${c}"102,111,111"$n"'.
\n
\n  - '"$c"{image,feature}"$n"' is substituted by a specific feature of the image "$c"[image]"$n".
\n     '"${g}"image"$n"' can be either an image number or an image name. It can be also eluded.
\n     In which case, the last image '"$c"[-1]"$n"' of the list is considered for the requested feature.
\n     Specified '"${g}"feature"$n"' can be one of:
\n
\n       . '"${c}"b"$n"': The image basename (i.e. filename without the folder path nor extension).
\n       . '"${c}"f"$n"': The image folder name.
\n       . '"${c}"n"$n"': The image name or filename (if the image has been read from a file).
\n       . '"${c}"t"$n"': The text string from the image values regarded as ascii codes.
\n       . '"${c}"x"$n"': The image extension (i.e last characters after the last '.' in the image name).
\n       . '"${c}"^"$n" : The sequence of all image values, separated by commas ','.
\n       . '"${c}"@subset"$n"': The sequence of image values corresponding to the specified subset,
\n          and separated by commas ','.
\n       . Any other '"${c}"feature"$n"' is considered as a "${g}"mathematical expression"$n" associated to
\n          the image "$c"[image]"$n" and is substituted by the result of its evaluation (float value).
\n          For instance, expression '"$c"{0,w+h}"$n"' is substituted by the sum of the width and height
\n          of the first image (see section '"${c}"Mathematical expressions"$n"' for more details).
\n          If a mathematical expression starts with an underscore '"${g}"_"$n"', the resulting value is
\n          truncated to a readable format. For instance, item '"$c"{_pi}"$n"' is substituted by '"${g}"3.14159"$n"'
\n          (while '"$c"{pi}"$n"' is '"${g}"3.141592653589793"$n"').
\n       . A '"${c}"feature"$n"' delimited by backquotes is replaced by a string whose ascii codes correspond
\n          to the list of values resulting from the evaluation of the specified mathematical expression.
\n          For instance, item '"$c"{`[102,111,111]`}"$n"' is substituted by '"${c}"foo"$n"' and item '"$c"{`vector8(65)`}"$n"'
\n          by '"${c}"AAAAAAAA"$n"'
\n
\n  - '"$c"{*}"$n"' is substituted by the "${g}"visibility state"$n" of the instant display window "$c"[0]"$n"
\n     (can be "$g"{ 0=closed | 1=visible }"$n").
\n
\n  - '"$c"{*,feature}"$n"' or '"$c"{*indice,feature}"$n"' is substituted by a specific feature of the
\n     instant display window "$c"#0"$n" (or "$c"#indice"$n", if specified). Requested '"${g}"feature"$n"' can be:
\n
\n       . '"${c}"w"$n"': display width (i.e. width of the display area managed by the window).
\n       . '"${c}"h"$n"': display height (i.e. height of the display area managed by the window).
\n       . '"${c}"wh"$n"': display width x display height.
\n       . '"${c}"d"$n"': window width (i.e. width of the window widget).
\n       . '"${c}"e"$n"': window height (i.e. height of the window widget).
\n       . '"${c}"de"$n"': window width x window height.
\n       . '"${c}"u"$n"': screen width (actually independent on the window size).
\n       .' "${c}"v"$n"': screen height (actually independent on the window size).
\n       . '"${c}"uv"$n"': screen width x screen height.
\n       . '"${c}"n"$n"': current normalization type of the instant display.
\n       . '"${c}"t"$n"': window title of the instant display.
\n       . '"${c}"x"$n"': X-coordinate of the mouse position (or -1, if outside the display area).
\n       . '"${c}"y"$n"': Y-coordinate of the mouse position (or -1, if outside the display area).
\n       . '"${c}"b"$n"': state of the mouse buttons { 1=left-but. | 2=right-but. | 4=middle-but. }.
\n       . '"${c}"o"$n"': state of the mouse wheel.
\n       . '"${c}"k"$n"': decimal code of the pressed key if any, 0 otherwise.
\n       . '"${c}"c"$n"': boolean (0 or 1) telling if the instant display has been closed recently.
\n       . '"${c}"r"$n"': boolean telling if the instant display has been resized recently.
\n       . '"${c}"m"$n"': boolean telling if the instant display has been moved recently.
\n       . Any other '"${c}"feature"$n"' stands for a "${g}"keycode name"$n" (in capital letters), and is substituted
\n          by a boolean describing the current key state "$g"{ 0=pressed | 1=released }"$n".
\n       . You can also prepend a hyphen '"$c"-"$n"' to a '"${g}"feature"$n"' (that supports it) to flush the
\n          corresponding event immediately after reading its state (works for keys, mouse
\n          and window events).
\n
\n  - Item substitution is "${g}"never performed in items between double quotes"$n". One must break the quotes
\n    to enable substitution if needed, as in "$c"\"3+8 kg = \"{3+8}\" kg\""$n". Using double quotes
\n    is then a convenient way to disable the substitutions mechanism in items, when necessary.
\n
\n  - One can also disable the substitution mechanism on items outside double quotes, by
\n     escaping the '"$g"{"$n"','"$g"}"$n"' or '"$g"$"$n"' characters, as in '"$c"\\{3+4\\}\\ doesn\47t\\ evaluate"$n"'."
-_help_section "Mathematical expressions"
-_help_paragraph "  - "${-GMIC}" has an embedded "${g}"mathematical parser"$n". It is used to evaluate expressions inside
\n     braces '"$g"{}"$n"', or formulas in commands that may take one as an argument (e.g. '"$c"-fill"$n"').
\n
\n  - When used as a command argument, a formula is evaluated "${g}"for each pixel"$n" of the selected images.
\n
\n  - The mathematical parser understands the following set of functions, operators and variables:
\n
\n    _ "${g}"Usual operators:"$n" "$c"||"$n" (logical or), "$c"&&"$n" (logical and), "$c"|"$n" (bitwise or), "$c"&"$n" (bitwise and),
\n       "$c"!=, ==, <=, >=, <, >, <<"$n" (left bitwise shift), "$c">>"$n" (right bitwise shift), "$c"-, +, *, /,
\n       %"$n" (modulo), "$c"^"$n" (power), "$c"!"$n" (logical not), "$c"~"$n" (bitwise not),
\n       "$c"++"$n", "$c"--"$n", "$c"+="$n", "$c"-="$n", "$c"*="$n", "$c"/="$n", "$c"%="$n", "$c"&="$n", "$c"|="$n", "$c"^="$n", "$c">>="$n", "$c"<<="$n" (in-place operators).
\n
\n    _ "${g}"Usual functions:"$n" "${c}"abs(), acos(), arg(), argmax(), argmin(), asin(), atan(), atan2(),
\n       cbrt(), cos(), cosh(), cut(), exp(), fact(), fibo(), gauss(), hypoth(), int(), isval(), isnan(), isinf(),
\n       isint(), isbool(), isfile(), isdir(), isin(), kth(), log(), log2(), log10(), max(), mean(),
\n       med(), min(), narg(), prod(), rol()"$n" (left bit rotation), "${c}"ror()"$n" (right bit rotation)"${c}",
\n       round(), sign(), sin(), sinc(), sinh(), sqrt(), std(), sum(), tan(), tanh(), variance()"$n".
\n
\n       . '"${c}"atan2(x,y)"$n"' is the version of '"${c}"atan()"$n"' with two arguments '"${g}"y"$n"' and '"${g}"x"$n"' (as in C/C++).
\n       . '"${c}"hypoth(x,y)"$n"' computes the square root of the sum of the squares of x and y.
\n       . '"${c}"permut(k,n,with_order)"$n"' computes the number of permutations of k objects from a set of k objects.
\n       . '"${c}"gauss(x,_sigma)"$n"' returns '"${g}"exp(-x^2/(2*s^2))/sqrt(2*pi*sigma^2)'"$n".
\n       . '"${c}"cut(value,min,max)"$n"' returns value if it is in range "${g}"[min,max]"$n", or "${g}"min"$n" or "${g}"max"$n" otherwise.
\n       . '"${c}"narg(a_1,...,a_N)"$n"' returns the number of specified arguments (here, "${g}"N"$n").
\n       . '"${c}"arg(i,a_1,..,a_N)"$n"' returns the ith argument "${g}"a_i"$n".
\n       . '"${c}"isval()"$n"', '"${c}"isnan()"$n"', '"${c}"isinf()"$n"', '"${c}"isint()"$n"', '"${c}"isbool()"$n"' test the type of
\n          the given number or expression, and return "${g}"0 (false)"$n" or "${g}"1 (true)"$n".
\n       . '"${c}"isfile()"$n"' (resp. '"${c}"isdir()"$n"') returns "${g}"0 (false)"$n" or "${g}"1 (true)"$n" whether its argument
\n          is a valid path to a file (resp. to a directory) or not.
\n       . '"${c}"isin(v,a_1,...,a_n)"$n"' returns "${g}"0 (false)"$n" or "${g}"1 (true)"$n" whether the first value '"${g}"v"$n"' appears
\n          in the set of other values 'a_i'.
\n       . '"${c}"argmin()"$n"', '"${c}"argmax()"$n"', '"${c}"kth()"$n"', '"${c}"max()"$n"', '"${c}"mean()"$n"', '"${c}"med()"$n"', '"${c}"min()"$n"', '"${c}"std()"$n"', '"${c}"sum()"$n"'
\n          and '"${c}"variance()"$n"' can be called with an arbitrary number of scalar/vector arguments.
\n       . '"${c}"round(value,rounding_value,direction)"$n"' returns a rounded value.
\n          '"${g}"direction"$n"' can be "${g}"{ -1=to-lowest | 0=to-nearest | 1=to-highest }"$n".
\n
\n    _ "${g}"Variable names"$n" below are pre-defined. They can be overrided.
\n
\n       . '"${c}"l"$n"': length of the associated list of images, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"w"$n"': width of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"h"$n"': height of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"d"$n"': depth of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"s"$n"': spectrum of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"r"$n"': shared state of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"wh"$n"': shortcut for width x height.
\n       . '"${c}"whd"$n"': shortcut for width x height x depth.
\n       . '"${c}"whds"$n"': shortcut for width x height x depth x spectrum (i.e. total number of pixel values).
\n       . '"${c}"i"$n"': current processed pixel value (i.e. value located at "$g"(x,y,z,c)"$n") in the
\n          associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"iN"$n"': Nth channel value of current processed pixel (i.e. value located at "$g"(x,y,z,N)"$n") in
\n          the associated image, if any ("${g}"0"$n" otherwise). '"${g}"N"$n"' must be an integer in range "$g"[0,7]"$n".
\n       . '"${c}"R"$n"','"${c}"G"$n"','"${c}"B"$n"' and '"${c}"A"$n"' are equivalent to '"${c}"i0"$n"', '"${c}"i1"$n"', '"${c}"i2"$n"' and '"${c}"i3"$n"' respectively.
\n       . '"${c}"im"$n"','"${c}"iM"$n"','"${c}"ia"$n"','"${c}"iv"$n"','"${c}"is"$n"','"${c}"ip"$n"','"${c}"ic"$n"': Respectively the minimum, maximum, average values,
\n          variance, sum, product and median value of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"xm"$n"','"${c}"ym"$n"','"${c}"zm"$n"','"${c}"cm"$n"': The pixel coordinates of the minimum value in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"xM"$n"','"${c}"yM"$n"','"${c}"zM"$n"','"${c}"cM"$n"': The pixel coordinates of the maximum value in the associated
\n          image, if any ("${g}"0"$n" otherwise).
\n       . You may add '"${c}"#ind"$n"' to any of the variable name above to retrieve the information for any
\n          numbered image "${g}"[ind]"$n" of the list (when this makes sense). For instance '"${c}"ia#0"$n"' denotes the
\n          average value of the first image).
\n       . '"${c}"x"$n"': current processed column of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"y"$n"': current processed row of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"z"$n"': current processed slice of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"c"$n"': current processed channel of the associated image, if any ("${g}"0"$n" otherwise).
\n       . '"${c}"t"$n"': thread id when an expression is evaluated with multiple threads ("${g}"0"$n" means 'master thread').
\n       . '"${c}"e"$n"': value of e, i.e. "${g}"2.71828.."$n"
\n       . '"${c}"pi"$n"': value of pi, i.e. "${g}"3.1415926.."$n"
\n       . '"${c}"u"$n"': a random value between "${g}"[0,1]"$n", following a uniform distribution.
\n       . '"${c}"g"$n"': a random value, following a gaussian distribution of variance 1
\n          (roughly in "${g}"[-6,6]"$n").
\n       . '"${c}"interpolation"$n"': value of the default interpolation mode used when reading pixel values with
\n           the pixel access operators (i.e. when the interpolation argument is not explicitly specified,
\n           see below for more details on pixel access operators). Its initial default value is "${g}"0"$n".
\n       . '"${c}"boundary"$n"': value of the default boundary conditions used when reading pixel values with
\n           the pixel access operators (i.e. when the boundary condition argument is not explicitly specified,
\n           see below for more details on pixel access operators). Its initial default value is "${g}"0"$n".
\n
\n    _ "${g}"Vector calculus:"$n" Most operators are also able to work with vector-valued elements.
\n
\n       . '"${c}"[ a0,a1,..,aN ]"$n"' defines a "${g}"(N+1)"$n"-dimensional vector with specified scalar coefficients "${g}"ak"$n".
\n       . '"${c}"vectorN(a0,a1,,..,)"$n"' does the same, with the "${g}"ak"$n" being repeated periodically.
\n       . In both expressions, the "${g}"ak"$n" can be vectors themselves, to be concatenated into a single vector.
\n       . The scalar element "${g}"ak"$n" of a vector "${g}"X"$n" is retrieved by "${c}"X[k]"$n".
\n       . The sub-vector "${g}"[ ap..aq ]"$n" of a vector "${g}"X"$n" is retrieved by "${c}"X[p,q]"$n".
\n       . Equality/inequality comparisons between two vectors is possible with the operators '"${c}"=="$n"' and '"${c}"!="$n"'.
\n       . Some vector-specific functions can be used on vector values:
\n         '"${c}"cross(X,Y)"$n"' (cross product), '"${c}"dot(X,Y)"$n"' (dot product), '"${c}"size(X)"$n"' (vector dimension),
\n         '"${c}"sort(X,_is_increasing,_chunk_size)"$n"' (sorting values), '"${c}"reverse(A)"$n"' (reverse order of components)
\n         and '"${c}"same(A,B,_nb_vals,_is_case_sensitive)"$n"' (vector equality test).
\n       . Function '"${c}"resize(A,size,_interpolation)"$n"' returns a resized version of vector '"${g}"A"$n"'
\n          with specified interpolation mode. '"${g}"interpolation'"$n"  can be
\n          "$g"{ -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic |
\n            6=lanczos }"$n".
\n       . Function '"${c}"find(A,B,_is_forward,_starting_indice)"$n"' returns the index where sub-vector "${g}"B"$n" appears in vector "${g}"A"$n",
\n          (or "${g}"-1"$n" if "${g}"B"$n" is not found in "${g}"A"$n"). Argument "${g}"A"$n" can be also replaced by an image indice "${g}"#ind"$n".
\n       . A "${g}"2"$n"-dimensional vector may be seen as a complex number and used in those particular functions/operators:
\n         '"${c}"**"$n"' (complex multiplication), '"${c}"//"$n"' (complex division), '"${c}"^^"$n"' (complex exponentiation),
\n         '"${c}"**="$n"' (complex self-multiplication), '"${c}"//="$n"' (complex self-division), '"${c}"^^="$n"' (complex self-exponentiation),
\n         '"${c}"cabs()"$n"' (complex modulus), '"${c}"carg()"$n"' (complex argument), '"${c}"cconj()"$n"' (complex conjugate),
\n         '"${c}"cexp()"$n"' (complex exponential) and '"${c}"clog()"$n"' (complex logarithm).
\n       . A "${g}"MN"$n"-dimensional vector may be seen as a "${g}"M"${n}" x "${g}"N"$n" matrix and used in those particular functions/operators:
\n         '"${c}"**"$n"' (matrix-vector multiplication), '"${c}"det(A)"$n"' (determinant), '"${c}"diag(V)"$n"' (diagonal matrix from vector),
\n         '"${c}"eig(A)"$n"' (eigenvalues/eigenvectors), '"${c}"eye(n)"$n"' (n x n identity matrix), '"${c}"inv(A)"$n"' (matrix inverse),
\n         '"${c}"mul(A,B,_nb_colsB)"$n"' (matrix-matrix multiplication), '"${c}"rot(x,y,z,angle)"$n"' (3d rotation matrix),
\n         '"${c}"rot(angle)"$n"' (2d rotation matrix), '"${c}"solve(A,B,_nb_colsB)"$n"' (least-square solver of linear system A.X = B),
\n         '"${c}"trace(A)"$n"' (matrix trace) and '"${c}"transp(A,nb_colsA)"$n"' (matrix transpose).
\n         Argument '"${c}"nb_colsB"$n"' may be omitted if equal to "${g}"1"$n".
\n       . Specifying a vector-valued math expression as an argument of a command that operates on image values
\n          (e.g. '"$c"-fill"$n"') modifies the whole spectrum range of the processed image(s), for each spatial
\n          coordinates "$g"(x,y,z)"$n". The command does not loop over the "${g}"C"$n"-axis in this case.
\n
\n    _ "${g}"String manipulation:"$n" Character strings are defined and managed as vectors objects.
\n       Dedicated functions and initializers to manage strings are
\n
\n       . "${c}"[ 'string' ]"$n" and "${c}"'string'"$n" define a vector whose values are the ascii codes of the specified "${g}"character string"$n"
\n          (e.g. "${c}"'foo'"$n" is equal to "${g}"[ 102,111,111 ]"$n").
\n       . "${c}"_'character'"$n" returns the (scalar) ascii code of the specified character (e.g. "${c}"_'A'"$n" is equal to "${g}"65"$n").
\n       . A special case happens for "${g}"empty"$n" strings: Values of both expressions "${c}"[ '' ]"$n" and "${c}"''"$n" are "${g}"0"$n".
\n       . Functions '"${c}"lowercase()"$n"' and '"${c}"uppercase()"$n"' return string with all string characters lowercased or uppercased.
\n
\n    _ "${g}"Special operators"$n" can be used:
\n
\n       . '"$c";"$n"': expression separator. The returned value is always the last encountered
\n          expression. For instance expression '"${c}"1;2;pi"$n"' is evaluated as '"${c}"pi"$n"'.
\n       . '"$c"="$n"': variable assignment. Variables in mathematical parser can only refer to
\n          numerical values. Variable names are case-sensitive. Use this operator in
\n          conjunction with '"$c";"$n"' to define more complex evaluable expressions, such as
\n           '"${c}"t=cos(x);3*t^2+2*t+1"$n"'.
\n          These variables remain "${g}"local"$n" to the mathematical parser and cannot be accessed
\n          outside the evaluated expression.
\n
\n    _ The following "${g}"specific functions"$n" are also defined:
\n
\n       . '"${c}"normP(u1,...,un)"$n"' computes the LP-norm of the specified vector
\n         (P being an "${g}"unsigned integer"$n" or '"${g}"inf"$n"').
\n       . '"${c}"u(max)"$n"' or '"${c}"u(min,max)"$n"': return a random value between "$g"[0,max]"$n" or "$g"[min,max]"$n",
\n          following a uniform distribution.
\n       . '"${c}"i(_a,_b,_c,_d,_interpolation_type,_boundary_conditions)"$n"': return the value of the pixel
\n          located at position "$g"(a,b,c,d)"$n" in the associated image, if any ("${g}"0"$n" otherwise).
\n          '"${g}"interpolation_type"$n"' can be "$g"{ 0=nearest neighbor | other=linear }"$n".
\n          '"${g}"boundary_conditions"$n"' can be "$g"{ 0=dirichlet | 1=neumann | 2=periodic }"$n".
\n          Omitted coordinates are replaced by their default values which are respectively
\n          "${c}"x, y, z, c, interpolation"$n" and "${c}"boundary"$n".
\n          For instance command '"${c}"-fill 0.5*(i(x+1)-i(x-1))"$n"' will estimate the X-derivative
\n          of an image with a classical finite difference scheme.
\n       . '"${c}"j(_dx,_dy,_dz,_dc,_interpolation_type,_boundary_conditions)"$n"' does the same for the pixel
\n          located at position "$g"(x+dx,y+dy,z+dz,c+dc)"$n" (pixel access relative to the current coordinates).
\n       . '"${c}"i[offset,_boundary_conditions]"$n"' returns the value of the pixel located at specified '"${g}"offset"$n"'
\n          in the associated image buffer (or "${g}"0"$n" if offset is out-of-bounds).
\n       . '"${c}"j[offset,_boundary_conditions]"$n"' does the same for an offset relative to the current pixel "$g"(x,y,z,c)"$n".
\n       . '"${c}"i(#ind,_x,_y,_z,_c,_interpolation,_boundary)"$n"', '"${c}"j(#ind,_dx,_dy,_dz,_dc,_interpolation,_boundary)"$n"',
\n          '"${c}"i[#ind,offset,_boundary]"$n"' and '"${c}"i[offset,_boundary]"$n"' are similar expressions used to access
\n          pixel values for any numbered image "${g}"[ind]"$n" of the list.
\n       . '"${c}"I/J[offset,_boundary_conditions]"$n"' and '"${c}"I/J(#ind,_x,_y,_z,_interpolation,_boundary)"$n"' do the same
\n          as '"${c}"i/j[offset,_boundary_conditions]"$n"' and '"${c}"i/j(#ind,_x,_y,_z,_c,_interpolation,_boundary)"$n"' but
\n          return a vector instead of a scalar (e.g. a vector "${g}"[ R,G,B ]"$n" for a pixel at "${g}"(a,b,c)"$n" in a color image).
\n       . '"${c}"crop(_#ind,_x,_y,_z,_c,_dx,_dy,_dz,_dc,_boundary)"$n"' returns a vector whose values come from the
\n          cropped region of image "${g}"[ind]"$n" (or from default image selected if '"${c}"ind"$n"' is not specified).
\n          Cropped region starts from point "${g}"(x,y,z,c)"$n" and has a size of "${g}"dx x dy x dz x dc"$n". Arguments for
\n          coordinates and sizes can be omitted if they are not ambiguous (e.g. '"${c}"crop(#ind,x,y,dx,dy)"$n"' is a
\n          valid invokation of this function).
\n       . '"${c}"draw(_#ind,S,x,y,z,c,dx,_dy,_dz,_dc,_opacity,_M,_max_M)"$n"' draws a sprite "${g}"S"$n" in image "${g}"[ind]"$n"
\n          (or in default image selected if '"${c}"ind"$n"' is not specified) at specified coordinates "${g}"(x,y,z,c)"$n".
\n          The size of the sprite "${g}"dx x dy x dz x dc"$n" must be specified. You can also specify a corresponding
\n          opacity mask "${g}"M"$n" if its size matches "${g}"S"$n".
\n       . '"${c}"if(condition,expr_then,_expr_else)"$n"': return value of '"${c}"expr_then"$n"' or '"${c}"expr_else"$n"',
\n          depending on the value of '"${c}"condition"$n"' "${g}"(0=false, other=true)"$n". '"${c}"expr_else"$n"' can be
\n          omitted in which case "${g}"0"$n" is returned if the condition does not hold. Using the ternary operator
\n          '"${c}"condition?expr_then[:expr_else]"$n"' gives an equivalent expression.
\n          For instance, "${-GMIC}" commands '"${c}"-fill if(x%10==0,255,i)"$n"' and '"${c}"-fill x%10?i:255"$n"' both draw blank
\n          vertical lines on every 10th column of an image.
\n       . '"${c}"dowhile(expression,_condition)"$n"' repeats the evaluation of '"${c}"expression"$n"' until '"${c}"condition"$n"'
\n           vanishes (or until '"${c}"expression"$n"' vanishes if no '"${c}"condition"$n"' is specified). For instance,
\n           the expression: '"${c}"if(N<2,N,n=N-1;F0=0;F1=1;dowhile(F2=F0+F1;F0=F1;F1=F2,n=n-1))"$n"' returns
\n           the Nth value of the Fibonacci sequence, for "${g}"N>=0"$n" (e.g., "${g}"46368"$n" for "${g}"N=24"$n").
\n          '"${c}"dowhile(expression,condition)"$n"' always evaluates the specified expression at least once,
\n          then check for the nullity condition. When done, it returns the last value of '"${c}"expression"$n"'.
\n       . '"${c}"for(init,condition,_procedure,body)"$n"' first evaluates the expression '"${c}"init"$n"', then iteratively
\n          evaluates '"${c}"body"$n"' (followed by '"${c}"procedure"$n"' if specified) while '"${c}"condition"$n"' is verified
\n          (i.e. not zero). It may happen that no iteration is done, in which case the function
\n          returns "${g}"0"$n". Otherwise, it returns the last value of '"${c}"body"$n"'.
\n          For instance, the expression: '"${c}"if(N<2,N,for(n=N;F0=0;F1=1,n=n-1,F2=F0+F1;F0=F1;F1=F2))"$n"'
\n          returns the Nth value of the Fibonacci sequence, for "${g}"N>=0"$n" (e.g., "${g}"46368"$n" for "${g}"N=24"$n").
\n       . '"${c}"whiledo(condition,expression)"$n"' is exactly the same as '"${c}"for(init,condition,expression)"$n"'
\n          without the specification of an initializing expression.
\n       . '"${c}"date(attr,path)"$n"' returns the date attribute for the given 'path' (file or directory),
\n          with '"${g}"attr"$n"' being "$g"{ 0=year | 1=month | 2=day | 3=day of week | 4=hour | 5=minute | 6=second }"$n".
\n       . '"${c}"date(_attr)"$n" returns the specified attribute for the current (locale) date.
\n       . '"${c}"print(expression)"$n" prints the value of the specified expression on the console
\n          (and returns its value).
\n       . '"${c}"debug(expression)"$n" prints detailed debug information about the sequence of operations
\n          done by the math parser to evaluate the expression (and returns its value).
\n       . '"${c}"init(expression)"$n" evaluates the specified expression only once, even when multiple
\n          evaluations are required (e.g. in '"${c}"-fill init(foo=0);++foo"$n"').
\n       . '"${c}"copy(dest,src,_nb_elts,_inc_d,_inc_s)"$n" copies an entire memory block of '"${c}"nb_elts"$n"' elements
\n          starting from a source value '"${c}"src"$n"' to a specified destination '"${c}"dest"$n"', with increments
\n          defined by '"${c}"inc_d"$n"' and '"${c}"inc_s"$n"' respectively for the destination and source pointers.
\n
\n    - "${g}"User-defined functions:"$n"
\n
\n       . Custom macro functions can be defined in a math expression, using the assignment operator '"${c}"="$n"', e.g.
\n         '"${c}"foo(x,y) = cos(x + y); result = foo(1,2) + foo(2,3)"$n"'.
\n       . Overriding a built-in function has no effect.
\n       . Overriding an already defined macro function replaces its old definition.
\n       . Macro functions are indeed processed as "${g}"macros"$n" by the mathematical evaluator. You should avoid invoking
\n          them with arguments that are themselves results of assignments or self-operations. For instance,
\n          '"${c}"foo(x) = x + x; z = 0; result = foo(++x)"$n"' will set '"${c}"result = 4"$n"' rather than expected value '"${c}"2"$n"'.
\n
\n    - "${g}"Multi-threaded"$n" and "${g}"in-place"$n" evaluation:
\n
\n       . If your image data are large enough and you have several CPUs available, it is likely that
\n          the math expression passed to a '"$c"-fill"$n"' or '"$c"-input"$n"' command is evaluated in parallel, using
\n          multiple computation threads.
\n       . Starting an expression with '"$c":"$n"' or '"$c"*"$n"' forces the evaluations required for an image to be run in
\n          parallel, even if the amount of data to process is small (beware, it may be slower to evaluate!).
\n          Specify '"$c":"$n"' (instead of '"$c"*"$n"') to avoid possible image copy done before evaluating the expression
\n          (this saves memory, but do this only if you are sure this step is not required!)
\n       . If the specified expression starts with '"$c">"$n"' or '"$c"<"$n"', the pixel access operators
\n          '"${c}"i(), i[], j()"$n"' and '"${c}"j[]"$n"' return values of the image being currently modified,
\n          in forward ('"$c">"$n"') or backward ('"$c"<"$n"') order. The multi-threading evaluation of the expression is
\n          also disabled in this case.
\n       . Function '"$c"single(operands)"$n"' forces the execution of the given operands in a single thread at a time.
\n
\n    _ Expressions '"${c}"i(_#ind,x,_y,_z,_c)=value"$n"', '"${c}"j(_#ind,x,_y,_z,_c)=value"$n"', '"${c}"i[_#ind,offset]=value"$n"' and
\n       '"${c}"j[_#ind,offset]=value"$n"' set a pixel value at a different location than the running one in the
\n       image "${g}"[ind]"$n" (or in the associated image if argument '"${c}"#ind"$n"' is omitted), either with global
\n       coordinates/offsets (with '"${c}"i(...)"$n"' and '"${c}"i[...]"$n"'), or relatively to the current position "${g}"(x,y,z,c)"$n"
\n       (with '"${c}"j(...)"$n"' and '"${c}"j[...]"$n"'). These expressions always return '"${c}"value"$n"'.
\n
\n  - The last image of the list is always associated to the evaluations of '"$c"{expressions}"$n"',
\n     e.g. "${-GMIC}" sequence '"${c}"256,128 -f {w}"$n"' will create a 256x128 image filled with value 256."
-_help_section "Image and data viewers"
-_help_paragraph "  - "${-GMIC}" has some very handy embedded "${g}"visualization modules"$n", for 1d signals
\n     (command '"$c"-plot"$n"'), 1d/2d/3d images (command '"$c"-display"$n"') and 3d objects
\n     (command '"$c"-display3d"$n"'). It manages interactive views of the selected image data.
\n
\n  - The following keyboard shortcuts are available in the interactive viewers:
\n
\n    . "${g}"(mousewheel)"$n": Zoom in/out.
\n    . "${g}"CTRL+D"$n": Increase window size.
\n    . "${g}"CTRL+C"$n": Decrease window size.
\n    . "${g}"CTRL+R"$n": Reset window size.
\n    . "${g}"CTRL+W"$n": Close window.
\n    . "${g}"CTRL+F"$n": Toggle fullscreen mode.
\n    . "${g}"CTRL+S"$n": Save current window snapshot as numbered file 'gmic_xxxx.bmp'.
\n    . "${g}"CTRL+O"$n": Save current instance of the viewed data, as numbered file 'gmic_xxxx.cimgz'.
\n
\n  - Shortcuts specific to the 1d/2d/3d image viewer (command '"$c"-display"$n"') are:
\n
\n    . "${g}"CTRL+A"$n": Switch cursor mode.
\n    . "${g}"CTRL+P"$n": Play z-stack of frames as a movie (for volumetric 3d images).
\n    . "${g}"CTRL+V"$n": Show/hide 3D view (for volumetric 3d images).
\n    . "${g}"CTRL+(mousewheel)"$n": Go up/down.
\n    . "${g}"SHIFT+(mousewheel)"$n": Go left/right.
\n    . "${g}"Numeric PAD"$n": Zoom in/out (+/-) and move through zoomed image (digits).
\n    . "${g}"BACKSPACE"$n": Reset zoom scale.
\n
\n  - Shortcuts specific to the 3d object viewer (command '"$c"-display3d"$n"') are:
\n
\n    . "$g"(mouse)+(left mouse button)"$n": Rotate 3d object.
\n    . "$g"(mouse)+(right mouse button)"$n": Zoom 3d object.
\n    . "$g"(mouse)+(middle mouse button)"$n": Shift 3d object.
\n    . "${g}"CTRL+F1 .. CTRL+F6"$n": Toggle between different 3d rendering modes.
\n    . "${g}"CTRL+Z"$n": Enable/disable z-buffered rendering.
\n    . "${g}"CTRL+A"$n": Show/hide 3d axes.
\n    . "${g}"CTRL+G"$n": Save 3d object, as numbered file 'gmic_xxxx.off'.
\n    . "${g}"CTRL+T"$n": Switch between single/double-sided 3d modes."
-_help_section "Adding custom commands"
-_help_paragraph "  - New custom commands can be added by the user, through the use of "${-GMIC}" "${g}"custom commands files"$n".
\n
\n  - A command file is a simple ascii text file, where each line starts either by
\n     '"${c}"command_name: command_definition"$n"' or '"${c}"command_definition (continuation)"$n"'.
\n
\n  - At startup, "${-GMIC}" automatically includes user's command file "$g"$HOME/.gmic"$n" (on Unix) or
\n     "$g"%APPDATA%/user.gmic"$n" (on Windows). The CLI tool '"${g}"gmic"$n"' automatically runs the command
\n     '"${c}"-cli_start"$n"' if defined.
\n
\n  - Custom command names must use character set "$g"[a-zA-Z0-9_]"$n" and cannot start with a number.
\n
\n  - Any '"$c" ""# comment"$n"' expression found in a custom commands file is discarded by the "${-GMIC}"
\n     parser, wherever it is located in a line.
\n
\n  - In a custom command, the following "$g"$-expressions"$n" are recognized and substituted:
\n
\n    . '"$c"$""\*"$n"' is substituted by a copy of the specified string of arguments.
\n    . '"$c"$\"*\""$n"' is substituted by a copy of the specified string of arguments, each being double-quoted.
\n    . '"$c"$""#"$n"' is substituted by the maximum indice of known arguments (either specified by the
\n       user or set to a default value in the custom command).
\n    . '"$c"$""?"$n"' is substituted by a string telling about the command subset restriction (only
\n       useful when custom commands need to output descriptive messages).
\n    . '"$c"$i"$n"' and '"$c"${i}"$n"' are both substituted by the "${g}"i^th"$n" specified argument. Negative indices
\n       such as '"$c"${-j}"$n"' are allowed and refer to the "${g}"j^th"$n" latest argument. '"$c"$""0"$n"' is substituted
\n       by the custom command name.
\n    . '"$c"${i=default}"$n"' is substituted by the value of "$c"$i"$n" (if defined) or by its new value set
\n        to '"${g}"default"$n"' otherwise ('"${g}"default"$n"' may be a $-expression as well).
\n    . '"$c"${subset}"$n"' is substituted by the argument values (separated by commas '"$g","$n"') of a
\n       specified argument subset. For instance expression '"$c"$""{2--2}"$n"' is substitued by all
\n       specified command arguments except the first and the last one. Expression '"$c"$""{^0}"$n"' is
\n       then substituted by all arguments of the invoked command (eq. to '"$c"$""*"$n"' if all specified
\n       arguments have indeed a value).
\n    . '"$c"$""=var"$n"' is substituted by the set of instructions that will assign each argument "$c"$i"$n"
\n       to the named variable '"${c}"var$i"$n"' (for i in "$g"[0..$""#]"$n"). This is particularly useful when a
\n       custom command want to manage variable numbers of arguments. Variables names must
\n       use character set "$g"[a-zA-Z0-9_]"$n" and cannot start with a number.
\n
\n  - These particular "$g"$-expressions"$n" for custom commands are "${g}"always substituted"$n", even in double quoted
\n     items or when the dollar sign '"$g"$"$n"' is escaped with a backslash '"$g"\\"$n"'. To avoid substitution,
\n     place an empty double quoted string just after the '"$g"$"$n"' (as in '"$c"$\"\"1"$n"').
\n
\n  - Specifying arguments may be skipped when invoking a custom command, by replacing them by
\n     commas '"$g","$n"' as in expression '"${c}"-flower ,,3"$n"'. Omitted arguments are set to their default
\n     values, which must be thus explicitly defined in the code of the corresponding custom
\n     command (using default argument expressions as '"$c"$""{1=default}"$n"').
\n
\n  - If one numbered argument required by a custom command misses a value, an error is
\n     thrown by the "${-GMIC}" interpreter."
-_help_section "List of commands"
-_help_paragraph "   All available "${-GMIC}" commands are listed below, classified by themes.
\n   When several choices of command arguments are possible, they appear separated by '"$g"|"$n"'.
\n   An argument specified inside '"$g"[]"$n"' or starting by '"${g}"_"$n"' is optional except when standing for an
\n   existing image "$c"[image]"$n", where '"${g}"image'"$n"' can be either an indice number or an image name.
\n   In this case, the '"$g"[]"$n"' characters are mandatory when writing the item.
\n   A command marked with '"$g"(+)"$n"' is one of the "${g}"native"$n" commands.
\n   Note also that all images that serve as illustrations in this reference documentation are normalized
\n   in "$g"[0,255]"$n" before being displayed. You may need to do this explicitly (command '"$c"-normalize 0,255"$n"')
\n   if you want to save and view images with the same aspect than those illustrated in the example codes."
_help_examples :
g=$_gmic_g c=$_gmic_c n=$_gmic_n
-_help_section "Examples of use"
-_help_paragraph " '"${g}"gmic"$n"' is a generic image processing tool which can be used in a wide variety of situations.
\n The few examples below illustrate possible uses of this tool:
\n
\n  - View a list of images:
\n     "${c}"gmic file1.bmp file2.jpeg"$n"
\n
\n  - Convert an image file:
\n     "${c}"gmic input.bmp -o output.jpg"$n"
\n
\n  - Create a volumetric image from a movie sequence:
\n     "${c}"gmic input.mpg -a z -o output.hdr"$n"
\n
\n  - Compute image gradient norm:
\n     "${c}"gmic input.bmp -gradient_norm"$n"
\n
\n  - Denoise a color image:
\n     "${c}"gmic image.jpg -denoise 30,10 -o denoised.jpg"$n"
\n
\n  - Compose two images using overlay layer blending:
\n     "${c}"gmic image1.jpg image2.jpg -blend overlay -o blended.jpg"$n"
\n
\n  - Evaluate a mathematical expression:
\n     "${c}"gmic -e \"cos(pi/4)^2+sin(pi/4)^2={cos(pi/4)^2+sin(pi/4)^2}\""$n"
\n
\n  - Plot a 2d function:
\n     "${c}"gmic 1000,1,1,2 -f \"X=3*(x-500)/500;X^2*sin(3*X^2)+if(c==0,u(0,-1),cos(X*10))\" -plot"$n"
\n
\n  - Plot a 3d elevated function in random colors:
\n     "${c}"gmic 128,128,1,3,\"u(0,255)\" -plasma 10,3 -blur 4 -sharpen 10000 \\\
\n      -elevation3d. \"'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'\""$n"
\n
\n  - Plot the isosurface of a 3d volume:
\n     "${c}"gmic -m3d 5 -md3d 5 -db3d 0 -isosurface3d \"'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))'\",3"$n"
\n
\n  - Render a "${-GMIC}" 3d logo:
\n     "${c}"gmic 0 -text G\\\47MIC,0,0,53,1,1,1,1 -expand_xy 10,0 -blur 1 -n 0,100 --plasma 0.4 -+ \\\
\n      -blur 1 -elevation3d -0.1 -md3d 4"$n"
\n
\n  - Generate a 3d ring of torii:
\n     "${c}"gmic -repeat 20 -torus3d 15,2 -color3d. \"{u(60,255)},{u(60,255)},{u(60,255)}\" \\\
\n      -*3d. 0.5,1 -if \"{$>%2}\" -r3d. 0,1,0,90 -endif -+3d. 70 -+3d \\\
\n      -r3d 0,0,1,18 -done -md3d 3 -m3d 5 -db3d 0"$n"
\n
\n  - Create a vase from a 3d isosurface:
\n     "${c}"gmic -md3d 4 -isosurface3d \"'x^2+2*abs(y/2)*sin(2*y)^2+z^2-3',0\" -sphere3d 1.5 \\\
\n      --3d. 0,5 -plane3d 15,15 -r3d. 1,0,0,90 -center3d. -+3d. 0,3.2 \\\
\n      -color3d. 180,150,255 -color3d.. 128,255,0 -color3d... 255,128,0 -+3d"$n"
\n
\n  - Display filtered webcam stream:
\n     "${c}"gmic -apply_camera \\\"--mirror x --mirror y -+ -/ 4\\\""$n"
\n
\n  - Launch a set of "${-GMIC}" interactive demos:
\n     "${c}"gmic -demo"$n"
\n"
_help_header_ascii :
-__help_header_ascii
_section=0 _space1="" _space2=" "
-_help_section "Usage"
__help_header_ascii :
-if {narg($_prerelease)} strprerelease=" (pre-release ""#"$_prerelease")" -else strprerelease="" -endif
str="  "${_gmic_b}"gmic: GREYC\'s Magic for Image Computing."$_gmic_n"
\n
\n        "$_gmic_r${_gmic_b}"Version "${-strver}$strprerelease$_gmic_n", Copyright (c) 2008-2016, David Tschumperle.
\n        "$_gmic_r"(http://gmic.eu)"$_gmic_n
-l[] -_e[] "" -onfail -m "_e : -e[] \"$""*\"" -endl
-v + -_e[] $str -v -
_help_section_ascii :
_section+=1
{narg({'"$1"'})},1,1,1,{'-'}
-v +
-e[] "\n "$_gmic_m$_gmic_b$_section". $1"
-e[] "    "${_space{narg({'$_section'})}}{t}$_gmic_n"\n"
-v -
-rm.
_help_paragraph_ascii :
-v +
-e[] "$*"
-v -
_help_footer_ascii :
-v +
-e[] " "$_gmic_r$_gmic_b"** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: http://gmic.eu **"$_gmic_n
-v -
_help_header_html :
_section=0
-if {narg($_prerelease)} strprerelease=" (pre-release ""#"$_prerelease")" -else strprerelease="" -endif
_gmic_n="</font></b>" _gmic_r="<b><font color=\"#900000\">" _gmic_g="<b><font color=\"#009000\">"
_gmic_m="<b><font color=\"#900090\">" _gmic_c="<b><font color=\"#005090\">"
-v +
-e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<!--#include file=\"header.html\" -->
\n<div id=\"bloc_option\">
\n<div id=\"top_rouge\"><div id=\"text_top\">Reference</div></div>
\n<div id=\"center\"><div id=\"text_centre_intro\">
\n<h2>Preamble</h2>
\n<ul>
\n<li>This document is distributed under the <a href=\"http://www.gnu.org/licenses/fdl-1.3.txt\">GNU Free Documentation License</a>, version 1.3.</li>
\n<li>A <a href=\"gmic_reference.pdf\">.pdf version</a> of this document is available.</li>
\n<li>We also suggest you read <a href=\"tutorial/index.shtml\">these tutorial pages</a> which provide a more user-friendly explanation of most of the G\47MIC basics.</li>
\n</ul>
\n<h2><a id=\"toc\">Table of contents</a></h2>
\n<ul>
\n<li><a href=\"#section0\">Version</a></li>
\n<li><a href=\"#section1\">Usage</a></li>
\n<ul>
\n<li><a href=\"#section2\">Overall context</a></li>
\n<li><a href=\"#section3\">Image definition and terminology</a></li>
\n<li><a href=\"#section4\">Items of a processing pipeline</a></li>
\n<li><a href=\"#section5\">Input data items</a></li>
\n<li><a href=\"#section6\">Command items and selections</a></li>
\n<li><a href=\"#section7\">Input/output properties</a></li>
\n<li><a href=\"#section8\">Substitution rules</a></li>
\n<li><a href=\"#section9\">Mathematical expressions</a></li>
\n<li><a href=\"#section10\">Image and data viewers</a></li>
\n<li><a href=\"#section11\">Adding custom commands</a></li>
\n</ul>
\n<li><a href=\"#section12\">List of commands</a></li>
\n<ul>
\n<li><a href=\"#subsection1\">Global options</a></li>
\n<li><a href=\"#subsection2\">Input/output</a></li>
\n<li><a href=\"#subsection3\">List manipulation</a></li>
\n<li><a href=\"#subsection4\">Mathematical operators</a></li>
\n<li><a href=\"#subsection5\">Values manipulation</a></li>
\n<li><a href=\"#subsection6\">Colors manipulation</a></li>
\n<li><a href=\"#subsection7\">Geometry manipulation</a></li>
\n<li><a href=\"#subsection8\">Filtering</a></li>
\n<li><a href=\"#subsection9\">Features extraction</a></li>
\n<li><a href=\"#subsection10\">Image drawing</a></li>
\n<li><a href=\"#subsection11\">Matrix computation</a></li>
\n<li><a href=\"#subsection12\">3d rendering</a></li>
\n<li><a href=\"#subsection13\">Program control</a></li>
\n<li><a href=\"#subsection14\">Arrays,tiles and frames</a></li>
\n<li><a href=\"#subsection15\">Artistic</a></li>
\n<li><a href=\"#subsection16\">Warpings</a></li>
\n<li><a href=\"#subsection17\">Degradations</a></li>
\n<li><a href=\"#subsection18\">Blending and fading</a></li>
\n<li><a href=\"#subsection19\">Image sequences and videos</a></li>
\n<li><a href=\"#subsection20\">PINK-library operators</a></li>
\n<li><a href=\"#subsection21\">Convenience functions</a></li>
\n<li><a href=\"#subsection22\">Other interactive commands</a></li>
\n<li><a href=\"#subsection23\">Commands shortcuts</a></li>
\n</ul>
\n<li><a href=\"#section13\">Examples of use</a></li>
\n</ul>
\n<a id=\"section0\"><h2>Version</h2></a>
\n<pre><font color=\"blue\"><b>gmic:</b> GREYC\'s Magic for Image Computing.</font>
\n
\n       Version <font color=\"brown\"><b>"${-strver}$strprerelease"</b></font>, Copyright (c) 2008-2016, David Tschumperle
\n       (<a href=\"http://gmic.eu\">http://gmic.eu</a>)
\n</pre>
"
-v -
-_help_section "Usage"
_help_section_html :
_section+=1
-v +
-e[] "<h2><a href=\"#toc\"><img alt=\"\" border=\"0\" src=\"img/back_top.png\" />&nbsp;&nbsp;</a><a id=\"section"$_section"\">$1</a></h2>"
-v -
_help_paragraph_html :
-v +
-e[] "<pre>$*</pre>"
-v -
_help_footer_html :
-v +
-e[] "
\n<br/><b><font color=\"brown\">** G\47MIC comes with ABSOLUTELY NO WARRANTY; for details visit: <a href=\"http://gmic.eu\">http://gmic.eu **</a></font></b>
\n</tt>
\n</div>
\n</div>
\n<div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div>
\n</div>
\n<!--#include file=\"copyright.html\" -->
\n<!--#include file=\"footer.html\" -->
"
-v -
_help_header_latex :
strver=${-strver}
-if {narg($_prerelease)} strprerelease=" (pre-release \\#"$_prerelease")" -else strprerelease="" -endif
_gmic_n="\\aftergroup\\Ccn" _gmic_b="\\aftergroup\\Ccb" _gmic_r="\\aftergroup\\Ccr" _gmic_g="\\aftergroup\\Ccg" _gmic_c="\\aftergroup\\Ccb" _gmic_m=""
-v + -e[] "\\documentclass[a4paper,10.5pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,listings,color}
\n\\graphicspath{{img/}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{6in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\oddsidemargin}{15.5pt}
\n\\setlength{\\evensidemargin}{15.5pt}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\def\\Ccr{\\color{ca}}
\n\\def\\Ccb{\\color{cb}}
\n\\def\\Ccg{\\color{cc}}
\n\\def\\Ccc{\\color{cd}}
\n\\def\\Ccn{\\color{black}}
\n\\def\\comma{\\discretionary{,}{}{,}}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\title{\\fbox{\\parbox{\\textwidth}{\\begin{center}\\vspace*{2cm}\\includegraphics[width=12cm]{gmic_banner.jpg}\\\\\\vspace*{1cm}{\\Huge \\textbf{The Handbook}\\\\{\\small Version "$strver$strprerelease"}\\\\\\vspace*{1cm}}\\end{center}}}}
\n\\author{\\Large \\bf David Tschumperl\\'e}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\lstset{columns=fullflexible,basicstyle=\\normalfont}
\n\\begin{document}
\n\\maketitle
\n\\tableofcontents
\n\\chapter*{Preamble}
\n\\section*{License}
\nThis document is distributed under the \\textbf{GNU Free Documentation License}, version 1.3.\\\\
\nRead the full license terms at \\url{http://www.gnu.org/licenses/fdl-1.3.txt}.\\\\~\\\\
\nAn online version of this documentation is available at:\\\\\\url{http://gmic.eu/reference.shtml}.
\n\\section*{Motivations}
\n\\Cc{G\47MIC} is a full-featured open-source framework for image processing, providing several different user interfaces to
\nconvert/manipulate/filter/visualize generic image datasets, from 1d scalar signales to 3d+t sequences of multi-spectral volumetric images.
\nTechnically speaking, what it does is:
\n\\begin{itemize}
\n\\item Define a lightweight but powerful script language (the \\Cc{G\47MIC} language) dedicated to the design of image processing pipelines.
\n\\item Provide several user interfaces embedding the corresponding interpreter:
\n\\begin{itemize}
\n\\item A command-line executable '\\texttt{gmic}', to use the \\Cc{G\47MIC} framework from a shell.
\nIn this setting, \\Cc{G\47MIC} may be seen as a direct (and friendly) competitor of the ImageMagick or GraphicsMagick software suites.
\n\\item A plug-in '\\texttt{gmic\\_gimp}', to bring \\Cc{G\47MIC} capabilities to the GIMP image retouching software.
\n\\item A web-service '\\texttt{\\Cc{G\47MIC} Online}', to allow users applying image processing algorithms directly in a web brower.
\n\\item A Qt-based interface '\\texttt{ZArt}', for real-time manipulation of webcam images.
\n\\item A C++ library '\\texttt{libgmic}', to be linked with third-party applications.
\n\\end{itemize}
\n\\end{itemize}
\n\\Cc{G\47MIC} is focused on the design of possibly complex pipelines for converting, manipulating, filtering and visualizing generic 1d/2d/3d multi-spectral image datasets. This includes of course color images, but also more complex data as image sequences or 3d(+t) volumetric float-valued datasets.\\\\
\n
\n\\Cc{G\47MIC} is an open framework: the default language can be extended with custom \\Cc{G\47MIC}-written commands, defining thus new available image filters or effects. By the way, \\Cc{G\47MIC} already contains a substantial set of pre-defined image processing algorithms and pipelines (more than 1000).\\\\
\n
\n\\Cc{G\47MIC} has been designed with portability in mind and runs on different platforms (Windows, Unix, MacOSX). It is distributed under the CeCILL license (GPL-compatible). Since 2008, it is developed in the Image Team of the GREYC laboratory, in Caen/France, by permanent researchers working in the field of image processing on a daily basis.
\n\\section*{Version}
\n
\n \\Ca{\\textbf{gmic:} GREYC\'s Magic for Image Computing.}\\\\
\n
\n        \\Cb{Version \\textbf{"$strver$strprerelease"}, Copyright (c) 2008-2016, David Tschumperl\\'e}\\\\
\n        \\Cb{(\\url{http://gmic.eu})}
\n\\chapter{Usage}
"
-v -
_help_section_latex : -skip "$1"
-v +
-e[] "~\\\\\\section{$1}"
-v -
_help_paragraph_latex : -skip "$1"
-v +
-e[] "\\small"
-e[] "\\begin{lstlisting}[escapechar=]"
-e[] "$1"
-e[] "\\end{lstlisting}"
-e[] "\\normalsize"
-v -
_help_footer_latex :
-v +
-e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
-v -
_help_header_man :
-v + -e[] ".TH G\47MIC 1\n\
.SH NAME\n\
gmic \\- Perform generic image processing operations, through the G\47MIC language interpreter.\n\
\n\
.SH HELP\n" -v -
_gmic_n="\\fR" _gmic_b="\\fB" _gmic_r="" _gmic_g="" _gmic_c="\\fB" _gmic_m=""
_prerelease=
-__help_header_ascii
_gmic_n="__N" _gmic_b="__B" _gmic_r="__B" _gmic_c="__B"
_section=0 _space1="" _space2=" "
-_help_section "Usage"
_help_section_man :
_section+=1
{narg({'"$1"'})},1,1,1,{'-'}
-v +
-e[] "\n \\fB"$_section". $1"
-e[] "    "${_space{narg({'$_section'})}}{t}"\\fR\n"
-v -
-rm.
_help_paragraph_man :
-l[] ({'"$*"'})
-replace_str "\\fR","__N"
-replace_str "\\fB","__B"
-replace_str "\\","\\\\\\\\"
-replace_str "__N","\\\\fR"
-replace_str "__B","\\\\fB"
-v +
-e[] {0,t}
-v -
-rm -endl
_help_footer_man :
-_help_footer_ascii $"*"
use_vt100 :
-v - -if {0$_vt100>0}
_gmic_n="\33[0;0;0m" _gmic_r="\33[0;31;59m" _gmic_g="\33[0;32;59m" _gmic_m="\33[0;35;59m"
_gmic_c="\33[0;36;59m" _gmic_b="\33[1m"
-endif -v +
#@gmic version
#@gmic : Display current version number on stdout.
version :
-v -
-m "_e : -echo_stdout[] \"$""*\""
-if {$^==-1} -_e[] "" -endif
-__help_header_ascii[]
-uncommand _e
-v +
v :
-version
#@gmic :: Input/output
#@gmic camera : _camera_index>=0,_nb_frames>0,_skip_frames>=0,_capture_width>=0,_capture_height>=0 : (+)
#@gmic : Insert one or several frames from specified camera.
#@gmic : When 'nb_frames==0', the camera stream is released instead of capturing new images.
#@gmic : Default values: 'camera_index=0' (default camera), 'nb_frames=1', 'skip_frames=0' and 'capture_width=capture_height=0' (default size).
#@gmic m : eq. to '-command'. : (+)
#@gmic command : _add_debug_info={ 0 | 1 },{ filename | http[s]://URL | "string" } : (+)
#@gmic : Import G'MIC custom commands from specified file, URL or string.
#@gmic : (eq. to '-m').
#@gmic : Imported commands are available directly after the '-command' invocation.
#@gmic : Default value: 'add_debug_info=1'.
#@gmic : $ image.jpg -command "foo : -mirror y -deform $""1" --foo[0] 5 --foo[0] 15
#@gmic cursor : _mode = { 0=hide | 1=show } : (+)
#@gmic : Show or hide mouse cursor for selected instant display windows.
#@gmic : Command selection (if any) stands for instant display window indices instead of image indices.
#@gmic : Default value: 'mode=1'.
#@gmic d : eq. to '-display'. : (+)
#@gmic display : _X>=0,_Y>=0,_Z>=0,_exit_on_anykey={ 0 | 1 } : (+)
#@gmic : Display selected images in an interactive viewer (use the instant display window [0] if opened).
#@gmic : (eq. to '-d').
#@gmic : Arguments 'X','Y','Z' determine the initial selection view, for 3d volumetric images.
#@gmic : Default value: 'X=Y=Z=0' and 'exit_on_anykey=0'.
#@gmic : $$
#@gmic d0 : eq. to '-display0'.
d0 :
-_display0
#@gmic display0
#@gmic : Display selected images without value normalization.
#@gmic : (eq. to '-d0').
display0 :
-_$0
_display0 :
-v -
w=0 h=0 d=0 s=0
-repeat $! -l[$>] w+={w} h={max($h,h)} d={max($d,d)} s={max($s,s)} -endl -done
-if {$!==1} -w -1,-1,0,0,-1,-1,{0,n}\ ($wx$hx$dx$s)
-elif {$!==2} -w -1,-1,0,0,-1,-1,{0,n},{n}\ ($wx$hx$dx$s)
-else -w -1,-1,0,0,-1,-1,{0,n},..,{n}\ ($wx$hx$dx$s)
-endif
-v + -d
-v - -w[] 0 -v +
#@gmic d3d : eq. to '-display3d'. : (+)
#@gmic display3d : _[background_image],_exit_on_anykey={ 0 | 1 } : _exit_on_anykey={ 0 | 1 } : (+)
#@gmic : Display selected 3d objects in an interactive viewer (use the instant display window [0] if opened).
#@gmic : (eq. to '-d3d').
#@gmic : Default values: '[background_image]=(default)' and 'exit_on_anykey=0'.
#@gmic da : eq. to '-display_array'.
da :
-v - _gmic_s="$?" -v +
-_display_array $*
#@gmic display_array : _width>0,_height>0
#@gmic : Display images in interactive windows where pixel neighborhoods can be explored.
#@gmic : Default values: 'width=13' and 'height=width'.
display_array :
-v - _gmic_s="$?" -v +
-_$0 $*
_display_array : -check ${1=13}>0" && "${2=$1}>0
-e[0--3] "Display $1x$2 array of pixel values for image"$_gmic_s"."
-v -
dxb={round($1/2,1,1)} dxf={$1-1-$dxb}
dyb={round($2/2,1,1)} dyf={$2-1-$dyb}
-repeat $! -l[$>]
-if {w<128" && "h<128} -r 128,128,100%,100%,0,0,0.5,0.5 -endif
x0=0 y0=0 w={w} h={h}
wmax={0.9*{*,u}} hmax={0.9*{*,v}}
-do
-if {w>=$wmax||h>=$hmax}
n={n} -nm. "Image "'{b}.{x}'" is too large, please select a sub-image."
--select. 2 x0={i[0]} y0={i[1]} w={1+i[3]-i[0]} h={1+i[4]-i[1]}
-rm. -nm. $n
-endif
--z. $x0,$y0,0,{$x0+$w-1},{$y0+$h-1},0 -round. 1 -n. 0,255
-while {w>=$wmax||h>=$hmax}
x1=-1 y1=-1 c1=0 ox1=-1 oy1=-1 oc1=-1
x2=-1 y2=-1 c2=0 ox2=-1 oy2=-1 oc2=-1
x3=-1 y3=-1 c3=0 ox3=-1 oy3=-1 oc3=-1
c0=0 oxm=-1 oym=-1
-w. -1,-1,0,0,-1,-1,{-2,b}.{-2,x}
-do
-wait[0-3]
oc0=$c0
-repeat 4
-if {$>" && "!{*$>}" && "${x$>}>=0} -w$> 0 x$>=-1 y$>=-1 c$>=0 -endif
-if {*$>,o} c$>={(${c$>}+sign({*$>,o}))%s} -wait[$>] -1 -endif
-if {{*$>,SPACE}" || "{*$>,ENTER}" || "{*$>,ARROWRIGHT}" || "{*$>,ARROWDOWN}} c$>={(${c$>}+1)%s} -wait[$>] -1 -endif
-if {{*$>,BACKSPACE}" || "{*$>,ARROWLEFT}" || "{*$>,ARROWUP}} c$>={(${c$>}-1)%s} -wait[$>] -1 -endif
-done
-if {$oc0!=$c0} c1=$c0 c2=$c0 c3=$c0 -endif
xm={*,x} ym={*,y}
-if {$xm>=0" && "{*,b}&1} x1=$xm y1=$ym -endif
-if {$xm>=0" && "{*,b}&2} x2=$xm y2=$ym -endif
-if {$xm>=0" && "{*,b}&4} x3=$xm y3=$ym -endif
-if {$xm>=0" && "($oxm!=$xm" || "$oym!=$ym)} -w[] -1,-1,-1,-1,-1,-1,{-2,b}.{-2,x}" - ("$xm,$ym")" -endif
-if {$x1!=$ox1" || "$y1!=$oy1" || "$x2!=$ox2" || "$y2!=$oy2" || "$x3!=$ox3" || "$y3!=$oy3}
[-1]
-if {$x1>=0}
xb={$x1-$dxb} yb={$y1-$dyb} xe={$x1+$dxf} ye={$y1+$dyf}
-rectangle. $xb,$yb,$xe,$ye,0.2,0,255,255
-rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,0,255,255
-endif
-if {$x2>=0}
xb={$x2-$dxb} yb={$y2-$dyb} xe={$x2+$dxf} ye={$y2+$dyf}
-rectangle. $xb,$yb,$xe,$ye,0.2,255,32,255
-rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,32,255
-endif
-if {$x3>=0}
xb={$x3-$dxb} yb={$y3-$dyb} xe={$x3+$dxf} ye={$y3+$dyf}
-rectangle. $xb,$yb,$xe,$ye,0.2,255,255,0
-rectangle. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,255,0
-endif
-w. {-2,w},{-2,h} -rm. oxm=$xm oym=$ym
-endif
-if {$x1>=0" && "($ox1!=$x1" || "$oy1!=$y1" || "$oc1!=$c1)}
--z.. {$x1-$dxb},{$y1-$dyb},0,$c1,{$x1+$dxf},{$y1+$dyf},0,$c1
--z.. {$x1-$dxb},{$y1-$dyb},0,{$x1+$dxf},{$y1+$dyf},0
-__display_array[-2,-1] $1,$2,0,255,255
-w1. {w},{h},0,0,-1,-1,{-3,b}" - ("$x1,$y1,c=$c1")"
-rm. ox1=$x1 oy1=$y1 oc1=$c1
-endif
-if {$x2>=0" && "($ox2!=$x2" || "$oy2!=$y2" || "$oc2!=$c2)}
--z.. {$x2-$dxb},{$y2-$dyb},0,$c2,{$x2+$dxf},{$y2+$dyf},0,$c2
--z.. {$x2-$dxb},{$y2-$dyb},0,{$x2+$dxf},{$y2+$dyf},0
-__display_array[-2,-1] $1,$2,255,32,255
-w2. {w},{h},0,0,-1,-1,{-3,b}" - ("$x2,$y2,c=$c2")"
-rm. ox2=$x2 oy2=$y2 oc2=$c2
-endif
-if {$x3>=0" && "($ox3!=$x3" || "$oy3!=$y3" || "$oc3!=$c3)}
--z.. {$x3-$dxb},{$y3-$dyb},0,$c3,{$x3+$dxf},{$y3+$dyf},0,$c3
--z.. {$x3-$dxb},{$y3-$dyb},0,{$x3+$dxf},{$y3+$dyf},0
-__display_array[-2,-1] $1,$2,255,255,0
-w3. {w},{h},0,0,-1,-1,{-3,b}" - ("$x3,$y3,c=$c3")"
-rm. ox3=$x3 oy3=$y3 oc3=$c3
-endif
-while {{*}" && "\
!{*,ESC}" && "!{*,Q}" && "\
!{*1,ESC}" && "!{*1,Q}" && "\
!{*2,ESC}" && "!{*2,Q}" && "\
!{*3,ESC}" && "!{*3,Q}}
-k[0] -w 0 -w1 0 -w2 0 -w3 0
-endl -done -v +
__display_array :
-round.. 1 -c.. 0,999 -r. 100%,100%,1,3,{s==1}
--luminance. -r.. {$1*24},{$2*24} -grid.. {100/$1}%,{100/$2}%,0,0,1,0
xb={24*int($1/2)} yb={24*int($2/2)} xe={$xb+24} ye={$yb+24}
-rectangle.. $xb,$yb,$xe,$ye,1,0xFFFFFFFF,$3,$4,$5
-repeat $2 yg=$>
-repeat $1 xg=$>
-t.. {-3,i($xg,$yg)},{5+$xg*24},{5+$yg*24},13,0.8,{if(i($xg,$yg)>128,0,255)}
-done
-done
-rm[-3,-1]
#@gmic dfft : eq. to '-display_fft'.
dfft :
-_display_fft
#@gmic display_fft
#@gmic : Display fourier transform of selected images, with centered log-module and argument.
#@gmic : (eq. to '-dfft').
#@gmic : $ image.jpg --display_fft
display_fft :
-_$0
_display_fft :
-e[0--3] "Render fourier transform of image$? with centered log-module and argument."
-v - -repeat $! -l[$>] -fftpolar -+.. 1 -log.. -n 0,255 -a x -endl -done -s x,2 -v +
#@gmic dg : eq. to '-display_graph'.
dg : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
-_display_graph ${1-8},"$9","$10"
#@gmic display_graph : _width>32,_height>32,_plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_xlabel,_ylabel
#@gmic : Render graph plot from selected image data.
#@gmic : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@gmic : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@gmic : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@gmic : Default values: 'width=640', 'height=480', 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0 (auto)', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 128,1,1,1,'cos(x/10+u)' --display_graph 400,300,3
display_graph : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
-_display_graph ${1-8},"$9","$10"
_display_graph : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
-e[0--3] "Render $1x$2 graph plot from data of image$?."
-v - -repeat $! -l[$>] nm={0,n}
one={$3!=3} siz={w*h*d}
-if {$5==$6} xmin=0 xmax={$siz-$one} -else xmin={min($5,$6)} xmax={max($5,$6)} -endif
-if {$7==$8} ymin={im-(iM-im)/20} ymax={iM+(iM-im)/20} -else ymin={min($7,$8)} ymax={max($7,$8)} -endif
dx={$xmax-$xmin} dy={$ymax-$ymin}
u=${"-_axes[] "$xmin,$xmax",{0.3*$1/14}"} offx={arg(1,$u)} deltax={arg(2,$u)}
u=${"-_axes[] "$ymin,$ymax",{0.3*$2/14}"} offy={arg(1,$u)} deltay={arg(2,$u)}
gw={$1-32} gh={$2-32} gg={($gw-$one)/($siz-$one)}
$gw,$gh,1,3,255
-grid. {$deltax*$gw/$dx},{$deltay*$gh/$dy},{($offx-$xmin)*$gw/$dx},{$gh-($offy-$ymin)*$gh/$dy},0.25,0xCCCCCCCC,0
-if {{-2,s}==1} (120,120,200)
-elif {{-2,s}<=3} (220,10,10;10,220,10;10,10,220)
-else
(0,255) -r. 256,1,1,1,3 -map. 2 -z. 2,100% -permute. cxyz -r. 3,{-3,max(3,s)},1,1,0,2
-sh. 0,2,0,0 -f. 255,0,0,0,255,0,0,0,255 -rm.
-endif
-repeat {-3,s} -sh... $> -graph... [-1],$3,$4,$ymax,$ymin,1,{-2,@0-2} -rm. -shift. 0,-1 -done
-rm[-3,-1]
-line. 0,0,100%,0,1,110 -line. 100%,0,100%,100%,1,110
-line. 100%,100%,0,100%,1,255 -line. 0,100%,0,0,1,255
100%,100%,1,1,255
-axes. $xmin,$xmax,$ymax,$ymin,14,1,0
-if {$xmin>0} -axes. 0,0,$ymax,$ymin,14,1,160 -endif
-if {$xmax<0} -axes. {w-1},{w-1},$ymax,$ymin,14,1,160 -endif
-if {$ymin>0} -axes. $xmin,$xmax,{h-1},{h-1},14,1,160 -endif
-if {$ymax<0} -axes. $xmin,$xmax,0,0,14,1,160 -endif
--erode. 3 -!=. 255 -r.. 100%,100%,1,3 -j... [-2],0,0,0,0,1,[-1],1 -rm[-2,-1]
-frame. 16,16,220
0 -t. "$9",0,0,14,1,-220,-220,-220 -j.. [-1],{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 -rm.
0 -t. "$10",0,0,14,1,-220,-220,-220 -rotate. -90 -j.. [-1],2,{({-2,h}-h)/2},0,0,-1 -rm.
-nm $nm -endl -done -c 0,255 -v +
#@gmic dh : eq. to '-display_histogram'.
dh :
-v - _gmic_s="$?" -v +
-_display_histogram $"*"
#@gmic display_histogram : _width>0,_height>0,_clusters>0,_min_value[%],_max_value[%],_show_axes={ 0 | 1 },_expression.
#@gmic : Render a channel-by-channel histogram.
#@gmic : If selected image has several slices, the rendering is performed for all input slices.
#@gmic : 'expression' is a mathematical expression used to transform the histogram data for visualization purpose.
#@gmic : (eq. to '-dh').
#@gmic : Default values: 'width=512', 'height=300', 'clusters=256', 'min_value=0%', 'max_value=100%', 'show_axes=1' and 'expression=i'.
#@gmic : $ image.jpg --display_histogram 512,300
display_histogram :
-v - _gmic_s="$?" -v +
-_$0 $"*"
_display_histogram : -check "${1=512}>0 && ${2=300}>0 && ${3=256}>0" -skip ${4=0%},${5=100%},${6=1},"${7=i}"
-e[0--3] "Render $1x$2 channel-by-channel histogram of image"$_gmic_s", with $3 clusters, minimum value $4 and maximum value $5."
-v - -repeat $! -l[$>] nm={0,n}
-if ${-is_percent\ $4} m={im+(iM-im)*$4} -else m=$4 -endif
-if ${-is_percent\ $5} M={im+(iM-im)*$5} -else M=$5 -endif
s={s} -s c
-repeat $s -l[{-1-$>}] -s z -histogram $3,$m,$M -a z -endl -done
-a c -f '"$7"' vM={iM} -s z
-repeat $! -l[$>]
$1,$2,1,{s},-255
-repeat {s} -sh[-2,-1] $> -graph. [-2],3,0,$vM,0,1,0 -rm[-2,-1] -done
-rm.. -+ 255
-if $6
100%,100%
-axes. $m,$M,$vM,0,14,1,255
-if {$m>0} -axes. 0,0,$vM,0,14,1,200 -endif
-if {$M<0} -axes. {w-1},{w-1},$vM,0,14,1,200 -endif
--dilate. 3 -r.. [-3] -j... [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
-endif
-endl -done
-a z -nm $nm
-endl -done -v +
#@gmic display_parametric : _width>0,_height>0,_outline_opacity,_vertex_radius>=0,_is_antialiased={ 0 | 1 },_is_decorated={ 0 | 1 },_xlabel,_ylabel
#@gmic : Render 2d or 3d parametric curve or point clouds from selected image data.
#@gmic : Curve points are defined as pixels of a 2 or 3-channel image.
#@gmic : If the point image contains more than 3 channels, additional channels define the (R,G,B) color for each vertex.
#@gmic : If 'outline_opacity>1', the outline is colored according to the specified vertex colors and 'outline_opacity-1' is used
#@gmic : as the actual drawing opacity.
#@gmic : Default values: 'width=512', 'height=width', 'outline_opacity=3', 'vertex_radius=0', 'is_antialiased=1', 'is_decorated=1', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 1024,1,1,2,'t=x/40;if(c==0,sin(t),cos(t))*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)' -display_parametric 512,512
#@gmic : $ 1000,1,1,2,u(-100,100) -quantize 4,1 -noise 12 -channels 0,2 --normalize 0,255 -append c -display_parametric 512,512,0.1,8
display_parametric : -check "${1=512}>0 && ${2=$1}>0 && ${4=0}>=0" -skip ${3=3},${5=1},${6=1},"${7=x-axis}","${8=y-axis}"
-v - s0="no " s1="" o0="" o1="colored "
-v + -e[^-1] "Render $1x$2 parametric graph plot from data of image$?, with "${o{$3>1}}"outline opacity "{if($3>1,$3-1,$3)}\
", vertex radius $4, "${s{$5!=0}}"antialiasing and "${s{$6!=0}}"decoration." -v -
-repeat $! -l[$>]
nm={0,n} N={w*h*d}
-i[0] ({'CImg3d'}) -+[0] 0.5 -i[1] ($N;$N)
-if {s==4} --channels. 3,3 -r. 100%,100%,1,2 -a[-2,-1] c is_grayscale=1
-else is_grayscale={s<4} -channels. 0,5
-endif
-sh. 0 xm={im} xM={iM} -rm.
-sh. 1 ym={im} yM={iM} -rm.
-sh. 2 zm={im} zM={iM} -rm.
-permute. cxyz -s. x,2
-i.. (1,0;1,{$N-1}) -r.. 2,$N,1,1,3 -round.. 1,$N,1,1,1
-y -a y -c3d -n3d -*3d 1,-1,1
{if($6,max(1,$1-32),$1)},{if($6,max(1,$2-32),$2)},1,{if($is_grayscale,1,3)},255
-*3d[0] {0.96*min(w,h)}
-if $6 L={0.1*max($1,$2)} -grid[1] $L,$L,0,0,0.25,0xCCCCCCCC,0 -endif
-if $5
-r[1] 200%,200%,1,100%,1 -*3d[0] 2
-if $4 --circles3d[0] {2*$4} -j3d[1] [2],50%,50%,0,1,3,0,0 -rm[2] -endif
-elif $4
--circles3d[0] $4 -j3d[1] [2],50%,50%,0,1,3,0,0 -rm[2]
-endif
-if $3 -l[0] -s3d -f[1] 'i-y' -rm[3] -i[3] (2,0,1;2,{$N-2},{$N-1}) -r[3] 3,{$N-1},1,1,3 -round[3]
-r[5] 1,{h-1},1,1,0
-if {$3>1} -r[4] 3,{4,h/3},1,1,-1 -r[4] 3,{4,h-1},1,1,2 -else -rm[4] -i[4] 3,{$N-1} -endif
-y -a y -endl -j3d[1] [0],50%,50%,0,{if($3>1,$3-1,$3)},2,0,0
-endif
-rm[0]
-if $5 -r. 50%,50%,1,100%,2 -endif
-if $6
xc={0.5*($xm+$xM)} yc={0.5*($ym+$yM)} dx={0.5*($xM-$xm)/0.96} dy={0.5*($yM-$ym)/0.96}
xm={$xc-$dx} xM={$xc+$dx} ym={$yc-$dy} yM={$yc+$dy}
100%,100%,1,1,255 -axes. $xm,$xM,$yM,$ym,14,1,0
-if {$xm>0} -axes. 0,0,$yM,$ym,14,1,160 -endif
-if {$xM<0} -axes. {w-1},{w-1},$yM,$ym,14,1,160 -endif
-if {$ym>0} -axes. $xm,$xM,{h-1},{h-1},14,1,160 -endif
-if {$yM<0} -axes. $xm,$xM,0,0,14,1,160 -endif
--erode. 3 -!=. 255 -r.. 100%,100%,1,3 -j... [-2],0,0,0,0,1,[-1],1 -rm[-2,-1]
-frame 1,1,128 -frame 15,15,220
0 -t. "$7",0,0,14,1,-220,-220,-220 -j.. [-1],{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 -rm.
0 -t. "$8",0,0,14,1,-220,-220,-220 -rotate. -90 -j.. [-1],2,{({-2,h}-h)/2},0,0,-1 -rm.
-endif
-nm. $nm
-endl -done -v +
#@gmic dp : eq. to '-display_polar'.
dp :
-v - _gmic_s="$?" -v +
-_display_polar $*
#@gmic display_polar : _width>32,_height>32,_outline_type,_fill_R,_fill_G,_fill_B,_theta_start,_theta_end,_xlabel,_ylabel
#@gmic : Render polar curve from selected image data.
#@gmic : (eq. to '-dp').
#@gmic : 'outline_type' can be { r<0=dots with radius -r | 0=no outline | r>0=lines+dots with radius r }.
#@gmic : 'fill_color' can be { -1=no fill | R,G,B=fill with specified color }.
#@gmic : Default values: 'width=500', 'height=width', 'outline_type=1', 'fill_R=fill_G=fill_B=200', 'theta_start=0', 'theta_end=360', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 300,1,1,1,'0.3+abs(cos(10*pi*x/w))+u(0.4)' -display_polar 512,512,4,200,255,200
#@gmic : $ 3000,1,1,1,'x^3/1e10' -display_polar 400,400,1,-1,,,0,{15*360}
display_polar :
-v - _gmic_s="$?" -v +
-_$0 $*
_display_polar : -check "${1=500}>32 && ${2=$1}>32" -skip ${3=1},${4=200},${5=$4},${6=$5},${7=0},${8=360},"${9=x-axis}","${10=y-axis}"
-e[0--3] "Render $1x$2 polar graph plot from data of image"$_gmic_s", with outline $4 and fill color ($4,$5,$6)."
-v - -repeat $! -l[$>] nm={0,n}
M={max(abs(iM),abs(im))}
-* {0.48*min($1,$2)/$M}
-y ({$7*pi/180};{-$8*pi/180}) -r. 1,[-2],1,1,3
--sin. -cos.. -*. [-3] -*[-3,-2]
-a[-2,-1] x N={h}
-nm. coords
-if $3
({'CImg3d'}) -+. 0.5 ($N,$N)
--z[coords] 0,2
1,$N,1,1,2 1,$N,1,1,'y' --+. 1 -a[-3--1] x -=. 0,2,100%
3,$N,1,1,0 1,$N,1,1,1 -y[-6--1] -a[-6--1] y
-nm. _plot_polar_outline
-endif
-if {"$4>=0 && $5>=0 && $6>=0"}
({'CImg3d'}) -+. 0.5 ({$N+1},$N)
--z[coords] 0,-1,2,100% -z. 0,2
1,$N,1,1,3 1,$N 1,$N,1,1,'1+y' --+. 1 -a[-4--1] x -=. 1,3,100%
3,$N,1,1,$4,$5,$6 1,$N,1,1,1
-y[-6--1] -a[-6--1] y
-nm. _plot_polar_fill
-endif
-rm[coords]
{$1-32},{$2-32},1,3,255
L={0.1*max($1,$2)} -grid. $L,$L,0,0,0.25,0xCCCCCCCC,0
-if {"$4>=0 && $5>=0 && $6>=0"}
-j3d. [_plot_polar_fill],50%,50%,0,1,2,1,0
-rm[_plot_polar_fill]
-endif
-if $3
-if {$3>=0}
-j3d. [_plot_polar_outline],50%,50%,0,1,1,0,0
-endif
-if {$3!=0}
-if {abs($3)>1} -circles3d[_plot_polar_outline] {abs($3)} -endif
-j3d. [_plot_polar_outline],50%,50%,0,0.2,2,0,0
-endif
-rm[_plot_polar_outline]
-endif
nM={$M/0.96}
100%,100%,1,1,255 -axes. {-$nM},$nM,$nM,{-$nM},14,1,0
--erode. 3 -!=. 255 -r.. 100%,100%,1,3 -j... [-2],0,0,0,0,1,[-1],1 -rm[-2,-1]
-frame. 1,1,128 -frame. 15,15,220
0 -t. "$9",0,0,13,1,-220,-220,-220 -j.. [-1],{({-2,w}-w)/2},{{-2,h}-16},0,0,-1 -rm.
0 -t. "$10",0,0,13,1,-220,-220,-220 -rotate. -90 -j.. [-1],2,{({-2,h}-h)/2},0,0,-1 -rm.
-nm $nm -endl -done -v +
#@gmic drgba : eq. to '-display_rgba'.
drgba :
-_display_rgba
#@gmic display_rgba
#@gmic : Render selected RGBA images over a checkerboard background.
#@gmic : (eq. to '-drgba').
#@gmic : $ image.jpg --norm -threshold. 40% -blur. 3 -normalize. 0,255 -append c -display_rgba
display_rgba :
-_$0
_display_rgba :
-e[0--3] "Render RGBA image$? over a checkerboard background."
-v - -to_a -repeat $! -l[$>]
-i[0] (160,128;128,160) -nm[0] {1,n} -r[0] 16,16 -r[0] [1],[1],1,{s-1},0,2 -blend alpha
-endl -done -v +
#@gmic dt : eq. to '-display_tensors'.
dt :
-v - _gmic_s="$?" -v +
-_display_tensors $*
#@gmic display_tensors : _size_factor>0,_ellipse_factor>=0,_colored_mode={ 0 | 1 }
#@gmic : Render selected mask field of 2x2 tensors with ellipses.
#@gmic : (eq. to '-dt').
#@gmic : Default values: 'size_factor=16', 'ellipse_factor=0.92', 'color_mode=1'.
#@gmic : $ image.jpg -diffusiontensors 0.7,0.6 -crop 60,10,90,30 --display_tensors ,
#@gmic : $$
display_tensors :
-v - _gmic_s="$?" -v +
-_$0 $*
_display_tensors : -check "${1=16}>0 && ${2=0.92}>=0" -skip "${3=1}"
-e[0--3] "Render field of 2x2 tensors from image"$_gmic_s", with size factor $1, ellipse factor $2 in "${-arg\ 1+!$3,colored,masked}" mode."
-v -
-if {$3} -repeat $! -l[$>]
--_display_tensors $1,$2,0
-s[0] c --min[0,2] -*[1] -1 -+[1,-1] -a[0-2] c
-r[0] [-1],[-1] -n[0] 0,255 -*
-endl -done -else -repeat $! -l[$>]
w={w} h={h}
-* {($2*$1/2)^2/max(abs(im),abs(iM))}
-s c -i.. [-2] -a c -s yx -r 2,2,1,1,-1
(0.5,0;0,0.5) -+[^-1] [-1] -rm.
-invert -y c -r $1,$1
$1,$1,1,1,'x' --. {w/2}
$1,$1,1,1,'y' --. {h/2}
--sqr. -*.. [-3] -sqr... -i.. [-2] -a[-4--1] c
-*[^-1] [-1] -rm. -compose_channels + -<= 1
-append_tiles $w,$h
-endl -done -endif
-v +
#@gmic dw : eq. to '-display_warp'.
dw :
-v - _gmic_s="$?" -v +
-_display_warp $*
#@gmic display_warp : _cell_size>0
#@gmic : Render selected 2d warping fields.
#@gmic : (eq. to '-dw').
#@gmic : Default value: 'cell_size=15'.
#@gmic : $ image.jpg -luminance -blur 5 -gradient -append c -display_warp ,
display_warp :
-v - _gmic_s="$?" -v +
-_$0 $*
_display_warp : -check "${1=15}>0"
-e[0--3] "Render 2d warping field"$_gmic_s", with cell size $1."
-v - -repeat $! -l[$>]
-if {d!=1||s!=2}
-v + -error[0--3] "Command '-display_warp': Invalid image ["{$!-$>-1}"]: Dimensions "{w}","{h}","{d}","{s}" does not represent a 2d field of 2d vectors."
-endif
-i[0] 100%,100%,1,1,1 -grid[0] $1,$1 -nm[0] {1,n}
-warp[0] [1],1,1,0 -rm[1]
-endl -done -* 255 -v +
#@gmic document_gmic : _format={ ascii | bash | html | images | latex },_image_path,_write_wrapper={ 0 | 1 }
#@gmic : Create documentation of .gmic command files (loaded as raw 'uchar' images), in specified format.
#@gmic : Default values: 'format=ascii', 'image_path=""' and 'write_wrapper=1'.\n
#@gmic : Example(s) : raw:filename.gmic,char -document_gmic html,img
document_gmic : -skip ${1="ascii"},${2=""},${3=1}
-if {!$!} -return -endif
-v -1
_name={0,b}
-if {$!>1} -i[1--2] (10) -endif -a y -m {t} -s -,10
-_document_gmic_header_$1[] $3
_subsection=0
_example=0
_command=0
_is_example=0
_path="$2"
ks0="0" ks1="-k[0]"
-repeat $! -l[$>] -if {h>7" && "same([{^}],'#@gmic',6)" && (i[6]==_' ' || i[6]==_':')"}
-rows 7,100% -autocrop {'" "'}
_is_example=0
-if {i!=_':'}
_command+=1
-s -,{'": "'} -autocrop {'" "'}
-_document_gmic_declaration_$1
-else
-rows 1,100%
-if {i==_':'}
_subsection+=1
-rows 1,100% -autocrop {'" "'}
-_document_gmic_subsection_$1
-else
-autocrop {'" "'}
-if {i==_'$'}
-rows 1,100% -autocrop {'" "'}
_is_example=1
-if {i!=_'$'} _example+=1 -endif
_filename=$_path$_name$_example.jpg
-_document_gmic_example_$1
-else
-_document_gmic_description_$1
-endif
-endif
-endif
-endif ${ks{$!!=0}} -endl -done
-rm
-_document_gmic_footer_$1[] $3
_document_gmic_header_ascii : -skip $1
_shortcut=0
_document_gmic_subsection_ascii :
-v +
-e[] "\n\n "$_gmic_r$_gmic_b"**** "{0,t}":"$_gmic_n"\n"
-v -
_document_gmic_declaration_ascii :
-if {[{^}]=='(+)'} qualifier=" "{t} -rm. -else qualifier="" -endif
-if {$!>1" && "same([{^}],'"eq. to "',7)}
-rows. 7,100% -autocrop. {'.'} -autocrop. {'" "'} -autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
-else
-v + -e[] "\n    "$_gmic_m${_gmic_b}"-"{0,t}${qualifier}":"$_gmic_n -v - -rm[0]
-if $!
s="                        "
-y x
-repeat {$!-1} ({'" |"'}) -a[$>,-1] x -done
-repeat $! -l[$>] -_document_gmic_split_ascii 80,0
-repeat {$!-1} ({'\n$s"  "'}) -a[$>,-1] x -done
-a x -v + -e[] $_gmic_g$s{0,t}$_gmic_n -v -
-endl -done
-endif
-v + -e[] "" -v -
-endif
_document_gmic_description_ascii :
s="        " bs0="\n" bs1="\\\\\n         "
-y x -if {!narg($_is_tutorial)} -_document_gmic_split_ascii 96 -endif
-if {$!==1" && "0$_vt100>0" && "same([{^}],["'(eq. to '"],8)} -i[0] ({'$_gmic_b'}) ({'$_gmic_n\n'}) -a x -endif
-repeat {$!-1} ({'${bs$_is_example}$s"  "'}) -a[$>,-1] x -done -a x
-if {0$_vt100>0}
-replace_str "Default values:","\n"$s${_gmic_b}"Default values:"$_gmic_n
-replace_str "Default value:","\n"$s${_gmic_b}"Default value:"$_gmic_n
-endif
-v + -repeat $! -e[] $s{$>,t} -v - -done
_document_gmic_example_ascii :
_document_gmic_footer_ascii : -skip $1
-if $_shortcut
({'"Commands shortcuts"'}) -_document_gmic_subsection_ascii. -v + -e[] "" -v - -rm.
-v + -repeat $_shortcut
-e[] "    "$_gmic_m$_gmic_b"-"${_shortcut$>}" "${_shortcutqualifier$>}":"$_gmic_n" eq. to '"$_gmic_g${_shortcutlink$>}$_gmic_n"'."
-done -v -
-endif
-v + -e[] "\n   "$_gmic_c"[ Total number of commands: "$_command" ]"$_gmic_n -v -
_document_gmic_split_ascii :
-do -if {w>$1}
i={$1-1}
-repeat {$1/2} -if {C=i($1-1-$>);C==32||C==38||C==42||C==43||C==44||C==46||C==47||C==58||C==59||C==63||C==92||C==124} i={$1-1-$>} -break
-endif -done
--z. {$i+1},100% -z.. 0,$i
-endif -while {w>$1}
_document_gmic_header_bash : -skip $1
-v +
-e[] "#
\n#  Bash completion rules for 'gmic'.
\n#
\n# This file has been generated automatically.
\n# Do not edit!
\n#
\n# This file should be copied/renamed in '/etc/bash_completion.d/gmic'.
\n#
\n
\n_"$_name"()
\n{
\n\tlocal cur prev opts coms
\n\tCOMPREPLY=()
\n\tcur=\"${COMP_WORDS[COMP_CWORD]}\"
\n\tprev=\"${COMP_WORDS[COMP_CWORD-1]}\"
"
-v -
_opts=
_coms=
_argcommand=0
_shortcut=0
_nbopts=0
_nbcoms=0
_document_gmic_subsection_bash :
_document_gmic_description_bash :
_document_gmic_example_bash :
_document_gmic_declaration_bash :
_opts$_nbopts=-{0,t}" "--{0,t}
_nbopts+=1
_coms$_nbcoms={0,t}
_nbcoms+=1
-if {"s = ["{^}"]; s=='input' || s=='i' || s=='output' || s=='o' || s=='command' || s=='m'"} -return -endif
-repeat $! -if {[{^}]=='(+)'} -rm[$<] -endif -done
-if {$!==2" && "same([{^}],'"eq. to "',7)}
-rows. 7,100% -autocrop. {'.'} -autocrop. {'" "'} -autocrop. 39 -autocrop. {'-'}
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut=${-str2hex\ {1,t}}
-rm.
_shortcut+=1
-elif {$!>1}
_command$_argcommand={0,t}
-if {[{0,^}]=='help'}
_argument$_argcommand="$coms\" -- \"$cur"
-else
-if {$!==2} ({'>'}) -endif
-discard[^0] {'" "'} -i[2--2] ({'" "'}) -a[^0] y
_argument$_argcommand={1,t}
-endif
_argumentlink${-str2hex\ {0,t}}=${_argument$_argcommand}
_argcommand+=1
-endif
_document_gmic_footer_bash : -skip $1
-v +
-e[] "\topts=\"\\" -repeat $_nbopts -e[] "\t      "${_opts$>}\\ -done -e[] "\t     \""
-e[] "\n\tcoms=\"\\" -repeat $_nbcoms -e[] "\t      "${_coms$>}\\ -done -e[] "\t     \""
-e[] "\n\tcase \"${prev}\" in"
-repeat $_argcommand
-e[] "\t\t\"-"${_command$>}"\" | \"--"${_command$>}"\")"
-if {'${_command$>}'=='i'" || "'${_command$>}'=='o'" || "same('${_command$>}','input',5)" || "same('${_command$>}','output',6)}
-e[] "\t\tCOMPREPLY=( $(compgen -f) )\n\t\treturn 0\n\t\t;;"
-else
-e[] "\t\tCOMPREPLY=( $(compgen -W \""${_argument$>}"\") )\n\t\treturn 0\n\t\t;;"
-endif
-done
-repeat $_shortcut
-if {['${_shortcut$>}']=='i'" || "['${_shortcut$>}']=='o'}
-e[] "\t\t\"-"${_shortcut$>}"\" | \"--"${_shortcut$>}"\")"
-e[] "\t\tCOMPREPLY=( $(compgen -f) )\n\t\treturn 0\n\t\t;;"
-elif {narg(${_argumentlink${_shortcutlink$>}})}
-e[] "\t\t\"-"${_shortcut$>}"\" | \"--"${_shortcut$>}"\")"
-e[] "\t\tCOMPREPLY=( $(compgen -W \""${_argumentlink${_shortcutlink$>}}"\") )\n\t\treturn 0\n\t\t;;"
-endif
-done
-e[] "\tesac"
-e[] "\n\tif [[ \"$cur\" == -* ]] ; then
\n\t\tCOMPREPLY=( $(compgen -W \"$opts\" -- \"$cur\") )
\n\telse
\n\t\t_filedir
\n\tfi
\n
\n}
\n
complete -F _"$_name" -o filenames gmic"
-v -
_document_gmic_header_html :
-if $1 -v + -e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<head>
\n<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>
\n<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />
\n<script type=\"text/javascript\">
\nhs.graphicsDir = 'highslide/graphics/';
\nhs.wrapperClassName = 'wide-border';
\n</script>
\n</head>
\n<body>
\n"
-v - -endif
-m "don : -_document_gmic_desc_on_html"
-m "doff : -_document_gmic_desc_off_html"
-m "eon : -_document_gmic_ex_on_html"
-m "eoff : -_document_gmic_ex_off_html"
_is_desc=0
_is_ex=0
_shortcut=0
_document_gmic_desc_on_html :
-v -
-if $_is_desc
-u "<br/>"
-else
-u "<p style=\"margin-left:100px\"><tt>"
_is_desc=1
-endif
-v +
_document_gmic_desc_off_html :
-v -
-if $_is_desc
-u "</tt></p>"
_is_desc=0
-else -u ""
-endif
-v +
_document_gmic_ex_on_html :
-v -
-if $_is_ex
-u ""
-else
-u "<br/><table style=\"margin-left:100px\" width=\"75%\" bgcolor=\"#FFFFFF\" bordercolor=\"black\" border=\"1\" cellpadding=\"4\" cellspacing=\"0\">"\
"<tr><td colspan=\"2\" bgcolor=\"#000000\"><font color=\"white\"><b>Example of use:</b></font></td></tr>"
_is_ex=1
-endif
-v +
_document_gmic_ex_off_html :
-v -
-if $_is_ex
-u "</table>"
_is_ex=0
-else
-u ""
-endif
-v +
_document_gmic_subsection_html :
-v +
-e[] ${-eoff}${-doff}"<br/><h2><a href=\"#toc\"><img alt=\"\" border=\"0\" src=\"img/back_top.png\" /></a>&nbsp;&nbsp;"\
"<a id=\"subsection"$_subsection"\"><font color=\"#B00000\">"{0,t}"</font></a></h2>"
-v -
_document_gmic_declaration_html :
-if {[{^}]=='(+)'} qualifier=" "{t} -rm. -else qualifier="" -endif
s1="\n" s0=" |<br/>"
-if {$!>1" && "[{^}]=='"eq. to "'}
-rows. 7,100% -autocrop. {'.'} -autocrop. {'" "'} -autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
-else
_command_name={0,t}
-v +
-e[] ${-eoff}${-doff}"<p style=\"margin-left:20px\"><a id=\""{0,t}"\"><font color=\"#005090\">&nbsp;&nbsp;<b>-"{0,t}$qualifier"</b>:</font></a>"
-if {$!>1}
-e[] "<p style=\"margin-left:120px\"><tt><i><font color=\"#900090\">"
-repeat {$!-1} -l[{1+$>}]
-if {h>48} -v - -replace_str ",",", " -v + -endif
-e[] {0,t}${s{$<==0}}
-endl -done
-e[] "</font></i></tt></p>"
-else -e[] ""
-endif
-v -
-endif
_document_gmic_description_html :
-if {same([{^}],'"Default value"',13)}
-s +,{':'} -l[^0] -a y -endl -autocrop {':'} -autocrop {'" "'}
-v +
-if {$!>1} -e[] ${-don}"<br/><b>"{0,t}"</b>: "{t}
-else -e[] ${-don}"<br/>"{0,t}
-endif
-v -
-elif {same([{^}],'"(eq. to "',8)}
-v + -e[] ${-don}"<i><font color=\"blue\">"{t}"</font></i>" -v -
-else
-if {(i<_'A'" || "i>_'Z')" && "i!=40" && "i!=39} -v + -e[] ${-don}"&nbsp;"{t} -v -
-else -v + -e[] ${-don}{t} -v -
-endif
-endif
_document_gmic_example_html :
-if {i==_'$'}
-if {h==1" && "i==_'$'} tuturl=http://gmic.eu/tutorial/_$_command_name.shtml
-else -autocrop {'$'} -autocrop {'" "'} tuturl=http://gmic.eu/tutorial/{0,t}.shtml
-endif
-v +
-e[] ${-eon}"<tr><td width=\"24\" align=\"center\"><a target=\"_blank\" href=\""$tuturl"\"><img alt=\"\" border=\"0\" src=\"img/moreinfos.png\" /></td>"\
"<td><a target=\"_blank\" href=\""$tuturl"\">A tutorial page exists for this command.</a></td></tr>"
-v -
-else
-if $_filename -else
-m "foo : "{t}
-l[] -v -99 -reset -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
-uncommand foo
-endif
-v +
-e[] ${-eon}"<tr><td width=\"24\" align=\"center\"><div><a href=\""$_filename"\" class=\"highslide\" onclick=\"return hs.expand(this)\">"\
"<font color=\"blue\"><img alt=\"\" border=\"0\" src=\"img/zoom.png\" /></font></a><div class=\"highslide-caption\">"{t}"</div></div></td><td><tt>"{t}"</tt></td></tr>"
-v -
-endif
_document_gmic_footer_html : -skip $1
-if $_shortcut
_subsection+=1
({'"Commands shortcuts"'}) -_document_gmic_subsection_html. -rm.
-v + -e[] "<p style=\"margin-left:20px\">"
-repeat $_shortcut
-e[] "<font color=\"green\"><b>&nbsp;&nbsp;-"${_shortcut$>}" "${_shortcutqualifier$>}"</b>:</font>"
-e[] "<font color=\"blue\"><i>eq. to '"${_shortcutlink$>}"'</i></font><br/>"
-done
-e[] "</p>" -v -
-endif
-v +
-e[] ${-eoff}${-doff}"<p style=\"margin-left:100px\"><font color=\"blue\"><b>[ Total number of commands: "$_command" ]</b></font>"
-v -
-uncommand don,doff,eon,eoff
_document_gmic_header_images : -skip $1
-v +
-e[] "\n - Generate example images from set of commands '"$_name"'.\n"
-if image.jpg -else -testimage2d 400 -o. image.jpg -rm. -endif
-v -
_document_gmic_subsection_images :
-v +
-e[] "\n ** Section ""#"$_subsection": "{0,t}".\n"
-v -
_document_gmic_declaration_images : _command_name={0,t}
_document_gmic_description_images :
_document_gmic_example_images :
-if {i==_'$'} -return -endif
-v +
-e[] "    ["$_example"] Command '-"$_command_name"': $ "{t}
-v -
-if $_filename -else
-m "foo"$_example" : "{t}
-l[] -v -1 -reset -v -99 -foo$_example -v -1 -_document_gmic -o $_filename,85 -rm -endl
-uncommand foo$_example
-endif
_document_gmic_footer_images : -skip $1
-v +
-e[] " - [ All done! ]\n\n"
-v -
_document_gmic_header_latex :
-if $1 -v +
-e[] "\\documentclass[a4paper,10.5pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,color}
\n\\graphicspath{{"$_path"}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{5.875in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\oddsidemargin}{15.5pt}
\n\\setlength{\\evensidemargin}{15.5pt}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\definecolor{ca}{rgb}{0.8,0,0}
\n\\definecolor{cb}{rgb}{0,0.2,0.6}
\n\\definecolor{cc}{rgb}{0,0.5,0}
\n\\definecolor{cd}{rgb}{0.6,0.6,0.6}
\n\\def\\Ccr{\\color{ca}}
\n\\def\\Ccb{\\color{cb}}
\n\\def\\Ccg{\\color{cc}}
\n\\def\\Ccc{\\color{cd}}
\n\\def\\Ccn{\\color{black}}
\n\\def\\comma{\\discretionary{,}{}{,}}
\n\\newcommand{\\Ca}[1]{\\textcolor{ca}{#1}}
\n\\newcommand{\\Cb}[1]{\\textcolor{cb}{#1}}
\n\\newcommand{\\Cc}[1]{\\textcolor{cc}{#1}}
\n\\newcommand{\\Cd}[1]{\\textcolor{cd}{#1}}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\begin{document}
\n\\tableofcontents"
-v - -endif
-v + -e[] "\n\\chapter{List of commands}" -v -
-m "eon : -_document_gmic_ex_on_latex"
-m "eoff : -_document_gmic_ex_off_latex"
_is_desc=0
_is_ex=0
_shortcut=0
_document_gmic_ex_on_latex :
-v -
-if $_is_ex
-u "\\\\"
-else
-u "\\begin{center}"
_is_ex=1
-endif
-v +
_document_gmic_ex_off_latex :
-v -
-if $_is_ex
-u "\\end{center}"
_is_ex=0
-else
-u ""
-endif
-v +
_document_gmic_subsection_latex :
_is_desc=0
-_document_gmic_replace_latex
-v + -e[] ${-eoff}"\n\\section{"{0,t}"}" -v -
_document_gmic_declaration_latex :
_is_desc=0
-if {[{^}]=='(+)'} qualifier={t} -rm. -else qualifier="" -endif
e1="\\end{flushleft}" e0="~~~\\\\"
-if {$!>1" && "same([{^}],'"eq. to "',7)}
-_document_gmic_replace_latex
-rows. 7,100% -autocrop. {'.'} -autocrop. {'" "'} -autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
-else
-_document_gmic_replace_latex[0]
_command_name={0,t}
-v + -e[] ${-eoff}"\n\n\\subsection{\\emph{-"{0,t}"\\index{-"{0,t}"}} "$qualifier"}\\vspace*{-0.7em}"
-if {$!>1}
-e[] "~\\\\\\textbf{\\Cb{Arguments: }}\\begin{flushleft}"
-repeat {$!-1} -l[{1+$>}]
-v - -s y,-60 -if {$!>1} -i[1--2] ({'\\-'}) -endif -y -a y
-_document_gmic_replace_latex -v +
-e[] "{\\small \\Cb{\\hspace*{0.5cm}$\\bullet$~~\\texttt{"{0,t}"}}}"${e{$<==0}}
-endl -done
-endif
-v -
-endif
_document_gmic_description_latex :
s0="" s1="~\\\\" s=${s$_is_desc}
-_document_gmic_replace_latex
-if {same([{^}],'"Default value"',13)}
-s +,{':'} -l[^0] -a y -endl -autocrop {':'} -autocrop {'" "'}
-if {$!>1}
-replace_str[1] " and ","} and \\\\texttt{"
-v + -e[] ${-eoff}"\\begin{flushleft}\\Cc{\\textbf{"{0,t}"}:\\\\~\\\\\\hspace*{0.5cm}{\\small $\\bullet$~~\\texttt{"{t}"}}}\\end{flushleft}" -v -
-else -v + -e[] ${-eoff}$s"~\\\\"{0,t} -v -
-endif
-elif {same([{^}],'"(eq. to "',8)}
-rows. 8,100% -autocrop. {'.'} -autocrop. {')'} -autocrop. {'" "'}
-v + -e[] ${-eoff}$s"(\\emph{eq. to} {\\small \\texttt{"{t}"}})." -v -
-else
-if {(i<_'A'" || "i>_'Z')" && "i!=40" && "i!=39} -v + -e[] ${-eoff}{t} -v -
-else -v + -e[] ${-eoff}$s{t} -v -
-endif
-endif
_is_desc=1
_document_gmic_example_latex :
-if {i==_'$'}
-if {h==1" && "i==_'$'} tuturl=http://gmic.eu/tutorial/\\_$_command_name.shtml
-else -autocrop {'$'} -autocrop {'" "'} tuturl=http://gmic.eu/tutorial/{0,t}.shtml
-endif
-l[] ({'$tuturl'}) -replace_str "_","\\_"
-s x,-60 -if {$!>1} -i[1--2] ({'\\\\-'}) -endif -a x
-replace_str. "_","\\_" tuturl={t} -rm -endl
-v +
-e[] ${-eoff}
-if {!$_is_ex} -e[] "~\\\\" -endif
-e[] "~\\textbf{Tutorial page: }\\\\\\url{"$tuturl"}"
-v -
-else
_is_desc=0
-if $_filename -else
-m "foo : "{t}
-l[] -v -99 -reset -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
-uncommand foo
-endif
-_document_gmic_replace_latex
-v +
-e[] ${-eon}"\\includegraphics[keepaspectratio=true,height=6cm,width=\\textwidth]{"$_filename"}\\\\"
-e[] "{\\footnotesize \\textbf{Example "$_example"~:} \\texttt{"{t}"}}"
-v -
-endif
_document_gmic_footer_latex :
-if $_shortcut
({'"Commands shortcuts"'}) -_document_gmic_subsection_latex. -rm.
-v + -repeat $_shortcut
-e[] "$\\bullet$~'\\texttt{\\Ca{-"${_shortcut$>}"}}' "${_shortcutqualifier$>}"~is equivalent to~~'\\texttt{\\Ca{"${_shortcutlink$>}"}}'.\\\\"
-done -v -
-endif
-if $1
-v +
-e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
-v -
-endif
-uncommand eon,eoff
_document_gmic_replace_latex :
-replace_str "\\","\\\\textbackslash "
-replace_str "_","\\\\_"
-replace_str "%","\\\\%"
-replace_str "#","\\\\%"
-replace_str "^","\\\\textasciicircum "
-replace_str "$","\\\\$"
-replace_str "\{","\\\\\{"
-replace_str "\}","\\\\\}"
-replace_str "&","\\\\&"
-replace_str "|","~$|$~"
-replace_str "<","$\<$"
-replace_str ">","$\>$"
-replace_str "\\\\textbackslash -","\\\\-"
-replace_str ",","{\\\\\\comma}"
_document_gmic_header_man : -skip $1
_gmic_n="\\fR" _gmic_b="\\fB" _gmic_r="" _gmic_g="" _gmic_c="\\fB" _gmic_m=""
-_document_gmic_header_ascii $"*"
_document_gmic_subsection_man :
-v +
-e[] "\n "$_gmic_b"** "{0,t}":"$_gmic_n
-v -
_document_gmic_declaration_man :
-if {[{^}]=='(+)'} qualifier=" "{t} -rm. -else qualifier="" -endif
-if {$!>1" && "same([{^}],'"eq. to "',7)}
-rows. 7,100% -autocrop. {'.'} -autocrop. {'" "'} -autocrop. 39
_shortcut$_shortcut={0,t}
_shortcutlink$_shortcut={t}
_shortcutqualifier$_shortcut=$qualifier
_shortcut+=1
-else
-v + -e[] "\n    "${_gmic_b}"-"{0,t}${qualifier}":"$_gmic_n -v - -rm[0]
-if $!
s="                        "
-y x
-repeat {$!-1} ({'" |"'}) -a[$>,-1] x -done
-repeat $! -l[$>] -_document_gmic_split_ascii 80,0
-repeat {$!-1} ({'\n$s"  "'}) -a[$>,-1] x -done
-a x -v + -e[] $s{0,t} -v -
-endl -done
-endif
-v + -e[] "" -v -
-endif
_document_gmic_description_man :
s="        " bs0="\n" bs1="\\\\\n         "
-y x -if {!narg($_is_tutorial)} -_document_gmic_split_ascii 96 -endif
-repeat {$!-1} ({'${bs$_is_example}$s"  "'}) -a[$>,-1] x -done -a x
-replace_str "Default values:","Default values:"
-replace_str "Default value:","Default value:"
-replace_str "\\","\\\\"
-v + -repeat $! -e[] $s{$>,t} -v - -done
_document_gmic_example_man :
_document_gmic_footer_man : -skip $1
-_document_gmic_footer_ascii $"*"
_document_gmic :
-repeat $! -l[$>] W$>={w} H$>={h} D$>={d} S$>={s} IS_3D$>=${-_is_3d} -endl -done
-repeat $! -l[$>]
-if ${IS_3D$>} -r3d 1,1,0,-80 -r3d 0,1,0,80 -snapshot3d 400
-else -if {w>8192} -z 0,8191 -elif {h>8192} -rows 0,8191 -endif -n 0,255
-endif -endl -done
--append_tiles , -if {w>900} r={round(900*100/w,0.1)} -r[^-1] $r%,$r%,1,100%,2 -endif -rm.
-repeat $! -l[$>]
-if {s==1} -r {w},{h},1,3 -else -r {w},{h},1,3,0 -endif
-if {w<=h&&h<256} -r2dy 256,2 -elif {h<=w&&w<256} -r2dx 256,2 -endif
-if {w<=h&&h>512} -r2dy 512,2 -elif {h<=w&&w>512} -r2dx 512,2 -endif
-if {h<48} -r 100%,48 -endif
-if {w<48} -r 48,100% -endif
-frame 1,1,0 -frame 4,4,255
-endl -done
N=$! -repeat $N -l[$>]
{w},16,1,3,255
-if {w>75}
-if {$N>1} -if {w>110} -t. Image\ [$>]:,3,3,15 -else -t. [$>]:,3,3,15 -endif -endif
-if ${IS_3D$>} 0 -t. (3d\ object),0,0,13,1,255
-else 0 -t. (${W$>}x${H$>}x${D$>}x${S$>}),0,0,13,1,255
-endif
-negative. -n. 0,255 -+. 164 -c. 0,255 -to_rgb.
-j.. [-1],{{-2,w}-w-5},{{-2,h}-h-1} -rm.
-else -t. [$>]:,3,3,15 -endif
-rv[-2,-1] -a[-2,-1] y
-endl -done
-- 255 -append_tiles , -+ 255
-if {w<256} -- 255 -r 256,100%,1,3,0,0,0.5,0.5 -+ 255 -endif
-if {h<256} -- 255 -r 100%,256,1,3,0,0,0.5,0.5 -+ 255 -endif
#@gmic e : eq. to '-echo'. : (+)
#@gmic echo : message : (+)
#@gmic : Output specified message on the error output.
#@gmic : (eq. to '-e').
#@gmic : Command selection (if any) stands for displayed call stack subset instead of image indices.
#@gmic echo_file : filename,message
#@gmic : Output specified message, appending it to specified output file.
#@gmic : (similar to '-echo' for specified output file stream).
echo_file : -skip "${2='\n'}"
-v - ({"'${2--1}\n'"}) -o. raw:$1,char -rm. -v +
#@gmic echo_stdout : message
#@gmic : Output specified message, on the standard output (stdout).
#@gmic : (similar to '-echo' for output on standard output instead of standard error).
echo_stdout :
-v -  ({'"$*"\n'}) -o. -.raw,char -rm. -v +
#@gmic function1d : 0<=smoothness<=1,x0>=0,y0,x1>=0,y1,...,xn>=0,yn
#@gmic : Input continuous 1d function from specified list of keypoints (xk,yk)
#@gmic : in range [0,max(xk)] (xk are positive integers).
#@gmic : Default values: 'smoothness=1' and 'x0=y0=0'.
#@gmic : $ -function1d 1,0,0,10,30,40,20,70,30,80,0 --display_graph 400,300
function1d : -check "${1=1}>=0 && $1<=1" -skip ${2=0},${3=0}
-e[^-1] "Input continuous 1d function, with smoothness $1 and keypoints (${2--1})."
-v - -l[]
smoothness={max(0,min(1,$1))}
(${2--1}) -r 2,{int(w/2)},1,1,-1
-sort +,y -s x size={0,if(iM>=0,1+int(iM),0)}
-if {!$size} -rm 0 -break -endif
-a x
--f '0.5*(j(0,1,0,0,0,1)-j(0,-1,0,0,0,1))' -s. x -max.. 0.01 -/. [-2] -rm.. -a x
$size,1,1,1,-1
-repeat {0,h-1}
x0={0,i(0,$>)} y0={0,i(1,$>)} x1={0,i(0,$>+1)} y1={0,i(1,$>+1)}
slope={($y1-$y0)/max(0.01,$x1-$x0)}
yp0={0,i(2,$>)*$smoothness+(1-$smoothness)*$slope}
yp1={0,i(2,$>+1)*$smoothness+(1-$smoothness)*$slope}
i={round($x0,1,1)} j={round($x1,1,0)}
-line[1] $i,0,$j,0,1,$>
-if {$j-$i<=1}
({$y0-$x0*$slope}^{$slope}^0^0)
-else
(1,$x0,{($x0)^2},{($x0)^3};\
1,$x1,{($x1)^2},{($x1)^3};\
0,1,{2*$x0},{3*($x0)^2};\
0,1,{2*$x1},{3*($x1)^2})
($y0;$y1;$yp0;$yp1)
-solve. [-2] -rm.. -y. c
-endif
-done
-a[2--1] x -map.. [-1] -rm.
100%,1,1,1,1
(0,{w-1}) -r. {-2,w},1,1,1,3 -round.
--sqr. --*[-2,-1] -a[-4--1] c -*[-2,-1] -s. c -+[-4--1] -rm..
-endl -v +
#@gmic gmicky
#@gmic :  Insert new image of the G'MIC mascot 'Gmicky'.
gmicky :
-gmicky_deevad -nm. [gmicky]
#@gmic gmicky_deevad
#@gmic : Insert new image of the G'MIC mascot 'Gmicky', by David Revoy.
#@gmic : $ -gmicky_deevad
gmicky_deevad :
-e[^-1] "Insert image of the G\47MIC mascot 'Gmicky', by David Revoy."
-v -
filename=${_path_rc}gmicky_large_deevad.cimgz
-if $filename $filename
-else http://gmic.eu/img/gmicky_large_deevad.cimgz -o. $filename -+. 0
-endif
-nm. [gmicky_deevad]
-v +
#@gmic gmicky_mahvin
#@gmic : Insert new image of the G'MIC mascot 'Gmicky', by Mahvin.
#@gmic : $ -gmicky_mahvin
gmicky_mahvin :
-e[^-1] "Insert image of the G\47MIC mascot 'Gmicky', by Mahvin."
-v -
filename=${_path_rc}gmicky_large_mahvin.cimgz
-if $filename $filename
-else http://gmic.eu/img/gmicky_large_mahvin.cimgz -o. $filename -+. 0
-endif
-nm. [gmicky_mahvin]
-v +
#@gmic gmicky_wilber
#@gmic : Insert new image of the G'MIC mascot 'Gmicky' together with GIMP mascot 'Wilber', by Mahvin.
#@gmic : $ -gmicky_wilber
gmicky_wilber :
-e[^-1] "Insert image of the G\47MIC mascot 'Gmicky' together with GIMP mascot 'Wilber', by Mahvin."
-v -
filename=${_path_rc}gmicky_wilber_large.cimgz
-if $filename $filename
-else http://gmic.eu/img/gmicky_wilber_large.cimgz -o. $filename -+. 0
-endif
-nm. [gmicky_wilber] -v +
#@gmic i : eq. to '-input'. : (+)
#@gmic input : [type:]filename : [type:]http://URL : [selection]x_nb_copies>0 : { width>0[%] | [image_w] },{ _height>0[%] | [image_h] },{ _depth>0[%] | [image_d] },{ _spectrum>0[%] | [image_s] },_{ value1,_value2,.. | 'formula' } : (value1{,|;|/|^}value2{,|;|/|^}..) : 0 : (+)
#@gmic : Insert a new image taken from a filename or from a copy of an existing image ['indice'],"
#@gmic : or insert new image with specified dimensions and values. Single quotes may be omitted in
#@gmic : 'formula'. Specifying argument '0' inserts an 'empty' image.
#@gmic : (eq. to '-i' | (no arg)).
#@gmic : Default values: 'nb_copies=1', 'height=depth=spectrum=1' and 'value1=0'.
#@gmic : $ -input image.jpg
#@gmic : $ -i (1,2,3;4,5,6;7,8,9^9,8,7;6,5,4;3,2,1)
#@gmic : $ image.jpg (1,2,3;4,5,6;7,8,9) (255^128^64) 400,400,1,3,'if(x>w/2,x,y)*c'
#@gmic : $$
#@gmic input_clut : "clut_name",_resolution>0
#@gmic : Insert one of the pre-defined HaldCLUT at the end of the image list.
input_clut : -check "isval(${2=64}) && $2>0"
-e[^-1] "Input Hald-CLUT with name '$1' and resolution $2."
-v - -l[]
-if ${_path_rc}clut_"$1".cimgz -i ${_path_rc}clut_"$1".cimgz -endif
-if {"!"$!" || w!=$2 || h!=$2 || d!=$2"}
g_path_unix=/usr/lib/gimp/2.0/plug-ins/
-rm -repeat 2
-if {!$>" && "(isfile(${_path_rc}gmic_film_cluts.gmz)" || "\
isfile(${-path_gimp}plug-ins/gmic_film_cluts.gmz)" || "\
isfile(${g_path_unix}gmic_film_cluts.gmz))}
-if {isfile(${_path_rc}gmic_film_cluts.gmz)} -i ${_path_rc}gmic_film_cluts.gmz
-elif {isfile(${-path_gimp}plug-ins/gmic_film_cluts.gmz)} -i ${-path_gimp}plug-ins/gmic_film_cluts.gmz
-elif {isfile(${g_path_unix}gmic_film_cluts.gmz)} -i ${g_path_unix}gmic_film_cluts.gmz
-endif
-else -l[] -i http://gmic.eu/gmic_film_cluts.gmz -o ${_path_rc}gmic_film_cluts.gmz,uchar -endl
-endif
-repeat $! -if {['{$>,n}']==['"$1"']} -k[$>] -break -endif -done
-if {$!==1} -break -endif
-rm
-done
-if {!$!} -v + -error[0--4] "Command '-input_clut': Unknown CLUT name '$1'." -endif
-decompress_clut $2,$2,$2 -round
-o. ${_path_rc}clut_$1.cimgz,uchar
-endif
-endl -v +
#@gmic input_cube : "filename"
#@gmic : Insert CLUT data from a .cube filename (Adobe CLUT format).
input_cube :
-e[^-1] "Input Hald-CLUT from file '$1'."
-v - -l[]
-i raw:"$1",uchar -discard 13 -s -,{'\n'}
-repeat $! -if {$<,i==_'#'} -rm[$<] -endif -done
N=0
-repeat $! -if {same([{$>,^}],'LUT_3D_SIZE',11)}
-rows[$>] 11,100% -autocrop[$>] 32
dim={$>,t} N=$> -rm[$>] -break
-endif -done
N=0
-repeat $! -if {$>,i>=_'0'&&i<=_'9'} N=$> -break -endif -done
-k[$N--1]
(10) -append[^-1] [-1],y -rm. -a y
tmp_file=${-file_rand}
-o raw:$tmp_file,uchar -rm
-i dlm:$tmp_file
-r 3,$dim,$dim,$dim,-1 -permute yzcx -* 255
1 -o. raw:$tmp_file -rm.
-nm "$1"
-endl -v +
#@gmic ig : eq. to '-input_glob'.
ig :
-input_glob $*
#@gmic input_glob : pattern
#@gmic : Insert new images from several filenames that match the specified glob pattern.
input_glob :
-e[^1] "Input all files that match glob pattern '$*'."
-v -
-files 3,"$*"
N=$!
-m "_ig : $""=arg -repeat $""# -i ${arg{1+$>}} -done"
-_ig ${} -uncommand _ig
-if {$N==$!} -v + -error[0--3] "Command '-input_glob': No matching filenames for pattern '$*'." -endif
-v +
#@gmic input_gpl : filename
#@gmic : Input specified filename as a GIMP palette data file.
input_gpl :
-e[^-1] "Input GIMP palette file '$*'."
-v - -l[]
-i raw:"$*",char -replace 9,32 -s -,10
colors=0
-repeat $! -l[$>]
-s -,32
-if {$!>=3" && "isint({0,t})" && "isint({1,t})" && "isint({2,t})} colors=$colors;{0,t},{1,t},{2,t} -endif
-rm 0
-onfail -rm 0 -endl -done
-rm ($colors) -rows 1,100% -nm "$1" -permute yzcx
-endl -v +
#@gmic o : eq. to '-output'. : (+)
#@gmic output : [type:]filename,_format_options : (+)
#@gmic : Output selected images as one or several numbered file(s).
#@gmic : (eq. to '-o').
#@gmic : Default value: 'format_options'=(undefined).
#@gmic output_ggr : filename,_gradient_name
#@gmic : Output selected images as GIMP gradient files.
#@gmic : If no gradient name is specified, it is deduced from the filename.
output_ggr : -skip "${2=}"
-e[^-1] "Output image$? as GIMP gradient file '$1'."
-v - N=$!
-repeat $N --l[$>] -r 1,{w*h*d},1,100%,-1 -to_rgba -/ 255
-if {narg("$2")} name="$2"
-else -l[] 1 -nm. "$1" ({'{b}'}) -f "if(x==0 && i>=_'a' && i<=_'z',i-_'a'+_'A',i)" name={t} -rm -endl
-endif
({'"GIMP Gradient\nName: "$name\n{0,h}\n'})
-repeat {0,h}
start={_$>/{0,h}}
end={_($>+1)/{0,h}}
mid={_0.5*($start+$end)}
rgba={0,I(0,$>)}
r={arg(1,$rgba)} g={arg(2,$rgba)} b={arg(3,$rgba)} a={arg(4,$rgba)}
({'$start" "$mid" "$end" "$r" "$g" "$b" "$a" "$r" "$g" "$b" "$a" 0 0\n"'})
-done
-rm[0] -a x
-if {$N>1} -o raw:${"-filename \"$1\",$>"},char -else -o raw:"$1",char -endif
-rm
-endl -done -v +
#@gmic on : eq. to '-outputn'.
on :
-v - _gmic_s="$?" -v +
-_outputn $*
#@gmic outputn : filename
#@gmic : Output selected images as automatically numbered filenames in repeat..done loops.
#@gmic : (eq. to '-on').
outputn :
-v - _gmic_s="$?" -v +
-_$0 $*
_outputn :
-v - filename=${-filename\ "$1",$>} -v +
-e[0--3] "Output image"$_gmic_s" as file '"$filename"'."
-v - -o $filename -v +
#@gmic op : eq. to '-outputp'.
op :
-v - _gmic_s="$?" -v +
-_outputp $*
#@gmic outputp : prefix
#@gmic : Output selected images as prefixed versions of their original filenames.
#@gmic : (eq. to '-op').
#@gmic : Default value: 'prefix=_'.
outputp :
-v - _gmic_s="$?" -v +
-_$0 $*
_outputp : -skip ${1="_"}
-if {$!>1} -e[0--4] "Output image"$_gmic_s" as their initial locations, prefixed by '$1'."
-else -e[0--4] "Output image"$_gmic_s" as its initial location, prefixed by '$1'."
-endif
-v - -repeat $! -o[$>] {$>,f}$1{$>,b}.{$>,x} -done -v +
#@gmic ow : eq. to '-outputw'.
ow :
-v - _gmic_s="$?" -v +
-_outputw
#@gmic outputw
#@gmic : Output selected images by overwritting their original location.
#@gmic : (eq. to '-ow').
outputw :
-v - _gmic_s="$?" -v +
-_$0 $*
_outputw :
-if {$!>1} -e[0--4] "Output image"$_gmic_s" as their initial location."
-else -e[0--4] "Output image"$_gmic_s" as its initial location."
-endif
-v - -repeat $! -o[$>] {$>,n} -done -v +
#@gmic ox : eq. to '-outputx'.
ox :
-v - _gmic_s="$?" -v +
-_outputx $*
#@gmic outputx : extension1,_extension2,_...,_extensionN,_output_at_same_location={ 0 | 1 }
#@gmic : Output selected images with same base filenames but for N different extensions.
#@gmic : (eq. to '-ox').
#@gmic : Default value: 'output_at_same_location=0'.
outputx :
-v - _gmic_s="$?" -v +
-_$0 $*
_outputx :
-v -
$=arg
is_last_arg=0 is_same_location=0
-if {isval($-1)} is_last_arg={isint($-1)&&$-1>=0&&$-1<=1} is_same_location=$-1 -endif
N={$#-$is_last_arg} s0= s1=s
-if {!$N} -v + -e[0--3] "Output image"$_gmic_s" at same location, with same base filename but extension '' (skipped, no extension provided)." -return
-endif
-if $is_same_location
-v +
-if $is_last_arg -e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}"' ${^-1}'."
-else -e[0--4] "Output image"$_gmic_s" at same location, with same base filename but extension"${s{$N>1}}" '$*'."
-endif
-v -  -repeat $! -l[$>]
-repeat $N -o {0,f}{0,b}.${arg{1+$>}} -done
-endl -done
-else
-v +
-if $is_last_arg -e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}"' ${^-1}'."
-else -e[0--4] "Output image"$_gmic_s" with same base filename but extension"${s{$N>1}}" '$*'."
-endif
-v -  -repeat $! -l[$>]
-repeat $N -o {0,b}.${arg{1+$>}} -done
-endl -done
-endif
-v +
#@gmic pass : _shared_state={ 0=non-shared (copy) | 1=shared | 2=adaptive } : (+)
#@gmic : Insert images from parent context of a custom command or a local environment.
#@gmic : Command selection (if any) stands for a selection of images in the parent context.
#@gmic : By default (adaptive shared state), selected images are inserted in a shared state if they do not belong to the context (selection) of the current custom command or local environment as well.
#@gmic : Typical use of command '-pass' concerns the design of custom commands that take images as arguments.
#@gmic : Default value: 'shared_state=2'.
#@gmic : $ -command "average : -pass$""1 -add[^-1] [-1] -remove. -div 2" -testimage2d 512 --mirror y --average[0] [1]
#@gmic plot : _plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_exit_on_anykey={ 0 | 1 } : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_exit_on_anykey={ 0 | 1 } : (+)
#@gmic : Display selected image or formula in an interactive viewer (use the instant display window [0] if opened).
#@gmic : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@gmic : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@gmic : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@gmic : Default values: 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0 (auto)' and 'exit_on_anykey=0'.
#@gmic p : eq. to '-print'. : (+)
#@gmic print : (+)
#@gmic : Output information on selected images, on the standard error (stderr).
#@gmic : (eq. to '-p').
#@gmic rainbow_lut
#@gmic : Input a 256-entries RGB colormap of rainbow colors.
#@gmic : $ image.jpg -rainbow_lut --luminance.. -map. [-2]
rainbow_lut :
-e[^-1] "Input RGB colormap of 256 rainbow colors."
-v -
(2,10,13,13,15,16,15,15,18,23,26,31,33,37,38,39,42,42,44,45,44,44,45,45,44,42,44,45,45,49,50,52,54,55,56,57,\
56,56,57,57,58,57,58,58,59,58,60,59,58,59,59,59,59,59,60,60,59,59,59,59,60,59,59,59,59,59,59,59,58,58,58,56,\
56,54,51,48,44,39,33,20,5,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,25,50,66,81,90,102,109,118,129,137,144,152,158,168,178,183,190,199,207,\
213,220,227,230,236,242,246,250,255,255,253,253,253,252,251,250,250,249,248,248,247,248,246,246,246,245,246,\
245,245,245,246,246,246,246,246,246,246,246,245,245,245,245,245,244,245,244,245,245,245,245,245,245,245,245,\
245,244,244,245,245,243,239,235,230,226,220,216,211,204,201,194,190,184,176,171,164,160,152,144,138,130,122,\
114,107,96,87,78,69,57,50,46,38,31,19,5^3,10,14,15,17,18,19,18,19,23,25,30,31,35,37,39,42,44,45,48,49,50,51,\
52,53,56,59,63,66,66,68,69,71,73,74,75,76,76,77,78,79,79,80,81,81,82,82,83,84,84,84,84,84,85,85,86,86,86,86,\
87,88,87,86,86,86,86,88,89,89,90,92,92,94,96,99,102,104,107,111,117,120,126,130,136,142,149,155,161,167,172,\
176,178,179,179,178,178,178,178,177,177,177,176,176,176,176,175,173,173,174,173,172,171,171,171,171,171,171,\
171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,173,173,173,175,176,178,178,178,181,182,184,\
186,186,190,192,193,195,198,200,201,204,206,209,211,208,206,202,197,194,190,185,182,178,172,167,162,157,152,\
144,139,132,127,121,115,108,102,98,92,87,79,75,69,64,62,58,55,52,50,49,47,47,47,47,47,47,47,47,46,46,46,46,\
45,44,44,42,42,41,41,40,39,38,37,36,34,31,30,29,30,30,31,32,32,32,33,33,34,34,33,34,33,32,31,31,30,29,26,25,\
23,21,19,15,13,13,16,18,18,18,17,15,13,12,9,2^6,19,25,32,41,49,55,65,71,79,84,90,96,102,106,111,117,121,128,\
132,134,139,143,146,149,152,155,156,157,159,159,160,161,162,163,164,164,165,166,167,166,165,166,166,167,167,\
168,168,168,169,169,169,169,170,170,170,170,170,170,170,171,170,170,170,170,170,171,171,172,173,173,173,175,\
177,179,180,183,185,187,190,193,198,201,206,213,219,225,227,227,223,218,214,204,199,192,184,179,172,168,162,\
156,151,145,139,133,126,120,113,106,98,90,85,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,84,84,82,82,82,\
82,82,83,83,81,81,81,80,80,78,78,78,76,74,73,73,71,72,69,68,67,65,62,59,58,56,51,50,49,45,43,40,38,37,35,32,\
31,32,32,33,33,34,34,35,36,36,37,38,39,42,44,45,46,46,47,48,49,48,48,48,48,48,48,48,48,48,48,47,47,47,47,46,\
45,45,43,43,42,41,40,39,38,37,38,38,37,37,38,38,38,38,39,40,39,40,39,40,40,39,39,38,38,37,35,34,32,30,28,26,\
23,20,16,14,12,16,16,18,18,17,16,14,13,9,2)
-nm. [rainbow\ lut]
-v +
#@gmic roddy
#@gmic : Load a new image of the G'MIC Rodilius mascot 'Roddy'.
#@gmic : $ -roddy
roddy :
-e[^-1] "Load image of the G\47MIC Rodilius mascot 'Roddy'."
-v -
filename=${_path_rc}roddy_large.cimgz
-if $filename $filename
-else http://gmic.eu/img/roddy_large.cimgz -o. $filename -+. 0
-endif
-nm. [roddy] -v +
#@gmic select : feature_type,_X,_Y,_Z,_exit_on_anykey={ 0 | 1 } : (+)
#@gmic : Interactively select a feature from selected images (use the instant display window [0] if opened).
#@gmic : 'feature_type' can be { 0=point | 1=segment | 2=rectangle | 3=ellipse }.
#@gmic : Arguments 'X','Y','Z' determine the initial selection view, for 3d volumetric images.
#@gmic : The retrieved feature is returned as a 3d vector (if 'feature_type==0') or as a 6d vector
#@gmic : (if 'feature_type!=0') containing the feature coordinates.
#@gmic : The coordinates of the last selected features are also returned as the status value.
#@gmic : Default values: 'X=Y=Z=(undefined)' and 'exit_on_anykey=0'.
#@gmic serialize : _datatype,_is_compressed={ 0 | 1 },_store_names={ 0 | 1 } : (+)
#@gmic : Serialize selected list of images into a single image, optionnally in a compressed form.
#@gmic : 'datatype' can be { uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.
#@gmic : Specify 'datatype' if all selected images have a range of values constrained to a particular datatype, in order to minimize the memory footprint.
#@gmic : The resulting image has only integers values in [0,255] and can then be saved as a raw image of
#@gmic : unsigned chars (doing so will output a valid .cimg[z] or .gmz file).
#@gmic : If 'store_names' is set to '1', serialization uses the .gmz format to store data in memory (otherwise the .cimg[z] format).
#@gmic : Default values: 'datatype=float', 'is_compressed=1' and 'store_names=1'.
#@gmic : $ image.jpg --serialize uchar --unserialize.
#@gmic shape_heart : _size>=0
#@gmic : Input a 2d heart binary shape with specified size.
#@gmic : Default value: 'size=512'.
#@gmic : $ -shape_heart ,
shape_heart : -check "${1=512}>=0"
-e[^-1] "Input a $1x$1 heart binary shape."
-v -
ir={round($1)}
-if {!$ir} 0
-else -l[]
2048,1,1,1,'t=2*pi*x/w;16*sin(t)^3'
2048,1,1,1,'t=2*pi*x/w;13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)'
-a c -display_parametric $ir,$ir,1,0,0,0
-flood 50%,50%,0,0,0,1,0 -==. 0
-endl
-endif
-nm "[2d heart shape]"
-v +
#@gmic shape_circle : _size>=0
#@gmic : Input a 2d circle binary shape with specified size.
#@gmic : Default value: 'size=512'.
#@gmic : $ -shape_circle ,
shape_circle : -check "${1=512}>=0"
-e[^-1] "Input a $1x$1 circle binary shape."
-v -
ir={round($1)}
-if {!$ir} 0
-elif {$ir<2} $ir,$ir,1,1,1
-else
{int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} -=. 1,100%,100%
-distance. 1 -<=. {(i+0.4)/sqrt(2)}
--mirror. x
-if {$ir>1&&($ir%2)} -r. {w-1},100%,1,1,0,0,1 -endif
-a[-2,-1] x --mirror. y
-if {$ir>1&&($ir%2)} -r. 100%,{h-1},1,1,0,0,0,1 -endif
-a[-2,-1] y
-endif
-nm. "[2d circle shape]"
-v +
#@gmic shape_cupid : _size>=0
#@gmic : Input a 2d cupid binary shape with specified size.
#@gmic : Default value: 'size=512'.
#@gmic : $ -shape_cupid ,
shape_cupid : -check "${1=512}>=0"
-e[^-1] "Input a $1x$1 cupid binary shape." -v -
ir={round($1)}
-if {!$ir} 0
-else -l[]
(480,480,1,1,1)
({'"                                                                                                   -WHX         /ZL[         1\\N]         2k         2l         4m         4m         4m         4m      "\
"   4m         4m         4m         3l         3k         2k         1i         0i         /g         .g         -e         +c         )a         (`         &^         $\\         !Y          NW       "\
"   LU          IQ                                                                                                                                                                                       "\
"                                :R>Z         9ZD^      8T  *^G`      :X@Q  ?`Ib      ;ZCS  AcMe      ;[FTAQ \"{      ;\\GTBS $}      ;\\JVBS $}      ;]LWBT %}      ;hBV (~P      ;gBXNT 0~P      ;hC^ 0~P "\
"     GQEhC^ 0~P      KZKpK_ 0~P      M~TM_ 0~P      ~h 0~P     !~i 0~P     \"~j 0~P     \#~k 0~     \#~m 1~     $~n 0}     %~o 0|     %~q 1|     &~r 0{     \47~t 1z     (~w 1y     *~z 2x     +~| 2w     +~~"\
" 2v     ,~~P 1t     ,~~\\ <t     -~~_ =r     -~~` <p     .~~d =n     /~~f =m     0~~i =l     0~~i <j     0~~j ;h     0~~j 9f     /~~a /d     /~~a -b   4U  ~~` *_   3V !~~_ (\\   2X \"~~^ &Z   1Z $~~^ %X "\
"  0[ %~~^ \#U   /\\ &~~^     ,] \47~~^     ,^ (~~_     -_ )~~_     -` *~~_     -a +~~`     -a ,~~`     -c .~~a     -c /~~a     -d 0~~a     ,e 2~~b     -f 3~~b     ,f 4~~b     +f 5~~b     +h 8~~c     *i ;~"\
"~d     *k =~~d     )l @~~e     )o D~~f     (p F~~f     \47q I~~g     &r K~~g     %t N~~g     %w\"~~g     $x$~~g     .UJz\47~~f     .YL|*~~f KP    3ZL~-~~f LR    5~b1~~f MS    5~e4~~f MR    4~g5~~d MS    4~"\
"i8~~e MS    3~j:~~e MS    3~k;~~d LS    3~l<~~d LS    2~l=~~c KS    1~l>~~c LU    2~m?~~b KU    0~k?~~b KV    0~k@~~b KX    2~l@~~` KZ    2~k@~~` K[    1~j@~~_ LTKU   2U&~i?~~] LSHU   4X\47~i@~~] MTGT  "\
" 5[\47~g@~~\\ MTET   6\\\47~f?~~[ MSCT   7]&~e@~~Z MTCU   8_1VL~dA~~Z MTAU   9a5~pA~~Z NU@T   9c7~pA~~Y MT>U   :d:~qB~~Y LS=V   ;f<~rC~~Y MT<V   <h>~rC~~Y NT:V   <i@~rC~~Y U9V   =j@~qC~~Y T8W   =kB~qC~~Z\"T6"\
"V   <nD~oB~~Y\"T5V   =qF~oA~~X$T3U   <sH~n=~~T%T1U   ;vK~l:~~R\47T/U   <~~h9~~Q(U.U   <~~g8~~P(T-V   <~~g8~~P*T+U   ;~~f8~~P+U*U   ;~~e7~~+T(T   ;~~e6~|+T\47U   :~~d7~|+T&U   :~~c7~|,T%V   ;~~c6~{,S\#U   9~"\
"~b7~z-U\#V   9~~a7~z-T!U   7~~_7~y-U T   5~~^8~y.U NU   ?RH~~]8~x-T LU   BXK~~\\9~y.U LU   C~~k:~y/U JU   E~~l;~y.T IU   E~~l<~y.U HU   F~~m>~z/U GU   F~~m>~y.T FV   G~~m?~y.T DU   G~~m@~y.U DU   G~~n@~"\
"w-T BU   G~~m@UH~i-T AU   F~~m*~^-U AU   E~~l*~]-U ?U   E~~l*~Z+T >U   C~~l,~Y+U >U   B~~t5~X+U =V   A~~v9~W+U ;U   @~~w;~W+U ;U   >~~y@~W+U :U   <~~zC~W+T 9V   ;~~zF~W+U 9V   8~~yH~W,U 7U   5~~xL~X+U"\
" 7U   3~~~~S,U 6U   ?~~~~^,U 5U   @~~~~^+U 5V   B~~~~QIV+U 4V   C~~~~Q MU 3V   C~~~~P LT 2V   C~~~~ LU 2V   C~~~~ MU 1V   C~~~} MU 0V   B~~~| MT /V   A~~~{ NU /V   @~~~y NU /W   >~~~w NU /V   :~~~t U "\
".V   8~~~r!U -V   4~~~o\"U -V   .~~~j$U -W   1~~~r*V -V   3~~~y/V ,V   4~~~|1U ,W   5~~~~3V ,W   6~~~~R6V +V   5~~~~T8U +W   4~~~~U:T *W   4~~~~Z@U +W   3~~~~]DU +W   1~~~~^FT *W   0~~~~^HT *W   -~~~~^"\
"KT *X   +~~~~^NU +X   \"~~~~\\ +X   !~~~~\\ ,X    ~~~~[ +W    ~~~~\\ ,W    N~~~~\\ -W    N~~~~] .X    N~~~~] /X    M~~~~] 0Y    L~~~~] 1X    J~~~~\\ 2X    G~~~~[ 4X    @~~~~V 6Y    >~~~~U 7X    >~~~~X :X   "\
" >~~~~Z <Y    >~~~~] @Z    >~~~~t)Z    >~~~~{0[    =~~~~}4\\    =~~~~~Q9^    ;~~~~~R>a    4~~~~~Fd    4~~~~~n    5~~~~~o*S   1~~~~~q-X   4~~~~~y6Z   5~~~~~~UB]   7~~~~~~[J`   6~~~~~~p   /~~~~~hEu   /~~"\
"~~~f=o   0~~~~~f2d   /~~~~~e1c   /~~~~~e0a   ,~~~~~c/^   \#~~~~~\\.\\   !~~~~~[-Y    N~~~~~Z*T    K~~~~~Z    !~~~~~Z     ~~~~~X     K~~~~~T     C~~~~{     B~~~~y     @~~~~x     >~~~~v     =~~~~v     ;~~~"\
"~s     3~~~~l     1~~~~[M\\     0~~kKX:vGZ     .~~hHT4oDZ     ,TK`L~xGR\47_?Y     !]I~vGQ 5Y      ZG~vFP 4Y      NWF~vFP 4Y      =~wGQ 5Y      =~wGQ 5Y      =~wGQ 4X      >~xFP 4X      ?~zGQ 5X      @~{G"\
"Q 5Y      D~~GQ 4X      F~~QGR 5X      G~~RFQ 5X      H~~SFQ 4X      J~~TFR 5X      K~~UEQ 4W      L~~VEQ 4X      N~~WEQ 4X      ~~XER 4W      ~~XDQ 4X     \"~~YDQ 4X     \#~~ZDQ 3W     $~~[DR 4X     %~"\
"~[DR 4X     &~~\\CQ 4X     &~~\\CQ 4X     &~~\\CQ 4X     \47~~]CR 5X     \47~~]BQ 5X     \47~~\\AQ 5X     \47~~\\AQ 5X     (~~]AR 6X     (~~]@Q 6X     (~~]@Q 7Y     )~~]?Q 7X    LV 2~~]?R 8X   !] 5~~]>Q 8X   \#a 7~"\
"~]>Q 9Y   %d 8~~\\=R :X   &g 9~~\\=R :X   )k :~~\\<Q ;Y   7y :~~\\<Q ;X   8| ;~~[;R <X   9} ;~~[;R =Y   :~ ;~~[;R =X   :~Q <~~Z9Q >Y   ;~R <~~Z9R ?X   :~R <~~Y8R @Y   ;~S <~~X6Q @X   :~S <~~X6Q AY   ;~T ="\
"~~X5R BX   :~T >~~X4R CX   9~U B~~Z2Q CX   9~U F~~]1Q DX   8~V I~~_1Q EX   7~X L~~^/R GY   7~d*~~_/R HY   5~f/~~a.Q HX   4~h2~~a-Q IX   1TJ~_7~~c-R KY   $~^;~~e-R LY   \"~^=~~f,Q MY    ~_@~~h-Q NY    K"\
"~]B~~i-R!Y    H~[C~~k.R\"Y    B~WE~~l-Q\#Y    =~TG~~m-R%Y    ;~TH~~n.R\47Z    9~TJ~~p/R(Z    7~TL~~q.Q)Z    5~~~x.R,[    3~~~x/R-[    1~~~w/R.Z    /~~~w.Q0[    -~~~v.Q2\\    +~~~v/R4[    (~~~u/R6[    &~~~u"\
".Q8\\    $~~~t.Q9\\    \"~~~s.Q;\\     N~~~s/R>]     L~~~r.Q@]     I~~~q.QB^     G~~~p.QC]     D~~~p.QF\\     @~~~o.QH\\     =~~~n.RK\\     :~~~m.b     8~~~l.`     5~~~k.]     1~~~j.Y     +~~~h.W     (~~~g.U"\
"     &~~~g.T     \#~~~e.S     !~~VJ~X.S      N~~RF~V.R      L~~PD~U.R      J~{A~U/Q      G~w>~T      \#~s;~S      !~m6~R       N~i3~Q       J~a.~P       G~Z)~       E~ M}       Ds C|       Cf 6{       A"\
"a 2z       @] .z       ?Y +y       <S (y         C| 1R       :~R BVHX       ?~T CYKZ       A~U D[N]       C~V El       E~W El       G~X Dl       H~Y En       J~Z En       J~Y Dn       L~[ Dn       L~Z"\
" Cm       L~Z Al       M~Z @l       M~Z @l       N~Z ?k       M~Y =j       N~Y <i       M~X :h       N~W 8g       M~V 6e       M~V 4c       M~U 1a       L~T 0a       M~T ._       M~T ,]       M~S )[  "\
"     N~S %W       L~Q \"U       N~S  S       ~S         L~T         K~T         L~T         K~S         J~S         J~Q         G~P         G~         E|         Cz         Ax         ?v         =t    "\
"     ;r         9p         7p         6n         5n         4n         5n         4m         3l         2k         1j         0i         .g         -f         -f         ,e         ,e         ,f      "\
"   -f         ,e         ,f         -g         .g         .h         .g         .h         -f         -f         +c         \47`         \#Y                                                               "\
"                                            2"'})
--. {47+32} -a x -y -decompress_rle -r $ir,$ir,1,1,5 -if {$ir>480} -b. 0.2% -endif ->= 40%
-endl
-endif
-nm "[2d cupid shape]"
-v +
#@gmic shape_diamond : _size>=0
#@gmic : Input a 2d diamond binary shape with specified size.
#@gmic : Default value: 'size=512'.
#@gmic : $ -shape_diamond ,
shape_diamond : -check "${1=512}>=0"
-e[^-1] "Input a $1x$1 diamond binary shape."
-v -
ir={round($1)}
-if {!$ir} 0
-elif {$ir<2} $ir,$ir,1,1,1
-else
{int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} -=. 1,100%,100%
-distance. 1,1 -<=. {i/2}
--mirror. x
-if {$ir>1&&($ir%2)} -r. {w-1},100%,1,1,0,0,1 -endif
-a[-2,-1] x --mirror. y
-if {$ir>1&&($ir%2)} -r. 100%,{h-1},1,1,0,0,0,1 -endif
-a[-2,-1] y
-endif
-nm. "[2d diamond shape]"
-v +
#@gmic shape_polygon : _size>=0,_nb_vertices>=3,_angle
#@gmic : Input a 2d polygonal binary shape with specified geometry.
#@gmic : Default value: 'size=512', 'nb_vertices=5' and 'angle=0'.
#@gmic : $ -repeat 6 -shape_polygon 256,{3+$>} -done
shape_polygon : -check "${1=512}>=0 && isint(${2=5}) && $2>=3" -skip ${3=0}
-e[^-1] "Input a $1x$1 polygon binary shape, with $2 vertices and angle $3 deg."
-v -
ir={round($1)}
-if {!$ir} 0
-else -l[]
(0;{2*pi}) -+ {($3-90)*pi/180} -r. 1,{$2+1},1,1,3 -rows. 0,{h-2}
ir2={round($ir/2)}
--sin. -cos.. -a x -* {$ir2-1} -+ $ir2
$ir,$ir -polygon. $2,{-2,^},1,1 -rm..
-endl
-endif
-nm "[2d $2-polygon shape]"
-v +
#@gmic shape_snowflake : size>=0,_nb_recursions>=0
#@gmic : Input a 2d snowflake binary shape with specified size.
#@gmic : Default values: 'size=512' and 'nb_recursions=5'.
#@gmic : $ -repeat 6 -shape_snowflake 256,$> -done
shape_snowflake : -check "${1=512}>=0 && isint(${2=5}) && $2>=0 && $2<=6"
-e[^-1] "Input a $1x$1 snowflake binary shape, with $2 recursions."
-v -
ir={round($1)}
-if {!$ir} 0
-else -l[]
$ir,$ir (0;120;240) -*. {pi/180} --sin. -cos.. -a[-2,-1] c
-repeat $2
1,{4*h},1,2
-f.. "
p0 = I;
p1 = I[(y+1)%h];
t = (p1 - p0)/3;
pm = (p0 + p1)/2 - 0.866*[ -t[1], t[0] ];
k = 4*y;
I[#-1,k++] = p0;
I[#-1,k++] = p0 + t;
I[#-1,k++] = pm;
I[#-1,k] = p1 - t;
"
-rm..
-done
-*. {0.5*$1} -+. {$1/2} -permute. cyzx -polygon.. {h},{^},1,1 -rm.
-endl -endif
-nm "[2d snowflake shape]"
-v +
#@gmic shape_star : _size>=0,_nb_branches>0,0<=_thickness<=1
#@gmic : Input a 2d star binary shape with specified size.
#@gmic : Default values: 'size=512', 'nb_branches=5' and 'thickness=0.38'.
#@gmic : $ -repeat 9 -shape_star 256,{$>+2} -done
shape_star : -check "${1=512}>=0 && ${2=5}>0 && ${3=0.5}>=0 && $3<=1"
-e[^-1] "Input a $1x$1 star binary shape, with $2 branches and thickness $3."
-v -
ir={round($1)}
-if {!$ir} 0
-else -l[]
-star3d $2,$3 -col3d 1 -c3d -n3d -*3d $1,$1
$1,$1 -j3d. [-2],50%,50%,0,1,2 -rm..
-endl
-endif
-nm "[2d star shape]"
-v +
#@gmic sh : eq. to '-shared'. : (+)
#@gmic shared : x0[%],x1[%],y[%],z[%],v[%] : y0[%],y1[%],z[%],v[%] : z0[%],z1[%],v[%] : v0[%],v1[%] : v0[%] : (no arg) : (+)
#@gmic : Insert shared buffers from (opt. points/rows/planes/channels of) selected images.
#@gmic : Shared buffers cannot be returned by a command, nor a local environment.
#@gmic : (eq. to '-sh').
#@gmic : $ image.jpg -shared 1 -blur. 3 -remove.
#@gmic : $ image.jpg -repeat {s} -shared 25%,75%,0,$> -mirror. x -remove. -done
#@gmic : $$
#@gmic srand : value : (no arg) : (+)
#@gmic : Set random generator seed.
#@gmic : If no argument is specified, a random value is used as the random generator seed.
#@gmic testimage2d : _width>0,_height>0,_spectrum>0
#@gmic : Input a 2d synthetic image.
#@gmic : Default values: 'width=512', 'height=width' and 'spectrum=3'.
#@gmic : $ -testimage2d 512
testimage2d : -check "${1=512}>0 && ${2=$1}>0 && ${3=3}>0"
-e[^-1] "Input 2d synthetic image of size $1x$2x$3."
-v -
Dmax2={0.15*min($1,$2)^2}
$1,$2,1,$3,'X=x-w/2;Y=y-h/2;a=atan2(Y,X);if(X^2+Y^2<=$Dmax2,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))'
-polygon. 4,20%,20%,60%,20%,70%,70%,35%,45%,0.9,0,255,0
-torus3d {$1/7},{$1/20} -r3d. 0,1,1,80 -col3d. 128,200,255
-j3d.. [-1],30%,70%,0,1,5,0,0 -rm. -round. 1
-nm. "[2d test image]"
-v +
#@gmic uncommand : command_name[,_command_name2,...] : * : (+)
#@gmic : Discard last definition of specified custom commands.
#@gmic : Set argument to '*' for discarding all existing custom commands.
#@gmic uniform_distribution : nb_levels>=1,spectrum>=1
#@gmic : Input set of uniformly distributed N-d points in [0,1]^N.
#@gmic : $ -uniform_distribution 64,3 -* 255 --distribution3d -circles3d. 10
uniform_distribution : -check "isint($1) && $1>0 && isint($2) && $2>0"
-e[^1] "Input set of $1 uniformly distributed $2-d points in [0,1]^$2."
-v - n={round($1^(1/$2),1,1)}
(0,1) -r. $n,1,1,1,3
-repeat {$2-1} --channels. 100% -r. {$n*w},1,1,1,1 -r.. [-1],1,1,100%,0,2 -a[-2,-1] c -done
-r. $1,1,1,$2,1 -nm. "[uniform $2d distribution]" -v +
#@gmic unserialize : : (+)
#@gmic : Recreate lists of images from serialized image buffers, obtained with command '-serialize'.
#@gmic up : eq. to '-update'.
up :
-_update
#@gmic update
#@gmic : Update commands from the latest definition file on the G'MIC server.
#@gmic : This requires an active Internet connection and an access to the external
#@gmic : tools 'curl' or 'wget'.
#@gmic : Once the update has been downloaded, running 'gmic' makes it use automatically.
#@gmic : (eq. to '-up').
update :
-_$0
_update :
-e[0--3] "Update commands from the latest definition file on the G\47MIC server."
-v -
out=${_path_rc}cli_update$_version.gmic
-l[] cimgz:http://gmic.eu/cli_update$_version.gmic
-if {h>7" && "same([{^}],'#@gmic',6)} -o raw:$out,char -endif
-rm
-onfail -v + -error[0--3] "Command '-update' : Unreachable update file."
-endl
-m $out
-v +
update_film_emulation_html :
-if {!$!} -error[^-1] "Command '-update_film_emulation': Missing input images !" -endif
-v -
jpeg_quality=70
thumb_width=180
thumb_height=90
categories=bw,instant_consumer,instant_pro,negative_color,negative_new,negative_old,print,colorslide,various
category_names="Black and White","Instant [consumer]","Instant [pro]","Negative [color]","Negative [new]","Negative [old]","Print films","Slide [color]","Various"
-m "_thumb : -frame 3%,3%,255 -to_rgba -drop_shadow 2,2,3 -repeat $! -l[$>] -i[0] 100%,100%,1,3,245 -blend alpha -endl -done"
-m "_title : ({'\"$""*\"'}) -replace. {'_'},32 -f. if((x==0||j(-1)==32)&&i>=_'a'&&i<=_'z',i+_'A'-_'a',i) -u {t} -rm."
nb_presets=0
-repeat {narg($categories)}
category=${-arg\ {1+$>},$categories}
presets=${-_gimp_emulate_film_$category}
nb_presets+={narg({/$presets})}
-done
-v + -e[] "\n > Update film emulation pages, for "$!" image samples and "$nb_presets" presets." -v -
-v + -e[] "\n  * Prepare folder structure." -v -
-x "ln -fs ../copyright.html ."
-x "ln -fs ../favicon.ico ."
-x "ln -fs ../favicon.png ."
-x "ln -fs ../footer.html ."
-x "ln -fs ../header.html ."
-x "ln -fs ../gmicmenu ."
-x "ln -fs ../jquery-1.11.0.min.js ."
-x "ln -fs ../style.css ."
-x "ln -fs ../images ."
-x "mkdir -p img"
-x "cd img && ln -fs ../../img/logo4.jpg ."
-x "cd img && ln -fs ../../img/logos.jpg ."
-x "cd img && ln -fs ../../img/rss.png ."
-x "ln -fs ../highslide ."
-v + -e[] "\n  * Generate thumbnails from samples." -v -
-if original -else -x "mkdir original" -endif
nb_samples=$!
-to_rgb -repeat $nb_samples -l[$<]
-nm[0] sample_{1+$<}
basename={0,b} basename$<=$basename
-v + -e[] "    - "$basename -v -
--r2dx $thumb_width
--text_outline[0] "Reference",4,{0,h-28},20,2 -frame. 1,1,0
-o. original/$basename.jpg,$jpeg_quality -rm.
--_thumb[1] -o. original/thumb_$basename.jpg,$jpeg_quality -rm.
--r2dy[0] $thumb_height -_thumb. -o. original/minithumb_$basename.jpg,$jpeg_quality -rm.
-endl -done
ind_preset=0
-repeat {narg($categories)}
category=${-arg\ {1+$>},$categories}
presets=${-_gimp_emulate_film_$category}
-v + -e[] "\n  * Category ""#"{1+$>}": "$category" ***\n" -v -
-if $category -else -x "mkdir "$category -endif
-if $category/clut -else -x "mkdir "$category/clut -endif
-repeat {narg({/$presets})}
preset=${-arg\ {1+$>},$presets}
-v + -e[] "    - "$preset -v -
-input_clut $preset -to_rgb. s={sqrt(w*h*d)}
-if {!isint($s)}
-v + -warn[] "Preset '"$preset"' must be resampled." -v -
-r. 64,64,64,3,3
-endif
s={sqrt(w*h*d)} --r. $s,$s,1,3,-1
-if {iM<=255} -*. 257 -endif
-o. $category/clut/$preset.png
-rm.
-repeat $nb_samples -l[{2*$>},{2*$>+1},-1]
basename={0,b}
-if $category/$basename/$preset.jpg -else
-if $category/$basename -else -x "mkdir \""$category/$basename"\"" -endif
--map_clut[^-1] [-1]
-text_outline.. ${-_title\ $preset},4,{-2,h-28},20,2 -frame.. 1,1,0
-o.. $category/$basename/$preset.jpg,$jpeg_quality
-_thumb. -o. $category/$basename/thumb_$preset.jpg,$jpeg_quality
-rm[-2,-1]
-endif
-endl -done
-rm.
ind_preset+=1
-done
-done
-rm[1--1:2]
-v + -e[] "\n  * Generate html code.\n" -v -
-repeat {narg($categories)}
category=${-arg\ {1+$>},$categories}
-arg {1+$>},$category_names
category_name=${}
presets=${-_gimp_emulate_film_$category}
-repeat $nb_samples
width={$>,64+w} height={$>,64+h}
basename={$>,b}
-v + -e[] "    - "$category_name" / "$basename -v -
({'"
<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n
\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n
<!--#include file=\"header.html\" -->\n
<script type=\"text/javascript\">\n
hs.align = 'center';\n
</script>\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Film Emulation</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<p>Among all features available in <b><font color=\"#000066\">G\47MIC</font></b>, our <b>Film Emulation</b> filters are able to apply various pre-defined <b>color presets</b> on your images.\n
Most of those <b>300+</b> presets have been designed by <a href=\"http://blog.patdavid.net/2013/08/film-emulation-presets-in-gmic-gimp.html\">Patrick David</a>, in order to emulate the look of\n
analog films. They have a dedicated section in the open-source <a href=\"../gimp.shtml\"><b><font color=\"#000066\">G\47MIC</font></b> plug-in for GIMP</a>, so you can apply all these easily in GIMP.</p>\n\n
<p>Below, you can navigate through the different proposed color presets and see how they modify the colors of some sample images.\n
You can also download each color preset separately as its corresponding <a href=\"http://www.quelsolaar.com/technology/clut.html\">Hald-CLUT</a> file (in <b>.png</b> format), to use it in\n
other softwares that support this feature.</p>\n\n
<p><b>Image credits:</b> Sample images below have been borrowed from <a href=\"https://www.flickr.com/photos/patdavid/\">Patrick David</a> and\n
<a href=\"https://www.flickr.com/photos/davelau/\">Chi King</a>\47s Flickr accounts, distributed under\n
<a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-by-SA 2.0</a>.</p>\n\n
<p><font size=\"-1\"><b>Disclaimer:</b><br/>\n
<i>The trademarked names which may appear in the filenames of the Hald-CLUT images are there for informational purposes only. They serve only to inform the user which film stock the given Hald-CLUT image\n
is designed to approximate. As there is no way to convey this information other than by using the trademarked name, we believe this constitutes fair use. Neither the publisher nor the authors are affiliated\n
with or endorsed by the companies that own the trademarks.</i></font></p>\n\n
</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\"><a id=\"browse\">Browse</a></div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<table><tr>\n
<td valign=\"top\" width=\"300\">Select film category:\n
<ul>\n"'})
-repeat {narg($categories)}
_category=${-arg\ {1+$>},$categories}
-arg {1+$>},$category_names
_category_name=${}
-if {['$_category']==['$category']}
({'"
<li><font color=\"#CC7700\"><b>"$_category_name"</b></font></li>\n
"'})
-else
({'"
<li><a href=\""${_category}_$basename.shtml"#browse\">"$_category_name"</a></li>\n
"'})
-endif
-done
({'"
</ul>\n
</td>\n
<td valign=\"top\">Select sample image:<br/><br/>\n
"'})
-repeat {$nb_samples}
_basename=${basename$>}
-if {['$_basename']==['$basename']}
({'"
<a href=\""${category}_$_basename.shtml"#browse\"><img alt=\"\" style=\"border-color:#CC7700;\" border=\"3\" src=\""original/minithumb_$_basename.jpg"\"/></a>\n
"'})
-else
({'"
<a href=\""${category}_$_basename.shtml"#browse\"><img alt=\"\" border=\"0\" src=\""original/minithumb_$_basename.jpg"\"/></a>\n
"'})
-endif
-done
({'"
</td>\n
</tr></table>\n
</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n
"'})
({'"\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Presets ("{narg({/$presets})}")</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
<center><table>\n
<tr><td>\n
<div><a href=\"original/"$basename".jpg\" class=\"highslide\" onclick=\"return hs.expand(this)\"><img alt=\"\" border=\"0\" src=\"original/thumb_"$basename".jpg\" /></a>\n
<div class=\"highslide-caption\"><b>Reference Image</b></div></div>\n
</td></tr>\n
<tr><td align=\"center\"><b>Refence Image</b></td></tr>\n\n
"'})
-repeat {narg({/$presets})}
preset=${-arg\ {1+$>},$presets}
({'$preset'}) -replace_seq. 39,"92,92,39" preset_esc={t} -rm.
title=${-_title\ $preset}
-if {$>%4==0} -if $> ({'"</tr>\n"'}) -endif ({'"<tr>"'}) -endif
({'"
<td><table>\n
<tr><td>\n
<div><a href=\"#\" onclick=\"return hs.htmlExpand(this, { width: "$width", height: "$height" })\">\n
<img alt=\"\" border=\"0\" src=\""$category/$basename/thumb_$preset".jpg\" />\n
</a>\n
<div class=\"highslide-maincontent\"><center>\n
<img alt=\"\" border=\"0\" src=\""$category/$basename/$preset.jpg"\" onclick=\"hs.close()\" onmouseover=\"javascript:this.src='"$category/$basename/$preset_esc.jpg"';\" onmouseout=\"javascript:this.src='original/"$basename".jpg';\" />\n
</center></div>\n
<div class=\"highslide-caption\"><b>Preset:</b> <i>"$title"</i> [<a href=\""$category/clut/$preset.png"\">Download Hald-CLUT</a>]</div></div>\n
</td></tr>\n
<tr><td align=\"center\"><font size=\"-1\">"$title"</font></td></tr>\n
</table></td>\n\n"'})
-done
({'"
</tr></table></center>\n
</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n
"'})
({'"<!--#include file=\"copyright.html\" -->\n
<!--#include file=\"footer.html\" -->\n
"'})
-a[$nb_samples--1] x -o. raw:${category}_$basename.shtml,char -rm.
-done
-done
-rm
category=${-arg\ 1,$categories}
-x "ln -fs "${category}_$basename0.shtml" index.shtml"
-v + -e[] "\n > All done, for "$nb_presets" presets.\n"
update_gallery_html :
-e[^-1] "Generate gallery for the G'MIC web site."
-v -
thumb_size=128
-x "rm -f gallery.shtml img/gallery_*.jpg"
img/chloe.jpg
img/fawn.jpg
img/house.jpg
img/statue.jpg
img/beach.jpg
nb_imgs=$!
-repeat $! --r2dy[$>] $thumb_size width$>={w} -rm. -done
_nb_coms=-1
-_update_gallery_html " "
-_update_gallery_html " "
-_update_gallery_html " "
-_update_gallery_html " "
-_update_gallery_html " "
-_update_gallery_html "-luminance"
-_update_gallery_html "-solarize"
-_update_gallery_html "-negative"
-_update_gallery_html "-select_color 100,0,0,0 -n 0,255"
-_update_gallery_html "-array_fade 4,4"
-_update_gallery_html "--mirror. x -fade_x 40,60"
-_update_gallery_html "-shift_tiles 20,20"
-_update_gallery_html "-fisheye 40"
-_update_gallery_html "-fisheye 50"
-_update_gallery_html "-shade_stripes ,"
-_update_gallery_html "-shade_stripes 40,1"
-_update_gallery_html "-tetris 10"
-_update_gallery_html "-blur 1 -gradient_orientation 2 -+ -n 0,255 -smooth 60,0,1,1,3"
-_update_gallery_html "-flower 30,5"
-_update_gallery_html "-water 30,1.5"
-_update_gallery_html "-wave 4,0.4"
-_update_gallery_html "-wave 15,0.2"
-_update_gallery_html "-deform 10"
-_update_gallery_html "-light_patch 4,0.7,1.7"
-_update_gallery_html "-mosaic 0.5"
-_update_gallery_html "-sponge 13"
-_update_gallery_html "-hearts 15"
-_update_gallery_html "-color_ellipses 1400,10,0.07"
-_update_gallery_html "-whirls 3"
-_update_gallery_html "-edges 15 -n 0,255"
-_update_gallery_html "-to_rgba -gimp_reflect 50,1,110,160,190,64,0,1.5,0,-3.30,7,1.5 -display_rgba"
-_update_gallery_html "-transform_polar R-r"
-_update_gallery_html "-drawing 200"
-_update_gallery_html "-draw_whirl 100"
-_update_gallery_html "-texturize_paper"
-_update_gallery_html "-stencilbw 30"
-_update_gallery_html "-glow 4"
-_update_gallery_html "-ditheredbw"
-_update_gallery_html "-blur_angular 10"
-_update_gallery_html "-blur_radial 10"
-_update_gallery_html "-repeat 3 --deform[0] 10 -done -+ -n 0,255"
-_update_gallery_html "-flood 50%,50%,0,50,0,0.7,155,100,255"
-_update_gallery_html "--mirror x --mirror y -* -equalize 255 -n 0,255"
-_update_gallery_html "-kaleidoscope 0.5,0.5,50,20"
-_update_gallery_html "-noise 40 -cut 0,255 --meancurvature_flow. 20 -sharpen. 100 -a x"
-_update_gallery_html "-gradient_norm -sqrt -n 0,255"
-_update_gallery_html "-to_rgba -rotate_tiles 15,5,5 -display_rgba"
-_update_gallery_html "-taquin 5"
-_update_gallery_html "img/chloe.jpg -drop_shadow. 3 -rotate. 55 -blend alpha"
-_update_gallery_html "[-1] -deform 10 -morph 4,0.05 -a x"
-_update_gallery_html "-polaroid 20 -drop_shadow 3,3 -rotate 10,1 -display_rgba"
-_update_gallery_html "--plasma 10,10 -n. 0.5,2.5 -n 0,255 -and -equalize 256"
-_update_gallery_html "100%,100% -mandelbrot. -1.17229,-0.3038,-1.15209,-0.2836,1000 -map. 0 -*.. 1.5 -+ -n 0,255"
-_update_gallery_html "--edges 15 -n 0,255 -fade_y 30,70"
-_update_gallery_html "-split_tiles 5,5 -blur 8 -sharpen 1000 -equalize 255 -append_tiles 5,5"
-_update_gallery_html "-imagecube3d -*3d 256 -r3d 1,1,0,60 512,512,1,3 -plasma. 10,10 -n. 0,128 -m3d 5 -db3d 0 -object3d[1] [0],50%,50% -k[1] -n 0,255"
-_update_gallery_html "-warp_perspective 0.3,0.9,0.5"
-_update_gallery_html "-rodilius ,"
-_update_gallery_html "-blur 3 -gradient2rgb 1"
-_update_gallery_html "-normalize_local 80,7"
-_update_gallery_html "-normalize_local 80,3"
-_update_gallery_html "-normalize_local 80,7"
-_update_gallery_html "-normalize_local 80,6,2"
-_update_gallery_html "-isophotes 4 -dilate 3 -i[0] (0;255^0;255^100;100) -r[0] [1],[1],1,3,3 -blend alpha"
-_update_gallery_html "-crop 30%,30%,70%,70% -resize 200%,200%,1,100%,5 -frame_fuzzy 30,30"
-_update_gallery_html "-cartoon ,"
-_update_gallery_html "-cartoon ,"
-_update_gallery_html "-cartoon ,"
-_update_gallery_html "-cartoon ,"
-_update_gallery_html "-cartoon ,"
-_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
-_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
-_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
-_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
-_update_gallery_html "-resize2dx 300 -m3d 2 -elevation3d 0.3 -f3d 200 -snapshot3d 400,1.5"
-_update_gallery_html "-topographic_map 16,2"
-_update_gallery_html "-topographic_map 16,2"
-_update_gallery_html "-topographic_map 16,2"
-_update_gallery_html "-topographic_map 16,2"
-_update_gallery_html "-topographic_map 16,2"
-_update_gallery_html "--blur 10 -curvature. -norm. -+. 0.01 -/ -equalize 255 -n 0,255"
-_update_gallery_html "--blur 10 -curvature. -norm. -+. 0.01 -/ -equalize 255 -n 0,255"
-_update_gallery_html "--blur 10 -curvature. -norm. -+. 0.01 -/ -equalize 255 -n 0,255"
-_update_gallery_html "--blur 10 -curvature. -norm. -+. 0.01 -/ -equalize 255 -n 0,255"
-_update_gallery_html "--blur 10 -curvature. -norm. -+. 0.01 -/ -equalize 255 -n 0,255"
-_update_gallery_html "-blur 1 -pencilbw 0.3"
-_update_gallery_html "-blur 1 -pencilbw 0.3"
-_update_gallery_html "-blur 1 -pencilbw 0.3"
-_update_gallery_html "-blur 1 -pencilbw 0.3"
-_update_gallery_html "-blur 1 -pencilbw 0.3"
-_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -5,1 -display_rgba"
-_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -10,1 -display_rgba"
-_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -15,1 -display_rgba"
-_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -20,1 -display_rgba"
-_update_gallery_html "-old_photo -drop_shadow 3,3 -rotate -25,1 -display_rgba"
-_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 40,0,1,1,3 -n 0,255 -negative"
-_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 60,0,1,1,3 -n 0,255 -negative"
-_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 80,0,1,1,3 -n 0,255 -negative"
-_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 100,0,1,1,3 -n 0,255 -negative"
-_update_gallery_html "-erode 10 --erode 3 -- -equalize 255 -smooth 120,0,1,1,3 -n 0,255 -negative"
-_update_gallery_html "-light_relief ,"
-_update_gallery_html "-light_relief ,"
-_update_gallery_html "-light_relief ,"
-_update_gallery_html "-light_relief ,"
-_update_gallery_html "-light_relief ,"
-_update_gallery_html "--warhol 2 -fade_radial 50,70"
-_update_gallery_html "--warhol 3 -fade_radial 50,70"
-_update_gallery_html "--warhol 4 -fade_radial 50,70"
-_update_gallery_html "--warhol 5 -fade_radial 50,70"
-_update_gallery_html "--warhol 6 -fade_radial 50,70"
-_update_gallery_html "--sketchbw , -rv -blend overlay"
-_update_gallery_html "--sketchbw , -rv -blend overlay"
-_update_gallery_html "--mirror x -a x -map_sphere ,"
-_update_gallery_html "--mirror x -a x -map_sphere ,"
-_update_gallery_html "-gimp_painting 2,1.5,2"
-_update_gallery_html "-f3d 800 -rm 512,512,1,3 -chessboard 64,64,0,0,15,1,${-RGB},${-RGB} --imagecube3d -*3d. 230 -r3d. 1,1,0.5,50 -m3d 3 -object3d.. [-1],50%,50%,0 -rm. -gimp_painting 1,1.5,2 -equalize. 256"
-_update_gallery_html "--histogram 256 -display_graph. {0,w},{0,h},3 -to_rgba. -*. 0.5 -blend alpha"
-_update_gallery_html "100%,100%,1,1,'X=(x-w/2)/30;Y=(y-h/2)/30;5*cos(X*Y)*sqrt(X^2+Y^2)' -elevation3d[0] [1] -k[0] -r3d 1,1,0,60 -snapshot3d 500,2"
-_update_gallery_html "-kuwahara 10 -noise 30 -smooth 100,0,1,3,3 -sharpen 400 -n 0,255 -equalize 256"
-_update_gallery_html "-frame 4,4,0 -array_mirror 1,3"
_nb_coms+=1
({'"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\
\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\
<!--#include file=\"header.html\" -->\n
<div id=\"bloc_option\"><div id=\"top_bleu\"><div id=\"text_top\">Image Gallery</div></div>\n
<div id=\"center\"><div id=\"text_centre_intro\">\n
All the images below have been processed by the command line version <b><a href=\"documentation.shtml\">gmic</a></b>\n
of <b><font color=\"#000066\">G\47MIC</font></b>, from a set of initial 2D color images (displayed on the first row).<br/>\n
Click on an image to zoom-in. The corresponding <b><font color=\"#000066\">G\47MIC</font></b> command used to generate the image appears as a caption.\n
This gallery is intended to show the flexibility and the genericity of the <b><font color=\"#000066\">G\47MIC</font></b> language.\n
Remember, you can easily define your own image filters and effects by writting\n
your custom <b><font color=\"#000066\">G\47MIC</font></b> <a href=\"http://gmic.eu/gmic_stdlib.gmic\">command file</a>,\n
and eventually put them directly in <a href=\"http://www.gimp.org\">GIMP</a> afterwards.\n\n
<ul>\n
<li>See also the <a href=\"gimp.shtml\">GIMP plug-in page</a> to see various screenshots of what <b><font color=\"#000066\">G\47MIC</font></b> can do.</li>\n
<li>See also the <a href=\"reference.shtml\">G\47MIC reference page</a> to have processing examples of almost all <b><font color=\"#000066\">G\47MIC</font></b> commands\n
(scroll down there to view example images).</li>\n
<li>See also the <a href=\"http://www.flickr.com/groups/gmic/pool/\">Flickr slideshow</a>, showing uses of the <a href=\"gimp.shtml\">G\47MIC plug-in</a>\n
by various artists.</li>\n
</ul>\n
<b>Copyrights : </b> All pictures have been shot by <a href=\"http://tschumperle.users.greyc.fr/\">David Tschumperl&eacute;</a>.<br/><br/>\n"'})
({'"<center><table cellpadding=\"1\" border=\"0\" cellspacing=\"2\">"\n'})
row=0
-repeat $_nb_coms
ind={$>%$nb_imgs}
out_img=${"-filename "img/gallery.jpg,$>}
out_thumb=${"-filename "img/gallery_thumb.png,$>}
-if {!$ind} ({'"<tr>\n"'}) -endif
com=${_com$>}
-v + -e[] " - Image "{$>+1}/$_nb_coms" : $ "$com -v -
displayed_com$ind=$com
-if {!narg($com)} com="-skip ," -endif
--__update_gallery_html[$ind] $com
iind={$ind%5}
width={$iind,w} height={$iind,h}
-o. $out_img,75
-r2dy. $thumb_size -if {w>${width$ind}} -r. ${width$ind},100%,100%,100%,2 -endif
-l. -frame 3%,3%,255 -to_rgba -drop_shadow 2,2,3 -endl
-o. $out_thumb -rm.
({'"<td width=\""${width$>}"\"><center><div>\
<a href=\""$out_img"\" class=\"highslide\" onclick=\"return hs.expand(this)\">\
<img alt=\"\" border=\"0\" src=\""$out_thumb"\"/></a>\
<div class=\"highslide-caption\">gmic "{$ind,b}.{$ind,x}" "${displayed_com$ind}"</div>\
</div></center></td>\n"'})
-if {$ind==$nb_imgs-1" || "$>==$_nb_coms-1}
({'"</tr>\n<tr bgcolor=\""$bgcolor"\">"\n'})
-repeat {$ind+1}
({'"<td width=\""${width$>}"\"><center><font size=\"1\">gmic "{$>,b}.{$>,x}" "${displayed_com$>}"</font></center></td>\n"'})
-done
({'"</tr>\n"'})
row+=1
-endif
-done
({'"</table></center>\n"'})
({'"</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>\n\
<!--#include file=\"copyright.html\" -->\n\
<!--#include file=\"footer.html\" -->\n"'})
-rm[0-{$nb_imgs-1}] -a x
-o gallery.raw,uchar -x "mv gallery.raw gallery.shtml" -rm
-v + -e[^-1] "All done !"
_update_gallery_html :
_nb_coms+=1 _com$_nb_coms="$1"
__update_gallery_html :
${1--1}
update_server : -skip ${1=$_version},${2=1}
-v -
-_update_server_move[] "/Arrays~&amp;~tiles/Hearts","/Testing/Samj/Arrays~&amp;~tiles"
-_update_server_move[] "/Arrays~&amp;~tiles/Reptile","/Patterns"
-_update_server_move[] "/Artistic/Pastell~art","/Testing/Naggobot"
-_update_server_move[] "/Artistic/Simple~noise~canvas","/Patterns"
-_update_server_move[] "/Artistic/Granular~texture","/Testing/Samj/Artistic"
-_update_server_move[] "/Artistic/Colored~engraving","/Testing/Samj/Artistic"
-_update_server_move[] "/Artistic/Variations~on~a~single~color","/Testing/Samj/Artistic"
-_update_server_move[] "/Black~&amp;~white/Hard~sketch~xy","/Testing/Samj/Black~&amp;~white"
-_update_server_move[] "/Colors/Couleurs~metalliques","/Testing/Samj/Colors"
-_update_server_move[] "/Degradations/Tilt~shift","/Testing/J&#233;J&#233;"
-_update_server_move[] "/Degradations/Deteriorated~areas","/Testing/Samj/Degradations"
-_update_server_move[] "/Layers/Fast~median~stack","/Testing/Iain~fergusson"
-_update_server_move[] "/Patterns/Random~pattern~courtepointe","/Testing/Samj/Patterns"
-_update_server_move[] "/Rendering/Adjacent~rectangles","/Testing/Samj/Rendering"
-_update_server_move[] "/Rendering/Chryzodes","/Testing/Samj/Rendering"
-_update_server_move[] "/Rendering/Lines~of~varying~thickness","/Testing/Samj/Rendering"
-_update_server_move[] "/Rendering/Pintograph","/Testing/Samj/Rendering"
-_update_server_move[] "/Rendering/Hawaiian~earring","/Testing/Samj/Rendering"
-_update_server_move[] "/Rendering/Lines~around~a~point","/Testing/Samj/Rendering"
-_update_server_move[] "/Rendering/Pappus~chain","/Testing/Samj/Rendering"
-_update_server_move[] "/Rendering/Straight~lines","/Testing/Samj/Rendering"
-_update_server_move[] "/Testing/J&#233;J&#233;/Rays","/Patterns"
-_update_server_move[] "/Testing/Iain~fergusson/Halftone~shapes","/Patterns"
-_update_server_move[] "/Testing/Iain~fergusson/Simple~local~contrast","/Details"
-_update_server_move[] "/Testing/Garagecoder/Aurora","/Artistic"
-_update_server_move[] "/Testing/Garagecoder/Despeckle","/Repair"
-_update_server_move[] "/Testing/Garagecoder/Emboss","/Black~&amp;~white"
-_update_server_move[] "/Testing/Garagecoder/HSL~adjustment","/Colors"
-_update_server_move[] "/Testing/Garagecoder/HSV~select","/Colors"
-_update_server_move[] "/Testing/Garagecoder/Stereo~image","/Stereoscopic~3d"
-_update_server_move[] "/Testing/Garagecoder/Undo~anaglyph","/Stereoscopic~3d"
-_update_server_move[] "/Testing/Garagecoder/Sharpen~[gradient]","/Details"
-_update_server_move[] "/Testing/Garagecoder/Sharpen~[tones]","/Details"
-_update_server_move[] "/Testing/Garagecoder/Tone~enhance","/Details"
-_update_server_move[] "/Testing/Garagecoder/Wiremap","/Rendering"
-_update_server_move[] "/Testing/Naggobot/Blockism","/Artistic"
-_update_server_move[] "/Testing/Samj/Chalk~it~up","/Artistic"
-_update_server_move[] "/Testing/Samj/Denim~texture","/Patterns"
-_update_server_move[] "/Testing/Souphead/Kitaoka~spin~illusion","/Rendering"
-_update_server_move[] "/Testing/Zonderr/Spiral","/Rendering"
-_update_server_move[] "/Finger~paint","/Artistic"
-m "parent : -l[] ({'$""1'}) -s -,{'/'} -if $! -rm. -endif -i[0--1] (47) -a y -u {0,t} -rm -endl"
-m "_max : ({'\"$""1\"'}) ({'\"$""2\"'}) -f[-2,-1] 'if(i>=97&&i<=122,i-32,i)' -r[-2,-1] {max(w,{-2,w})},1,1,1,0 --[-2,-1] -autocrop. 0 "\
"-u {i>0} -rm."
-m "varname : ({'\"$""1\"'}) -f. if((i>=48&&i<=57)||(i>=65&&i<=90)||(i>=97&&i<=122),i,95) -u {t} -rm."
-m "load_gmic : "\
"_nb_sources+=1 filename=${\"-basename $""1\"} "\
"-v + -e[] \"  \"$_nb_sources\". \"$filename\"  \" -v - "\
"-l[] "\
"  -i raw:$""1,char -nm {0,b} -v + -e[] \"      [retrieved from source '$""1']\" -v - "\
"  -l "\
"    -o raw:/tmp/$filename,char "\
"    -_update_server_upload /tmp/$filename,include/$filename "\
"    -v + -e[] \"      [archived]\n\" -v - "\
"  -onfail -v + -e[] \"      [could not be archived!]\n\" -v - -endl "\
"-onfail -l[] "\
"  source=http://gmic.eu/include/$filename "\
"  -i raw:$source,char -v + -e[] \"      [retrieved from archive '\"$source\"']\n\" -v - "\
"  -onfail -v + -e[] \"      [error, not reachable!]\n\" -v -"\
"  -endl -endl"
-m "calibrate_name : "\
"-autocrop 32 "\
"-f 'if(i>=65&&i<=90,i+32,i)' "\
"-replace {'_'},32 -autocrop 32 "\
"-replace_str Fft,FFT "\
"-replace_str rgb,RGB "\
"-replace_str lab,Lab "\
"-replace_str hsv,HSV "\
"-replace_str hsl,HSL "\
"-replace_str ycbcr,YCbCr "\
"-replace_str cmyk,CMYK "\
"-replace_str b&amp;w,B&amp;W "\
"-replace_str gimp,GIMP "\
"-replace_str roddy,Roddy "\
"-replace_str crt,CRT "\
"-replace_str g\47mic,G\47MIC "\
"-f 'if(y==0&&i>=97&&i<=122,i-32,i)' "
-if {$1==$_version}
-v + -e[] "> Upload latest version ("${-strver}") of commands on G'MIC server.\n" -v -
-_update_server_upload $HOME/work/src/gmic/src/gmic_stdlib.gmic,gmic_stdlib.$1
-_update_server_upload $HOME/work/src/gmic/src/gmic_stdlib.gmic
-endif
-v + -e[] "> Load and archive .gmic source files.\n" -v -
_nb_sources=0
-load_gmic http://gmic.eu/gmic_stdlib.$1
-if {$1!=$_version} -l -load_gmic http://gmic.eu/backports$1.gmic -onfail -endl -endif
-x "cd $HOME/work/src/gmic-community && git pull 2>&1 >/dev/null"
-load_gmic ${HOME}/work/src/gmic-community/garagecoder.gmic
-load_gmic ${HOME}/work/src/gmic-community/garryosgood.gmic
-load_gmic ${HOME}/work/src/gmic-community/gentlemanbeggar.gmic
-load_gmic ${HOME}/work/src/gmic-community/iainfergusson.gmic
-load_gmic ${HOME}/work/src/gmic-community/jayprich.gmic
-load_gmic ${HOME}/work/src/gmic-community/jboulanger.gmic
-load_gmic ${HOME}/work/src/gmic-community/karos.gmic
-load_gmic ${HOME}/work/src/gmic-community/naggobot.gmic
-load_gmic ${HOME}/work/src/gmic-community/photocomix.gmic
-load_gmic ${HOME}/work/src/gmic-community/ronounours.gmic
-load_gmic ${HOME}/work/src/gmic-community/souphead.gmic
-load_gmic ${HOME}/work/src/gmic-community/tomkeil.gmic
-load_gmic ${HOME}/work/src/gmic-community/translation_ja.gmic
-load_gmic ${HOME}/work/src/gmic-community/samj.gmic
-load_gmic ${HOME}/work/src/gmic-community/zonder.gmic
-i[0] (10) -i[2--1] ({"'\n#@gimp ________________\n'"}) -y -a y -discard 13 -replace 9,32
-s +,{'"#@gimp"'}
-repeat {int(($!-1)/2)} -a[{$>+1},{$>+2}] y -done
-nm[0] !header
-v + -e[] "> Start filter parsing.\n" -v -
progress_factor={100/($!-1)}
merge_request=0
merge_start=0
nb_filters=0
offset=0
path=/
-repeat $!
ind={$>-$offset}
-if {{{$ind-1},@-1}==10" && "same([{^}],'#@gimp',6)" && "({$ind,@6}==32" || "{$ind,@6}==_'_')} -l[$ind]
-if {i[6]==_'_'} locale=_{`[i[7],i[8]]`}
-else locale=
-endif
is_folder=0
-s +,10
-if {{0,@6}==_'_'} --rows[0] 9,100% -rows[0] 0,8
-else --rows[0] 6,100% -rows[0] 0,5
-endif
-autocrop. 32 -mv. 1
-if {{1,@0}!=_':'}
-l[1]
-s +,{':'}
-replace_str[0] "<b>"
-replace_str[0] "</b>"
-replace_str[0] "<i>"
-replace_str[0] "</i>"
-replace[0] {'/'},{'-'}
-replace[0] {','},{';'}
-autocrop[0] 32
-if {$!>1}
-calibrate_name[0] --replace[0] 32,{'~'}
name=$path{t} -rm.
merge_request=1
nb_filters+=1
-i[0,1] (32) -a y
-v + -e[] "  "$nb_filters". "$name" ("{round($>*$progress_factor)}"%)." -v -
-else
-if {i==_'_'}
-do path=${"-parent[] "$path} -shift 0,-1,0,0 -while {i==_'_'}
-autocrop 0
-endif
-autocrop 32
-if {w}
-varname {0,t} locale_${}=$locale
-calibrate_name
-replace 32,{'~'}
path=$path{0,t}/
-endif
is_folder=1
-endif
-endl
-if $is_folder -rm[0,1] -i[0] (10)
-else -nm[0] $name -endif
-else
-if {$!>=3} -l[1]
-s +,{'='}
-if {$!>=3} -if {{1,@0}==_'='}
-rows[0] 1,100% -calibrate_name[0]
-i[0] ({':'};32) -i[2] (32)
-endif -endif
-endl -endif
-i[1] (32)
-endif
-a y
-endl -endif
-if {$merge_request" && "$ind>0}
-a[$merge_start-{$ind-1}] y
offset+={$ind-$merge_start-1}
merge_start+=1
merge_request=0
-endif
-done
-a[$merge_start--1] y
-v + -e[] "\n> Force filters to move, if necessary." -v -
-repeat $! ind=$> -repeat $_nbm -if {['{$ind,n}']==['${_to_move$>}']}
-v + -e[] "  "$ind". Move '"{$ind,n}"' to '"${_move_to$>}"'." -v -
-nm[$ind] ${_move_to$>}/{$ind,b}
-endif -done -done
-v + -e[] "\n> Sort filters by lexicographic order." -v -
-_update_server_sort 0,{$!-1}
-v + -e[] "\n> Rebuild folder structure." -v -
-m "nb_levels : -l[] ({'$""1'}) -s -,{'/'} -u $! -rm -endl"
path=/
-repeat $! -l[$>]
npath=${"-parent "{0,n}}
-if {['$path']!=['$npath']}
nc=${"-nb_levels[] "$path}
nn=${"-nb_levels[] "$npath}
nb_up=0
nb_down=0
basis=$path nbasis=$npath
-do
nc=${"-nb_levels[] "$basis}
nn=${"-nb_levels[] "$nbasis}
-if {$nc>$nn} basis=${"-parent[] "$basis} nb_up+=1
-elif {$nn>$nc} nbasis=${"-parent[] "$nbasis} nb_down+=1
-elif {['$nbasis']!=['$basis']} basis=${"-parent[] "$basis} nb_up+=1 nbasis=${"-parent[] "$nbasis} nb_down+=1
-endif
-while {['$nbasis']!=['$basis']}
command=
-if $nb_up 1,$nb_up,1,1,{'_'} command="#@gimp "{t}"\n" -rm. -endif
-if $nb_down -l[]
({'$npath'}) -s -,{'/'} -k[-$nb_down--1] -replace {'~'},32
level={${"-nb_levels "$path}-$nb_up}
balise=${"-if "{$level<=0" && "['$npath']!='/About/'}" -u b -else -u i -endif"}
-repeat $!
-varname {$>,t} locale=${locale_${}}
command=$command"#@gimp"$locale" <"$balise">"{$>,t}"</"$balise">\n"
balise="i"
-done -rm
-endl -endif
-if {narg(['$command'])} nm={0,n} -i[0] ({'$command'}) -y[0] -a y -nm $nm
-endif
path=$npath
-endif
-endl -done
-v + -e[] "> Search and replace strings." -v -
-replace_str "#@gmic\n",""
-replace_str "<small>Author: <i>Samj</i>.","<small>Author: <i>Samj</i>."
-replace_str "   Latest update: <i>20","   Latest update: <i>20"
-repeat $! -l[$>] -s -,10 -repeat $! -l[$<]
-if {i[0]==_'#'" && "i[1]!=_'@'} -rm -endif
-endl -done -i[^0] ({'\n'}) -a y -endl -done
-repeat $! --l[$>] command_name$>=""
--rows 0,6 head={t} -rm.
-if {['$head']=='"#@gimp "'} -s -,{':'}
-if {$!>=1} -l[1] -s -,{','}
-if $! -autocrop[0] 32 command_name$>={0,t} -endif
-endl -endif
-endif
-rm -endl -done
-if {$nb_filters>400}
-v + -e[] "> Compress and save output .gmic files." -v -
--a y -l.
--compress_gmic[0]
--compress_gmic_gimp[0]
-i[0,1,2] ({'"#@gmic"\n\
"#"\n\
"#  File        : update"$_version".gmic"\n\
"#                ( G\47MIC command file )"\n\
"#"\n\
"#  Description : Update file for G\47MIC commands and filters (for version "${-strver}")."\n\
"#                ( http://gmic.eu )"\n\
"#"\n\
"#  License     : CeCILL v2.0"\n\
"#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )"\n\
"#"\n\n'})
-i[2,4,6] ({'"\n\n# Local Variables:"\n\
"# mode: sh"\n\
"# End:"\n\
"#"\n\
"# (End of G\47MIC update file)"'})
-y -a[6-8] y -a[3-5] y -a[0-2] y
-o[1] raw:${_path_rc}cli_update$1.gmic,uchar
-o[2] raw:${_path_rc}gimp_update$1.gmic,uchar
-o[0] raw:/tmp/update$1.gmic,uchar
-o[1] cimgz:/tmp/cli_update$1.gmic,uchar
-o[2] cimgz:/tmp/gimp_update$1.gmic,uchar
-_update_server_upload[] /tmp/update$1.gmic
-_update_server_upload[] /tmp/cli_update$1.gmic
-_update_server_upload[] /tmp/gimp_update$1.gmic
-_update_server_upload[] /tmp/update$1.gmic,update.gmic
-if {$1>=172} (172,173)
-else 0
-endif
-repeat {w}
-_update_server_upload[] /tmp/cli_update$1.gmic,cli_update{i[$>]}.gmic
-_update_server_upload[] /tmp/gimp_update$1.gmic,gimp_update{i[$>]}.gmic
-done -rm.
-rm -endl
-endif
-if {$2" && "$1==$_version}
-v + -e[] "> Output list of filters in stdout.\n" -v -
-x "date +%Y,%m,%d,%H >"${-path_tmp}date.dlm
${-path_tmp}date.dlm
-echo_stdout "*** List of filters in the G\47MIC plug-in for GIMP ("$nb_filters" filters, on "{i}/{i(1)}/{i(2)}" "{i[3]}:00") ***\n"
-rm.
-echo_stdout "* List of filters, sorted by path:\n"
-repeat $! -l[$>]
({'{0,n}'}) -if {i!=_'!'}
-r. {w-1},1,1,1,0,0,1
-replace_str. "&amp;","&"
-replace_str. "&#233;","e"
-replace_str. "/","~/~"
-replace. {'~'},32
-if {narg(${command_name$>})} -echo_stdout[] "  "{t}" (command '-"${command_name$>}"')"
-else -echo_stdout[] "  "{t}
-endif
-endif -rm.
-endl -done
-echo_stdout "\n* List of filters, sorted alphabetically:\n"
-repeat $!
name={$>,b}
path={$>,f}
-nm[$>] $name"~(in~'"$path"')"
-done
-_update_server_sort 0,{$!-1}
-repeat $! -l[$>]
({'{0,n}'}) -if {i!=_'!'}
-replace_str. "&amp;","&"
-replace_str. "&#233;","e"
-replace. {'~'},32
-echo_stdout[] "  "{t}
-endif -rm.
-endl -done
-echo_stdout "\n*** End of list ***\n"
-endif
-rm -v + -e[] "> All done !\n"
_update_server_sort :
mid={int(($1+$2)/2)}
-if ${"-_max[] "{$1,n},{$mid,n}} -rv[$1,$mid] -endif
-if ${"-_max[] "{$mid,n},{$2,n}} -rv[$2,$mid] -endif
-if ${"-_max[] "{$1,n},{$mid,n}} -rv[$1,$mid] -endif
-if {$2-$1>=3}
pivot={$mid,n}
i=$1 j=$2
-do
-if ${"-_max[] "$pivot,{$i,n}} -do i+=1 -while ${"-_max[] "$pivot,{$i,n}} -endif
-if ${"-_max[] "{$j,n},$pivot} -do j-=1 -while ${"-_max[] "{$j,n},$pivot} -endif
-if {$i<=$j} -rv[$i,$j] i+=1 j-=1 -endif
-while {$i<=$j}
-if {$1<$j} -_update_server_sort $1,$j -endif
-if {$i<$2} -_update_server_sort $i,$2 -endif
-endif
_update_server_move :
-if {!narg($_nbm)} _nbm=0 -endif
_to_move${_nbm}="$1" _move_to${_nbm}="$2" _nbm+=1
_update_server_upload : -skip "${2=""}"
-if {narg("$2")} out="$2" -else -basename "$1" out=${} -endif
-l[] GMIC_LOGIN=${-gmic_ftp\ 0} -onfail GMIC_LOGIN="" -endl
-l[] GMIC_PASSWD=${-gmic_ftp\ 1} -onfail GMIC_PASSWD="" -endl
-if {narg($GMIC_LOGIN)}
-x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"put -O /www/gmic/ \\\"$1\\\" -o \\\""$out"\\\"; quit\" >/dev/null"
-endif
_update_server_binaries :
-e[^-1] "Upload released binaries ($1) on the G'MIC web server."
-v -
is_pre=${"-strcontains $1,_pre"}
file0=gmic_$1_debian_jessie_amd64.deb
file1=gmic_$1_debian_jessie_i386.deb
file2=gmic_$1_debian_wheezy_amd64.deb
file3=gmic_$1_debian_wheezy_i386.deb
file4=gmic_$1_ubuntu_xenial_amd64.deb
file5=gmic_$1_ubuntu_trusty_i386.deb
file6=gmic_$1_ubuntu_vivid_amd64.deb
file7=gmic_$1_win32.zip
file8=gmic_$1_win64.zip
file9=gmic_gimp_$1_linux32.zip
file10=gmic_gimp_$1_linux64.zip
file11=gmic_gimp_$1_win32.exe
file12=gmic_gimp_$1_win32.zip
file13=gmic_gimp_$1_win64.exe
file14=gmic_gimp_$1_win64.zip
file15=gmic_static_$1_linux32.zip
file16=gmic_static_$1_linux64.zip
N=17
t0=$|
-v + -e[] "- Waiting for binary files to be build." -v -
-do
-repeat 17
file=${file$>}
-if $file
-strreplace $file,_$1_,_
file_short=${}
-v + -e[] "- Upload file '"$file"' to 'http://gmic.eu/files/prerelease/"$file_short -v -
-_update_server_upload $file,"files/prerelease/"$file_short
-if {!$is_pre}
is_win=${-strcontains[]" "$file,win}
-if $is_win folder="windows" -else folder="linux" -endif
-v + -e[] "- Upload file '"$file"' to 'http://gmic.eu/files/"$folder/$file"'." -v -
-_update_server_upload $file,"files/"$folder/$file
-v + -e[] "- Upload file '"$file"' to 'http://gmic.eu/files/"$folder/$file_short"'." -v -
-_update_server_upload $file,"files/"$folder/$file_short
-endif
file$>= N-=1
-endif
-done
-if $N -wait 5000 -endif
-while {$N" && "$|<$t0+60*120}
-v +
-if $N -e[] "- Partial uploads done (timeout reached)."
-else -e[] "- All uploads done !"
-endif
update_tutorial_html :
-e[^-1] "Convert G\47MIC tutorial from Garry Osgood\47s blog (http://www.particularart.com), for the G\47MIC web page."
-v - -rm -m "add_page : -__update_tutorial_html $""*"
-use_vt100
-add_page /,1700,index,__index
-add_page basics,4000
-add_page beginners-cookbook,1000
-add_page beginners-cookbook/cauldron,3500
-add_page beginners-cookbook/dyidiffusion,1000
-add_page beginners-cookbook/dyidiffusion/graduated-blurs,3800
-add_page beginners-cookbook/dyidiffusion/variations-on-a-theme,3800
-add_page beginners-cookbook/dyidiffusion/eigenvalues-and-eigenvectors,2300
-add_page beginners-cookbook/dyidiffusion/directional-blurring,3500
-add_page beginners-cookbook/dyidiffusion/tensors-for-the-tonsorially-challenged,8500
-add_page beginners-cookbook/dyidiffusion/eigen-thingys,4800
-add_page beginners-cookbook/dyidiffusion/fake-depth-of-field,7600
-add_page beginners-cookbook/fingerpainting,12000
-add_page beginners-cookbook/ramps,1200
-add_page beginners-cookbook/ramps/applying-a-curve,600
-add_page beginners-cookbook/ramps/blurring,600
-add_page beginners-cookbook/ramps/general-ramps,2500
-add_page beginners-cookbook/ramps/input-and-fill,1200
-add_page beginners-cookbook/ramps/one-dimensional-functions,800
-add_page beginners-cookbook/ramps/remapping-space,2200
-add_page beginners-cookbook/ramps/resizing,600
-add_page beginners-cookbook/ramps/warp,800
-add_page beginners-cookbook/road-systems,2500
-add_page beginners-cookbook/stained-glass,4000
-add_page beginners-cookbook/spectral-art,1500
-add_page beginners-cookbook/spectral-art/the-spatial-and-the-spectral,2000
-add_page beginners-cookbook/spectral-art/the-spectral-course,2000
-add_page beginners-cookbook/spectral-art/the-spectral-domain,2000
-add_page beginners-cookbook/spectral-art/the-complex-number-field,3300
-add_page beginners-cookbook/spectral-art/painting-with-waves-part-one,2200
-add_page beginners-cookbook/spectral-art/painting-with-waves-part-two,2200
-add_page beginners-cookbook/spectral-art/a-revised-map,1500
-add_page beginners-cookbook/spectral-art/intermezzo-spectral-editing,1500
-add_page beginners-cookbook/spectral-art/a-wave-painting-workflow,2000
-add_page beginners-cookbook/spectral-art/tiletex,5000
-add_page beginners-cookbook/spectral-art/coefficient-values,3000
-add_page beginners-cookbook/spectral-art/coefficient-values-part-two,4500
-add_page beginners-cookbook/spectral-art/coefficient-values-part-three,2500
-add_page beginners-cookbook/spectral-art/cheat-sheet,9000
-add_page beginners-cookbook/spectral-art/appendix,2500
-add_page command-decorations,3500
-add_page images,2000
-add_page images/conjuring-images,1000
-add_page images/images-as-datasets,3500
-add_page images/images-have-edges,1200
-add_page command-guide,5500
-add_page command-guide/color-manipulation/-autoindex,1000,,,commands-colors-manipulation
-add_page command-guide/color-manipulation/-compose_channels,1000,,,commands-colors-manipulation
-add_page command-guide/color-manipulation/-colormap,1000,,,commands-colors-manipulation
-add_page command-guide/color-manipulation/-direction2rgb,1000,,,commands-colors-manipulation
-add_page command-guide/color-manipulation/-gradient2rgb,1000,,,commands-colors-manipulation
-add_page command-guide/color-manipulation/-mix_rgb,4000,,,commands-colors-manipulation
-add_page command-guide/color-manipulation/-select_color,3000,,,commands-colors-manipulation
-add_page command-guide/feature-extraction/-distance,9500,,,commands-features-extraction
-add_page command-guide/feature-extraction/-area,2000,,,commands-features-extraction
-add_page command-guide/feature-extraction/-label,1300,,,commands-features-extraction
-add_page command-guide/filtering/-bandpass,5000,,,commands-filtering
-add_page command-guide/filtering/-blur,2000,,,commands-filtering
-add_page command-guide/filtering/-blur_angular,700,,,commands-filtering
-add_page command-guide/filtering/-blur_linear,700,,,commands-filtering
-add_page command-guide/filtering/-blur_radial,700,,,commands-filtering
-add_page command-guide/filtering/-blur_selective,3500,,,commands-filtering
-add_page command-guide/filtering/-blur_x,700,,,commands-filtering
-add_page command-guide/filtering/-blur_xy,700,,,commands-filtering
-add_page command-guide/filtering/-blur_xyz,700,,,commands-filtering
-add_page command-guide/filtering/-blur_y,700,,,commands-filtering
-add_page command-guide/filtering/-blur_z,2500,,,commands-filtering
-add_page command-guide/filtering/-convolve,3500,,,commands-filtering
-add_page command-guide/filtering/-dct-and-idct,1500,,,commands-filtering
-add_page command-guide/filtering/-deriche,1500,,,commands-filtering
-add_page command-guide/filtering/-diffusiontensors,7200,,,commands-filtering
-add_page command-guide/filtering/-fft,6300,,,commands-filtering
-add_page command-guide/filtering/-gradient,3000,,,commands-filtering
-add_page command-guide/filtering/-gradient_norm,1300,,,commands-filtering
-add_page command-guide/filtering/-gradient_orientation,3300,,,commands-filtering
-add_page command-guide/filtering/-haar,2000,,,commands-filtering
-add_page command-guide/filtering/-smooth,4300,,,commands-filtering
-add_page command-guide/filtering/-structuretensors,3300,,,commands-filtering
-add_page command-guide/geometry-manipulation/-warp,5000,,,commands-geometry-manipulation
-add_page command-guide/image-drawing/-gaussian,2000,,,commands-image-drawing
-add_page command-guide/image-drawing/-plasma,4500,,,commands-image-drawing
-add_page command-guide/image-drawing/-turbulence,5500,,,commands-image-drawing
-add_page command-guide/inputs-outputs/-display,2000,,,commands-inputs-outputs
-add_page command-guide/inputs-outputs/-display_tensors,1500,,,commands-inputs-outputs
-add_page command-guide/inputs-outputs/-input,7500,,,commands-inputs-outputs
-add_page command-guide/inputs-outputs/-shared,2000,,,commands-inputs-outputs
-add_page command-guide/matrix-computation/-eigen,2000,,,commands-matrix-computation
-add_page command-guide/program-control/-local,3500,,,commands-program-control
-add_page command-guide/program-control/-do,6500,,,commands-program-control
-add_page command-guide/program-control/-if,3500,,,commands-program-control
-add_page command-guide/program-control/-repeat,2000,,,commands-program-control
-add_page command-guide/values-manipulation/-eigen2tensor,5500,,,commands-values-manipulation
-add_page command-guide/values-manipulation/-index,3500,,,commands-values-manipulation
-add_page command-guide/values-manipulation/-map,3500,,,commands-values-manipulation
-add_page command-guide/values-manipulation/-norm,700,,,commands-values-manipulation
-add_page command-guide/values-manipulation/-normalize,1700,,,commands-values-manipulation
-add_page command-guide/values-manipulation/-orientation,5000,,,commands-values-manipulation
-add_page command-guide/values-manipulation/-threshold,1500,,,commands-values-manipulation
-add_page technical-notes/trigometric-and-inverse-trigometric-commands,2500
-add_page technical-notes/wavelet-analysis-and-synthesis-in-gmic,5000
-add_page technical-notes/gmic-color-mapping,1000
-add_page technical-notes/gmic-color-mapping/median-cut-algorithm,5500
-add_page technical-notes/gmic-color-mapping/k-means-algorithm,10000
-add_page gimp-filters,1500
-add_page gimp-filters/blur-by-color-filter,23500
-add_page gimp-filters/hedcut-filter,2000
-add_page gimp-filters/the-fingerpainting-filter,2200
-add_page gimp-filters/the-hairlock-filter,8500
-v + -e[] "\n  * Prepare folder structure." -v -
-x "ln -fs ../tutorial.css ."
-x "ln -fs ../copyright.html ."
-x "ln -fs ../favicon.ico ."
-x "ln -fs ../favicon.png ."
-x "ln -fs ../footer.html ."
-x "ln -fs ../header.html ."
-x "ln -fs ../gmicmenu ."
-x "ln -fs ../jquery-1.11.0.min.js ."
-x "ln -fs ../style.css ."
-x "ln -fs ../images ."
-x "mkdir -p img"
-x "cd img && ln -fs ../../img/logo4.jpg ."
-x "cd img && ln -fs ../../img/logos.jpg ."
-x "cd img && ln -fs ../../img/rss.png ."
-x "cd img && ln -fs ../../convert_raw_img/* ."
-x "ln -fs ../convert_raw.html ../convert_raw.shtml ."
-x "ln -fs ../tutorial_toc.html ."
-x "ln -fs ../highslide ."
11,11,1,3,255 -frame 1,1,0 -line 3,50%,{w-4},50%,1,0 --line 50%,3,50%,{h-4},1,0
-a x -o img/toc_buttons.png
100%,100%,1,4 -fc. 245,245,245,0 -o. img/toc_void.png
-rm
-if {!narg($_N)} _N=0 -endif
0 -repeat $_N
-o. ${_output_html$>} -o. ${_output_shtml$>}
-done -rm.
-repeat $_N
-v + -_update_tutorial_html[] ${_input$>},${_height$>},${_output_shtml$>},${_output_html$>},${_img_prefix$>},${_tocid$>} -v -
-done
-x "rm -f __tmp.html"
-v + -e[] "\n  * All done !.\n\n"
__update_tutorial_html : -skip ${3=""},${4=""},${5=""}
-if {!narg($_N)} _N=0 -endif
_input$_N=$1 _height$_N=$2
-if {narg("$5")} _tocid$_N="$5"
-else
({'"$1"'}) -s -,{'/'} -if $! _tocid$_N={0,t} -rm -else _tocid$_N=index -endif
-endif
({'"$1"'}) -s -,{'/'}
output_base=""
-if $! output_base={t} -endif
-if {$!>2" && "i[0]!=_'-'} output_base={-2,t}_{t} -endif
-rm
-if {narg($output_base)}
({'$output_base'}) -if {i==_'-'} -=. {'_'} output_base={t} -endif -rm.
-endif
-if {narg("$3")} _output_shtml$_N="$3".shtml _output_html$_N="$3".html _img_prefix$_N="$3"
-else _output_shtml$_N=$output_base.shtml _output_html$_N=$output_base.html _img_prefix$_N=$output_base
-endif
-if {narg("$4")} _output_html$_N="$4".html -endif
_N+=1
_update_tutorial_html :
-v -
url="http://particularart.com/tools-and-toys/gmic/$1"
-v + -e[] "\n  * Convert tutorial page '"$url"'." -v -
-v + -e[] "    > Retrieve page '"$url"'." -v -
-x "wget -q "$url" -O __tmp.html"
-i raw:__tmp.html,char
-discard 13
-replace_str "class=\"internal\" "
-replace_str "class=\"external\" "
-replace_str "dir=\"ltr\" "
-replace_str "border: 1px","border: 0px"
-replace_str "G\140MIC","G\47MIC"
-replace_str "CNTL","CTRL"
-replace_str "Rashid","Rachid"
-replace_str "gmic.sourceforge.net","gmic.eu"
-replace_str "gmic_def","gmic_stdlib"
-replace_str "@#","$!"
-replace_str "@{-1,","{"
-replace_str "@{","{"
-s -,{'"<!-- GIMMICKRY! -->"'} -k[1]
-s -,{'"<!-- GIMMICKRY! End -->"'} -k[0]
-s +,{'"   </div>\n</div>\n<footer>"'} -k[0]
-i[0] ({'"<!DOCTYPE html>"\n\
"<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
"<link rel=\"stylesheet\" href=\"tutorial.css\">"\n\
"<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>"\n\
"<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />"\n\
"<script type=\"text/javascript\">"\n\
"hs.graphicsDir = 'highslide/graphics/';"\n\
"hs.wrapperClassName = 'wide-border';"\n\
"</script>"\n\
"<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>"\n\
"<body>"\n\n'})
({'\n</body></html>'})
-y -a y
-replace_str "\"/static/media/uploads/","\"http://particularart.com/static/media/uploads/"
-replace_str "\"/tools-and-toys/gmic/","\"http://particularart.com/tools-and-toys/gmic/"
-replace_str "\"http://particularart.com/","\"http://www.particularart.com/"
-s +,{'"<a "'}
-repeat $! -if {$>>0" && "[{{$>-1},^}]=='"<a "'} -l[$>] -s +,{'href=\"'} -l.
-s +,{'\"'}
-if {$!>0}
link={0,t}
({'$link'}) -z. 0,48 baselink={t} -rm.
-if {['$baselink']=='http://www.particularart.com/tools-and-toys/gmic/'}
-l[] anchor="" ({'$link'}) -s +,{"'#'"} -if {$!>1} anchor=#{t} link={0,t} -endif -rm -endl
({'$link'}) -autocrop. {'/'}
-l. -s -,{'/'} -if {com='command-guide';$!>6" && "[{-2,^}]!=com" && "[{-3,^}]!=com} relink={-2,t}_{t}.shtml -else relink={t}.shtml -endif -rm -endl
({'$relink'}) -if {i==_'-'} -=. {'_'} relink={t} -endif -rm.
-if $relink
relink=$relink$anchor
-v + -e[] "    > Local link '"$link$anchor"' relinked to '"$relink"'." -v -
-rm[0] -i[0] ({'$relink'}) -y[0]
-else
({'$relink'}) -if {i==_'_'}
-l. -z 1,100% -s -,{'.'} command=${-basename\ {0,t}} -k[0] -endl
relink="http://gmic.eu/reference.shtml#"$command
-v + -e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_g}"(reference command)."${_gmic_n} -v -
-rm[0] -i[0] ({'$relink'}) -y[0]
-else
relink=$link$anchor
-v + -e[] "    > Local link '"$link$anchor"' relinked to '"$relink"' "${_gmic_r}"(no corresponding local page)."${_gmic_n} -v -
-rm[0] -i[0] ({'$relink'}) -y[0]
-endif
-rm.
-endif
-else -l
0 -nm. $link ext={x} -rm.
-if {narg($ext)} ext=${-struncase\ $ext} -endif
-if {s=['$ext'];s=='png'||s=='jpg'||s=='jpeg'}
-basename $link relink=img/$5_${} 0 -nm. $relink relink={f}{b}.jpg -rm.
-if $relink -v + -e[] "    > External image link '"$link"' relinked to '"$relink"'." -v -
-else
-l[] -i $link -k[0] is_opaque=0
-split_opacity -if {$!==1" || "ia>250} is_opaque=1 -endif -a c
-if {$is_opaque} -to_rgb -else -to_rgba -i[0] 100%,100%,1,3 -fc[0] 245,245,245 -blend alpha -endif
-o $relink,60 -rm
-v + -e[] "    > Image link '"$link"' converted and relinked to '"$relink"'." -v -
-onfail relink=$link -v + -e[] "    > Failed to retrieve image link '"$link"'." -v - -rm
-endl
-endif
-rm[0] -i[0] ({'$relink'})
-i[2] ({'" class=\"highslide\" onclick=\"return hs.expand(this)\""'})
-y[0,2]
-else
-v + -e[] "    > External link '"$link"' found." -v -
-endif
-onfail -endl -endif
-a y
-endif
-endl -a y -endl -endif -done
-a y
-s +,{'"<img"'}
-repeat $! -if {$>>0" && "[{{$>-1},^}]=='"<img "'}
-l[$>]
-s +,{'"src=\""'}
-l[2]
-s +,{'\"'} link={0,t}
relink=img/$5_${-basename\ $link} 0 -nm. $relink relink={f}{b}.jpg -rm.
-if $relink -v + -e[] "    > Image '"$link"' relinked to '"$relink"'." -v -
-else
-l[] -i $link -k[0] is_opaque=0
-split_opacity -if {$!==1" || "ia>250} is_opaque=1 -endif -a c
-if $is_opaque -to_rgb -frame 1,1,0 -frame 10,10,245
-else -to_rgba -i[0] 100%,100%,1,3 -fc[0] 245,245,245 -blend alpha
-endif
-o $relink,60 -rm
-v + -e[] "    > Image '"$link"' converted and relinked to '"$relink"'." -v -
-onfail relink=$link -v + -e[] "      > Failed to retrieve image '"$link"'." -v - -rm
-endl
-endif
-rm[0] -i[0] ({'$relink'}) -y[0]
-endl
-a y
-endl
-endif -done
-a y
-replace_str "<td><img","<td width=\"256\"><img"
-replace_str "<td>\n<p><img","<td width=\"256\"><p><img"
-replace_str "<td>&nbsp;<img","<td width=\"256\"><img"
-replace_str "<a ","<a target=\"_parent\" "
-o raw:$4,char
-rm
({'"<!DOCTYPE html>"\n\
"<html lang=\"en-us\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">"\n\
"<!--#include file=\"header.html\" -->"\n\
"<div id=\"bloc_option\"><div id=\"top_vert\"><div id=\"text_top\">Tutorial</div></div>"\n\
"<div id=\"center\"><div id=\"text_centre_intro\">"\n\
"<script language=\"javascript\">var gFilename = '$6';</script>"\n\
"<!--#include file=\"tutorial_toc.html\" -->"\n\
"<iframe width=\"100%\" height=\"$2\" frameborder=\"0\" src=\""$4"\" seamless></iframe>"\n\
"</div></div><div id=\"footer\"><img alt=\"\" src=\"images/footer.jpg\" /></div></div>"\n\
"<!--#include file=\"copyright.html\" -->"\n\
"<!--#include file=\"footer.html\" -->"\n'})
-o raw:$3,char
-rm
-wait {5000+u(2000)}
-v +
#@gmic v : eq. to '-verbose'. : (+)
#@gmic verbose : level : { + | - } : (+)
#@gmic : Set or increment/decrement the verbosity level. Default level is 0.
#@gmic : (eq. to '-v').
#@gmic : When 'level'>=0, G'MIC log messages are displayed on the standard error (stderr).
#@gmic : Default value: 'level=0'.
#@gmic wait : delay : (no arg) : (+)
#@gmic : Wait for a given delay (in ms), optionally since the last call to '-wait'.
#@gmic : or wait for a user event occuring on the selected instant display windows.
#@gmic : 'delay' can be { <0=delay+flush events | 0=event | >0=delay }.
#@gmic : Command selection (if any) stands for instant display window indices instead of image indices.
#@gmic : If no window indices are specified and if 'delay' is positive, the command results
#@gmic : in a 'hard' sleep during specified delay.
#@gmic : Default value: 'delay=0'.
#@gmic warn : _force_visible={ 0 | 1 },_message : (+)
#@gmic : Print specified warning message, on the standard error (stderr).
#@gmic : Command selection (if any) stands for displayed call stack subset instead of image indices.
#@gmic w : eq. to '-window'. : (+)
#@gmic window : _width[%]>=-1,_height[%]>=-1,_normalization,_fullscreen,_pos_x[%],_pos_y[%],_title : (+)
#@gmic : Display selected images into an instant display window with specified size, normalization type,
#@gmic : fullscreen mode and title.
#@gmic : (eq. to '-w').
#@gmic : If 'width' or 'height' is set to -1, the corresponding dimension is adjusted to the window
#@gmic : or image size.
#@gmic : When arguments 'pos_x' and 'pos_y' are both different than -1, the window is moved to
#@gmic : the specified coordinates.
#@gmic : 'width'=0 or 'height'=0 closes the instant display window.
#@gmic : 'normalization' can be { -1=keep same | 0=none | 1=always | 2=1st-time | 3=auto }.
#@gmic : 'fullscreen' can be { -1=keep same | 0=no | 1=yes }.
#@gmic : You can manage up to 10 different instant display windows by using the numbered variants
#@gmic : '-w0' (default, eq. to '-w'),'-w1',..,'-w9' of the command '-w'.
#@gmic : Invoke '-window' with no selection to make the window visible, if is has been closed by the user.
#@gmic : Default values: 'width=height=normalization=fullscreen=-1' and 'title=(undefined)'.
#@gmic :: List manipulation
#@gmic k : eq. to '-keep'. : (+)
#@gmic keep : (+)
#@gmic : Keep only selected images.
#@gmic : (eq. to '-k').
#@gmic : $ image.jpg -split x -keep[0-50%:2] -append x
#@gmic : $ image.jpg -split x -keep[^30%-70%] -append x
#@gmic mv : eq. to '-move'. : (+)
#@gmic move : position[%] : (+)
#@gmic : Move selected images at specified position.
#@gmic : (eq. to '-mv').
#@gmic : $ image.jpg -split x,3 -move[1] 0
#@gmic : $ image.jpg -split x -move[50%--1:2] 0 -append x
#@gmic nm : eq. to '-name'. : (+)
#@gmic name : "name" : (+)
#@gmic : Set name of selected images.
#@gmic : (eq. to '-nm').
#@gmic : $ image.jpg -name image -blur[image] 2
#@gmic nms : eq. to '-names'.
nms :
-v - _gmic_s="$?" -v +
-_names $*
#@gmic names : name1,name2,...,nameN
#@gmic : Set each name of (multiple) selected images from the sequence of the provided arguments.
#@gmic : (eq. to '-nms').
names :
-v - _gmic_s="$?" -v +
-_$0 $*
_names :
-e[0--3] "Set names of image$? to '$*'."
-if {$#!=$!} -warn[0--3] "Number of selected images ("$!") is different than number of provided arguments ($#)." -endif
-v - $=arg -repeat {min($!,$#)} -nm[$>] ${arg{1+$>}} -done -v +
#@gmic rm : eq. to '-remove'. : (+)
#@gmic remove : (+)
#@gmic : Remove selected images.
#@gmic : (eq. to '-rm').
#@gmic : $ image.jpg -split x -remove[30%-70%] -append x
#@gmic : $ image.jpg -split x -remove[0-50%:2] -append x
#@gmic remove_duplicates
#@gmic : Remove duplicates images in the selected images list.
#@gmic : $ (1,2,3,4,2,4,3,1,3,4,2,1) -split x -remove_duplicates -append x
remove_duplicates :
-e[^-1] "Remove duplicates images in selected list of image$?."
-v - -repeat $!
base=$> off=0
-repeat {$!-$>-1}
comp={$base+1+$>-$off}
-if {$comp>=$!} -break -endif
---[$base,$comp] -abs. is_duplicate={!is} -rm.
-if $is_duplicate -rm[$comp] off+=1 -endif
-done
-done -v +
#@gmic remove_empty
#@gmic : Remove empty images in the selected image list.
remove_empty :
-e[^-1] "Remove empty images in selected list of image$?."
-v - -repeat $! -if {$<,!whds} -rm[$<] -endif -done -v +
#@gmic rv : eq. to '-reverse'. : (+)
#@gmic reverse : (+)
#@gmic : Reverse positions of selected images.
#@gmic : (eq. to '-rv').
#@gmic : $ image.jpg -split x,3 -reverse[-2,-1]
#@gmic : $ image.jpg -split x,-16 -reverse[50%-100%] -append x
#@gmic sort_list : _ordering={ + | - },_criterion
#@gmic : Sort list of selected images according to the specified image criterion.
#@gmic : Default values: 'ordering=+', 'criterion=i'.
#@gmic : $ (1;4;7;3;9;2;4;7;6;3;9;1;0;3;3;2) -split y -sort_list + -append y
sort_list : -skip ${1=+},${2=i}
-v - s0="descending" s1="ascending" -v +
-e[^-1] "Sort list of image$? in "${s{_'+'=='$1'}" order, according to the image criterion '$2'."
-v - -if $!
i=$! -repeat $! ({$>,$2}) -done -a[$i--1] y --f. 'y' -a[-2,-1] x -sort. $1,y -z. 1,1
-repeat {h} nm$>={$>,n} -nm[$>] sortlist$> -done
-repeat {h} -mv[sortlist{i(0,$>)}] -1 -done
-repeat {h} -nm[$>] ${nm{i(0,$>)}} -done
-rm. -endif -v +
#@gmic sort_str
#@gmic : Sort selected images (viewed as a list of strings) in lexicographic order.
sort_str :
-e[^-1] "Sort image$? in lexicographic order."
-v - -y -a x
-repeat {round(h/4,1,1)} y={4*$>}
-repeat $! -l[$<]
--rows $y,{$y+3} -f[1] 'if(i>=97&&i<=122,i-32,i)' --. 32 -c. 0,63 -s. y -*.. 64 -*... 4096 -*[-4] 262144 -+[-4--1]
-rv -a y -sort +,x --rows 0 -rows[0] 1,100% -label[1] -%[1] 2
-s[1] +,0 N={$!-1}
x0=0 -repeat {$!-1} x1={$x0+{{1+$>},h}} --z[0] $x0,{$x1-1} x0=$x1 -done
-rm[0-$N]
-endl -done
-done -s x -v +
#@gmic :: Mathematical operators
#@gmic abs : (+)
#@gmic : Compute the pointwise absolute values of selected images.
#@gmic : $ image.jpg --sub {ia} -abs.
#@gmic : $ 300,1,1,1,'cos(20*x/w)' --abs -display_graph 400,300
#@gmic acos : (+)
#@gmic : Compute the pointwise arc-cosine of selected images.
#@gmic : $ image.jpg --normalize -1,1 -acos.
#@gmic : $ 300,1,1,1,'x/w+0.1*u' --acos -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands
#@gmic + : eq. to '-add'. : (+)
#@gmic add : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Add specified value, image or mathematical expression to selected images,
#@gmic : or compute the pointwise sum of selected images.
#@gmic : (eq. to '-+').
#@gmic : $ image.jpg --add 30% -cut 0,255
#@gmic : $ image.jpg --blur 5 -normalize 0,255 -add[1] [0]
#@gmic : $ image.jpg -add '80*cos(80*(x/w-0.5)*(y/w-0.5)+c)' -cut 0,255
#@gmic : $ image.jpg -repeat 9 --rotate[0] {$>*36},1,0,50%,50% -done -add -div 10
#@gmic & : eq. to '-and'. : (+)
#@gmic and : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise AND of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise AND of selected images.
#@gmic : (eq. to '-&').
#@gmic : $ image.jpg -and {128+64}
#@gmic : $ image.jpg --mirror x -and
#@gmic asin : (+)
#@gmic : Compute the pointwise arc-sine of selected images.
#@gmic : $ image.jpg --normalize -1,1 -asin.
#@gmic : $ 300,1,1,1,'x/w+0.1*u' --asin -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands
#@gmic atan : (+)
#@gmic : Compute the pointwise arc-tangent of selected images.
#@gmic : $ image.jpg --normalize 0,8 -atan.
#@gmic : $ 300,1,1,1,'4*x/w+u' --atan -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands
#@gmic atan2 : [x_argument] : (+)
#@gmic : Compute the pointwise oriented arc-tangent of selected images.
#@gmic : Each selected image is regarded as the y-argument of the arc-tangent function, while the
#@gmic : specified image gives the corresponding x-argument.
#@gmic : $ (-1,1) (-1;1) -resize 400,400,1,1,3 -atan2[1] [0] -keep[1] -mod {pi/8}
#@gmic : $$ trigometric-and-inverse-trigometric-commands
#@gmic << : eq. to '-bsl'. : (+)
#@gmic bsl : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise left shift of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise left shift of
#@gmic : selected images.
#@gmic : (eq. to '-<<').
#@gmic : $ image.jpg -bsl 'round(3*x/w,0)' -cut 0,255
#@gmic >> : eq. to '-bsr'. : (+)
#@gmic bsr : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise right shift of selected images with specified value, image or"
#@gmic : mathematical expression, or compute the pointwise sequential bitwise right shift of
#@gmic : selected images.
#@gmic : (eq. to '->>').
#@gmic : $ image.jpg -bsr 'round(3*x/w,0)' -cut 0,255
#@gmic cos : (+)
#@gmic : Compute the pointwise cosine of selected images.
#@gmic : $ image.jpg --normalize 0,{2*pi} -cos.
#@gmic : $ 300,1,1,1,'20*x/w+u' --cos -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands
#@gmic cosh : (+)
#@gmic : Compute the pointwise hyperbolic cosine of selected images.
#@gmic : $ image.jpg --normalize -3,3 -cosh.
#@gmic : $ 300,1,1,1,'4*x/w+u' --cosh -display_graph 400,300
#@gmic / : eq. to '-div'. : (+)
#@gmic div : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Divide selected image by specified value, image or mathematical expression,
#@gmic : or compute the pointwise quotient of selected images.
#@gmic : (eq. to '-/').
#@gmic : $ image.jpg -div '1+abs(cos(x/10)*sin(y/10))'
#@gmic : $ image.jpg --norm -add. 1 --div
#@gmic div_complex : [divider_real,divider_imag],_epsilon>=0
#@gmic : Perform division of the selected complex pairs (real1,imag1,...,realN,imagN) of images by specified complex pair of images (divider_real,divider_imag).
#@gmic : In complex pairs, the real image must be always located before the imaginary image in the image list.
#@gmic : Default value: 'epsilon=1e-8'.
div_complex : -check ${3=1e-8}>=0
-e[^-1] "Divide complex pair$? by complex pair $1,$2 (with epsilon $3)."
-v - -repeat {int($!/2)} -pass${1,2} 0 -l[$>,{$>+1},-2,-1]
--*[1,2] --*[0,3] --[-2,-1]
-*[0] [2] -*[1] [3] -+[0,1]
-sqr[1,2] -+[1,2] -+[1] $3
-/[2] [1] -/[0,1]
-endl -done -v +
#@gmic == : eq. to '-eq'. : (+)
#@gmic eq : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean equality of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean equality of selected images.
#@gmic : (eq. to '-==').
#@gmic : $ image.jpg -round 40 -eq {round(ia,40)}
#@gmic : $ image.jpg --mirror x -eq
#@gmic exp : (+)
#@gmic : Compute the pointwise exponential of selected images.
#@gmic : $ image.jpg --normalize 0,2 -exp.
#@gmic : $ 300,1,1,1,'7*x/w+u' --exp -display_graph 400,300
#@gmic >= : eq. to '-ge'. : (+)
#@gmic ge : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'greater or equal than' of selected images with specified value, image
#@gmic : or mathematical expression, or compute the boolean 'greater or equal than' of selected images.
#@gmic : (eq. to '->=').
#@gmic : $ image.jpg -ge {ia}
#@gmic : $ image.jpg --mirror x -ge
#@gmic > : eq. to '-gt'. : (+)
#@gmic gt : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'greater than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'greater than' of selected images.
#@gmic : (eq. to '->').
#@gmic : $ image.jpg -gt {ia}
#@gmic : $ image.jpg --mirror x -gt
#@gmic <= : eq. to '-le'. : (+)
#@gmic le : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'less or equal than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'less or equal than' of selected images.
#@gmic : (eq. to '-<=').
#@gmic : $ image.jpg -le {ia}
#@gmic : $ image.jpg --mirror x -le
#@gmic < : eq. to '-lt'. : (+)
#@gmic lt : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean 'less than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'less than' of selected images.
#@gmic : (eq. to '-<').
#@gmic : $ image.jpg -lt {ia}
#@gmic : $ image.jpg --mirror x -lt
#@gmic log : (+)
#@gmic : Compute the pointwise base-e logarithm of selected images.
#@gmic : $ image.jpg --add 1 -log.
#@gmic : $ 300,1,1,1,'7*x/w+u' --log -display_graph 400,300
#@gmic log10 : (+)
#@gmic : Compute the pointwise base-10 logarithm of selected images.
#@gmic : $ image.jpg --add 1 -log10.
#@gmic : $ 300,1,1,1,'7*x/w+u' --log10 -display_graph 400,300
#@gmic log2 : (+)
#@gmic : Compute the pointwise base-2 logarithm of selected images
#@gmic : $ image.jpg --add 1 -log2.
#@gmic : $ 300,1,1,1,'7*x/w+u' --log2 -display_graph 400,300
#@gmic max : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the maximum between selected images and specified value, image or
#@gmic : mathematical expression, or compute the pointwise maxima between selected images.
#@gmic : $ image.jpg --mirror x -max
#@gmic : $ image.jpg -max 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'
#@gmic // : eq. to '-mdiv'. : (+)
#@gmic mdiv : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the matrix division of selected matrices/vectors by specified value, image or
#@gmic : mathematical expression, or compute the matrix division of selected images.
#@gmic : (eq. to '-//').
#@gmic min : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the minimum between selected images and specified value, image or
#@gmic : mathematical expression, or compute the pointwise minima between selected images.
#@gmic : $ image.jpg --mirror x -min
#@gmic : $ image.jpg -min 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'
#@gmic % : eq. to '-mod'. : (+)
#@gmic mod : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the modulo of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential modulo of selected images.
#@gmic : (eq. to '-%').
#@gmic : $ image.jpg --mirror x -mod
#@gmic : $ image.jpg -mod 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'
#@gmic ** : eq. to '-mmul'. : (+)
#@gmic mmul : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the matrix right multiplication of selected matrices/vectors by specified value, image or
#@gmic : mathematical expression, or compute the matrix right multiplication of selected images.
#@gmic : (eq. to '-**').
#@gmic : $ (0,1,0;0,0,1;1,0,0) (1;2;3) --mmul
#@gmic * : eq. to '-mul'. : (+)
#@gmic mul : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Multiply selected images by specified value, image or mathematical expression,
#@gmic : or compute the pointwise product of selected images.
#@gmic : (eq. to '-*').
#@gmic : $ image.jpg --mul 2 -cut 0,255
#@gmic : $ image.jpg (1,2,3,4,5,6,7,8) -resize. [0] -mul[0] [-1]
#@gmic : $ image.jpg -mul '1-3*abs(x/w-0.5)' -cut 0,255
#@gmic : $ image.jpg --luminance -negative. --mul
#@gmic mul_channels : value1,_value2,...,_valueN
#@gmic : Multiply channels of selected images by specified sequence of values.
#@gmic : $ image.jpg --mul_channels 1,0.5,0.8
mul_channels :
-e[^-1] "Multiply channels of image$? by value sequence ($*)."
-v - $=arg -repeat $#
i=$> fact=${arg{1+($>%$#)}}
-repeat $! -if {$>,$i<s} -sh[$>] $i -*. $fact -rm. -endif -done
-done -v +
#@gmic mul_complex : [multiplier_real,multiplier_imag]
#@gmic : Perform multiplication of the selected complex pairs (real1,imag1,...,realN,imagN) of images by specified complex pair of images (multiplier_real,multiplier_imag).
#@gmic : In complex pairs, the real image must be always located before the imaginary image in the image list.
mul_complex :
-e[^-1] "Multiply complex pair$? by complex pair $1,$2."
-v - -repeat {int($!/2)} -pass${1,2} 0 -l[$>,{$>+1},-2,-1]
--*[0,3] --*[1,2] -+[-2,-1]
-*[0,2] -*[1,2] --[0,1]
-endl -done -v +
#@gmic != : eq. to '-neq'. : (+)
#@gmic neq : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the boolean inequality of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean inequality of selected images.
#@gmic : (eq. to '-!=').
#@gmic : $ image.jpg -round 40 -neq {round(ia,40)}
#@gmic | : eq. to '-or'. : (+)
#@gmic or : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise OR of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise OR of selected images.
#@gmic : (eq. to '-|').
#@gmic : $ image.jpg -or 128
#@gmic : $ image.jpg --mirror x -or
#@gmic ^ : eq. to '-pow'. : (+)
#@gmic pow : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Raise selected image to the power of specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential powers of selected images.
#@gmic : (eq. to '-^').
#@gmic : $ image.jpg -div 255 --pow 0.5 -mul 255
#@gmic : $ image.jpg -gradient -pow 2 -add -pow 0.2
#@gmic rol : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise left rotation of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise left rotation of
#@gmic : selected images.
#@gmic : $ image.jpg -rol 'round(3*x/w,0)' -cut 0,255
#@gmic ror : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise right rotation of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise right rotation of
#@gmic : selected images.
#@gmic : $ image.jpg -ror 'round(3*x/w,0)' -cut 0,255
#@gmic sign : (+)
#@gmic : Compute the pointwise sign of selected images.
#@gmic : $ image.jpg --sub {ia} -sign.
#@gmic : $ 300,1,1,1,'cos(20*x/w+u)' --sign -display_graph 400,300
#@gmic sin : (+)
#@gmic : Compute the pointwise sine of selected images.
#@gmic : $ image.jpg --normalize 0,{2*pi} -sin.
#@gmic : $ 300,1,1,1,'20*x/w+u' --sin -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands
#@gmic sinc : (+)
#@gmic : Compute the pointwise sinc function of selected images.
#@gmic : $ image.jpg --normalize {-2*pi},{2*pi} -sinc.
#@gmic : $ 300,1,1,1,'20*x/w+u' --sinc -display_graph 400,300
#@gmic sinh : (+)
#@gmic : Compute the pointwise hyperbolic sine of selected images.
#@gmic : $ image.jpg --normalize -3,3 -sinh.
#@gmic : $ 300,1,1,1,'4*x/w+u' --sinh -display_graph 400,300
#@gmic sqr : (+)
#@gmic : Compute the pointwise square function of selected images.
#@gmic : $ image.jpg --sqr
#@gmic : $ 300,1,1,1,'40*x/w+u' --sqr -display_graph 400,300
#@gmic sqrt : (+)
#@gmic : Compute the pointwise square root of selected images.
#@gmic : $ image.jpg --sqrt
#@gmic : $ 300,1,1,1,'40*x/w+u' --sqrt -display_graph 400,300
#@gmic - : eq. to '-sub'. : (+)
#@gmic sub : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Subtract specified value, image or mathematical expression to selected images,
#@gmic : or compute the pointwise difference of selected images.
#@gmic : (eq. to '--').
#@gmic : $ image.jpg --sub 30% -cut 0,255
#@gmic : $ image.jpg --mirror x -sub. [0]
#@gmic : $ image.jpg -sub 'i(w/2+0.9*(x-w/2),y)'
#@gmic : $ image.jpg --mirror x -sub
#@gmic tan : (+)
#@gmic : Compute the pointwise tangent of selected images.
#@gmic : $ image.jpg --normalize {-0.47*pi},{0.47*pi} -tan.
#@gmic : $ 300,1,1,1,'20*x/w+u' --tan -display_graph 400,300
#@gmic : $$ trigometric-and-inverse-trigometric-commands
#@gmic tanh : (+)
#@gmic : Compute the pointwise hyperbolic tangent of selected images.
#@gmic : $ image.jpg --normalize -3,3 -tanh.
#@gmic : $ 300,1,1,1,'4*x/w+u' --tanh -display_graph 400,300
#@gmic xor : value[%] : [image] : 'formula' : (no arg) : (+)
#@gmic : Compute the bitwise XOR of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise XOR of selected images.
#@gmic : $ image.jpg -xor 128
#@gmic : $ image.jpg --mirror x -xor
#@gmic :: Values manipulation
#@gmic apply_curve : 0<=smoothness<=1,x0,y0,x1,y1,x2,y2,...,xN,yN
#@gmic : Apply curve transformation to image values.
#@gmic : Default values: 'smoothness=1', 'x0=0', 'y0=100'.
#@gmic : $ image.jpg --apply_curve 1,0,0,128,255,255,0
apply_curve : -check "${1=1}>=0 && $1<=1" -skip ${2=0},${3=100}
-e[^-1] "Apply intensity curve with smoothness $1 and keypoints (${2--1}) on image$?."
-v - -function1d ${^0} -map[^-1] [-1],1 -rm.
-v +
#@gmic apply_gamma : gamma>=0
#@gmic : Apply gamma correction to selected images.
#@gmic : $ image.jpg --apply_gamma 2
apply_gamma : -check $1>=0
-e[^-1] "Apply Gamma-correction to image$?, with gamma $1."
-if {$1==1} -return -endif
-v - -repeat $! -l[$>] mM={im},{iM} -n 0,1 -^ {1/$1} -n $mM -endl -done -v +
#@gmic balance_gamma : _ref_color1,...
#@gmic : Compute gamma-corrected color balance of selected image, with respect to specified reference color.
#@gmic : Default value: 'ref_color1=128'.
#@gmic : $ image.jpg --balance_gamma 128,64,64
balance_gamma : -skip ${1=128}
-e[^-1] "Apply gamma-corrected color balance of image$?, with reference color ("${^0}")."
-v - -repeat $! -l[$>]
(${^0}) -r. {-2,s},1,1,1,0,1 -s.. c -/. 255
-repeat {$!-1} -/[$>] 255 -^[$>] {log({@$>})/log({$>,ia})} -*[$>] 255 -done
-rm. -a c -c 0,255
-endl -done -v +
#@gmic complex2polar
#@gmic : Compute complex to polar transforms of selected images.
#@gmic : $ image.jpg --fft -complex2polar[-2,-1] -log.. -shift.. 50%,50%,0,0,2 -remove.
complex2polar :
-e[^-1] "Compute complex to polar transforms of image$?."
-v - -repeat {int($!/2)} -l[{2*$>},{2*$>+1}]
-r[1] [0],3 --atan2[1] [0] -nm. {1,n} -sqr[-3,-2] -+[-3,-2] -sqrt..
-endl -done -v +
#@gmic compress_clut : _max_nbpoints>=1,_max_error>=0,_avg_error>=0
#@gmic : Compress selected color LUTs as sequences of colored keypoints.
#@gmic : Default values: 'max_nb_points=2048', 'max_error=17.5' and 'avg_error=1.75'.
compress_clut : -check "isint(${1=2048}) && $1>=1 && ${2=17.5}>=0 && ${3=1.75}>=0"
-e[^-1] "Compress color LUT$? as a set of colored keypoints, with $1 max points, maximum error $2 and average error $3."
-v -
-repeat $! -l[$>]
({'{b}'}) -replace_str. "film_","" nm={t} -rm.
w={w} h={h} d={d}
w_size=${-fitscreen" "$w,$h,$d,256,50%}
-v + -e[] "  > Process clut '"$nm"' ("${w}"x"${h}"x"${d}")." -v -
-nm clut
100%,100%,100% -nm. keypoints
--laplacian[0] -norm. -pow. 0.5 -nm. potential
0 -nm. keycoords
-m "add_keypoint : rgb={clut,I($""1,$""2,$""3)} -=[keypoints] 1,$""1,$""2,$""3 ({$""1*255/$_w1},{$""2*255/$_h1},{$""3*255/$_d1},$rgb) -a[keycoords,-1] y"
_w1={max(1,$w-1)} _h1={max(1,$h-1)} _d1={max(1,$d-1)}
-add_keypoint {potential,xM},{potential,yM},{potential,zM}
0 -nm. error
max_error=inf avg_error=inf
-v + -e[] "" -v -
iter=0
-repeat inf
-if {keycoords,h>=$1} -break -endif
-if {$iter<2}
--distance[keypoints] 1,[potential],0 X={xM} Y={yM} Z={zM} -rm.
-else
--decompress_clut[keycoords] $w,$h,$d
-if {*0} -w. $w_size,0,"Reconstructed Hald-CLUT (step 1)" -endif
--. [clut] -abs. max_error={iM} avg_error={ia} X={xM} Y={yM} Z={zM} -rm.
-if {$max_error<=$2" && "$avg_error<=$3} -break -endif
($max_error^{10*$avg_error}) -a[error,-1] x -_compress_clut_draw_error
iter=0
-endif
-v + -e[] "\r    - Insert keypoint "{keycoords,h}": Max error = "{_$max_error}" ( avg = "{_$avg_error}" )        " -v -
-add_keypoint $X,$Y,$Z
iter+=1
-done
-rows[keycoords] 0,{keycoords,min($1-1,h-1)}
-v + -e[] "" -v -
-if {$max_error<=$2" && "$avg_error<=$3}
nb_attempts=1
-do
nb_max_attempts={keycoords,round(h*75%)}
-v + -e[] "\r    - Remove attempt \#"$nb_attempts/$nb_max_attempts" : Keypoints "{keycoords,h}", Max error = "{_$max_error}" ( avg = "{_$avg_error}" )        " -v -
k={keycoords,round(u(h-1))} --l[keycoords] -s y -rm[$k] -a y -nm new_keycoords -endl
--decompress_clut[new_keycoords] $w,$h,$d
-if {*0} -w. 400,400,0,"Reconstructed Hald-CLUT (step 2)" -endif
--. [clut] -abs. new_max_error={iM} new_avg_error={ia} -rm.
-if {$new_max_error<=$2" && "$new_avg_error<=$3}
max_error=$new_max_error
avg_error=$new_avg_error
-rm[keycoords] -nm[new_keycoords] keycoords
($max_error^{10*$avg_error}) -a[error,-1] x -_compress_clut_draw_error
nb_attempts=0
-else -rm[new_keycoords] nb_attempts+=1
-endif
-while {$nb_attempts<=$nb_max_attempts}
-endif
-k[keycoords] -nm $nm
-o ${_path_rc}comp_$nm.gmz,uchar
-endl -done -v +
_compress_clut_draw_error :
-if {error,w>=2}
--dg[error] 640,480,1,0,0,{keycoords,h},0,{error,@0},"Number of keypoints","Maximum reconstruction error"
-if {*1} -w1. 100%,100%,0,"Evolution of the reconstruction error" -endif
-rm. -endif
#@gmic compress_rle : _is_binary_data={ 0 | 1 },_maximum_sequence_length>=0
#@gmic : Compress selected images as 2xN data matrices, using RLE algorithm.
#@gmic : Set 'maximum_sequence_length=0' to disable maximum length constraint.
#@gmic : Default values: 'is_binary_data=0' and 'maximum_sequence_length=0'.
#@gmic : $ image.jpg -resize2dy 100 -quantize 4 -round --compress_rle , --decompress_rle.
compress_rle : -skip ${1=0} -check "isint(${2=0}) && $2>=0"
-v - s0=" for binary data" s1=""
-if $2 s=", with maximal sequence length "$2 -else s="" -endif
-v + -e[^-1] "Compress image$? using RLE algorithm"${s{!$1}}$s"." -v -
-repeat $! -l[$>] nm={0,n} im={im} header={w};{h};{d};{s};$im;{$1!=0}
-- $im -y x ({{0,@-1}+1}) -a x -r 100%,3
-f '>if(y==0,i,if(y==1,if(i(x,0)==i(x+1,0),-1,x),if(i(x-1,1)==-1,i(x-1,2)+1,1)))'
-if $2
-transpose -mirror x
-f. '>if(x==2,i,if(x==0,if(j(0,-1)==$2,1,if(i!=1,j(0,-1)+1,1)),if(i==-1&&j(-1)==$2,y,i)))'
-mirror x -transpose
-endif
-z 0,{w-2} -s y,3 -discard[1] -1 -warp[0,2] [1],0,0 -rm[1]
-if $1
-!=[0] 0 -*[0] 2 --[0] 1 -*
-else
-*. -1 -rv -a x -y -discard -1 -f '>if(i(0,y-1)<0&&i==0&&i(0,y+1)<0,-1,i)' -discard -1
-endif
-i[0] ($header) -a y -nm $nm
-endl -done -v +
#@gmic cumulate : { x | y | z | c }..{ x | y | z | c } : (no arg) : (+)
#@gmic : Compute the cumulative function of specified image data, optionally along the specified axes.
#@gmic : $ image.jpg --histogram --cumulate. -display_graph[-2,-1] 400,300,3
#@gmic c : eq. to '-cut'. : (+)
#@gmic cut : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (no arg) : (+)
#@gmic : Cut values of selected images in specified range.
#@gmic : (eq. to '-c').
#@gmic : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@gmic : In this case, the chosen cut values are returned in the status.
#@gmic : $ image.jpg --add 30% -cut. 0,255
#@gmic : $ image.jpg --cut 25%,75%
#@gmic decompress_clut : _width>0,_height>0,_depth>0
#@gmic : Decompress color LUT expressed as a list of colored keypoints.
#@gmic : Default value: 'width=height=depth=64'.
decompress_clut : -check "isint(${1=64}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=$1}) && $3>0"
-e[^-1] "Decompress color LUT$? into a $1x$2x$3 volumetric image."
-v - -transpose -repeat $! -l[$>]
-s y -*[0] {($1-1)/255} -*[1] {($2-1)/255} -*[2] {($3-1)/255} -round[0-2] -a y
100%,1,1,1,255 -a y -pointcloud 0,$1,$2,$3 -solidify 100%,1,15 -c 0,255
-endl -done -v +
#@gmic decompress_rle
#@gmic : Decompress selected 2xN data matrices, using RLE algorithm.
decompress_rle :
-e[^-1] "Decompress data vector$?, using RLE algorithm."
-v - -repeat $! -l[$>]
-y whds={0,@0-3} im={0,@4} is_binary_data={0,@5} -rows 6,100%
-if $is_binary_data
-->= 0 -abs[0] -a x
-else
--<. 0 (0;1;1) -erode.. [-1],0 -rm. --. 1 -a x -discard -1
--< 0 (1;1;0) -dilate.. [-1] -rm. -*. -2 -+. 1
-rv -abs. -a x -discard -1
-r 2,{h/2},1,1,-1
-endif
-s y,-256
-repeat $! -l[$>]
-i[0] ({'CImg3d'}) -+[0] 0.5
-i[1] ({2*h};{h})
-s. x,2 -cumulate.. siz={-2,@-1}
--shift.. 0,1 --... 1 -rv[-3,-1] -z[-3,-1] 0,2 -a[-3,-1] x
-i[3] (2,0,1;2,{2*h-2},{2*h-1}) -r[3] 3,{h},1,1,3 -round[3]
-r[4] 3 1,100%,1,1,1 -y -a y
$siz -j3d. [-2],0,0,0,1,2,0,0 -rm..
-endl -done
-a x -r $whds,-1 -+ $im
-endl -done -v +
#@gmic discard : _value1,_value2,... : { x | y | z | c}..{ x | y | z | c},_value1,_value2,... : (no args) : (+)
#@gmic : Discard specified values in selected images or discard neighboring duplicate values,
#@gmic : optionally only for the values along the first of a specified axis.
#@gmic : If no values are specified, neighboring duplicate values are discarded.
#@gmic : If all pixels of a selected image are discarded, an empty image is returned.
#@gmic : $ (1;2;3;4;3;2;1) --discard 2
#@gmic : $ (1,2,2,3,3,3,4,4,4,4) --discard x
#@gmic eigen2tensor
#@gmic : Recompose selected pairs of eigenvalues/eigenvectors as 2x2 or 3x3 tensor fields.
#@gmic : $$
eigen2tensor :
-e[^-1] "Recompose pairs in eigen field$? as 2x2 or 3x3 tensor fields."
-v - -repeat {$!/2} -l[$>,{$>+1}] nm={0,n}
-if {s==2}
-s. c
--sqr. -*.. [-3] -sqr...
-sh. --*... -1
-sh[-5]
-a[-3--1] c -a[-4--2] c
-sh... 0 -*[-3,-1]
-sh... 1 -*[-2,-1]
-rm... -+[-2,-1]
-elif {s==6}
-s. c
-l[-6--4] --sqr.. --*[-2,-3] --sqr... -*[-5] [-6] -*[-4] [-6] -sqr[-6] -a c -endl
-l[-3--1] --sqr.. --*[-2,-3] --sqr... -*[-5] [-6] -*[-4] [-6] -sqr[-6] -a c -endl
-s... c
--[-5] [-3] --[-4] [-3] -*.. [-5] -*. [-4]
(1^0^0^1^0^1) -r. [-3] -*. [-4] -rm[-6--4] -+[-3--1]
-else -v + -error[0--3] "Command '-eigen2tensor': Invalid image ["{$!-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2d or 3d eigenvectors."
-endif
-nm $nm -endl -done -v +
#@gmic endian : _datatype : (+)
#@gmic : Reverse data endianness of selected images, eventually considering the pixel being of the specified datatype.
#@gmic : 'datatype' can be { uchar | char | ushort | short | uint | int | uint64 | int64 | float | double }.
#@gmic equalize : _nb_levels>0[%],_value_min[%],_value_max[%] : (+)
#@gmic : Equalize histograms of selected images.
#@gmic : If value range is specified, the equalization is done only for pixels in the specified
#@gmic : value range.
#@gmic : Default values: 'nb_levels=256', 'value_min=0%' and 'value_max=100%'.
#@gmic : $ image.jpg --equalize
#@gmic : $ image.jpg --equalize 4,0,128
#@gmic f : eq. to '-fill'. : (+)
#@gmic fill : value1,_value2,.. : [image] : 'formula' : (+)
#@gmic : Fill selected images with values read from the specified value list, existing image
#@gmic : or mathematical expression. Single quotes may be omitted in 'formula'.
#@gmic : (eq. to '-f').
#@gmic : $ 4,4 -fill 1,2,3,4,5,6,7
#@gmic : $ 4,4 (1,2,3,4,5,6,7) -fill.. [-1]
#@gmic : $ 400,400,1,3 -fill "X=x-w/2; Y=y-h/2; R=sqrt(X^2+Y^2); a=atan2(Y,X); if(R<=180,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))"
#@gmic float2int8
#@gmic : Convert selected float-valued images to 8bits integer representations.
float2int8 :
-e[^-1] "Convert float-valued image$? to 8bits integer representations."
-v - -repeat $! -l[$>]
-s c -repeat $! -l[$>]
m={im} M={iM} -quantize 16777216,0,1
-->> 8 -&. 255 --&.. 255 ->>... 16
({'$m,$M'}) -a y
-endl -done -a c
-endl -done -v +
#@gmic int82float
#@gmic : Convert selected 8bits integer representations to float-valued images.
int82float :
-e[^-1] "Convert 8bits integer representation$? to float-valued image$?."
-v - -repeat $! -l[$>]
-s c -repeat $! -l[$>]
-sh. {h-1},{h-1},0,0 m={t} -rm.
-rows 0,{h-2} -s y,3 -*... 65536 -*.. 256 -|
-skip ${-n\ $m}
-endl -done -a c
-endl -done -v +
#@gmic index : { [palette] | predefined_palette },0<=_dithering<=1,_map_palette={ 0 | 1 } : (+)
#@gmic : Index selected vector-valued images by specified vector-valued palette.
#@gmic : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@gmic : Default values: 'dithering=0' and 'map_palette=0'.
#@gmic : $ image.jpg --index 1,1,1
#@gmic : $ image.jpg (0;255;255^0;128;255^0;0;255) --index.. [-1],1,1
#@gmic : $$
#@gmic ir : eq. to '-inrange'.
ir :
-v - _gmic_s="$?" -v +
-_inrange $*
#@gmic inrange : min[%],max[%]
#@gmic : Detect pixels whose values are in specified range [min,max], in selected images.
#@gmic : (eq. to '-ir').
#@gmic : $ image.jpg --inrange 25%,75%
inrange :
-v - _gmic_s="$?" -v +
-_$0 $*
_inrange :
-e[0--3] "Detect pixel values in range [$1,$2] in image"$_gmic_s"."
-v - -repeat $! -l[$>]
m=$1 M=$2
-if ${-is_percent\ $1} m={im+(iM-im)*$1} -endif
-if ${-is_percent\ $2} M={im+(iM-im)*$2} -endif
-- {0.5*($m+$M)} -abs -<= {0.5*abs($M-$m)}
-endl -done -v +
#@gmic map : [palette],_boundary : predefined_palette,_boundary : (+)
#@gmic : Map specified vector-valued palette to selected indexed scalar images.
#@gmic : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --luminance -map. 3
#@gmic : $ image.jpg --rgb2ycbcr -split. c (0,255,0) -resize. 256,1,1,1,3 -map[-4] [-1] -remove. -append[-3--1] c -ycbcr2rgb.
#@gmic : $$
#@gmic map_clut : [clut]
#@gmic : Map specified RGB color LUT to selected images.
#@gmic : $ image.jpg -uniform_distribution {2^6},3 -mirror. x --map_clut[0] [1]
map_clut : -check ${-is_image_arg\ $1}
-e[^-1] "Map color LUT $1 on image$?."
-v -
-if {!$!} -v + -return -endif
-to_color
-pass$1 0 -to_rgb.
l={round((w*h*d)^(1/3))}
-if {w*h*d!=$l^3} -v + -error "Command '-map_clut': Specified Hald-CLUT $1 has invalid dimensions "({w},{h},{d},{s}). -endif
-r. $l,$l,$l,3,-1
-repeat {$!-1} -l[$>,-1] -split_opacity[0] -/[0] {256/$l}
--warp. [0],0,1,1
-rm[0] -mv. 0 -a[^-1] c
-endl -done -rm. -v +
#@gmic mix_channels : (a00,...,aMN)
#@gmic : Apply specified matrix to channels of selected images.
#@gmic : $ image.jpg --mix_channels (0,1,0;1,0,0;0,0,1)
mix_channels :
-e[^-1] "Apply matrix $1 to channels of image$?."
-v - -repeat $! -l[$>] nm={0,n}
whd={w},{h},{d} -r {w*h*d},{s},1,1,-1 -i[0] ${^0} -** -r $whd,{h},-1
-nm $nm -endl -done -v +
#@gmic negative
#@gmic : Compute negative of selected images.
#@gmic : $ image.jpg --negative
negative :
-e[^-1] "Compute negative of image$?."
-v - -repeat $! -l[$>] -- {iM} -endl -done -* -1 -v +
#@gmic noise : std_variation>=0[%],_noise_type : (+)
#@gmic : Add random noise to selected images.
#@gmic : 'noise_type' can be { 0=gaussian | 1=uniform | 2=salt&pepper | 3=poisson | 4=rice }.
#@gmic : Default value: 'noise_type=0'.
#@gmic : $ image.jpg --noise[0] 50,0 --noise[0] 50,1 --noise[0] 10,2 -cut 0,255
#@gmic : $ 300,300,1,3 [0] -noise[0] 20,0 -noise[1] 20,1 --histogram 100 -display_graph[-2,-1] 400,300,3
#@gmic normlp : p>=0
#@gmic : Compute the pointwise Lp-norm norm of vector-valued pixels in selected images.
#@gmic : Default value: 'p=2'.
#@gmic : $ image.jpg --normlp[0] 0 --normlp[0] 1 --normlp[0] 2 --normlp[0] inf
normlp : -check "isval(${1==2}) && $1>=0"
-e[^-1] "Compute pointwise L"$1"-norm of vectors, in image$?."
-v -
-if {$1==0} -neq 0 -compose_channels +
-elif {$1==1} -abs -compose_channels +
-elif {$1==2} -norm
-elif {$1==inf} -abs -compose_channels max
-else -pow $1 -compose_channels + -pow {1/$1}
-endif
-v +
#@gmic norm
#@gmic : Compute the pointwise euclidean norm of vector-valued pixels in selected images.
#@gmic : $ image.jpg --norm
#@gmic : $$
norm :
-e[^-1] "Compute pointwise euclidean norm of vectors, in image$?."
-v - -sqr -compose_channels + -sqrt -v +
#@gmic n : eq. to '-normalize'. : (+)
#@gmic normalize : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (+)
#@gmic : Linearly normalize values of selected images in specified range.
#@gmic : (eq. to '-n').
#@gmic : $ image.jpg -split x,2 -normalize. 64,196 -append x
#@gmic : $$
#@gmic normalize_sum
#@gmic : Normalize selected images with a unitary sum.
#@gmic : $ image.jpg --histogram. -normalize_sum. -display_graph. 400,300
normalize_sum :
-e[^-1] "Normalize image$? with a unitary sum."
-v - -repeat $! -/[$>] {sum={$>,is};if(sum!=0,sum,1)} -done -v +
#@gmic not
#@gmic : Apply boolean not operation on selected images.
#@gmic : $ image.jpg --ge 50% --not.
not :
-e[^-1] "Apply boolean not operation on image$?."
-v - -== 0 -v +
#@gmic orientation
#@gmic : Compute the pointwise orientation of vector-valued pixels in selected images.
#@gmic : $ image.jpg --orientation --norm.. -negative. -mul.. [-1] -reverse[-2,-1]
#@gmic : $$
orientation :
-e[^-1] "Compute pointwise orientation vectors, in image$?."
-v - -repeat $! --norm[$>] -replace. 0,1 -/[$>,-1] -done -v +
#@gmic oneminus
#@gmic : For each selected image, compute one minus image.
#@gmic : $ image.jpg -n 0,1 --oneminus
oneminus :
-e[^-1] "Compute one minus selected images$?."
-v + -* -1 -+ 1 -v -
#@gmic otsu : _nb_levels>0
#@gmic : Hard-threshold selected images using Otsu's method.
#@gmic : The computed thresholds are returned as a list of values in the status.
#@gmic : Default value: 'nb_levels=256'.
#@gmic : $ image.jpg -luminance --otsu ,
otsu : -check "isint(${1=256}) && $1>0"
-e[^-1] "Hard-threshold image$? using Otsu\47s method, with $1 histogram levels."
-v - -repeat $! -l[$>]
im={im} iM={iM} -n 0,{$1-1}
--histogram $1 total={is}
--*. 'x' sum={is} -rm.
sumB=0 wB=0 wF=0 varMax=0 threshold=0
-repeat $1
wB+={@$>}
-if {$wB==0} -continue -endif
wF={$total-$wB}
-if {$wF==0} -break -endif
sumB+={$>*{@$>}}
mB={$sumB/$wB}
mF={($sum-$sumB)/$wF}
varBetween={$wB*$wF*($mB-$mF)^2}
-if {$varBetween>$varMax} varMax=$varBetween threshold=$> -endif
-done
-rm. ->=. $threshold
threshold={$im+$threshold*($iM-$im)/($1-1)}
-if $> -u ${},$threshold -else -u $threshold -endif
-endl -done -v +
#@gmic polar2complex
#@gmic : Compute polar to complex transforms of selected images.
polar2complex :
-e[^-1] "Compute polar to complex transforms of image$?."
-v - -repeat {int($!/2)} -l[{2*$>},{2*$>+1}]
-r[1] [0],3 --sin. -cos.. -*. [-3] -*[-3,-2]
-endl -done -v +
#@gmic quantize : nb_levels>=1,_keep_values={ 0 | 1 },_is_uniform={ 0 | 1 }
#@gmic : Quantize selected images.
#@gmic : Default value: 'keep_values=1' and 'is_uniform=0'.
#@gmic : $ image.jpg -luminance --quantize 3
#@gmic : $ 200,200,1,1,'cos(x/10)*sin(y/10)' --quantize[0] 6 --quantize[0] 4 --quantize[0] 3 --quantize[0] 2
quantize : -check "isint($1) && $1>=1" -skip ${2=1},${3=0}
-e[^-1] "Quantize image$? using $1 levels, "${-arg\ 1+!$2,with,without}" keeping value range."
-v - -repeat $! -l[$>]
-if $3
-if {s==1}
-if $2 mM={im},{iM} -n 0,$1 -round 1,-1 -min {$1-1} -n $mM
-else -n 0,$1 -round 1,-1 -min {$1-1} -endif
-else mM={im},{iM} -uniform_distribution $1,{s} -n. $mM -index.. [-1],0,$2 -rm.
-endif
-else --colormap $1,1,1 -index.. [-1],0,$2 -rm.
-endif
-endl -done -v +
#@gmic rand : { value0[%] | [image0] },_{ value1[%] | [image1] } : [image] : (+)
#@gmic : Fill selected images with random values uniformly distributed in the specified range.
#@gmic : $ 400,400,1,3 -rand -10,10 --blur 10 -sign.
#@gmic replace : value_src,value_dest
#@gmic : Replace pixel values in selected images.
#@gmic : $ (1;2;3;4) --replace 2,3
replace :
-e[^-1] "Replace pixel values $1 with $2 in image$?."
-v - -repeat $! -l[$>] --== $1 -*. {$2-$1} -+ -endl -done -v +
#@gmic replace_inf : _expression
#@gmic : Replace all infinite values in selected images by specified expression.
#@gmic : $ (0;1;2) -log --replace_inf 2
replace_inf :
-e[^-1] "Replace all infinite values in image$? by expression '$1'."
-v - -f "if(i==i+1,$1,i)" -v +
#@gmic replace_nan : _expression
#@gmic : Replace all NaN values in selected images by specified expression.
#@gmic : $ (-1;0;2) -sqrt --replace_nan 2
replace_nan :
-e[^-1] "Replace all NaN values in images$? by expression '$1'."
-v - -f "if(i>=0 || i<=0,i,$1)" -v +
#@gmic replace_seq : "search_seq","replace_seq"
#@gmic : Search and replace a sequence of values in selected images.
#@gmic : $ (1;2;3;4;5) --replace_seq "2,3,4","7,8"
replace_seq : -skip "${2=}"
-e[^-1] "Replace value sequence '$1' by value sequence '${2--1}' in image$?."
-v - ns={narg($1)} nd={narg(${2--1})} ratio={$nd*100/$ns}
-repeat $! -l[$>] -if {w}
-s +,$1 --rows[0] 0,{$ns-1} ($1) --[-2,-1] -abs. ind={iM!=0} -rm.
-if {$ind<$!} -if $nd -r[$ind--1:2] 1,$ratio%,1,1,0 -f[$ind--1:2] ${2--1} -else -rm[$ind--1:2] -endif -a y -endif
-endif -endl -done -v +
#@gmic replace_str : "search_str","replace_str"
#@gmic : Search and replace a string in selected images (viewed as strings, i.e. sequences of ascii codes).
#@gmic : $ ({'"Hello there, how are you ?"'}) --replace_str "Hello there","Hi David"
replace_str : -skip "${2=}"
-e[^-1] "Replace string '$1' by string '${2--1}' in image$? (viewed as string$?)."
-v -
-replace_seq {``{'"$1"'}},{'"${2--1}"'}
-v +
#@gmic round : rounding_value>=0,_rounding_type : (no arg) : (+)
#@gmic : Round values of selected images.
#@gmic : 'rounding_type' can be { -1=backward | 0=nearest | 1=forward }.
#@gmic : Default value: 'rounding_type=0'.
#@gmic : $ image.jpg --round 100
#@gmic : $ image.jpg -mul {pi/180} -sin --round
#@gmic roundify : gamma>=0
#@gmic : Apply roundify transformation on float-valued data, with specified gamma.
#@gmic : Default value: 'gamma=0'.
#@gmic : $ 1000 -fill '4*x/w' -repeat 5 --roundify[0] {$>*0.2} -done -append c -display_graph 400,300
roundify : -check $1>=0
-e[^-1] "Roundify image$?, with gamma $1."
-if {$1==1} -return -endif
-v - -repeat $! -l[$>]
--round 1 --.. [-1] --*.. 2 -abs. -^. $1 -sign... -*[-3,-1] -*.. 0.5 -+
-endl -done -v +
#@gmic = : eq. to '-set'. : (+)
#@gmic set : value,_x[%],_y[%],_z[%],_c[%] : (+)
#@gmic : Set pixel value in selected images, at specified coordinates.
#@gmic : (eq. to '-=').
#@gmic : If specified coordinates are outside the image bounds, no action is performed.
#@gmic : Default values: 'x=y=z=c=0'.
#@gmic : $ 2,2 -set 1,0,0 -set 2,1,0 -set 3,0,1 -set 4,1,1
#@gmic : $ image.jpg -repeat 10000 -set 255,{u(100)}%,{u(100)}%,0,{u(100)}% -done
#@gmic threshold : value[%],_is_soft={ 0 | 1 } : (no arg) : (+)
#@gmic : Threshold values of selected images.
#@gmic : 'soft' can be { 0=hard-thresholding | 1=soft-thresholding }.
#@gmic : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@gmic : In this case, the chosen threshold value is returned in the status.
#@gmic : Default value: 'is_soft=0'.
#@gmic : $ image.jpg --threshold[0] 50% --threshold[0] 50%,1
#@gmic : $$
#@gmic unrepeat
#@gmic : Remove repetition of adjacent values in selected images.
#@gmic : $ (1;1;1;1;1;2;2;2;3;4;4;4;5;5;5) --unrepeat
unrepeat :
-e[^-1] "Remove repetition of adjacent values in image$?."
-v - -repeat $! -l[$>] nm={0,n}
-y x ({{0,@-1}+1}) -a x -r 100%,2
-f. '>if(y==0,i,if(i(x,0)==i(x+1,0),-1,x))'
-z 0,{w-2} -s y,2 -discard[1] -1 -map[1] [0]
-rm[0] -nm $nm
-endl -done -v +
#@gmic vector2tensor
#@gmic : Convert selected vector fields to corresponding tensor fields.
vector2tensor :
-e[^-1] "Convert vector field$? to tensor field$?."
-v - -repeat $! -l[$>]
-s c
-if {$!==2} --sqr. -*.. [-3] -sqr...
-elif {$!==3} --sqr.. --*... [-2] --sqr... -*[-5,-4] [-6] -sqr[-6]
-else -v + -error[0--4] "Command '-vector2tensor': Invalid image ["{$!-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2d or 3d vectors."
-endif
-a c
-endl -done -v +
#@gmic :: Colors manipulation
#@gmic ac : eq. to '-apply_channels'.
ac :
-v - _gmic_s="$?" -v +
-_apply_channels $"*"
#@gmic apply_channels : "command",channels,_value_action={ 0=none | 1=cut | 2=normalize }
#@gmic : Apply specified command on the chosen color channel(s) of each selected images.
#@gmic : (eq. to '-ac').
#@gmic : Argument 'channels' refers to a colorspace, and can be basically one of { all | rgba | rgb | lrgb | ycbcr | lab | lch | hsv | hsi | hsl | cmy | cmyk | yiq }.
#@gmic : You can also focus the processing on one particular channel of this colorspace, by setting 'channels' as 'colorspace_channel' (e.g. 'hsv_h' for the hue).
#@gmic : All channel values are considered to be in the [0,255] range.
#@gmic : Default value: 'value_action=0'.
#@gmic : $ image.jpg --apply_channels "-equalize -blur 2",ycbcr_cbcr
apply_channels :
-v - _gmic_s="$?" -v +
-_$0 $"*"
_apply_channels : -check "isint(${3=0}) && $3>=0 && $3<=2"
-v -
-if {isval("$2")} -if {isint("$2")}
mode=${-arg\ 1+$2,all,rgba,rgb,rgb_r,rgb_g,rgb_b,rgba_a,\
lrgb,lrgb_r,lrgb_g,lrgb_b,\
ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
lab_l,lab_ab,lab_a,lab_b,\
lch_ch,lch_c,lch_h,\
hsv_h,hsv_s,hsv_v,hsi_i,hsl_l,\
cmyk_c,cmyk_m,cmyk_y,cmyk_k,\
yiq_y,yiq_iq}
-else mode="$2" -endif -else mode="$2" -endif
-v + -e[^-1] "Apply command '$1' on channel '"$mode"' of image"$_gmic_s"." -v -
-_ac_$mode -m "_ac_precond : "$_p -m "_ac_forward : "$_f -m "_ac_backward : "$_b
-repeat $! -l[$>]
-_ac_precond is_alpha={s==2" || "s==4}
-if $is_alpha -s c,{1-s} -endif
-_ac_forward[0] -a c
-sh $_s -_ac. "$1"
-if {$3==1} -c. 0,255 -elif {$3==2} -n. 0,255 -endif
-rm.
-if $is_alpha -s c,{1-s} -endif
-_ac_backward[0] -a c
-endl -done
-uncommand "_ac_precond" -uncommand "_ac_forward" -uncommand "_ac_backward"
-v +
_ac :
whs={w},{h},1,{s} ${1--1} -k[0] -r $whs,0
_ac_all : _p="" _f="" _b="" _s=0,100%
_ac_rgba : _p="-to_rgba" _f="" _b="" _s=0,3
_ac_rgba_r : _p="-to_color" _f="" _b="" _s=0
_ac_rgba_g : _p="-to_color" _f="" _b="" _s=1
_ac_rgba_b : _p="-to_color" _f="" _b="" _s=2
_ac_rgba_a : _p="-to_rgba" _f="" _b="" _s=3
_ac_rgb : _p="-to_color" _f="" _b="" _s=0,2
_ac_rgb_r : -_ac_rgba_r
_ac_rgb_g : -_ac_rgba_g
_ac_rgb_b : -_ac_rgba_b
_ac_lrgb : _p="-to_color" _f="-srgb2rgb" _b="-rgb2srgb" _s=0,2
_ac_lrgb_r : _p="-to_color" _f="-srgb2rgb" _b="-rgb2srgb" _s=0
_ac_lrgb_g : _p="-to_color" _f="-srgb2rgb" _b="-rgb2srgb" _s=1
_ac_lrgb_b : _p="-to_color" _f="-srgb2rgb" _b="-rgb2srgb" _s=2
_ac_ycbcr : _p="-to_color" _f="-rgb2ycbcr" _b="-ycbcr2rgb" _s=0,2
_ac_ycbcr_y : _p="-to_color" _f="-rgb2ycbcr" _b="-ycbcr2rgb" _s=0
_ac_ycbcr_cbcr : _p="-to_color" _f="-rgb2ycbcr" _b="-ycbcr2rgb" _s=1,2
_ac_ycbcr_cb : _p="-to_color" _f="-rgb2ycbcr" _b="-ycbcr2rgb" _s=1
_ac_ycbcr_cr : _p="-to_color" _f="-rgb2ycbcr" _b="-ycbcr2rgb" _s=2
_ac_ycbcr_cg : _p="-to_color" _f="-sh 0,1 -mirror. c -rm. -rgb2ycbcr" _b="-ycbcr2rgb -sh 0,1 -mirror. c -rm." _s=2
_ac_lab : _p="-to_color" _f="-srgb2rgb -rgb2lab8" _b="-lab82rgb -rgb2srgb" _s=0,2
_ac_lab_l : _p="-to_color" _f="-srgb2rgb -rgb2lab8" _b="-lab82rgb -rgb2srgb" _s=0
_ac_lab_ab : _p="-to_color" _f="-srgb2rgb -rgb2lab8" _b="-lab82rgb -rgb2srgb" _s=1,2
_ac_lab_a : _p="-to_color" _f="-srgb2rgb -rgb2lab8" _b="-lab82rgb -rgb2srgb" _s=1
_ac_lab_b : _p="-to_color" _f="-srgb2rgb -rgb2lab8" _b="-lab82rgb -rgb2srgb" _s=2
_ac_lch : _p="-to_color" _f="-srgb2rgb -rgb2lch8" _b="-lch82rgb -rgb2srgb" _s=0,2
_ac_lch_l : -_ac_lab_l
_ac_lch_ch : _p="-to_color" _f="-srgb2rgb -rgb2lch8" _b="-lch82rgb -rgb2srgb" _s=1,2
_ac_lch_c : _p="-to_color" _f="-srgb2rgb -rgb2lch8" _b="-lch82rgb -rgb2srgb" _s=1
_ac_lch_h : _p="-to_color" _f="-srgb2rgb -rgb2lch8" _b="-lch82rgb -rgb2srgb" _s=2
_ac_hsv : _p="-to_color" _f="-rgb2hsv8" _b="-hsv82rgb" _s=0,2
_ac_hsv_h : _p="-to_color" _f="-rgb2hsv8" _b="-hsv82rgb" _s=0
_ac_hsv_s : _p="-to_color" _f="-rgb2hsv8" _b="-hsv82rgb" _s=1
_ac_hsv_v : _p="-to_color" _f="-rgb2hsv8" _b="-hsv82rgb" _s=2
_ac_hsi : _p="-to_color" _f="-rgb2hsi8" _b="-hsi82rgb" _s=0,2
_ac_hsi_h : _p="-to_color" _f="-rgb2hsi8" _b="-hsi82rgb" _s=0
_ac_hsi_s : _p="-to_color" _f="-rgb2hsi8" _b="-hsi82rgb" _s=1
_ac_hsi_i : _p="-to_color" _f="-rgb2hsi8" _b="-hsi82rgb" _s=2
_ac_hsl : _p="-to_color" _f="-rgb2hsl8" _b="-hsl82rgb" _s=0,2
_ac_hsl_h : _p="-to_color" _f="-rgb2hsl8" _b="-hsl82rgb" _s=0
_ac_hsl_s : _p="-to_color" _f="-rgb2hsl8" _b="-hsl82rgb" _s=1
_ac_hsl_l : _p="-to_color" _f="-rgb2hsl8" _b="-hsl82rgb" _s=2
_ac_cmy : _p="-to_color" _f="-rgb2cmy" _b="-cmy2rgb" _s=0,2
_ac_cmy_c : _p="-to_color" _f="-rgb2cmy" _b="-cmy2rgb" _s=0
_ac_cmy_m : _p="-to_color" _f="-rgb2cmy" _b="-cmy2rgb" _s=1
_ac_cmy_y : _p="-to_color" _f="-rgb2cmy" _b="-cmy2rgb" _s=2
_ac_cmyk : _p="-to_color" _f="-rgb2cmyk" _b="-cmyk2rgb" _s=0,3
_ac_cmyk_c : _p="-to_color" _f="-rgb2cmyk" _b="-cmyk2rgb" _s=0
_ac_cmyk_m : _p="-to_color" _f="-rgb2cmyk" _b="-cmyk2rgb" _s=1
_ac_cmyk_y : _p="-to_color" _f="-rgb2cmyk" _b="-cmyk2rgb" _s=2
_ac_cmyk_k : _p="-to_color" _f="-rgb2cmyk" _b="-cmyk2rgb" _s=3
_ac_yiq : _p="-to_color" _f="-rgb2yiq8" _b="-yiq82rgb" _s=0,2
_ac_yiq_y : _p="-to_color" _f="-rgb2yiq8" _b="-yiq82rgb" _s=0
_ac_yiq_iq : _p="-to_color" _f="-rgb2yiq8" _b="-yiq82rgb" _s=1,2
_ac_yiq_i : _p="-to_color" _f="-rgb2yiq8" _b="-yiq82rgb" _s=1
_ac_yiq_q : _p="-to_color" _f="-rgb2yiq8" _b="-yiq82rgb" _s=2
#@gmic autoindex : nb_colors>0,0<=_dithering<=1,_method={ 0=median-cut | 1=k-means }
#@gmic : Index selected vector-valued images by adapted colormaps.
#@gmic : Default values: 'dithering=0' and 'method=1'.
#@gmic : $ image.jpg --autoindex[0] 4 --autoindex[0] 8 --autoindex[0] 16
autoindex : -check "isint($1) && $1>0 && ${2=0}>=0" -skip ${3=1}
-e[^-1] "Index colors in images$? by adapted colormap with $1 entries, dithering level $2 and "\
${-arg\ 1+!$3,k-means,median-cut}" method."
-v - -repeat $! -l[$>]
-if {w>h} -if {w>256} --r2dx 256 -else [0] -endif
-else -if {h>256} --r2dy 256 -else [0] -endif
-endif
-colormap[1] $1,$3,0
-index[0] [1],$2,1 -rm[1]
-endl -done -v +
#@gmic bayer2rgb : _GM_smoothness,_RB_smoothness1,_RB_smoothness2
#@gmic : Transform selected RGB-Bayer sampled images to color images.
#@gmic : Default values: 'GM_smoothness=RB_smoothness=1' and 'RB_smoothness2=0.5'.
#@gmic : $ image.jpg -rgb2bayer 0 --bayer2rgb 1,1,0.5
bayer2rgb : -skip ${1=1},${2=1},${3=0.5}
-e[^-1] "Transform RGB-Bayer image$? to color images, with smoothness ($1,$2,$3)."
-v - -channels 0 -repeat $! -l[$>]
-expand_x {"2 + 4*$1"},0 -expand_y {"2 + 4*$1"},0
(-1,1;1,-1) -r. [-2],[-2],1,1,0,2
--*.. [-1]
(0.25,0.5,0.25) -convolve.. [-1] -transpose. -convolve.. [-1] -rm.
-b. $1
-*.. [-1]
--[-3,-2]
(1,-1) -r. [-2],[-2],1,1,0,2
-*. [-3]
(0.25,0.5,0.25) -convolve.. [-1] -transpose. -convolve.. [-1] -rm.
-blur_y. $2 -blur_x. $3
(1;-1) -r. [-2],[-2],1,1,0,2
-*. [-4]
(0.25,0.5,0.25) -convolve.. [-1] -transpose. -convolve.. [-1] -rm.
-blur_x. $2 -blur_y. $3
-+[-2,-1] -/. 2
(2,0;0,-2) -r. [-2],[-2],1,1,0,2
-*. [-2]
--[-4,-1]
-a[-3--1] c
-mix_rgb. 1,-1,2,1,1,0,1,-1,-2
-shrink_x {"2 + 4*$1"},0 -shrink_y {"2 + 4*$1"},0
-c 0,255
-endl -done -v +
#@gmic cmy2rgb
#@gmic : Convert selected images from CMY to RGB colorbases.
cmy2rgb :
-e[^-1] "Convert image$? from CMY to RGB color bases."
-v - -rgb2cmy -v +
#@gmic cmyk2rgb
#@gmic : Convert selected images from CMYK to RGB colorbases.
cmyk2rgb :
-e[^-1] "Convert image$? from CMYK to RGB color bases."
-v - -repeat $! -l[$>]
-s c --/. -255 -+. 1 -*[0-2] [-1] -rm. -+[0-2] [-1] -rm.
-a c -cmy2rgb
-endl -done -v +
#@gmic colorblind : type={ 0=protanopia | 1=protanomaly | 2=deuteranopia | 3=deuteranomaly | 4=tritanopia | 5=tritanomaly | 6=achromatopsia | 7=achromatomaly }
#@gmic : Simulate color blindness vision.
#@gmic : $ image.jpg --colorblind 0
colorblind : -check "isint($1) && $1>=0 && $1<=7"
-v - s0="protanopia" s1="protanomaly" s2="deuteranopia" s3="deuteranomaly" s4="tritanopia" s5="tritanomaly" s6="achromatopsia" s7="achromatomaly" -v +
-v + -e[^-1] "Simulate color blindness of type '"${s$1}"' on image$?." -v -
type0=(0.567,0.433,0;0.558,0.442,0;0,0.242,0.758)
type1=(0.817,0.183,0;0.333,0.667,0;0,0.125,0.875)
type2=(0.625,0.375,0;0.7,0.3,0;0,0.3,0.7)
type3=(0.8,0.2,0;0.258,0.742,0;0,0.142,0.858)
type4=(0.95,0.05,0;0,0.433,0.567;0,0.475,0.525)
type5=(0.967,0.033,0;0,0.733,0.267;0,0.183,0.817)
type6=(0.299,0.587,0.114;0.299,0.587,0.114;0.299,0.587,0.114)
type7=(0.618,0.320,0.062;0.163,0.775,0.062;0.163,0.320,0.516)
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb -mix_channels ${type$1} -endl -a c -endl -done
-v +
#@gmic colormap : nb_levels>=0,_method={ 0=median-cut | 1=k-means },_sort_vectors={ 0 | 1 }
#@gmic : Estimate best-fitting colormap with 'nb_colors' entries, to index selected images.
#@gmic : Set 'nb_levels==0' to extract all existing colors of an image.
#@gmic : Default value: 'method=1' and 'sort_vectors=1'.
#@gmic : $ image.jpg --colormap[0] 4 --colormap[0] 8 --colormap[0] 16
#@gmic : $$
colormap : -check "isint($1) && $1>=0" -skip ${2=1},${3=1}
-if $1
-e[0--3] "Estimate colormap with $1 entries for image$?, by "${-arg\ 1+!$2,k-means,median-cut}" method."
-else
-e[0--3] "Estimate full colormap for image$?."
-endif
-v - -repeat $! -l[$>]
-if $1
-r {w*h},1,1,100%,-1
-if {!$2} -_colormap $1
-else
m={im} M={iM} -n. 0,255
--_colormap $1 --index.. [-1] -*. 256 -+[-3,-1]
-do
-repeat {s}
-sh[0] $> --histogram. {$1*256},0,{$1*256-1} -rm..
-i.. 256,1,1,1,'x' -r.. {w},1,1,1,0,2 -*.. [-1] -r[-2,-1] $1,1,1,1,2 -max. 0.01 -/[-2,-1]
-done -a[2--1] c
--.. [-1] -abs.. diff={{-2,is}/w} -rm..
-&.. 255 --index.. [-1],0,0 -*. 256 -+[-3,-1]
-while {$diff>0.5}
-rm.. -*. {($M-$m)/255} -+. $m
-endif
-else
-r {w*h*d},1,1,100%,-1
-repeat {s} -ap "-sort +,x" -s x,0 -ap "-shift 0,0,0,1,2" -done
-ap "-discard x" -a x
-endif
-if $3 --norm -rv -a y -sort +,x -rows 1 -endif
-nm "[colormap of "{b}"]"
-endl -done -v +
_colormap :
-repeat {$1-1}
$!,{s} -repeat {$!-1}
n=$> -repeat {$n,s} -sh[$n] $> -=.. {if(w>1,iv,-1)},$n,$> -rm. -done
-done
c={[xM,yM]}
b=${-arg\ 1,$c}
a=${-arg\ 2,$c}
-rm. -shift[$b] 0,0,0,{-$a},2 -sort[$b] +,x -shift[$b] 0,0,0,$a,2 -s[$b] x,2
-done
-r 1,1,1,100%,2 -a x
#@gmic compose_channels
#@gmic : Compose all channels of each selected image, using specified arithmetic operator (+,-,or,min,...).
#@gmic : Default value: '1=+'.
#@gmic : $ image.jpg --compose_channels and
#@gmic : $$
compose_channels : -skip ${1="+"}
-e[^-1] "Compose all channels of image$?, with operator '$1'."
-v - -repeat $! -l[$>]
-sh 0
-repeat {{-2,s}-1} -sh.. {$>+1} -l[-2,-1] -$1 -endl -done
-rm. -r 100%,100%,100%,1,-1
-endl -done -v +
#@gmic direction2rgb
#@gmic : Compute RGB representation of selected 2d direction fields.
#@gmic : $ image.jpg -luminance -gradient -append c -blur 2 -orientation --direction2rgb
direction2rgb :
-e[^-1] "Compute RGB representation of 2d direction field$?."
-v - -channels 0,1 -repeat $! -l[$>] nm={0,n}
-s c -complex2polar -round.. 0.001
-*. {180/pi} -%. 360 100%,100%,1,1,1 -mv... $!
-if {im!=iM} -n. 0,1 -else -f. 1 -endif
-a c -hsv2rgb
-nm $nm -endl -done -v +
#@gmic ditheredbw
#@gmic : Create dithered B&W version of selected images.
#@gmic : $ image.jpg --equalize -ditheredbw.
ditheredbw :
-e[^-1] "Create dithered B&W version of image$?."
-v - -repeat $! -l[$>] -split_opacity
-luminance[0] -n[0] 0,255 (0,255) -index[0] [-1],1,1 -rm.
-a c -endl -done -v +
#@gmic fc : eq. to '-fill_color'.
fc :
-v - _gmic_s="$?" -v +
-_fill_color $*
#@gmic fill_color : col1,...,colN
#@gmic : Fill selected images with specified color.
#@gmic : (eq. to '-fc').
#@gmic : $ image.jpg --fill_color 255,0,255
fill_color :
-v - _gmic_s="$?" -v +
-_$0 $*
_fill_color :
-e[0--3] "Fill image"$_gmic_s" with color (${^0})."
-v - -repeat $! -l[$>]
-repeat {s} -sh[0] $> -f. {arg(1+$>,${^0})} -done -k[0]
-nm {n} -endl -done -v +
#@gmic gradient2rgb : _is_orientation={ 0 | 1 }
#@gmic : Compute RGB representation of 2d gradient of selected images.
#@gmic : Default value: 'is_orientation=0'.
#@gmic : $ image.jpg --gradient2rgb 0 -equalize.
gradient2rgb : -check "isbool(${1=0})"
-arg 1+!$1,"orientation ",""
-e[^-1] "Compute RGB representation of 2d gradient "${}"of image$?."
-v - -norm -repeat $! -l[$>]
-if $1 -gradient_orientation 2 -else -g xy -endif
-a c -direction2rgb
-endl -done -v +
#@gmic hsi2rgb : (+)
#@gmic : Convert selected images from HSI to RGB colorbases.
#@gmic hsi82rgb
#@gmic : Convert selected images from HSI8 to RGB color bases.
hsi82rgb :
-e[^-1] "Convert image$? from HSI8 to RGB color bases."
-v - -_hsx82rgb -hsi2rgb -v +
#@gmic hsl2rgb : (+)
#@gmic : Convert selected images from HSL to RGB colorbases.
#@gmic hsl82rgb
#@gmic : Convert selected images from HSL8 to RGB color bases.
hsl82rgb :
-e[^-1] "Convert image$? from HSL8 to RGB color bases."
-v - -_hsx82rgb -hsl2rgb -v +
#@gmic hsv2rgb : (+)
#@gmic : Convert selected images from HSV to RGB colorbases.
#@gmic : $ (0,360;0,360^0,0;1,1^1,1;1,1) -resize 400,400,1,3,3 -hsv2rgb
#@gmic hsv82rgb
#@gmic : Convert selected images from HSV8 to RGB color bases.
hsv82rgb :
-e[^-1] "Convert image$? from HSV8 to RGB color bases."
-v - -_hsx82rgb -hsv2rgb -v +
_hsx82rgb :
-repeat $!
-sh[$>] 0 -/. 0.708333 -rm.
-sh[$>] 1,2 -/. 255 -rm.
-done
#@gmic int2rgb
#@gmic : Convert selected images from INT24 scalars to RGB.
int2rgb :
-e[^-1] "Convert image$? from INT24 scalars to RGB."
-v - -round -repeat $! -l[$>]
-->> 8 -&[1] 255 --&[0] 255 ->>[0] 16 -a c
-endl -done -v +
#@gmic lab2lch
#@gmic : Convert selected images from Lab to Lch color bases.
lab2lch :
-e[^-1] "Convert image$? from Lab to Lch color bases."
-v - -r 100%,100%,100%,3 -repeat $! -l[$>]
-s c -complex2polar[-2,-1] -a c
-endl -done -v +
#@gmic lab2rgb : (+)
#@gmic : Convert selected images from Lab to RGB colorbases.
#@gmic : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) -resize 400,400,1,3,3 -lab2rgb
#@gmic lab82rgb
#@gmic : Convert selected images from Lab8 to RGB color bases.
lab82rgb :
-e[^-1] "Convert image$? from Lab8 to RGB color bases."
-v - -repeat $!
-sh[$>] 0 -/. 2.55 -rm.
-sh[$>] 1 -/. 1.275 --. 100 -rm.
-sh[$>] 2 -/. 1.15909 --. 110 -rm.
-done -lab2rgb -v +
#@gmic lch2lab
#@gmic : Convert selected images from Lch to Lab color bases.
lch2lab :
-e[^-1] "Convert image$? from Lch to Lab color bases."
-v - -r 100%,100%,100%,3 -repeat $! -l[$>]
-s c -polar2complex[-2,-1] -a c
-endl -done -v +
#@gmic lch2rgb
#@gmic : Convert selected images from Lch to RGB color bases.
lch2rgb :
-e[^-1] "Convert image$? from Lch to RGB color bases."
-v - -lch2lab -lab2rgb -v +
#@gmic lch82rgb
#@gmic : Convert selected images from Lch8 to RGB color bases.
lch82rgb :
-e[^-1] "Convert image$? from Lch8 to RGB color bases."
-v - -repeat $!
-sh[$>] 0 -/. 2.55 -rm.
-sh[$>] 1 -/. 1.88889 -rm.
-sh[$>] 2 -/. 40.5845 --. 3.14159 -rm.
-done -lch2rgb -v +
#@gmic luminance
#@gmic : Compute luminance of selected sRGB images.
#@gmic : $ image.jpg --luminance
luminance :
-e[^-1] "Compute luminance of image$?."
-v - -remove_opacity -srgb2rgb
-repeat $! -l[$>]
-if {s==3} -sh 0 -sh[0] 1 -sh[0] 2 -*[1] 0.299 -*[2] 0.587 -*[3] 0.114 -+[1-3] -rm[1]
-elif {s!=1} -norm -n 0,255
-endif -endl -done
-channels 0 -rgb2srgb -v +
#@gmic mix_rgb : a11,a12,a13,a21,a22,a23,a31,a32,a33
#@gmic : Apply 3x3 specified matrix to RGB colors of selected images.
#@gmic : Default values: 'a11=1', 'a12=a13=a21=0', 'a22=1', 'a23=a31=a32=0' and 'a33=1'.
#@gmic : $ image.jpg --mix_rgb 0,1,0,1,0,0,0,0,1
#@gmic : $$
mix_rgb : -skip ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
-e[^-1] "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
-v - -r 100%,100%,100%,3,0,2 -mix_channels ($1,$2,$3;$4,$5,$6;$7,$8,$9) -v +
#@gmic pseudogray : _max_increment>=0,_JND_threshold>=0,_bits_depth>0
#@gmic : Generate pseudogray colormap with specified increment and perceptual threshold.
#@gmic : If 'JND_threshold' is 0, no perceptual constraints are applied.
#@gmic : Default values: 'max_increment=5', 'JND_threshold=2.3' and 'bits_depth=8'.
#@gmic : $ -pseudogray 5
pseudogray : -check "isint(${1=5}) && $1>=0 && ${2=2.3}>=0 && isint(${3=8}) && $3>0"
-e[^-1] "Generate pseudogray colormap with increment $1, JND threshold $2 and $3 bits depth."
-v -
{round(2^$3)},1,1,3,'x'
-if {!$1} -n. 0,255 -v + -return -endif
{$1+1},{$1+1},{$1+1},1,'x' --f. 'y' --f. 'z' -a[-3--1] c -r. {w*h*d},1,1,3,-1
-f. 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(min(R,G,B),-1,i)'
-permute. cxyz -discard. -1 -r. 3,{h/3},1,1,-1 -permute. yzcx
-r.. {w*100}% -r. [-2],0,2 -+[-2,-1]
-f. 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(max(R,G,B)>2^$3-1,-1,i)'
-permute. cxyz -discard. -1 -r. 3,{h/3},1,1,-1 -permute. yzcx
-n. 0,255
--srgb2rgb. -rgb2lab. -rv[-2,-1] -a[-2,-1] y -sort. +,x
-if {!$2} -rows. 1
-else
-s. y -rv[-2,-1] [-1] -sh. 1,2 -f. 0 -rm. --[-2,-1] -norm.
-<=. $2 -*. 'x+1' -discard. 0 --. 1 -map. [-2] -rm..
-repeat 10000
--srgb2rgb. -rgb2lab. --shift. 0,{1-2*($>%2)},0,0,1 --[-2,-1] -norm.
-<=. $2
-if {im} -rm. -break -endif
-*. 'y+1' -discard. 0 --. 1 -map. [-2] -rm..
-done
-transpose.
-endif
-v +
#@gmic replace_color : tolerance[%]>=0,smoothness[%]>=0,src1,src2,...,dest1,dest2,...
#@gmic : Replace pixels from/to specified colors in selected images.
#@gmic : $ image.jpg --replace_color 40,3,204,153,110,255,0,0
replace_color : -check "$1>=0 && $2>=0"
-v - -l[] (${3--1}) -y c -s c,2 col1={0,^} col2={1,^} -rm -endl -v +
-e[^-1] "Replace color ("$col1") by color ("$col2") in image$?, with tolerance $1 and smoothness $2."
-v - -repeat $! -l[$>]
1,1,1,100%,$col1 -r[1] [0]
-if $1 --[1] [0] -norm[1] -<=[1] $1 -else -==[1] [0] -l[1] -s c -& -endl -endif
-b[1] $2
1,1,1,{0,s},$col2 -r[2] [0] -j[0] [2],0,0,0,0,1,[1] -k[0]
-endl -done -v +
#@gmic rgb2bayer : _start_pattern=0,_color_grid=0
#@gmic : Transform selected color images to RGB-Bayer sampled images.
#@gmic : Default values: 'start_pattern=0' and 'color_grid=0'.
#@gmic : $ image.jpg --rgb2bayer 0
rgb2bayer : -skip ${1=0},${2=0}
-e[^-1] "Transform image$? to a RGB-Bayer "${-arg\ 1+!$2,color,monochrome}" grid, starting from pattern '$1'."
-v - -to_rgb -repeat $! -l[$>]
-_rgb2bayer$1 -r[1] [0],0,2 -* -if {!$2} -s c -+ -endif
-endl -done -v +
_rgb2bayer0 : (1,0;0,0^0,1;1,0^0,0;0,1)
_rgb2bayer1 : (0,0;0,1^0,1;1,0^1,0;0,0)
_rgb2bayer2 : (0,1;0,0^1,0;0,1^0,0;1,0)
_rgb2bayer3 : (0,0;1,0^1,0;0,1^0,1;0,0)
#@gmic rgb2cmy
#@gmic : Convert selected images from RGB to CMY colorbases.
#@gmic : $ image.jpg -rgb2cmy -split c
rgb2cmy :
-e[^-1] "Convert image$? from RGB to CMY color bases."
-v - -to_rgb -c 0,255 -* -1 -+ 255 -v +
#@gmic rgb2cmyk
#@gmic : Convert selected images from RGB to CMYK colorbases.
#@gmic : $ image.jpg -rgb2cmyk -split c
#@gmic : $ image.jpg -rgb2cmyk -split c -fill[3] 0 -append c -cmyk2rgb
rgb2cmyk :
-e[^-1] "Convert image$? from RGB to CMYK color bases."
-v - -rgb2cmy -repeat $! -l[$>]
-s c --min --[0-2] [-1] --/. 255 --. 1 -*. -1 --==. 0 -+[-2,-1]
-/[0-2] [-1] -rm. -a c
-endl -done -v +
#@gmic rgb2hsi : (+)
#@gmic : Convert selected images from RGB to HSI colorbases.
#@gmic : $ image.jpg -rgb2hsi -split c
#@gmic rgb2hsi8
#@gmic : Convert selected images from RGB to HSI8 color bases.
#@gmic : $ image.jpg -rgb2hsi8 -split c
rgb2hsi8 :
-e[^-1] "Convert image$? from RGB to HSI8 color bases."
-v - -rgb2hsi -_rgb2hsx8 -v +
#@gmic rgb2hsl : (+)
#@gmic : Convert selected images from RGB to HSL colorbases.
#@gmic : $ image.jpg -rgb2hsl -split c
#@gmic : $ image.jpg -rgb2hsl --split c -add... 100 -mod... 360 -append[-3--1] c -hsl2rgb
#@gmic rgb2hsl8
#@gmic : Convert selected images from RGB to HSL8 color bases.
#@gmic : $ image.jpg -rgb2hsl8 -split c
rgb2hsl8 :
-e[^-1] "Convert image$? from RGB to HSL8 color bases."
-v - -rgb2hsl -_rgb2hsx8 -v +
#@gmic rgb2hsv : (+)
#@gmic : Convert selected images from RGB to HSV colorbases.
#@gmic : $ image.jpg -rgb2hsv -split c
#@gmic : $ image.jpg -rgb2hsv --split c -add.. 0.3 -cut.. 0,1 -append[-3--1] c -hsv2rgb
#@gmic rgb2hsv8
#@gmic : Convert selected images from RGB to HSV8 color bases.
#@gmic : $ image.jpg -rgb2hsv8 -split c
rgb2hsv8 :
-e[^-1] "Convert image$? from RGB to HSV8 color bases."
-v - -rgb2hsv -_rgb2hsx8 -v +
_rgb2hsx8 :
-repeat $!
-sh[$>] 0 -*. 0.708333 -rm.
-sh[$>] 1,2 -*. 255 -rm.
-done
#@gmic rgb2lab : (+)
#@gmic : Convert selected images from RGB to Lab colorbases.
#@gmic : $ image.jpg -rgb2lab -split c
#@gmic : $ image.jpg -rgb2lab --split c -mul[-2,-1] 2.5 -append[-3--1] c -lab2rgb
#@gmic rgb2lab8
#@gmic : Convert selected images from RGB to Lab8 color bases.
#@gmic : $ image.jpg -rgb2lab8 -split c
rgb2lab8 :
-e[^-1] "Convert image$? from RGB to Lab8 color bases."
-v - -rgb2lab -repeat $!
-sh[$>] 0 -*. 2.55 -rm.
-sh[$>] 1 -+. 100 -*. 1.275 -rm.
-sh[$>] 2 -+. 110 -*. 1.15909 -rm.
-done -v +
#@gmic rgb2lch
#@gmic : Convert selected images from RGB to Lch color bases.
#@gmic : $ image.jpg -rgb2lch -split c
rgb2lch :
-e[^-1] "Convert image$? from RGB to Lch color bases."
-v - -rgb2lab -lab2lch -v +
#@gmic rgb2lch8
#@gmic : Convert selected images from RGB to Lch8 color bases.
#@gmic : $ image.jpg -rgb2lch8 -split c
rgb2lch8 :
-e[^-1] "Convert image$? from RGB to Lch8 color bases."
-v - -rgb2lch -repeat $!
-sh[$>] 0 -*. 2.55 -rm.
-sh[$>] 1 -*. 1.88889 -rm.
-sh[$>] 2 -+. 3.14159 -*. 40.5845 -rm.
-done -v +
#@gmic rgb2luv
#@gmic : Convert selected images from RGB to LUV color bases.
#@gmic : $ image.jpg -rgb2luv -split c
rgb2luv :
-e[^-1] "Convert image$? from RGB to LUV color bases."
-v - -repeat $! -l[$>]
--rgb2xyz -rgb2lab.. -channels.. 0 -s. c
-*. 3 --*.. 15 -+[-2,-1] -+. [-3] -+. 1e-8
-*... 4 -*.. 9 -/[-3,-2] [-1] -rm.
--.. 0.2009 --. 0.4610
--*... 13 -*... [-1] -*[-2,-1] -a c
-endl -done -v +
#@gmic rgb2int
#@gmic : Convert selected images from RGB to INT24 scalars.
#@gmic : $ image.jpg -rgb2int
rgb2int :
-e[^-1] "Convert image$? from RGB to INT24 scalars."
-v - -to_rgb -round -repeat $! -l[$>]
-s c -<<[0] 16 -<<[1] 8 -+
-endl -done -v +
#@gmic rgb2srgb : (+)
#@gmic : Convert selected images from RGB to sRGB colorbases.
#@gmic rgb2xyz
#@gmic : Convert selected images from RGB to XYZ colorbases.
#@gmic : the D65 illuminant is used as the white point).
#@gmic : $ image.jpg -rgb2xyz -split c
rgb2xyz :
-e[^-1] "Convert image$? from RGB to XYZ color bases."
-v - -/ 255 -mix_rgb 0.412453,0.357580,0.180423,0.212671,0.715160,0.072169,0.019334,0.119193,0.950227 -v +
#@gmic rgb2xyz8
#@gmic : Convert selected images from RGB to XYZ8 color bases.
#@gmic : $ image.jpg -rgb2xyz8 -split c
rgb2xyz8 :
-e[^-1] "Convert image$? from RGB to XYZ8 color bases."
-v - -rgb2xyz -repeat $!
-sh[$>] 0 -*. 255 -rm.
-sh[$>] 1 -*. 255 -rm.
-sh[$>] 2 -*. 231.8182 -rm.
-done -v +
#@gmic rgb2yiq
#@gmic : Convert selected images from RGB to YIQ colorbases.
#@gmic : $ image.jpg -rgb2yiq -split c
rgb2yiq :
-e[^-1] "Convert image$? from RGB to YIQ color bases."
-v - -mix_rgb 0.299,0.587,0.114,0.595716,-0.274453,-0.321263,0.211456,-0.522591,0.311135 -v +
#@gmic rgb2yiq8
#@gmic : Convert selected images from RGB to YIQ8 colorbases.
#@gmic : $ image.jpg -rgb2yiq8 -split c
rgb2yiq8 :
-e[^-1] "Convert image$? from RGB to YIQ color bases."
-v - -mix_rgb 0.299,0.587,0.114,0.595716,-0.274453,-0.321263,0.211456,-0.522591,0.311135
-repeat $!
-sh[$>] 1 -+. 151.908 -*. 0.8393238012481239 -rm.
-sh[$>] 2 -+. 133.261 -*. 0.9567690472081104 -rm.
-done -v +
#@gmic rgb2ycbcr
#@gmic : Convert selected images from RGB to YCbCr colorbases.
#@gmic : $ image.jpg -rgb2ycbcr -split c
rgb2ycbcr :
-e[^-1] "Convert image$? from RGB to YCbCr color bases."
-v - -mix_rgb 66,129,25,-38,-74,112,112,-94,-18 -+ 128 -/ 256
-repeat $!
-sh[$>] 0 -+. 16 -rm.
-sh[$>] 1,2 -+. 128 -rm.
-done -v +
#@gmic rgb2yuv
#@gmic : Convert selected images from RGB to YUV colorbases.
#@gmic : $ image.jpg -rgb2yuv -split c
rgb2yuv :
-e[^-1] "Convert image$? from RGB to YUV color bases."
-v - -/ 255 -mix_rgb 0.299,0.587,0.114,-0.14713,-0.28886,0.436,0.615,-0.51498,-0.10001 -v +
#@gmic rgb2yuv8
#@gmic : Convert selected images from RGB to YUV8 color bases.
#@gmic : $ image.jpg -rgb2yuv8 -split c
rgb2yuv8 :
-e[^-1] "Convert image$? from RGB to YUV8 color bases."
-v - -rgb2yuv -repeat $!
-sh[$>] 0 -*. 255 -rm.
-sh[$>] 1 -+. 0.44 -*. 289.773 -rm.
-sh[$>] 2 -+. 0.62 -*. 205.645 -rm.
-done -v +
#@gmic remove_opacity
#@gmic : Remove opacity channel of selected images.
remove_opacity :
-e[^-1] "Remove opacity channel of image$?."
-v - -repeat $! -l[$>]
-if {s==2} -channels 0
-elif {s==4} -channels 0,2
-endif
-nm {n} -endl -done -v +
#@gmic select_color : tolerance[%]>=0,col1,..,colN
#@gmic : Select pixels with specified color in selected images.
#@gmic : $ image.jpg --select_color 40,204,153,110
#@gmic : $$
select_color : -skip ${1=0}
-e[^-1] "Select color (${2--1}) in image$?, with tolerance $1."
-v - -repeat $! -l[$>]
--fc ${2--1} -- -norm -<= $1
-endl -done -v +
#@gmic sepia
#@gmic : Apply sepia tones effect on selected images.
#@gmic : $ image.jpg --sepia
sepia :
-e[^-1] "Apply sepia tones effect on image$?."
-v - (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200) -r. 256,1,1,3,3
-repeat {$!-1} -l[$>,-1] -split_opacity -luminance[0] -map[0] [-1] -a[^-1] c -endl -done
-rm. -v +
#@gmic solarize
#@gmic : Solarize selected images.
#@gmic : $ image.jpg --solarize
solarize :
-e[^-1] "Solarize image$?."
-v - -luminance -n 0,128 -map 1 -v +
#@gmic split_colors : _tolerance>=0,_max_nb_outputs>0,_min_area>0
#@gmic : Split selected images as several image containing a single color.
#@gmic : One selected image can be split as at most 'max_nb_outputs' images.
#@gmic : Output images are sorted by decreasing area of extracted color regions and have an additional alpha-channel.
#@gmic : Default values: 'tolerance=0', 'max_nb_outputs=256' and 'min_area=8'.
#@gmic : $ image.jpg -quantize 5 --split_colors , -display_rgba
split_colors : -check "${1=0}>=0 && isint(${2=256}) && $2>0 && ${3=8}>=1"
-e[^-1] "Split image$? as single color outputs, with tolerance $1, $2 maximal outputs and minimal color area $3."
-v - -repeat $! -l[$>]
--label 0,1 -norm. -area. 0,1
-repeat {$2-1}
coordsM={[xM,yM,zM,cM]}
-if {1,i($coordsM)<$3} -break -endif
color={0,I($coordsM)}
--select_color[0] $1,$color
-==. 0 -*[1] [-1] -==. 0
-done
-if {1,iM} -!=[1] 0 -mv[1] $!
-else -rm[1] -endif
-r[^0] [0],[0],[0],{0,s+1}
N={$!-1}
-sh[^0] 0,{s-2} -*[-$N--1] [0] -rm[-$N--1]
-sh[^0] 100% -*[-$N--1] 255 -rm[0,-$N--1]
-endl -done -v +
#@gmic split_opacity
#@gmic : Split color and opacity parts of selected images.
split_opacity :
-e[^-1] "Split color and opacity parts of image$?."
-v - -repeat $! -l[$<] -s c,{if(s==4,-3,if(s==2,-1,-s))} -endl -done -v +
#@gmic srgb2rgb : (+)
#@gmic : Convert selected images from sRGB to RGB colorbases.
#@gmic to_a
#@gmic : Force selected images to have an alpha channel.
to_a :
-e[^-1] "Force image$? to have an alpha channel."
-v - -repeat $! -l[$>]
-if {s==1||s==3} -channels 0,{s} -sh. {s-1} -f. 255 -rm. -endif
-endl -done -v +
#@gmic to_color
#@gmic : Force selected images to be in color mode (RGB or RGBA).
to_color :
-e[^-1] "Force image$? to be in color mode."
-v - -repeat $! -l[$>]
-if {s>4} -v + -error[] "Command '-to_color': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {s==2} -r 100%,100%,1,4,0,1,0,0,0,1
-elif {s==1} -r 100%,100%,1,3,1
-endif
-endl -done -v +
#@gmic to_colormode : mode={ 0=adaptive | 1=G | 2=GA | 3=RGB | 4=RGBA }
#@gmic : Force selected images to be in a given color mode.
#@gmic : Default value: 'mode=0'.
to_colormode : -skip ${1=0}
-if {$1==1} -to_gray
-elif {$1==2} -to_graya
-elif {$1==3} -to_rgb
-elif {$1==4} -to_rgba
-else
-v - is_rgb=0 is_alpha=0
-repeat $!
-if {$>,!s||s>4} -v + -error "Command '-to_colormode': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {$>,s==2} is_alpha=1
-elif {$>,s==3} is_rgb=1
-elif {$>,s==4} is_rgb=1 is_alpha=1
-endif
-done
-to_colormode {if($is_rgb,3,1)+$is_alpha}
-v +
-endif
#@gmic to_gray
#@gmic : Force selected images to be in GRAY mode.
#@gmic : $ image.jpg --to_gray
to_gray :
-e[^-1] "Force image$? to be in GRAY mode."
-v - -repeat $! -l[$>]
-if {s>4} -v + -error[] "Command '-to_gray': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {s>=3} -channels 0,2 -luminance
-elif {s==2} -r 100%,100%,100%,1,0
-endif
-endl -done -v +
#@gmic to_graya
#@gmic : Force selected images to be in GRAYA mode.
to_graya :
-e[^-1] "Force image$? to be in GRAYA mode."
-v - -repeat $! -l[$>]
-if {s>4} -v + -error[] "Command '-to_graya': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {s==4} --channels 3 -channels.. 0,2 -luminance.. -a c
-elif {s==3} -luminance -channels 0,1 -sh. 1 -f. 255 -rm.
-elif {s==1} -channels 0,1 -sh. 1 -f. 255 -rm.
-endif
-endl -done -v +
#@gmic to_pseudogray : _max_step>=0,_is_perceptual_constraint={ 0 | 1 },_bits_depth>0
#@gmic : Convert selected scalar images ([0-255]-valued) to pseudo-gray color images.
#@gmic : Default parameters : 'max_step=5', 'is_perceptual_constraint=1' and 'bits_depth=8'.
#@gmic : The original pseudo-gray technique has been introduced by Rich Franzen [http://r0k.us/graphics/pseudoGrey.html].
#@gmic : Extension of this technique to arbitrary increments for more tones, has been done by David Tschumperle.
to_pseudogray : -check "isint(${1=5}) && $1>=0 && isint(${3=8}) && $3>0" -skip ${2=1}
-e[^-1] "Convert scalar image$? to pseudo-gray color images, with steps $1."
-v - -channels 0 -srgb2rgb -pseudogray $1,{2.3*$2},$3
--srgb2rgb. -rgb2lab. -channels. 0 -*. {65535/100} -round. -rows. 0,2
-rv[-2,-1] -permute. xcyz -+. 1 -a[-2,-1] y -pointcloud. 0
--norm. -!=. 0 -distance. 1 -*. -1 -watershed.. [-1] -rm. --. 1
-repeat {$!-1}
-to_rgb[$>] -rgb2lab[$>] -channels[$>] 0 -*[$>] {65535/100} -round[$>] -c[$>] 0,65535
-map[$>] [-1]
-done -rm. -v +
#@gmic to_rgb
#@gmic : Force selected images to be in RGB mode.
to_rgb :
-e[^-1] "Force image$? to be in RGB mode."
-v - -repeat $! -l[$>]
-if {s>4} -v + -error[] "Command '-to_rgb': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {s==4} -channels 0,2
-elif {s==2} -channels 0,0 -r 100%,100%,100%,3
-elif {s==1} -r 100%,100%,100%,3
-endif
-endl -done -v +
#@gmic to_rgba
#@gmic : Force selected images to be in RGBA mode.
to_rgba :
-e[^-1] "Force image$? to be in RGBA mode."
-v - -repeat $! -l[$>]
-if {s>4} -v + -error[] "Command '-to_rgba': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
-elif {s==3} -channels 0,3 -sh. 3 -f. 255 -rm.
-elif {s==2} -r 100%,100%,100%,4 -sh. 2 -f. [-2] -rm.
-elif {s==1} -r 100%,100%,100%,4 -sh. 3 -f. 255 -rm.
-endif
-endl -done -v +
#@gmic transfer_colors : [reference_image],_transfer_brightness={ 0 | 1 }
#@gmic : Transfer colors of the specified reference image to selected images.
#@gmic : Default value: 'transfer_brightness=0'.
#@gmic : $ image.jpg --rand 0,255 --transfer_colors[0] [1],1
transfer_colors : -skip ${1=0}
-e[^-1] "Transfer colors of image $1 to image$?."
-v - -pass$1 0 -mv. 0 -to_rgb[0] -to_colormode[^0] {max(3,${-max_s})} -c 0,255
-repeat $! -l[$>] -split_opacity -rgb2ycbcr[0] -a c -endl -done
-l[0] -s c -histogram_cumul 256,1,0,255 -a c -* 255 -endl
-repeat {$!-1} -l[0,{$<+1}]
-if $1 -repeat 3 -sh[0,1] $> -equalize. 256,0,255 -index. [-2],0,0 -rm[-2,-1] -done
-else -repeat 2 -sh[0,1] {$>+1} -equalize. 256,0,255 -index. [-2],0,0 -rm[-2,-1] -done
-endif
-endl -done -rm[0]
-repeat $! -l[$>] -split_opacity -ycbcr2rgb[0] -a c -endl -done
-v +
_transfer_colors :
-repeat $! -l[$>] -rgb2ycbcr -s c -histogram 256,0,255 -a c -dg 300,200 -endl -done
#@gmic transfer_rgb : [target],_gamma>=0,_regularization>=0,_luminosity_constraints>=0,_rgb_resolution>=0,_is_constraints={ 0 | 1 }
#@gmic : Transfer colors from selected source images to selected reference image (given as argument).
#@gmic : 'gamma' determines the importance of color occurences in the matching process (0=none to 1=huge).
#@gmic : 'regularization' determines the number of guided filter iterations to remove quantization effects.
#@gmic : 'luminosity_constraints' tells if luminosity constraints must be applied on non-confident matched colors.
#@gmic : 'is_constraints' tells if additional hard color constraints must be set (opens an interactive window).
#@gmic : Default values: 'gamma=0.3','regularization=8', 'luminosity_constraints=0.1', 'rgb_resolution=64' and 'is_constraints=0'.
transfer_rgb : -check "${2=0.3}>=0 && ${3=8}>=0 && ${4=0.15}>=0 && ${5=64}>=0 && isint(${6=0})"
sigma=1.5
-repeat $! -pass$1 0 -l[$>,-1]
nm_from={0,b} nm_to={1,b}
-nm[0] source -nm[1] target
--_transfer_rgb[source,target] $2,$sigma,$5
-nm.. fsource -nm. ftarget
-n[fsource,ftarget] 0,255
-if $6
h0={2*{*,v}/3} ws0={source,max(1,w*$h0/h)} wt0={target,max(1,w*$h0/h)}
w1={2*{*,u}/3} hs1={source,max(1,h*$w1/w)} ht1={target,max(1,h*$w1/w)}
-if {abs($ws0+$wt0-$w1)<abs($hs1+$ht1-$h0)}
--r2dy[source,target] $h0 --b[-2,-1] 0.5% -a[-4,-3] x -a[-2,-1] x
-else
--r2dx[source,target] $w1 --b[-2,-1] 0.5% -a[-4,-3] y -a[-2,-1] y
-endif
-if {w>$w1} -r2dx[-2,-1] $w1 -endif
-if {h>$h0} -r2dy[-2,-1] $h0 -endif
-nm.. visu -nm. both
-w[visu] -1,-1
N=0 -do
-w[] -1,-1,"[G'MIC] Add color guide (constraint ""#"{1+$N}")"
--select[$visu] 1 -if {i==-1} -rm. -break -endif
-line[$visu] {i[0]},{i[1]},{i[3]},{i[4]},1,0xF0F0F0F0,0
-line[$visu] {i[0]},{i[1]},{i[3]},{i[4]},1,0x0F0F0F0F,255
-circle[$visu] {i[0]},{i[1]},5,1,0,0,0 -circle[$visu] {i[0]},{i[1]},3,1,255,0,0
-circle[$visu] {i[3]},{i[4]},5,1,0,0,0 -circle[$visu] {i[3]},{i[4]},3,1,0,255,0
-s. y,2 -rows[-2,-1] 0,1 -a[-2,-1] x -permute. xczy
--warp[$both] [-1],0,0 -rm..
-*. {$5/256} -s. x,2
--. [-2] -*. -1 -a[-2,-1] c
N+=1
-while {*}
-if $N -a[-$N--1] x -permute. xczy -nm. constraints -endif
-rm[$visu,$both] -w 0
-endif
-if $constraints
--pointcloud. 0 -r. [-3],[-3],[-3],3,0 --compose_channels. + -a[-2,-1] c
-displacement[fsource] [ftarget],0.001,5,0,10000,1,[-1] -rm[ftarget,constraints,-1]
-else
-displacement[fsource] [ftarget],0.005 -rm[ftarget]
-endif
-nm[fsource] displacement
--_transfer_rgb[target] 0,$sigma,{displacement,w}
-warp. [displacement],1,1,1 -c. 0,100% -nm. fconfidence
--map_clut[source] [-1] -nm. confidence
[displacement],[displacement],[displacement],1,x --f. y --f. z -a[-3--1] c -*. {256/w} -+. 1
--_transfer_rgb[target] 0,0,{w} -*.. [-1]
-warp[-2,-1] [displacement],1,0,1
-distance. 1 -*. -1 -watershed.. [-1] -rm. --. 1
-nm. clut
-b[clut] $sigma%
-if {$4>0}
-pow[fconfidence] {$4/10} -*[fconfidence] -1 -+[fconfidence] 1
--f[fconfidence] x --f. y --f. z -a[-3--1] c -*. {256/w}
-rgb2hsv[clut,-1] -channels. 100%
-j[clut] [-1],0,0,0,2,1,[fconfidence] -rm.
-hsv2rgb[clut]
-endif
--map_clut[source] [clut] -nm. res_noregul
-if {!$3}
-nm[res_noregul] res
-else
-l[source,res_noregul]
-rgb2ycbcr
---[1] [0] -repeat $3 -guided. [0],5,5 -done -+. [0] -c. 0,255
-ycbcr2rgb
-endl
-nm. res
-j[res] [res_noregul],0,0,0,0,1,[confidence]
-rm[res_noregul]
-endif
-k[res]
-endl -done
_transfer_rgb : -v - -l[] -check "${1=0}>=0 && ${2=1.5}>=0 && ${3=128}>0" gamma=$1 smoothness=$2 res=$3 -onfail -noarg gamma=0 smoothness=1.5 res=128 -endl -v +
-e[^-1] "Convert image$? as 3d volumetric scalar functions for color matching, with gamma "$gamma", smoothness "$smoothness" and resolution "$res"."
-v - -to_rgb -repeat $! -l[$>]
-b 0.3%
-r {w*h},3,1,1,-1 -* {$res/256} -c 0,{$res-1}
-pointcloud 1,$res,$res,$res -f 'if(i,i^$gamma,0)' -b $smoothness% -n 0,1
-endl -done -v +
#@gmic xyz2rgb
#@gmic : Convert selected images from XYZ to RGB colorbases.
xyz2rgb :
-e[^-1] "Convert image$? from XYZ to RGB color bases."
-v - -* 255 -mix_rgb 3.240479,-1.537150,-0.498535,-0.969256,1.875992,0.041556,0.055648,-0.204043,1.057311 -c 0,255 -v +
#@gmic xyz82rgb
#@gmic : Convert selected images from XYZ8 to RGB color bases.
xyz82rgb :
-e[^-1] "Convert image$? from XYZ8 to RGB color bases."
-v - -repeat $!
-sh[$>] 0 -/. 255 -rm.
-sh[$>] 1 -/. 255 -rm.
-sh[$>] 2 -/. 231.8182 -rm.
-done -xyz2rgb -v +
#@gmic ycbcr2rgb
#@gmic : Convert selected images from YCbCr to RGB colorbases.
ycbcr2rgb :
-e[^-1] "Convert image$? from YCbCr to RGB color bases."
-v - -repeat $! -l[$>] -sh 0 --. 16 -rm. -sh 1,2 --. 128 -rm. -endl -done
-mix_rgb 298,0,409,298,-100,-208,298,516,0 -+ 128 -/ 256 -c 0,255
-v +
#@gmic yiq2rgb
#@gmic : Convert selected images from YIQ to RGB colorbases.
yiq2rgb :
-e[^-1] "Convert image$? from YIQ to RGB color bases."
-v - -mix_rgb 1,0.9563,0.6210,1,-0.2721,-0.6474,1,-1.1070,1.7046 -v +
#@gmic yiq82rgb
#@gmic : Convert selected images from YIQ8 to RGB colorbases.
yiq82rgb :
-e[^-1] "Convert image$? from YIQ8 to RGB color bases."
-v - -repeat $!
-sh[$>] 1 -/. 0.8393238012481239 --. 151.908 -rm.
-sh[$>] 2 -/. 0.9567690472081104 --. 133.261 -rm.
-done
-mix_rgb 1,0.9563,0.6210,1,-0.2721,-0.6474,1,-1.1070,1.7046 -c 0,255 -v +
#@gmic yuv2rgb
#@gmic : Convert selected images from YUV to RGB colorbases.
yuv2rgb :
-e[^-1] "Convert image$? from YUV to RGB color bases."
-v - -mix_rgb 1,0,1.13983,1,-0.39465,-0.5806,1,2.03211,0 -* 255 -v +
#@gmic yuv82rgb
#@gmic : Convert selected images from YUV8 to RGB color bases.
yuv82rgb :
-e[^-1] "Convert image$? from YUV8 to RGB color bases."
-v - -repeat $!
-sh[$>] 0 -/. 255 -rm.
-sh[$>] 1 -/. 289.773 --. 0.44 -rm.
-sh[$>] 2 -/. 205.645 --. 0.62 -rm.
-done -yuv2rgb -v +
#@gmic :: Geometry manipulation
#@gmic a : eq. to '-append' : (+)
#@gmic append : [image],axis,_centering : axis,_centering : (+)
#@gmic : Append specified image to selected images, or all selected images together, along specified axis.
#@gmic : (eq. to '-a').
#@gmic : 'axis' can be { x | y | z | c }.
#@gmic : Usual 'centering' values are { 0=left-justified | 0.5=centered | 1=right-justified }.
#@gmic : Default value: 'centering=0'.
#@gmic : $ image.jpg -split y,10 -reverse -append y
#@gmic : $ image.jpg -repeat 5 --rows[0] 0,{10+18*$>}% -done -remove[0] -append x,0.5
#@gmic : $ image.jpg -append[0] [0],y
#@gmic append_tiles : _M>=0,_N>=0,0<=_centering_x<=1,0<=_centering_y<=1
#@gmic : Append MxN selected tiles as new images.
#@gmic : If 'N' is set to 0, number of rows is estimated automatically.
#@gmic : If 'M' is set to 0, number of columns is estimated automatically.
#@gmic : If 'M' and 'N' are both set to '0', auto-mode is used.
#@gmic : If 'M' or 'N' is set to 0, only a single image is produced.
#@gmic : 'centering_x' and 'centering_y' tells about the centering of tiles when they have different sizes.
#@gmic : Default values: 'M=0', 'N=0', 'centering_x=centering_y=0.5'.
#@gmic : $ image.jpg -split xy,4 -append_tiles ,
append_tiles : -check "isint(${1=0}) && isint(${2=0}) && ${3=0.5}>=0 && $3<=1 && ${4=$3}>=0 && $4<=1"
-if {!$!} -e[0--3] "Append image$? as a 0x0-tiled image." -return -endif
-if {!$1&&!$2}
-v - N={int(sqrt($!))} M={round($!/$N,1,1)}
-v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image (auto-mode)." -v -
MN={$M*$N} -if {$!%$MN} {$MN-($!%$MN)} -s. x -endif
-elif {!$2}
-v - M=$1 N={round($!/$1,1,1)}
-v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image." -v -
-if {$M>$!} -v + -warn[0--3] "Missing images for having one row in a "${M}x${N}"-tiled image." -return -endif
-if {$!%$M} {$M-($!%$M)} -s. x -endif
-elif {!$1}
-v - M={round($!/$2,1,1)} N=$2
-v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image." -v -
-if {$N>$!} -v + -warn[0--3] "Missing images for having one column in a "${M}x${N}"-tiled image." -return -endif
-if {$!%$M} {$M-($!%$M)} -s. x -endif
-else
-e[0--3] "Append image$?, as $1x$2-tiled images." -v -
M=$1 N=$2
-endif
MN={$M*$N}
-repeat {int($!/$MN)} -l[$>-{$>+$MN-1}]
$MN,1,1,2 -repeat $MN -point. $>,0,0,1,{$>,w},{$>,h} -done -r. $M,$N,1,2,-1
-s. c -l.. -s y -max -endl -l. -s x -max -endl
i=0 -repeat $N y=$> -repeat $M -r[$i] {-2,@$>},{@$y},100%,100%,0,0,$3,$4 i+=1 -done -done
-rm[-2,-1]
-repeat {int($!/$M)} -a[$>-{$>+$M-1}] x -done
-repeat {int($!/$N)} -a[$>-{$>+$N-1}] y -done
-endl -done
-v +
#@gmic apply_scales : "command",number_of_scales>0,_min_scale[%]>=0,_max_scale[%]>=0,_scale_gamma>0,_interpolation
#@gmic : Apply specified command on different scales of selected images.
#@gmic : 'interpolation' can be { 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : Default value: 'min_scale=25%', 'max_scale=100%' and 'interpolation=3'.
#@gmic : $ image.jpg -apply_scales "-blur 5 -sharpen 1000",4
apply_scales : -skip "${1=}" -check "isint($2) && $2>0 && ${3=25%}>=0 && ${4=100%}>=0 && ${5=1}>0 && isint(${6=3}) && $6>=0"
-v - s0="no" s1="nearest-neighbor" s2="average" s3="linear" s4="grid" s5="bicubic" s6="lanczos" -v +
-e[^-1] "Apply command '$1' on image$? for $2 scales ($3 -> $4) and "${s{min(6,$6)}}" interpolation."
-v - -repeat $! -l[$<] nm={0,n}
scale0={if(${"-is_percent $3"},$3*max(w,h,d),$3)}
scale1={if(${"-is_percent $4"},$4*max(w,h,d),$4)}
-repeat $2
scale={$scale0+($scale1-$scale0)*($>/max(1,$2-1))^$5}
w={0,w==1?1:max(1,round($scale*w/max(w,h,d)))}
h={0,h==1?1:max(1,round($scale*h/max(w,h,d)))}
d={0,d==1?1:max(1,round($scale*d/max(w,h,d)))}
--r[0] $w,$h,$d,100%,$6
-if {narg("$1")} -l. $1 -endl -endif
-done
-rm[0] -nm $nm
-endl -done -v +
#@gmic autocrop : value1,value2,... : (no arg) : (+)
#@gmic : Autocrop selected images by specified vector-valued intensity.
#@gmic : If no arguments are provided, cropping value is guessed.
#@gmic : $ 400,400,1,3 -fill_color 64,128,255 -ellipse 50%,50%,120,120,0,1,255 --autocrop
#@gmic autocrop_components : _threshold[%],_min_area[%]>=0,_is_high_connectivity={ 0 | 1 },_output_type={ 0=crop | 1=segmentation | 2=coordinates }
#@gmic : Autocrop and extract connected components in selected images, according to a mask given as the last channel of
#@gmic : each of the selected image (e.g. alpha-channel).
#@gmic : Default values: 'threshold=0%', 'min_area=0.1%', 'is_high_connectivity=0' and 'output_type=1'.
#@gmic : $ 256,256 -noise 0.1,2 -dilate_circ 20 -label_fg 0,1 -normalize 0,255 --neq 0 -*. 255 -append c --autocrop_components ,
autocrop_components : -skip ${1=0%} -check "${2=0.1%}>=0 && isbool(${3=0}) && isint(${4=1}) && $4>=0 && $4<=2"
-e[^-1] "Autocrop connected components from image$?, with threshold $1, minimal area $2, "${-arg\ 1+$3,low,high}" connectivity "\
"and output type set to '"${-arg\ 1+$4,crop,segmentation,coordinates}"'.\n"
-v - -repeat $! -l[$>]
min_area={max(1,round(if(${-is_percent\ $2},$2*w*h,$2)))}
--channels 100% ->. $1 -area_fg. 0,$3 ->=. $min_area
--area. 0,1 -<. $min_area -|[-2,-1] -label_fg. 0,1
N={iM} -repeat {iM}
n={1+$>}
-v + -e[] "\r  > "$n/$N -v -
-rprogress {100*$n/$N}
--==[1] $n --*[0,-1] -rm..
-if {$4==0} coords=${-autocrop_coords.\ auto} -rm. --z[0] $coords
-elif {$4==1} -autocrop.
-else coords=${-autocrop_coords.\ auto} -rm. ($coords) -y.
-endif
-done
-rm[0,1]
-if {!$!} 0 -endif
-if {$4==2} -a x -endif
-endl -done -v +
#@gmic autocrop_seq : value1,value2,... | auto
#@gmic : Autocrop selected images using the crop geometry of the last one by specified vector-valued intensity,
#@gmic : or by automatic guessing the cropping value.
#@gmic : Default value: auto mode.
#@gmic : $ image.jpg --fill. 0 -ellipse. 50%,50%,30%,20%,0,1,1 -autocrop_seq 0
autocrop_seq : -skip ${1=auto}
-e[^-1] "Auto-crop image$? using crop geometry of last image by vector '$*'."
-if {!$!} -return -endif
-v -
-if {$!==1} -_autocrop$is_auto ${1--1} -v + -return -endif
coords=${-autocrop_coords.\ ${1--1}}
x0={arg(1,$coords)} y0={arg(2,$coords)} z0={arg(3,$coords)}
x1={arg(4,$coords)} y1={arg(5,$coords)} z1={arg(6,$coords)}
-if {$x0>$x1" || "$y0>$y1" || "$z0>$z1} -i[0--2] 0 -rm[1--1:2]
-else -z $x0,$y0,$z0,$x1,$y1,$z1
-endif
-v +
#@gmic channels : { [image0] | c0[%] },_{ [image1] | c1[%] } : (+)
#@gmic : Keep only specified channels of selected images.
#@gmic : Dirichlet boundary is used when specified channels are out of range.
#@gmic : $ image.jpg -channels 0,1
#@gmic : $ image.jpg -luminance -channels 0,2
#@gmic columns : { [image0] | x0[%] },_{ [image1] | x1[%] } : (+)
#@gmic : Keep only specified columns of selected images.
#@gmic : Dirichlet boundary is used when specified columns are out of range.
#@gmic : $ image.jpg -columns -25%,50%
#@gmic z : eq. to '-crop'. : (+)
#@gmic crop : x0[%],x1[%],_boundary : x0[%],y0[%],x1[%],y1[%],_boundary : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%],_boundary : x0[%],y0[%],z0[%],c0[%],x1[%],y1[%],z1[%],c1[%],_boundary : (no arg) : (+)
#@gmic : Crop selected images with specified region coordinates.
#@gmic : (eq. to '-z').
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --crop -230,-230,280,280,1 -crop[0] -230,-230,280,280,0
#@gmic : $ image.jpg -crop 25%,25%,75%,75%
#@gmic diagonal
#@gmic : Transform selected vectors as diagonal matrices.
#@gmic : $ 1,10,1,1,'y' --diagonal
diagonal :
-e[^-1] "Transform vector$? as diagonal matrix."
-v - -y -repeat $! -r[$>] {$>,h+1},100%,1,1,0 -r[$>] {$>,h},100%,1,1,-1 -done -v +
#@gmic elevate : _depth,_is_plain={ 0 | 1 },_is_colored={ 0 | 1 }
#@gmic : Elevate selected 2d images into 3d volumes.
#@gmic : Default values: 'depth=64', 'is_plain=1' and 'is_colored=1'.
elevate : -check "${1=64}>0" -skip ${2=1},${3=1}
-e[^-1] "Elevate 2d image$? into $1-slices volume(s)."
-v - -r 100%,100%,1,100%
-repeat $! -l[$>] nm={0,n}
--norm 100%,100%,$1,{if($3,{0,s},1)}
m={-2,im} d={-2,iM-$m}
-repeat $1
-if $2 -->=[1] {$m+$d*($>+1)/$1}
-else --ir[1] {$m+$d*$>/$1},{$m+$d*($>+1)/$1}
-endif
-r. 100%,100%,1,[-2] -if $3 -*. [0] -endif
-j.. [-1],0,0,$> -rm.
-done
-rm[0,1] -nm $nm -endl -done -v +
#@gmic expand_x : size_x>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the x-axis.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_x 30,0
expand_x : -check "$1>=0 && ${2=1}>=0 && $2<=2"
-e[^-1] "Expand image$? along the x-axis with size $1 and boundary conditions $2."
-v - -repeat $! -r[$>] {$>,w+2*$1},100%,100%,100%,0,$2,0.5,0.5,0.5 -done -v +
#@gmic expand_xy : size>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the xy-axes.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_xy 30,0
expand_xy : -check "$1>=0 && ${2=1}>=0 && $2<=2"
-e[^-1] "Expand image$? along the xy-axes with size $1 and boundary conditions $2."
-v - -repeat $! -r[$>] {$>,w+2*$1},{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 -done -v +
#@gmic expand_xyz : size>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the xyz-axes.
#@gmic : Default value: 'border=1'.
expand_xyz : -check "$1>=0 && ${2=1}>=0 && $2<=2"
-e[^-1] "Expand image$? along the xyz-axes with size $1 and boundary conditions $2."
-v - -repeat $! -r[$>] {$>,w+2*$1},{$>,h+2*$1},{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 -done -v +
#@gmic expand_y : size_y>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the y-axis.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_y 30,0
expand_y : -check "$1>=0 && ${2=1}>=0 && $2<=2"
-e[^-1] "Expand image$? along the y-axis with size $1 and boundary conditions $2."
-v - -repeat $! -r[$>] 100%,{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 -done -v +
#@gmic expand_z : size_z>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Expand selected images along the z-axis.
#@gmic : Default value: 'border=1'.
expand_z : -check "$1>=0 && ${2=1}>=0 && $2<=2"
-e[^-1] "Expand image$? along the z-axis with size $1 and boundary conditions $2."
-v - -repeat $! -r[$>] 100%,100%,{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 -done -v +
#@gmic montage : "_layout_code",_montage_mode={ 0<=centering<=1 | 2<=scale+2<=3 },_output_mode={ 0=single layer | 1=multiple layers },"_processing_command"
#@gmic : Create a single image montage from selected images, according to specified layout code :
#@gmic : - 'X' to assemble all images using an automatically estimated layout.
#@gmic : - 'H' to assemble all images horizontally.
#@gmic : - 'V' to assemble all images vertically.
#@gmic : - 'A' to assemble all images as an horizontal array.
#@gmic : - 'B' to assemble all images as a vertical array.
#@gmic : - 'Ha:b' to assemble two blocks 'a' and 'b' horizontally.
#@gmic : - 'Va:b' to assemble two blocks 'a' and 'b' vertically.
#@gmic : - 'Ra' to rotate a block 'a' by 90 deg. ('RRa' for 180 deg. and 'RRRa' for 270 deg.).
#@gmic : - 'Ma' to mirror a block 'a' along the X-axis ('MRRa' for the Y-axis).
#@gmic : A block 'a' can be an image indice (treated periodically) or a nested layout expression 'Hb:c','Vb:c','Rb' or 'Mb' itself.
#@gmic : For example, layout code 'H0:V1:2' creates an image where image [0] is on the left, and images [1] and [2] vertically packed on the right.
#@gmic : Default values: 'layout_code=X', 'montage_mode=2', output_mode='0' and 'processing_command=""'.
#@gmic : $ image.jpg -testimage2d 512 --plasma[0] -shape_cupid 256 -normalize 0,255 -frame 3,3,0 -frame 10,10,255 -to_rgb --montage A --montage[^-1] H1:V0:VH2:1H0:3
montage : -check "isval(${2=2}) && $2>=0 && $2<=3" -skip "${1=X}",${3=0},"${4=}"
-v -
-if {$2<=1} -v + -e[0--3] "Create aligned montage from image$?, with layout code '$1' and centering $2."
-else -v + -e[0--3] "Create scaled montage from image$?, with layout code '$1' and scale "{$2-2}"."
-endif
-v -
-if {lowercase('"$1"')=='x'} --l
-repeat $! -nm[$>] $> -done
-repeat {$!-1}
-if {{-2,w>h}" && "w>h} mode=V
-elif {{-2,h>w}" && "h>w} mode=H
-elif {{-2,w>h}" && "h>w}
-if {{-2,h/w}<(w/h)} mode=V -else mode=H -endif
-else
-if {{-2,w/h}<(h/w)} mode=H -else mode=V -endif
-endif
name=$mode{-2,n}:{n}
-montage[-2,-1] $mode,$2
-mv. 0 -nm[0] $name
-done
layout={0,n}
-rm -endl -montage $layout,$2,$3,"$4"
-else
N=$!
-l[] _scode="$1" _mode=$2
-if {lowercase('"$1"')=='h'} -if {$N>1} {$N-1},1,1,1,-1 $N,1,1,1,x -a x -y -else -v + -return -endif
-elif {lowercase('"$1"')=='v'} -if {$N>1} {$N-1},1,1,1,-2 $N,1,1,1,x -a x -y -else -v + -return -endif
-elif {s=lowercase('"$1"');s=='a'||s=='b'}
-if {$N<2} -v + -return -endif
nr={round(sqrt($N))} nc={round($N/$nr,1,1)}
-if {lowercase('"$1"')=='b'} n=$nr nr=$nc nc=$n -endif
$N,1,1,1,x -s x,-{round(w/$nr,1,1)} -repeat $! -l[$>] -if {w>1} -i[0] {w-1},1,1,1,-1 -a x -endif -endl -done -a x
-if {$nr>1} -i[0] {$nr-1},1,1,1,-2 -a x -endif -y
-else
({'"$1"'}) -f 'if(i==72||i==104,-1,if(i==86||i==118,-2,if(i==82||i==114,-3,if(i==77||i==109,-4,if(i>=48&&i<=57,i-48,-5)))))'
-s +,-1 -s +,-2 -s +,-3 -s +,-4 -s +,-5
-repeat $! -l[$>] -if {im>=0} --+. 48 -=.. {t} -rm. -rows 0 -endif -endl -done -a y -discard -5
-endif
-f 'if(i<0,i,i%$N)'
-endl
-if {$!==$N} -rm -v + -return -endif
-nm[^-1] 0 -repeat {h} c={i[$>]} -if {$c>=0} -if {$c,n} -i.. [$c] i={$!-2} -=. $i,0,$> ref$i=$c -else -nm[$c] 1 ref$c=$c -endif -endif -done
_code={^} _lcode={narg($_code)} -rm.
N=$! -repeat $N ($>,0,0,{$>,w},{$>,h},0,0,0) -done
-l[$N--1] _p=1 -k[${-_montage}] w={i[3]} h={i[4]} -f 'if(i(0,y)<0,-1,i)' -discard -1 -r 8,{h/8},1,1,-1 -endl
-if {narg("$4")} -m "__montage : $4 -k[0]"
-else
-m "__montage : -if {$""7%2} -mirror x -endif -if {$""8%2} -mirror y -endif -rotate {90*$""6} -r {max(1,round($""4,1,1))},{max(1,round($""5,1,1))},1,100%,3"
-endif
s=${-max_s[^-1]}
-repeat {h}
i={i(0,$>)} xi={i(1,$>)} yi={i(2,$>)} wi={i(3,$>)} hi={i(4,$>)} ai={i(5,$>)} mxi={i(6,$>)} myi={i(7,$>)}
-if {$3||!$>} -i.. $w,$h,1,$s -endif
-__montage[$i] ${ref$i},$xi,$yi,{max(1,$wi)},{max(1,$hi)},$ai,$mxi,$myi
-j.. [$i],$xi,$yi
-done
-uncommand __montage
-rm[0-{$N-1},-1]
-endif
-nm "[Montage '$1']"
-v +
_montage :
-if {$_p>$_lcode} -v + -error "Command '-montage': Incomplete layout code '"$_scode"'." -endif
c={arg($_p,$_code)}
-if {$c>=0} _p+=1 -u $c
-elif {$c==-4}
_p+=1 l=${-_montage} -f[$l] 'a=i(5,y)%2;if((x==7&&a)||(x==6&&!a),!i,if(x==1,i(3,0)-i(3,y)-i,i))' -u $l
-elif {$c==-3}
_p+=1 l=${-_montage} -l[$l] -s x -+[2] [4] -rv[1,2] -*[1] -1 -+[1] {4,@0} -rv[3,4] -+[5] 1 -a x -endl -u $l
-else
_p+=1
l=${-_montage} lw={$l,@3} lh={$l,@4}
r=${-_montage} rw={$r,@3} rh={$r,@4}
-if {$c==-1}
-if {$_mode<2}
h={max($lh,$rh)} -+[$l] '0,0,{($h-$lh)*min(1,$_mode)},0,0,0,0,0' -+[$r] '0,$lw,{($h-$rh)*min(1,$_mode)},0,0,0,0,0'
-else
h={($_mode-2)*max($lh,$rh)+(3-$_mode)*min($lh,$rh)}
lf={$h/$lh} rf={$h/$rh} lw={$lw*$lf} rw={$rw*$rf}
-*[$l] '1,$lf,$lf,$lf,$lf,1,1,1' -*[$r] '1,$rf,$rf,$rf,$rf,1,1,1' -+[$r] '0,$lw,0,0,0,0,0,0'
-endif
-i[$l] (-1,0,0,{$lw+$rw},$h,0,0,0) -a[$l,{$l+1}] y -a[$l] [$r],y -r[$r] 1,1,1,1,0
-else
-if {$_mode<2}
w={max($lw,$rw)} -+[$l] '0,{($w-$lw)*min(1,$_mode)},0,0,0,0,0,0' -+[$r] '0,{($w-$rw)*min(1,$_mode)},$lh,0,0,0,0,0'
-else
w={($_mode-2)*max($lw,$rw)+(3-$_mode)*min($lw,$rw)}
lf={$w/$lw} rf={$w/$rw} lh={$lh*$lf} rh={$rh*$rf}
-*[$l] '1,$lf,$lf,$lf,$lf,1,1,1' -*[$r] '1,$rf,$rf,$rf,$rf,1,1,1' -+[$r] '0,0,$lh,0,0,0,0,0'
-endif
-i[$l] (-1,0,0,$w,{$lh+$rh},0,0,0) -a[$l,{$l+1}] y -a[$l] [$r],y -r[$r] 1,1,1,1,0
-endif
-u $l
-endif
#@gmic mirror : { x | y | z }..{ x | y | z } : (+)
#@gmic : Mirror selected images along specified axes.
#@gmic : $ image.jpg --mirror y --mirror[0] c
#@gmic : $ image.jpg --mirror x --mirror y -append_tiles 2,2
#@gmic permute : permutation_string : (+)
#@gmic : Permute selected image axes by specified permutation.
#@gmic : 'permutation' is a combination of the character set {x|y|z|c},
#@gmic : e.g. 'xycz', 'cxyz', ..
#@gmic : $ image.jpg -permute yxzc
#@gmic r : eq. to '-resize'. : (+)
#@gmic resize : [image],_interpolation,_boundary,_ax,_ay,_az,_ac : {[image_w] | width>0[%]},_{[image_h] | height>0[%]},_{[image_d] | depth>0[%]},_{[image_s] | spectrum>0[%]},_interpolation,_boundary,_ax,_ay,_az,_ac : (no arg) : (+)
#@gmic : Resize selected images with specified geometry.
#@gmic : (eq. to '-r').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0 or 4'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : (no arg) runs interactive mode (uses the instant display window [0] if opened).
#@gmic : Default values: 'interpolation=1', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg (0,1;0,1^0,0;1,1^1,1;1,1) -resize. [-2],3 -mul.. [-1]
#@gmic : $ image.jpg --resize. 256,128,1,3,2 --resize. 120%,120%,1,3,0,1,0.5,0.5 --resize. 120%,120%,1,3,0,0,0.2,0.2 --resize. [0],[0],1,3,4
#@gmic resize_pow2 : _interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images so that each dimension is a power of 2.
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=0', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize_pow2. 0
resize_pow2 : -check "isint(${1=0}) && $1>=-1 && $1<=6" -skip ${2=0},${3=0},${4=0},${5=0},${6=0}
-e[^-1] "Resize image$? so that each dimension is a power of 2."
-v - -repeat $!
-r[$>] {$>,2^(round(log2(w),1,1))},{$>,2^(round(log2(h),1,1))},{$>,2^(round(log2(d),1,1))},100%,${1-6}
-done -v +
#@gmic rr2d : eq. to '-resize_ratio2d'.
rr2d :
-v - _gmic_s="$?" -v +
-_resize_ratio2d $*
#@gmic resize_ratio2d : width>0,height>0,_mode={ 0=inside | 1=outside | 2=padded },0=<_interpolation<=6
#@gmic : Resize selected images while preserving their aspect ratio.
#@gmic : (eq. to '-rr2d').
#@gmic : Default values: 'mode=0' and 'interpolation=6'.
resize_ratio2d :
-v - _gmic_s="$?" -v +
-_$0 $*
_resize_ratio2d : -check "$1>0 && $2>0 && ${3=0}>=0 && $3<=2 && ${4=6}>=0 && $4<=6"
-e[0--3] "Resize 2d image"$_gmic_s" to $1x$2 with ratio-"${-arg\ 1+$3,inside,outside,padded}\
" mode and interpolation type $4."
-v - -repeat $!
ratio={$>,if($3==1,max($1/w,$2/h),min($1/w,$2/h))}
-r[$>] {$>,w*$ratio},{$>,h*$ratio},100%,100%,$4
-done
-if {$3==2} -r $1,$2,100%,100%,0,0,0.5,0.5 -endif
-v +
#@gmic r2dx : eq. to '-resize2dx'.
r2dx :
-v - _gmic_s="$?" -v +
-_resize2dx $*
#@gmic resize2dx : width[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the x-axis, preserving 2d ratio.
#@gmic : (eq. to '-r2dx').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize2dx 100,2 -append x
resize2dx :
-v - _gmic_s="$?" -v +
-_$0 $*
_resize2dx : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
-e[0--3] "Resize 2d image"$_gmic_s" to $1 pixels along the x-axis, preserving 2d ratio."
-v - -repeat $! -l[$>]
size={if(${-is_percent\ $1},$1*w,$1)}
-r {max(1,$size)},{max(1,h*$size/w)},100%,100%,${2-7}
-endl -done -v +
#@gmic r2dy : eq. to '-resize2dy'.
r2dy :
-v - _gmic_s="$?" -v +
-_resize2dy $*
#@gmic resize2dy : height[%]>=0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the y-axis, preserving 2d ratio.
#@gmic : (eq. to '-r2dy').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize2dy 100,2 -append x
resize2dy :
-v - _gmic_s="$?" -v +
-_$0 $*
_resize2dy : -check "$1>=0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
-e[0--3] "Resize 2d image"$_gmic_s" to $1 pixels along the y-axis, preserving 2d ratio."
-v - -repeat $! -l[$>]
size={if(${-is_percent\ $1},$1*h,$1)}
-r {max(1,w*$size/h)},{max(1,$size)},100%,100%,${2-7}
-endl -done -v +
#@gmic r3dx : eq. to '-resize3dx'.
r3dx :
-v - _gmic_s="$?" -v +
-_resize3dx $*
#@gmic resize3dx : width[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the x-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dx').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dx :
-v - _gmic_s="$?" -v +
-_$0 $*
_resize3dx : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
-e[0--3] "Resize 3d image"$_gmic_s" to $1 pixels along the x-axis, preserving 3d ratio."
-v - -repeat $! -l[$>]
size={if(${-is_percent\ $1},$1*w,$1)}
-r {max(1,$size)},{max(1,h*$size/w)},{max(1,d*$size/w)},100%,${2-7}
-endl -done -v +
#@gmic r3dy : eq. to '-resize3dy'.
r3dy :
-v - _gmic_s="$?" -v +
-_resize3dy $*
#@gmic resize3dy : height[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the y-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dy').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dy :
-v - _gmic_s="$?" -v +
-_$0 $*
_resize3dy : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
-e[0--3] "Resize 3d image"$_gmic_s" to $1 pixels along the y-axis, preserving 3d ratio."
-v - -repeat $! -l[$>]
size={if(${-is_percent\ $1},$1*h,$1)}
-r {max(1,w*$size/h)},{max(1,$size)},{max(1,d*$size/h)},100%,${2-7}
-endl -done -v +
#@gmic r3dz : eq. to '-resize3dz'.
r3dz :
-v - _gmic_s="$?" -v +
-_resize3dz $*
#@gmic resize3dz : depth[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the z-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dz').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dz :
-v - _gmic_s="$?" -v +
-_$0 $*
_resize3dz : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
-e[0--3] "Resize 3d image"$_gmic_s" to $1 pixels along the z-axis, preserving 3d ratio."
-v - -repeat $! -l[$>]
size={if(${-is_percent\ $1},$1*d,$1)}
-r[$>] {max(1,w*$size/d)},{max(1,h*$size/d)},{max(1,$size)},100%,${2-7}
-endl -done -v +
#@gmic rotate : angle,_interpolation,_boundary,_center_x[%],_center_y[%],_zoom : (+)
#@gmic : Rotate selected images with specified angle (in deg.).
#@gmic : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : When rotation center is specified, the size of the image is preserved.
#@gmic : Default values: 'interpolation=1', 'boundary=0', 'center_x=center_y=(undefined)' and 'zoom=1'.
#@gmic : $ image.jpg --rotate -25,1,2,50%,50%,0.6 -rotate[0] 25
#@gmic rotate_tileable : angle,_max_size_factor>=0
#@gmic : Rotate selected images by specified angle and make them tileable.
#@gmic : If resulting size of an image is too big, the image is replaced by a 1x1 image.
#@gmic : Default values: 'max_size_factor=8'.
rotate_tileable : -check ${2=8}>=0
-e[^-1] "Rotate image$? with angle $1 deg. and make them tileable."
-v -
angle={$1%360}
-if {$angle>=270} -rotate 270 angle-=270
-elif {$angle>=180} -rotate 180 angle-=180
-elif {$angle>=90} -rotate 90 angle-=90
-endif
(0,1;1,8;1,7;1,6;1,5;1,4;1,5;1,3;2,5;1,2;2,5;3,5;2,3;3,4;4,5;1,1;5,4;7,5;3,2;8,5;9,5;2,1;3,1;4,1;5,1;6,1;7,1;8,1)
-s. x,2 --/[-2,-1] -atan. -*. {180/pi}
($angle) -index. [-2] -rm..
p={-3,@{^}} q={-2,@{^}} -rm[-3--1]
-if {!$p||!$q} -return -endif
-repeat $! -l[$>]
theta={atan2($p,$q)}
gcd=${-gcd" "{h*$q},{w*$p}}
pw={h*$q/$gcd}
nw={round($pw*w/cos($theta))}
gcd=${-gcd" "{h*$p},{w*$q}}
qh={w*$q/$gcd}
nh={round($qh*h/cos($theta))}
-if {!$2" || "($nw<$2*w" && "$nh<$2*h)}
-r {1.5*$nw},{1.5*$nh},1,100%,0,2
-rotate {$theta*180/pi},1,2,50%,50%
-r $nw,$nh,1,100%,0,2,0.5,0.5
-else -v + -error[0--4] "Command '-rotate_tileable': Invalid image dimension "({w},{h},{d},{s}).
-endif
-endl -done -v +
#@gmic rows : { [image0] | y0[%] },_{ [image1] | y1[%] } : (+)
#@gmic : Keep only specified rows of selected images.
#@gmic : Dirichlet boundary is used when specified rows are out of range.
#@gmic : $ image.jpg -rows -25%,50%
#@gmic scale2x
#@gmic : Resize selected images using the Scale2x algorithm.
#@gmic : $ image.jpg -threshold 50% -resize 50%,50% --scale2x
scale2x :
-e[^-1] "Double xy-dimensions of image$?, using Scale2x algorithm."
-v - -repeat $! -l[$>]
-r 200%,200%
-f "dx=x&1;dy=y&1;A=j(0,-2,0,0,0,1);B=j(2,0,0,0,0,1);C=j(-2,0,0,0,0,1);D=j(0,2,0,0,0,1);"\
"!dy*(!dx*if(C==A&&C!=D&&A!=B,A,i) + dx*if(A==B&&A!=C&&B!=D,B,i)) + dy*(dx*if(B==D&&B!=A&&D!=C,D,i) + !dx*if(D==C&&D!=B&&C!=A,C,i))"
-endl -done -v +
#@gmic scale3x
#@gmic : Resize selected images using the Scale3x algorithm.
#@gmic : $ image.jpg -threshold 50% -resize 33%,33% --scale3x
scale3x :
-e[^-1] "Triple xy-dimensions of image$?, using Scale3x algorithm."
-v - -repeat $! -l[$>]
-r 300%,300%
-f "dx=x%3;dy=y%3;c0=!dx;c1=(dx==1);c2=(dx==2);"\
"A=j(-3,-3,0,0,0,1);B=j(0,-3,0,0,0,1);C=j(3,-3,0,0,0,1);"\
"D=j(-3,0,0,0,0,1);F=j(3,0,0,0,0,1);"\
"G=j(-3,3,0,0,0,1);H=j(0,3,0,0,0,1);I=j(3,3,0,0,0,1);"\
"!dy*(c0*if(D==B&&D!=H&&B!=F,D,i) + c1*if((D==B&&D!=H&&B!=F&&i!=C)||(B==F&&B!=D&&F!=H&&i!=A),B,i) + c2*if(B==F&&B!=D&&F!=H,F,i)) + "\
"(dy==1)*(c0*if((H==D&&H!=F&&D!=B&&i!=A)||(D==B&&D!=H&&B!=F&&i!=G),D,i) + c1*i + c2*if((B==F&&B!=D&&F!=H&&i!=I)||(F==H&&F!=B&&H!=D&&i!=C),F,i)) + "\
"(dy==2)*(c0*if(H==D&&H!=F&&D!=B,D,i) + c1*if((F==H&&F!=B&&H!=D&&i!=G)||(H==D&&H!=F&&D!=B&&i!=I),H,i) + c2*if(F==H&&F!=B&&H!=D,F,i))"
-endl -done -v +
#@gmic scale_dcci2x : _edge_threshold>=0,_exponent>0,_extend_1px={ 0=false | 1=true }
#@gmic : Double image size using directional cubic convolution interpolation,
#@gmic : as described in https://en.wikipedia.org/wiki/Directional_Cubic_Convolution_Interpolation.
#@gmic : Default values: 'edge_threshold=1.15', 'exponent=5' and 'extend_1px=0'.
#@gmic : $ image.jpg --scale_dcci2x ,
scale_dcci2x : -check "${1=1.15}>=0 && ${2=5}>=0" -skip ${3=0}
-e[^-1] "Double xy-dimensions of image$?, using DCCI2x algorithm."
-v - -repeat $! -l[$>]
a={-1/16} b={9/16} whd={w},{h},{d} s={s}
(0,-1;1,0) --convolve[0] [1] -mirror[1] x --convolve[0] [1] -rm[1] -abs[^0]
3,3,1,1,1 -convolve[-3,-2] [-1] -rm. -r[-2,-1] $whd,1,2 -r[-2,-1] $whd,$s
($a,$b,$b,$a) -diagonal. --convolve[0] [-1] -mirror[-2] x --convolve[0] [-2] -rm[-3]
--+[1,2] 1 -/[-2,-1]
-_scale_dcci2x_smooth[-5,-4] [-3],[-2],$2 -_scale_dcci2x_mask[-4--1] $1
--g[0] x,-1 --g[0] y,1 --g[1] xy,-1 -abs[-4--1]
(1,1;1,1) -convolve[-5] [-1] -rm. (1,1,1) -convolve[-4] [-1] -rm.
(1;1;1) -convolve[-3] [-1] -rm. (0,1,1;0,1,1) -convolve[-2] [-1] -rm.
-+[-3,-1] -+[-3,-1] -r[-2,-1] $whd,1,2 -r[-2,-1] $whd,$s
($a;$b;$b;$a) --convolve[0] [-1] -rm[-2] (0,$a,$b,$b,$a) --convolve[1] [-1] -rm[-2]
--+[2,3] 1 -/[-2,-1]
-_scale_dcci2x_smooth[-5,-4] [-3],[-2],$2 -_scale_dcci2x_mask[-4--1] $1
--g[0] x,1 --g[0] y,-1 --g[1] xy,-1 -abs[-4--1]
(1;1;1) -convolve[-5] [-1] -rm. (1,1;1,1) -convolve[-4] [-1] -rm.
(0,0;1,1;1,1) -convolve[-3] [-1] -rm. (1,1,1) -convolve[-2] [-1] -rm.
-+[-3,-1] -+[-3,-1] -r[-2,-1] $whd,1,2 -r[-2,-1] $whd,$s
(0;$a;$b;$b;$a) --convolve[1] [-1] -rm[-2] ($a,$b,$b,$a) --convolve[0] [-1] -rm[-2]
--+[3,4] 1 -/[-2,-1]
-_scale_dcci2x_smooth[-5,-4] [-3],[-2],$2 -_scale_dcci2x_mask[-4--1] $1
-r2dx 200%,4 -shift[1] 1,1 -shift[2] 0,1 -shift[3] 1 -+
-if {!$3} -r {w-1},{h-1},100%,100%,0 -endif
-endl -done -v +
_scale_dcci2x_smooth : -skip ${3=5}
-^[0,1] $3 -+[0,1] 1 --+[0,1] -/[0,1] [-1] -rm.
-pass$1 -pass$2 -*[0,-2] -*[1,-1] -+[0,1]
_scale_dcci2x_mask : -skip ${1=1.15}
--lt[-1] {1/$1} -gt[-2] $1 -*[-4] [-2] -*[-3] [-1]
-or[-2,-1] -not[-1] -*[-4,-1] -+[-3--1]
#@gmic seamcarve : _width[%]>=0,_height[%]>=0,_is_priority_channel={ 0 | 1 },_is_antialiasing={ 0 | 1 },_maximum_seams[%]>=0
#@gmic : Resize selected images with specified 2d geometry, using the seam-carving algorithm.
#@gmic : Default values: 'height=100%', 'is_priority_channel=0', 'is_antialiasing=1' and 'maximum_seams=25%'.
#@gmic : $ image.jpg --seamcarve 60%
seamcarve : -check "${2=100%}>=0 && ${5=25%}>=0" -skip ${3=0},${4=1}
-e[^-1] "Resize image$? to $1x$2 using seam-carving algorithm, "${-arg\ 1+!$3,with,without}" priority channel, "${-arg\ 1+!$4,with,without}" anti-aliasing and maximum seams $5."
-v - -repeat $! -l[$>]
nw={max(1,round(if(${-is_percent\ $1},$1*w,$1)))}
nh={max(1,round(if(${-is_percent\ $2},$2*h,$2)))}
-if {$nw!=w} -_seamcarve $nw,$3,$4,$5 -endif
-if {$nh!=h} -transpose -_seamcarve $nh,$3,$4,$5 -transpose -endif
-endl -done -v +
_seamcarve :
-do
max_seams={max(1,round(if(${-is_percent\ $4},$4*w,$4)))}
ssms={max(min(round($1-w),w),1-w)}
sms={min($max_seams,abs($ssms))}
-if $2 -s[0] c,{1-s} -/. 256 -endif
--gradient[0] -a[-2,-1] c -abs. -compose_channels. + -n. 0,1
-if $2 -+. [-2] -a[0,1] c -endif
-if $3 100%,1,1,1,x -r. [0],[0] -a[0,-1] c -endif
[-1]
-repeat {h}
--rows. {$<+1} -erode. 3
-j.. [-1],0,$<,0,0,-1 -rm.
-done
100%,100% --rows[1] 0
-nm[1] grad -nm[2] low -nm[3] seam -nm[4] top
-repeat {0,h-1} nr={$>+1}
--rows[low] $nr
--*[4,5] --shift[4] 1 -*. [5] --shift[5] 1 -*. [4]
-+[-2,-1] -j[5] [4] -a[-3--1] c
-f. ">if(c,i,max(j(-1)+j(0,0,0,1),j(-2)+j(0,0,0,2)))"
-s. c -shift... 1 -+.. [-3] -shift... 1 -+[-3,-1]
->[-2,-1] -f. "<if(j(1)<0,1,-i)"
-j[seam] [-1],0,$>
-a[-2,-1] c -f. "j(i,0,0,-1)" -channels. 1
--rows[grad] $nr -+[top,-1]
-done
max={iM*2} -repeat $sms -=. $max,{xm} -done
-j[grad] [-1],0,100% -rm[low,top] -a[-2,-1] c
-f. "<if(c,i,j(j(0,0,0,1),1,0,0,0,1))" -channels. 0
-+[0] 0.1 -!=. $max
w={w} h={h} s={0,s}
-if {$ssms<0} -* -discard 0 -r {$w-$sms},$h,1,$s,-1
-elif {$ssms>0}
--. 2 -s[0] c
-repeat $s -if {$><($s-1)} [-1] -endif -a[$>,-1] c -done
-permute cxyz -a c -discard -1 -f "if(i<0,j(0,-1),i)"
-r {$w+$sms},$h,1,$s,-1
-endif
-if $3
-s c,{1-s} -gradient. x,1 -round -!=. 1
(0.5,0.5) --convolve[0] [-1] -rm..
-j[0] [-1],0,0,0,0,1,[1] -rm[-2,-1]
-endif
-rprogress {a=w/$1;if(a<1,a*100,100/a)}
-while {w!=$1}
#@gmic shift : vx[%],_vy[%],_vz[%],_vc[%],_boundary : (+)
#@gmic : Shift selected images by specified displacement vector.
#@gmic : Displacement vector can be non-integer in which case linear interpolation of the shift is computed.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --shift[0] 50%,50%,0,0,0 --shift[0] 50%,50%,0,0,1 --shift[0] 50%,50%,0,0,2
#@gmic shrink_x : size_x>=0
#@gmic : Shrink selected images along the x-axis.
#@gmic : $ image.jpg -shrink_x 30
shrink_x : -check "$1>=0"
-e[^-1] "Shrink image$? along the x-axis with size $1."
-v - -repeat $! -z[$>] $1,{$>,w-$1-1} -done -v +
#@gmic shrink_xy : size>=0
#@gmic : Shrink selected images along the xy-axes.
#@gmic : $ image.jpg -shrink_xy 30
shrink_xy : -check "$1>=0"
-e[^-1] "Shrink image$? along the xy-axes with size $1."
-v - -repeat $! -z[$>] $1,$1,{$>,w-$1-1},{$>,h-$1-1} -done -v +
#@gmic shrink_xyz : size>=0
#@gmic : Shrink selected images along the xyz-axes.
shrink_xyz : -check "$1>=0"
-e[^-1] "Shrink image$? along the xyz-axes with size $1."
-v - -repeat $! -z[$>] $1,$1,$1,{$>,w-$1-1},{$>,h-$1-1},{$>,d-$1-1} -done -v +
#@gmic shrink_y : size_y>=0
#@gmic : Shrink selected images along the y-axis.
#@gmic : $ image.jpg -shrink_y 30
shrink_y : -check "$1>=0"
-e[^-1] "Shrink image$? along the y-axis with size $1."
-v - -repeat $! -z[$>] 0,$1,100%,{$>,h-$1-1} -done -v +
#@gmic shrink_z : size_z>=0
#@gmic : Shrink selected images along the z-axis.
shrink_z : -check "$1>=0"
-e[^-1] "Shrink image$? along the z-axis with size $1."
-v - -repeat $! -z[$>] 0,0,$1,100%,100%,{$>,d-$1-1} -done -v +
#@gmic slices : { [image0] | z0[%] },_{ [image1] | z1[%] } : (+)
#@gmic : Keep only specified slices of selected images.
#@gmic : Dirichlet boundary is used when specified slices are out of range.
#@gmic sort : _ordering={ + | - },_axis={ x | y | z | c } : (+)
#@gmic : Sort pixel values of selected images.
#@gmic : If 'axis' is specified, the sorting is done according to the data of the first column/row/slice/channel
#@gmic : of selected images.
#@gmic : Default values: 'ordering=+' and 'axis=(undefined)'.
#@gmic : $ 64 -rand 0,100 --sort -display_graph 400,300,3
#@gmic s : eq. to '-split'. : (+)
#@gmic split : { x | y | z | c }..{ x | y | z | c },_split_mode : keep_splitting_values={ + | - },_{ x | y | z | c }..{ x | y | z | c },value1,_value2,... : (no args) : (+)
#@gmic : Split selected images along specified axes, or regarding to a sequence of scalar values (optionally along specified axes too).
#@gmic : (eq. to '-s').
#@gmic : 'split_mode' can be { 0=split according to constant values | >0=split in N parts | <0=split in parts of size -N }.
#@gmic : Default value: 'split_mode=-1'.
#@gmic : $ image.jpg -split c
#@gmic : $ image.jpg -split y,3
#@gmic : $ image.jpg -split x,-128
#@gmic : $ 1,20,1,1,"1,2,3,4" --split -,2,3 -append[1--1] y
#@gmic : $ (1,2,2,3,3,3,4,4,4,4) --split x,0 -append[1--1] y
#@gmic split_tiles : M!=0,_N!=0,_is_homogeneous={ 0 | 1 }
#@gmic : Split selected images as a MxN array of tiles.
#@gmic : If M or N is negative, it stands for the tile size instead.
#@gmic : Default values: 'N=M' and 'is_homogeneous=0'.
#@gmic : $ image.jpg --local -split_tiles 5,4 -blur 3,0 -sharpen 700 -append_tiles 4,5 -endlocal
split_tiles : -skip ${2=$1},${3=0}
-if $3 -e[^-1] "Split image$? as a $1x$2 array of homogeneous tiles."
-else -e[^-1] "Split image$? as a $1x$2 array of tiles."
-endif
-v - -repeat $! -l[$<] -s y,$2 -s x,$1 -if $3 -r [0],[0],100%,100%,0 -endif -endl -done -v +
#@gmic y : eq. to '-unroll'. : (+)
#@gmic unroll : _axis={ x | y | z | c } : (+)
#@gmic : Unroll selected images along specified axis.
#@gmic : (eq. to '-y').
#@gmic : Default value: 'axis=y'.
#@gmic : $ (1,2,3;4,5,6;7,8,9) --unroll y
#@gmic upscale_smart : width[%],_height[%],_depth,_smoothness>=0,_anisotropy=[0,1],sharpening>=0
#@gmic : Upscale selected images with an edge-preserving algorithm.
#@gmic : Default values: 'height=100%', 'depth=100%', 'smoothness=2', 'anisotropy=0.4' and 'sharpening=10'.
#@gmic : $ image.jpg -resize2dy 100 --upscale_smart 500%,500% -append x
upscale_smart : -skip ${2=100%},${3=100%} -check "${4=2}>=0 && ${5=0.4}>=0 && $5<=1 && ${6=10}>=0"
-e[^-1] "Upscale image$? to $1x$2x$3, with smoothness $4, anisotropy $5 and sharpening $6."
-v - -repeat $! -l[$>]
w={w} h={h}
--r. $1,$2,$3,1,0
-if {w<$w" && "h<$h}
-rm. -r. $1,$2,$3,100%,2
-else
-rm. --diffusiontensors 0,$5,1.2,1.2
-r[-2,-1] $1,$2,$3,100%,5
-smooth.. [-1],$4 -rm.
-ac "-sharpen. $6,10",ycbcr_y
-endif
-endl -done -v +
#@gmic warp : [warping_field],_mode,_interpolation,_boundary,_nb_frames>0 : (+)
#@gmic : Warp selected image with specified displacement field.
#@gmic : 'mode' can be { 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=forward-relative }.
#@gmic : 'interpolation' can be { 0=nearest-neighbor | 1=linear | 2=cubic }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=periodic }.
#@gmic : Default values: 'mode=0', 'interpolation=1', 'boundary=1' and 'nb_frames=1'.
#@gmic : $ image.jpg 100%,100%,1,2,'X=x/w-0.5;Y=y/h-0.5;R=(X*X+Y*Y)^0.5;A=atan2(Y,X);130*R*if(c==0,cos(4*A),sin(8*A))' -warp.. [-1],1,1,0 -quiver. [-1],10,0.2,1,1,100
#@gmic : $$
#@gmic :: Filtering
#@gmic bandpass : _min_freq[%],_max_freq[%]
#@gmic : Apply bandpass filter to selected images.
#@gmic : Default values: 'min_freq=0' and 'max_freq=20%'.
#@gmic : $ image.jpg -bandpass 1%,3%
#@gmic : $$
bandpass : -skip ${1=0},${2=20%}
-e[^-1] "Apply bandpass filter [$1,$2] to image$?."
-v - -repeat $! -l[$>]
100%,100%,100% -f. "sqrt((x/w-0.5)^2 + (y/h-0.5)^2 + (z/d-0.5)^2)"
-n. 0,1 -ir. $1,$2 -shift. {int(w/2)},{int(h/2)},{int(d/2)},0,2
-fft.. -*... [-1] -*[-2,-1] -ifft -rm.
-endl -done -v +
#@gmic bilateral : [guide],std_variation_s>0[%],std_variation_r[%]>0,_sampling_s>=0,_sampling_r>=0 : std_variation_s>0[%],std_variation_r[%]>0,_sampling_s>=0,_sampling_r>=0 : (+)
#@gmic : Blur selected images by anisotropic (eventually joint/cross) bilateral filtering.
#@gmic : If a guide image is provided, it is used for drive the smoothing filter.
#@gmic : A guide image must be of the same xyz-size as the selected images.
#@gmic : Set 'sampling' arguments to '0' for automatic adjustment.
#@gmic : $ image.jpg [0] -repeat 5 -bilateral. 10,10 -done
#@gmic b : eq. to '-blur'. : (+)
#@gmic blur : std_variation>=0[%],_boundary,_kernel : axes,std_variation>=0[%],_boundary,_kernel : (+)
#@gmic : Blur selected images by a quasi-gaussian or gaussian filter (recursive implementation).
#@gmic : (eq. to '-b').
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann } and 'kernel' can be { 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@gmic : Specifying one axis multiple times apply also the blur multiple times.
#@gmic : Default values: 'boundary=1' and 'kernel=0'.
#@gmic : $ image.jpg --blur 5,0 --blur[0] 5,1
#@gmic : $ image.jpg --blur y,10%
#@gmic : $$
#@gmic blur_angular : amplitude[%],_center_x[%],_center_y[%]
#@gmic : Apply angular blur on selected images.
#@gmic : Default values: 'center_x=center_y=50%'.
#@gmic : $ image.jpg --blur_angular 2%
#@gmic : $$
blur_angular : -skip ${2=50%},${3=50%}
-e[^-1] "Apply angular blur on image$?, with amplitude $1 and center point ($2,$3)."
-v - -euclidean2polar $2,$3,1.3,1 -expand_y 16,2 -blur_y $1 -shrink_y 16 -polar2euclidean $2,$3,1.3,1 -v +
#@gmic blur_linear : amplitude1[%],_amplitude2[%],_angle,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Apply linear blur on selected images, with specified angle and amplitudes.
#@gmic : Default values: 'amplitude2=0', 'angle=0' and 'boundary=1'.
#@gmic : $ image.jpg --blur_linear 10,0,45
#@gmic : $$
blur_linear : -skip ${2=0},${3=0},${4=1}
-e[^-1] "Apply linear blur on image$?, with angle $3 deg. and amplitudes ($1,$2)."
-v -
std1={if(${-is_percent\ $1},$1*max(w,h),$1)}
std2={if(${-is_percent\ $2},$2*max(w,h),$2)}
stdM={round(1.25*max($std1,$std2))}
-if {$stdM<=0} -return -endif
-repeat $! -l[$>]
-expand_xy $stdM,{$4!=0}
{2*$stdM},{2*$stdM} -gaussian. $1,$2,$3 -normalize_sum.
-convolve_fft[0] [1] -rm. -shrink_xy $stdM
-endl -done -v +
#@gmic blur_radial : amplitude[%],_center_x[%],_center_y[%]
#@gmic : Apply radial blur on selected images.
#@gmic : Default values: 'center_x=center_y=50%'.
#@gmic : $ image.jpg --blur_radial 2%
#@gmic : $$
blur_radial : -skip ${2=50%},${3=50%}
-e[^-1] "Apply radial blur on image$?, with amplitude $1 and center point ($2,$3)."
-v - -euclidean2polar $2,$3,5,1 -blur_x $1 -polar2euclidean $2,$3,5,1 -v +
#@gmic blur_selective : sigma>=0,_edges>0,_nb_scales>0
#@gmic : Blur selected images using selective gaussian scales.
#@gmic : Default values: 'sigma=5', 'edges=0.5' and 'nb_scales=5'.
#@gmic : $ image.jpg -noise 20 -cut 0,255 --local. -repeat 4 -blur_selective , -done -endlocal
#@gmic : $$
blur_selective : -check "${1=5}>=0 && ${2=0.5}>=0 && isint(${3=5}) && $3>0"
-e[^-1] "Blur image$? using $3 selective gaussian scales, with sigma $1 and edges $2."
-v - -repeat $! -l[$>] nm={0,n}
--gradient_norm -+. 1 -^. {-max(0.01,$2)} -quantize. {$3+1},0,1 -min. {$3-1} -r. [-2]
-repeat $3 --==. $> -*. [-3] -+[-2,-1] -b.. {$1/($3+1)} -done
-rm.. -nm $nm -endl -done -v +
#@gmic blur_x : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the x-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_x 6
#@gmic : $$
blur_x : -skip ${2=1}
-e[^-1] "Blur image$? along the x-axis, with sigma $1 and "${-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
-v - -deriche $1,0,x,$2 -v +
#@gmic blur_xy : amplitude_x[%],amplitude_y[%],_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the X and Y axes.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_xy 6
#@gmic : $$
blur_xy : -skip ${2=$1},${3=1}
-e[^-1] "Blur image$? along the xy-axes, with sigma $1 and "${-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
-v - -deriche $1,0,x,$3 -deriche $2,0,y,$3 -v +
#@gmic blur_xyz : amplitude_x[%],amplitude_y[%],amplitude_z,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the X, Y and Z axes.
#@gmic : Default value: 'boundary=1'.
#@gmic : $$
blur_xyz : -skip ${4=1}
-e[^-1] "Blur image$? along the xyz-axes, with sigma $1 and "${-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
-v - -deriche $1,0,x,$4 -deriche $2,0,y,$4 -deriche $3,0,z,$4 -v +
#@gmic blur_y : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the y-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_y 6
#@gmic : $$
blur_y : -skip ${2=1}
-e[^-1] "Blur image$? along the y-axis, with sigma $1 and "${-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
-v - -deriche $1,0,y,$2 -v +
#@gmic blur_z : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the z-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $$
blur_z : -skip ${2=1}
-e[^-1] "Blur image$? along the z-axis, with sigma $1 and "${-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
-v - -deriche $1,0,z,$2 -v +
#@gmic boxfilter : size>=0[%],_order,_boundary : axes,size>=0[%],_order,_boundary : (+)
#@gmic : Blur selected images by a box filter of specified size (recursive implementation).
#@gmic : 'order' can be { 0=smooth | 1=1st-derivative | 2=2nd-derivative }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann } and 'kernel' can be { 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : When specified, argument 'axes' is a sequence of { x | y | z | c }.
#@gmic : Specifying one axis multiple times apply also the blur multiple times.
#@gmic : Default values: 'order=0' and 'boundary=1'.
#@gmic : $ image.jpg --boxfilter 5%
#@gmic : $ image.jpg --boxfilter y,3,1
#@gmic compose_freq
#@gmic : Compose selected low and high frequency parts into new images.
#@gmic : $ image.jpg -split_freq 2% -mirror. x -compose_freq
compose_freq :
-e[^-1] "Compose low and high frequency part$? into new images."
-v - -repeat {int($!/2)} -+[$>,{$>+1}] -done -v +
#@gmic convolve : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Convolve selected images by specified mask.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg (0,1,0;1,-4,1;0,1,0) -convolve.. [-1] -keep..
#@gmic : $ image.jpg (0,1,0) -resize. 130,1,1,1,3 --convolve[0] [1]
#@gmic : $$
#@gmic convolve_fft : [mask]
#@gmic : Convolve selected images with specified mask, in the fourier domain.
#@gmic : $ image.jpg 100%,100% -gaussian. 20,1,45 --convolve_fft[0] [1]
convolve_fft : -check ${-is_image_arg\ $1}
-e[^-1] "Convolve image$? with mask $1, in the fourier domain."
-v - -repeat $! -pass$1 0 -l[$>,-1]
w2={0,int(w/2)} h2={0,int(h/2)} d2={0,int(d/2)}
-r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 -shift[1] -$w2,-$h2,-$d2,0,2
-fft[0] -fft[2]
--*[-4] [-1] --*[-4] [-3] -+[-2,-1]
-*[-5,-3] -*[-3,-2] --[-3,-2]
-ifft -rm.
-endl -done -v +
#@gmic correlate : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Correlate selected images by specified mask.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg (0,1,0;1,-4,1;0,1,0) -correlate.. [-1] -keep..
#@gmic : $ image.jpg --crop 40%,40%,60%,60% --correlate[0] [-1],0,1
#@gmic cross_correlation : [mask]
#@gmic : Compute cross-correlation of selected images with specified mask.
#@gmic : $ image.jpg --shift -30,-20 --cross_correlation[0] [1]
cross_correlation : -check ${-is_image_arg\ $1}
-e[^-1] "Compute cross-correlation of image$? with mask $1."
-v - -repeat $! -pass$1 0 -l[$>,-1]
-norm -fft.. -fft. [-2,-1] -*.. [-5] -*. [-6]
--[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] -ifft -rm.
-endl -done -v +
#@gmic curvature
#@gmic : Compute isophote curvatures on selected images.
#@gmic : $ image.jpg -blur 10 -curvature
curvature :
-e[^-1] "Compute isophote curvatures on image$?."
-v - -repeat $! -l[$>]
-if {d==1}
--g xy,0 -hessian... xxxyyy
-*... [-2] -*[-4] [-1] -*[-4] -2
-+[-4,-3] -*... [-2]
-sqr[-2,-1] -*[-4] [-1] -+[-4,-3]
-+[-2,-1] -+. 0.1 -^. 1.5 -/
-else
--inn --gradient_norm.. -laplacian...
--[-3,-2] -+. 0.1 -/[-2,-1]
--inn. -laplacian.. --
-endif
-endl -done -v +
#@gmic dct : _{ x | y | z }..{ x | y | z } : (no arg)
#@gmic : Compute the discrete cosine transform of selected images,
#@gmic : optionally along the specified axes only.
#@gmic : Default values: (no arg)
#@gmic : $ image.jpg --dct --idct. -abs.. -+.. 1 -log..
#@gmic : $$ _dct-and-idct
dct : -skip ${1=0}
-v - ({'"$1"'})
is_axes={im>=_'x'" && "iM<=_'z'}
-if $is_axes
-v + -e[0--3] "Compute discrete cosine transform of image$? along axes '$1'." -v -
-repeat {w}
axis={i[$>]}
-if {$axis==_'x'} -repeat {$!-1} -l[$>] -if {w>1} -_dct -endif -endl -done
-elif {$axis==_'y'} -repeat {$!-1} -l[$>] -if {h>1} -permute yxzc -_dct -permute yxzc -endif -endl -done
-elif {$axis==_'z'} -repeat {$!-1} -l[$>] -if {d>1} -permute zxyc -_dct -permute yzxc -endif -endl -done
-endif
-done
-else
-rm.
-v + -e[0--3] "Compute discrete cosine transform of image$?." -v -
-noarg
-repeat $! -l[$>]
-if {w>1} -_dct -endif
-if {h>1} -permute yxzc -_dct -permute yxzc -endif
-if {d>1} -permute zxyc -_dct -permute yzxc -endif
-endl -done
-endif
-v +
_dct :
is_odd={w%2}
-if $is_odd -r {w+1},100%,100%,100%,0,1 -endif
-s x -l[1--1:2] -a x -mirror x -endl -mv[1] $! -a x
-fft x
100%,1,1,1,2*cos(-x*pi/(2*w)) -*[0,2]
100%,1,1,1,2*sin(-x*pi/(2*w)) -*[1,2]
--
-if $is_odd -r {w-1},100%,100%,100%,0 -endif
--z[0] 0,0 -/. {sqrt(2)} -j.. [-1],0,0,0 -rm. -* {sqrt(2/w)}
#@gmic deblur : amplitude[%]>=0,_nb_iter>=0,_dt>=0,_regul>=0,_regul_type={ 0=Tikhonov | 1=meancurv. | 2=TV }
#@gmic : Deblur image using a regularized Jansson-Van Cittert algorithm.
#@gmic : Default values: 'nb_iter=10', 'dt=20', 'regul=0.7' and 'regul_type=1'.
#@gmic : $ image.jpg -blur 3 --deblur 3,40,20,0.01
deblur : -check "${2=10}>=0 && ${3=20}>=0 && ${4=0.7}>=0" -skip ${5=1}
-e[^-1] "Deblur image$? with a regularized Jansson-Van Cittert algorithm, with sigma $1, $2 iterations, time step $3 and regularization $4." -v -
-repeat $! -l[$>] nm={0,n}
[0]
-repeat $2
-if {$5>=2} --curvature.
-elif {$5>=1} --iee.
-else --laplacian.
-endif
-*. $4
--b.. $1 --. [-4]
--[-2,-1]
-*. {$3/(0.0001+max(abs(im),abs(iM)))}
-+[-2,-1]
-done
-rm..
-nm $nm -endl -done -v +
#@gmic deblur_goldmeinel : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur selected images using Gold-Meinel algorithm
#@gmic : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_goldmeinel. 1
deblur_goldmeinel : -check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1}
-e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${-arg\ 1+!$4,"",quasi-}"gaussian kernel."
-v - -repeat $! -l[$>]
[0] -repeat $2
--b. $1,1,$4 --/[0,-1] -rm.. -^. $3 -*[-1,-2]
-done -rm[0]
-endl -done -v +
#@gmic deblur_richardsonlucy : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur selected images using Richardson-Lucy algorithm.
#@gmic : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_richardsonlucy. 1
deblur_richardsonlucy : -check "$1>=0 && ${2=50}>=0" -skip ${3=1}
-e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${-arg\ 1+!$3,"",quasi-}"gaussian kernel."
-v - -repeat $! -l[$>]
[0] -repeat $2
--b. $1,1,{$3!=0} -max. 1e-6 --/[0,-1] -rm.. -b. $1,1,{$3!=0} -*[-1,-2]
-done -rm[0]
-endl -done -v +
#@gmic deconvolve_fft :  [kernel],_regularization>=0
#@gmic : Deconvolve selected images by specified mask in the fourier space.
#@gmic : Default value: 'regularization>=0'.
#@gmic : $ image.jpg --gaussian 5 --convolve_fft[0] [1] --deconvolve_fft. [1]
deconvolve_fft : -check ${-is_image_arg\ $1}" && ${2=.001}>=0"
-e[^-1] "Deconvolve image$? with mask $1 and regularization $2, in the fourier domain."
-v - -repeat $! -pass$1 0 -l[$>,-1]
w2={0,int(w/2)} h2={0,int(h/2)} d2={0,int(d/2)}
-r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 -shift[1] -$w2,-$h2,-$d2,0,2
-fft[0] -fft[2]
--l[-1,-2] -sqr -+ -+ $2 -endl
--*[-4] [-3]
--*[-6] [-3]
--[-2,-1]
-*[-6,-4]
-*[-4,-3]
-+[-4,-3]
-/. [-2] -/[-3,-2]
-ifft -rm.
-endl -done -v +
#@gmic deinterlace : _method={ 0 | 1 }
#@gmic : Deinterlace selected images ('method' can be { 0=standard or 1=motion-compensated }).
#@gmic : Default value: 'method=0'.
#@gmic : $ image.jpg --rotate 3,1,1,50%,50% -resize 100%,50% -resize 100%,200%,1,3,4 -shift. 0,1 -add --deinterlace 1
deinterlace : -skip ${1=0}
-e[^-1] "Deinterlace image$? with "${-arg\ 1+!$1,motion-compensated,standard}" method."
-v - -repeat $! -l[$>]
wh={w},{h}
-s y -a[0--1:2] y -a[^0] y -r.. [-1],0 -r 100%,200%,1,100%,5
-if {$1!=0} --displacement. [-2],0.05 -warp... [-1],1,1,1 -rm. -endif
-+ -/ 2 -c 0,255 -r $wh
-endl -done -v +
#@gmic denoise : std_variation_s>=0,_std_variation_p>=0,_patch_size>0,_lookup_size>0,_smoothness,_fast_approx={ 0 | 1 } : (+)
#@gmic : Denoise selected images by non-local patch averaging.
#@gmic : Default values: 'std_variation_p=10', 'patch_size=5', 'lookup_size=6' and 'smoothness=1'.
#@gmic : $ image.jpg --denoise 5,5,8
#@gmic denoise_haar : _threshold>=0,_nb_scales>=0,_cycle_spinning>0
#@gmic : Denoise selected image using haar-wavelet thresholding with cycle spinning.
#@gmic : Set 'nb_scales==0' to automatically determine the optimal number of scales.
#@gmic : Default values: 'threshold=1.4', 'nb_scale=0' and 'cycle_spinning=10'.
#@gmic : $ image.jpg -noise 20 -c 0,255 --denoise_haar. 0.8
denoise_haar : -check "${1=1.4}>=0 && isint(${2=0}) && $2>=0 && isint(${3=10}) && $3>0"
-e[^-1] "Denoise image$? using haar-wavelet thresholding, with threshold $1, "\
${-arg\ 1+($2>0),auto,$2}" scales and $3 spinning cycles."
-v - -repeat $! -l[$>] nm={0,n}
nb_scales={min(if($2,$2,32),int(log2(min(w,h))-1))}
w={w} h={h} d={d} sigma=${-std_noise}
-r {round(w,2^($nb_scales+1),1)},{round(h,2^($nb_scales+1),1)},{if(d==1,1,round(d,2^($nb_scales+1),1))},100%,0,0
--f 0
-repeat $3
dx={round(u(0,{4*$nb_scales}))}
dy={round(u(0,{4*$nb_scales}))}
dz={if($d==1,0,round(u(0,{4*$nb_scales})))}
--shift[0] $dx,$dy,$dz,0,2
-haar. $nb_scales
-threshold. {$1*$sigma},1
-ihaar. $nb_scales
-shift. {-$dx},{-$dy},{-$dz},0,2
-+[-2,-1]
-done
-rm[0] -/ $3 -r $w,$h,$d,100%,0
-nm $nm -endl -done -v +
#@gmic denoise_patchpca : _strength>=0,_patch_size>0,_lookup_size>0,_spatial_sampling>0
#@gmic : Denoise selected images using the patch-pca algorithm.
#@gmic : Default values: 'patch_size=7', 'lookup_size=11', 'details=1.8' and 'spatial_sampling=5'.
#@gmic : $ image.jpg --noise 20 -c. 0,255 --denoise_patchpca. ,
denoise_patchpca : -check "${1=1.8} && $1>=0 && isint(${2=7}) && $2>0 && isint(${3=11}) && $3>0 && isint(${4=5}) && $4>0"
-e[^-1] "Denoise image$? using patch-pca, with strength $1, patch size $2, lookup size $3 and spatial sampling $4."
-v - -repeat $! -l[$>]
N2={$2*$2} M2={$3*$3} stdnoise=${-std_noise}
100%,100%,1,100% -nm. aggreg
100%,100% -nm. weights
-f[0] "*
init(
n1 = int($2/2); n2 = $2 - n1 - 1;
m1 = int($3/2); m2 = $3 - m1 - 1;
patch(x,y) = crop(x-n1,y-n1,0,c,$2,$2,1,1,1);
ngauss(x) = exp(-x*x/(2*n1*n1));
zero = vector"$N2"(0);
mask = vector"$N2"(0);
for (l = 0; q = -n1, q<=n2, ++q,
for (p = -n1, p<=n2, ++p, mask[l++] = ngauss(p)*ngauss(q)
)
)
);
if (!(x%$4) && !(y%$4),
X = patch(x,y);
M = vector"{$N2*$N2}"(0);
for (q = -m1, q<=m2, ++q,
for (p = -m1, p<=m2, ++p,
Xk = patch(x + p,y + q) - X;
M += mul(Xk,Xk,"$N2");
)
);
M/="$M2";
eig = eig(M);
lambda = sqrt(abs(eig[0,"$N2"-1]));
for (k = 0, k<size(lambda) && lambda[k]>=$1*"$stdnoise", ++k);
Qt = eig["$N2",size(eig) - 1];
Q = transp(Qt,"$N2");
for (q = -m1, q<=m2, ++q,
for (p = -m1, p<=m2, ++p,
pY = Qt**(patch(x + p,y + q) - X);
copy(pY[k],zero[0],size(pY) - k);
(Y = Q**pY)+=X;
draw(#"$aggreg",Y,x + p - n1,y + q - n1,0,c,$2,$2,1,1,-1,mask);
draw(#"$weights",mask,x + p - n1,y + q - n1,0,c,$2,$2,1,1,-1);
)
);
0);0"
-max[weights] 0.01 -/[aggreg,weights] -k[aggreg]
-endl -done -v +
#@gmic deriche : std_variation>=0[%],order={ 0 | 1 | 2 },axis={ x | y | z | c },_boundary : (+)
#@gmic : Apply Deriche recursive filter on selected images, along specified axis and with
#@gmic : specified standard deviation, order and boundary conditions.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --deriche 3,1,x
#@gmic : $ image.jpg --deriche 30,0,x -deriche.. 30,0,y -add
#@gmic : $$
#@gmic dilate : size>=0 : size_x>=0,size_y>=0,size_z>=0 : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Dilate selected images by a rectangular or the specified structuring element.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_z=1', 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate 10
#@gmic dilate_circ : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply circular dilation of selected image by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate_circ 7
dilate_circ : -check $1>=0 -skip ${2=1},${3=0}
-e[^-1] "Apply circular dilation of image$? by size $1, boundary $2 and is_normalized $3."
-if {$1<2} -return -endif
-v - -shape_circle $1 -dilate[^-1] [-1],$2,$3 -rm. -v +
#@gmic dilate_oct : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply octagonal dilation of selected image by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate_oct 7
dilate_oct : -check $1>=0 -skip ${2=1},${3=0}
-e[^-1] "Apply octagonal dilation of image$? by size $1, boundary $2 and is_normalized $3."
-v -
-if {$1<2} -return -endif
-if {$1&1} ss={$1} -else ss={$1+1} -endif
-i[0] (0,1,0;1,1,1;0,1,0) -i[1] (1,1,1;1,1,1;1,1,1)
-repeat {$!-2}
r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
q={round(($ss-1)/(1+sqrt(2))/2)}
-if {$r>0} -repeat $r -dilate. [0],$2,$3 -done -endif
-if {$q>0} -repeat $q -dilate. [1],$2,$3 -done -endif
-mv. 2 -done -rm[0,1] -v +
_kr_circle :
-if {$1%2==0} -i 2,2,1,1,1 -else -i 1,1,1,1,1 -endif -r. $1,$1,1,1,0,0,0.5,0.5
-distance. 1 -round. 0.5 -ir. 0,{$1/2}
_jf_circle :
{round($1)},{round($1)}
center={0.5*(w-1)}
-f. 'sqrt((x-$center)^2+(y-$center)^2)'
-if {!(w%2)}
-round. 0.0001,-1
t1={sqrt(((round($1)-1)/2)^2+0.25)}
t2={sqrt(((round($1)+1)/2)^2+0.25)}
k={$1-round($1)+0.5}
t={$t1+($t2-$t1)*$k}
-ir. 0,$t
-else -ir. 0,{$1/2-0.25}
-endif
#@gmic dilate_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary
#@gmic : Dilate selected images in the (X,Y,Z,I) space.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary=1'.
dilate_threshold : -check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
-e[^-1] "Erode image$? with mask $1x$2x$3, threshold $4 and "${-arg\ $5,dirichlet,neumann}" boundary conditions."
-v - -l[]
dx1={int($1/2)} dx2={$1-$dx1-1}
dy1={int($2/2)} dy2={$2-$dy1-1}
dz1={int($3/2)} dz2={$3-$dz1-1}
(-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) -r $1,$2,$3,1,3 -a c -round -r {w*h*d},3,1,1,-1 -transpose.
-i.. 1,100%,1,1,254 1,100%,1,1,255 -a x
({'{^}'}) -rm.. -replace_str "254,","(v=j(" -replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,-1e20))" list={t}
-rm
-endl
-f 'max($list)'
-v +
#@gmic divergence
#@gmic : Compute divergence of selected vector fields.
#@gmic : $ image.jpg -luminance --gradient -append[-2,-1] c -divergence.
divergence :
-e[^-1] "Compute divergence of vector field$?."
-v - -repeat $! -l[$>]
-if {s==1} -g x,0
-elif {s==2} -s c -g.. x,0 -g. y,0 -+
-elif {s==3} -s c -g... x,0 -g.. y,0 -g. z,0 -+
-else -v + -error[] "Command '-divergence': Cannot compute divergence of image ["$>"] (has "{s}">3 channels)."
-endif
-endl -done -v +
#@gmic dog : _sigma1>=0[%],_sigma2>=0[%]
#@gmic : Compute difference of gaussian on selected images.
#@gmic : Default values: 'sigma1=2%' and 'sigma2=3%'.
#@gmic : $ image.jpg --dog 2,3
dog : -check "${1=2%}>=0 && ${2=3%}>=0"
-e[^-1] "Compute difference of gaussian on image$?, with standard deviations $1 and $2."
-v - -repeat $! -l[$>]
[0] -parallel "-b[0] $1","-b[1] $2" -- -norm
-endl -done -v +
#@gmic diffusiontensors : _sharpness>=0,0<=_anisotropy<=1,_alpha[%],_sigma[%],is_sqrt={ 0 | 1 }
#@gmic : Compute the diffusion tensors of selected images for edge-preserving smoothing algorithms.
#@gmic : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1' and 'is_sqrt=0'.
#@gmic : $ image.jpg -diffusiontensors 0.8 -abs -pow 0.2
#@gmic : $$
diffusiontensors : -check "${1=0.7}>=0 && ${2=0.3}>=0 && $2<=1" -skip ${3=0.6},${4=1.1},${5=0}
-e[^-1] "Compute diffusion tensors for image$?, with sharpness $1, anisotropy $2, alpha $3 and sigma $4."
-v -
p1={if($5,0.5,1)*max($1,1e-5)}
p2={$p1/(1e-7+1-$2)}
-b $3 -n 0,255 -structuretensors 0 -b $4
-repeat $! -l[$>]
-eigen -max.. 0
-if {s==2} -s.. c -+[-3,-2] -+.. 1 --^.. -$p1 -^... -$p2 -a[-3,-1] c
-else -s.. c -+[-4--2] -+.. 1 --^.. -$p1 -r. 100%,100%,100%,2 -^... -$p2 -a[-3,-1] c
-endif
-eigen2tensor
-endl -done -v +
#@gmic edges : _threshold[%]>=0
#@gmic : Estimate contours of selected images.
#@gmic : Default value: 'edges=15%'
#@gmic : $ image.jpg --edges 15%
edges : -skip ${1=15%}
-e[^-1] "Estimate image contours of image$?, with threshold $1."
-v - -gradient_norm -b 0.5 ->= $1 -distance 0 -equalize -negative -c 30%,70% -n 0,1 -v +
#@gmic erode : size>=0 : size_x>=0,size_y>=0,_size_z>=0 : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Erode selected images by a rectangular or the specified structuring element.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_z=1', 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode 10
#@gmic erode_circ : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply circular erosion of selected images by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode_circ 7
erode_circ : -check $1>=0 -skip ${2=1},${3=0}
-e[^-1] "Apply circular erosion of image$? by size $1, boundary $2 and is_normalized $3."
-if {$1<2} -return -endif
-v - -shape_circle $1 -erode[^-1] [-1],$2,$3 -rm. -v +
#@gmic erode_oct : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply octagonal erosion of selected images by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode_oct 7
erode_oct : -check $1>=0 -skip ${2=1},${3=0}
-e[^-1] "Apply octagonal erosion of image$? by size $1, boundary $2 and is_normalized $3."
-v -
-if {$1<2} -return -endif
-if {$1&1} ss={$1} -else ss={$1+1} -endif
-i[0] (0,1,0;1,1,1;0,1,0) -i[1] (1,1,1;1,1,1;1,1,1)
-repeat {$!-2}
r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
q={round(($ss-1)/(1+sqrt(2))/2)}
-if {$r>0} -repeat $r -erode. [0],$2,$3 -done -endif
-if {$q>0} -repeat $q -erode. [1],$2,$3 -done -endif
-mv. 2 -done -rm[0,1] -v +
#@gmic erode_threshold : size_x>=1,size_y>=1,size_z>=1,_threshold>=0,_boundary
#@gmic : Erode selected images in the (X,Y,Z,I) space.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_y=size_x', 'size_z=1', 'threshold=255' and 'boundary=1'.
erode_threshold : -check "isint($1) && $1>=1 && isint(${2=$1}) && $2>=1 && isint(${3=1}) && $3>=1 && ${4=255}>=0 && isint(${5=1}) && $5>=0"
-e[^-1] "Erode image$? with mask $1x$2x$3, threshold $4 and "${-arg\ $5,dirichlet,neumann}" boundary conditions."
-v - -l[]
dx1={int($1/2)} dx2={$1-$dx1-1}
dy1={int($2/2)} dy2={$2-$dy1-1}
dz1={int($3/2)} dz2={$3-$dz1-1}
(-$dx1,$dx1) (-$dy1;$dy1) (-$dz1/$dz1) -r $1,$2,$3,1,3 -a c -round -r {w*h*d},3,1,1,-1 -transpose.
-i.. 1,100%,1,1,254 1,100%,1,1,255 -a x
({'{^}'}) -rm.. -replace_str "254,","(v=j(" -replace_str ",255",",0,0,$5);if(abs(v-i)<=$4,v,1e20))" list={t}
-rm
-endl
-f 'min($list)'
-v +
#@gmic fft : _{ x | y | z }..{ x | y | z } : (+)
#@gmic : Compute the direct fourier transform (real and imaginary parts) of selected images,
#@gmic : optionally along the specified axes only.
#@gmic : $ image.jpg -luminance --fft -append[-2,-1] c -norm. -log. -shift. 50%,50%,0,0,2
#@gmic : $ image.jpg w2={int(w/2)} h2={int(h/2)} -fft -shift $w2,$h2,0,0,2 -ellipse $w2,$h2,30,30,0,1,0 -shift -$w2,-$h2,0,0,2 -ifft -remove.
#@gmic : $$
#@gmic g : eq. to '-gradient'. : (+)
#@gmic gradient : { x | y | z }..{ x | y | z },_scheme : (no arg) : (+)
#@gmic : Compute the gradient components (first derivatives) of selected images.
#@gmic : (eq. to '-g').
#@gmic : 'scheme' can be { -1=backward | 0=centered | 1=forward | 2=sobel | 3=rotation-invariant (default) | 4=deriche | 5=vanvliet }.
#@gmic : (no arg) compute all significant 2d/3d components.
#@gmic : Default value: 'scheme=3'.
#@gmic : $ image.jpg -gradient
#@gmic : $$
#@gmic gradient_norm
#@gmic : Compute gradient norm of selected images.
#@gmic : $ image.jpg --gradient_norm -equalize.
#@gmic : $$
gradient_norm :
-e[^-1] "Compute gradient norm of image$?."
-v - -repeat $! -l[$>]
--g x -sqr.
--g.. y -sqr. -+[-2,-1]
-g.. z -sqr.. -+[-2,-1]
s={s} -s. c -+[-$s--1] -sqrt.
-endl -done -v +
#@gmic gradient_orientation : _dimension={1,2,3}
#@gmic : Compute N-d gradient orientation of selected images.
#@gmic : Default value: 'dimension=3'.
#@gmic : $ image.jpg --gradient_orientation 2
gradient_orientation : -check "${1=3}==1 || $1==2 || $1==3"
-e[^-1] "Compute $1-d gradient orientation of image$?."
-v - -repeat $! -l[$<]
-if {$1==1} -g x --abs. -+. 1e-8 -/
-elif {$1==2} -g xy --sqr -+[-2,-1] -+. 1e-8 -sqrt. -/... [-1] -/[-2,-1]
-else -g xyz --sqr -+[-3--1] -+. 1e-8 -sqrt. -/[-4,-3] [-1] -/[-2,-1]
-endif
-endl -done -v +
#@gmic guided : [guide],radius[%]>0,regularization>0 : radius[%]>0,regularization>0 : (+)
#@gmic : Blur selected images by guided image filtering.
#@gmic : If a guide image is provided, it is used to drive the smoothing process.
#@gmic : A guide image must be of the same xyz-size as the selected images.
#@gmic : This command implements the filtering algorithm described in:
#@gmic : He, Kaiming; Sun, Jian; Tang, Xiaoou, "Guided Image Filtering," Pattern Analysis and Machine Intelligence,
#@gmic : IEEE Transactions on , vol.35, no.6, pp.1397,1409, June 2013
#@gmic : $ image.jpg [0] --guided 5,400
#@gmic haar : scale>0
#@gmic : Compute the direct haar multiscale wavelet transform of selected images.
#@gmic : $$
haar : -check "isint(${1=1}) && $1>=0"
-e[^-1] "Compute haar transform of image$? with $1 scales."
-v - -repeat $! -l[$>]
-_haar
-repeat {$1-1}
w={max(0,round(w/2^(1+$>))-1)}
h={max(0,round(h/2^(1+$>))-1)}
d={max(0,round(d/2^(1+$>))-1)}
--z 0,0,0,$w,$h,$d -_haar. -j.. [-1] -rm.
-done
-endl -done -v +
_haar :
-_haar_x -_haar_y -_haar_z
_haar_x :
-if {w<=1} -return -endif
-if {w%2} -v + -error[0--6] "Command '-haar': Invalid image width="{w}" (is not even)." -endif
--shift -1 -r 50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a x
_haar_y :
-if {h<=1} -return -endif
-if {h%2} -v + -error[0--6] "Command '-haar': Invalid image height="{h}" (is not even)." -endif
--shift 0,-1 -r 100%,50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a y
_haar_z :
-if {d<=1} -return -endif
-if {d%2} -v + -error[0--6] "Command '-haar': Invalid image depth="{h}" (is not even)." -endif
--shift 0,0,-1 -r 100%,100%,50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a z
#@gmic heat_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of the heat flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --heat_flow 20
heat_flow : -skip ${1=10},${2=30},${3=0}
-e[^-1] "Apply $1 iterations of the heat flow on image$?, with time step $2."
-v - -pde_flow $1,$2,laplacian,$3 -v +
#@gmic hessian : { xx | xy | xz | yy | yz | zz }..{ xx | xy | xz | yy | yz | zz } : (no arg) : (+)
#@gmic : Compute the hessian components (second derivatives) of selected images.
#@gmic : (no arg) compute all significant components.
#@gmic : $ image.jpg -hessian
#@gmic idct : _{ x | y | z }..{ x | y | z } : (no arg)
#@gmic : Compute the inverse discrete cosine transform of selected images,
#@gmic : optionally along the specified axes only.
#@gmic : Default values: (no arg)
#@gmic : $$ _dct-and-idct
idct : -skip ${1=0}
-v - ({'"$1"'})
is_axes={im>=_'x'" && "iM<=_'z'}
-if $is_axes
-v + -e[0--3] "Compute inverse discrete cosine transform of image$? along axes '$1'." -v -
-repeat {w}
axis={i[$>]}
-if {$axis==_'x'} -repeat {$!-1} -l[$>] -if {w>1} -_idct -endif -endl -done
-elif {$axis==_'y'} -repeat {$!-1} -l[$>] -if {h>1} -permute yxzc -_idct -permute yxzc -endif -endl -done
-elif {$axis==_'z'} -repeat {$!-1} -l[$>] -if {d>1} -permute zxyc -_idct -permute yzxc -endif -endl -done
-endif
-done
-else
-rm.
-v + -e[0--3] "Compute inverse discrete cosine transform of image$?." -v -
-noarg
-repeat $! -l[$>]
-if {w>1} -_idct -endif
-if {h>1} -permute yxzc -_idct -permute yxzc -endif
-if {d>1} -permute zxyc -_idct -permute yzxc -endif
-endl -done
-endif
-v +
_idct :
is_odd={w%2}
-/ {sqrt(2/w)} --z[0] 0,0 -*. {sqrt(2)} -j.. [-1],0,0,0 -rm.
-if $is_odd -r {w+1},100%,100%,100%,0,0 -endif
--mirror x -shift. 1 -*. -1
100%,1,1,1,cos(x*pi/(2*w))
100%,1,1,1,sin(x*pi/(2*w))
--*[0,3] --*[1,2] -+[-2,-1]
-*[0,2] -*[1,2] --[0,1]
-ifft x -k[0] -/ 2
-s x,2 -mirror. x
-r[0] 200%,100%,1,100%,4,0,0
-r[1] 200%,100%,1,100%,4,0,1
-+
-if $is_odd -r {w-1},100%,100%,100%,0 -endif
#@gmic iee
#@gmic : Compute gradient-orthogonal-directed 2nd derivative of image(s).
#@gmic : $ image.jpg -iee
iee :
-e[^-1] "Compute gradient-orthogonal-directed 2nd derivative of image$?."
-v - -repeat $! -l[$>]
-if {d==1}
--g xy,0 -hessian... xxxyyy
-*... [-2] -*[-4] [-1] -*[-4] -2
-+[-4,-3] -*... [-2]
-sqr[-2,-1] -*[-4] [-1] -+[-4,-3]
-+[-2,-1] -+. 1e-8 -/
-else
--inn -laplacian.. --
-endif
-endl -done -v +
#@gmic ifft : _{ x | y | z }..{ x | y | z } : (+)
#@gmic : Compute the inverse fourier transform (real and imaginary parts) of selected images.
#@gmic : optionally along the specified axes only.
#@gmic : $$ _fft
#@gmic ihaar : scale>0
#@gmic : Compute the inverse haar multiscale wavelet transform of selected images.
ihaar : -check "isint(${1=1}) && $1>=0"
-e[^-1] "Compute inverse haar transform of image$? with $1 scales."
-v - -repeat $! -l[$>]
-repeat {$1-1}
w={max(0,round(w/2^(1+$<))-1)}
h={max(0,round(h/2^(1+$<))-1)}
d={max(0,round(d/2^(1+$<))-1)}
--z 0,0,0,$w,$h,$d -_ihaar. -j.. [-1] -rm.
-done
-_ihaar
-endl -done -v +
_ihaar :
-_ihaar_x -_ihaar_y -_ihaar_z
_ihaar_x :
-if {w<=1} -return -endif
-if {w%2} -v + -error[0--6] "Command '-ihaar': Invalid image width="{w}" (is not even)." -endif
-s x,2 -r 200% (-1,1) -*[-2,-1] -+ -/ {sqrt(2)}
_ihaar_y :
-if {h<=1} -return -endif
-if {h%2} -v + -error "Command '-ihaar': Invalid image height="{h}" (is not even)." -endif
-s y,2 -r 100%,200% (-1;1) -r. {-2,w} -*[-2,-1] -+ -/ {sqrt(2)}
_ihaar_z :
-if {d<=1} -return -endif
-if {d%2} -v + -error "Command '-ihaar': Invalid image depth="{h}" (is not even)." -endif
-s z,2 -r 100%,100%,200% (-1/1) -r. {-2,w},{-2,h} -*[-2,-1] -+ -/ {sqrt(2)}
#@gmic inn
#@gmic : Compute gradient-directed 2nd derivative of image(s).
#@gmic : $ image.jpg -inn
inn :
-e[^-1] "Compute gradient-directed 2nd derivative of image$?."
-v - -repeat $! -l[$>]
-if {d==1}
--g xy,0 -hessian... xxxyyy
-*[-5] [-2] -*[-4] [-1] -*[-4] 2
-+[-5,-4] -*[-4] [-2]
-sqr[-2,-1] -*... [-1] -+[-4,-3]
-+[-2,-1] -+. 1e-8 -/
-else
--g xyz,0 -hessian[-4] xxxyxzyyyzzz
-*[-9] [-3] -*[-8] [-2] -*[-8] 2 -*[-7] [-1] -*[-7] 2
-+[-9--7] -*[-7] [-3]
-*[-6] [-2] -*[-5] [-1] -*[-5] 2
-+[-6,-5] -*[-5] [-2] -+[-6,-5]
-sqr[-3--1] -*[-4] [-1] -+[-5,-4]
-+[-3--1] -+. 1e-8 -/
-endif
-endl -done -v +
#@gmic inpaint : [mask] : [mask],0,_fast_method : [mask],_patch_size>=1,_lookup_size>=1,_lookup_factor>=0,_lookup_increment!=0,_blend_size>=0,0<=_blend_threshold<=1,_blend_decay>=0,_blend_scales>=1,_is_blend_outer={ 0 | 1 } : (+)
#@gmic : Inpaint selected images by specified mask.
#@gmic : If no patch size (or 0) is specified, inpainting is done using a fast average or median algorithm.
#@gmic : Otherwise, it used a patch-based reconstruction method, that can be very time consuming.
#@gmic : 'fast_method' can be { 0=low-connectivity average | 1=high-connectivity average | 2=low-connectivity median | 3=high-connectivity median }.
#@gmic : Default values: 'patch_size=0', 'fast_method=1', 'lookup_size=22', 'lookup_factor=0.5', 'lookup_increment=1', 'blend_size=0', 'blend_threshold=0', 'blend_decay=0.05', 'blend_scales=10' and 'is_blend_outer=1'.
#@gmic : $ image.jpg 100%,100% -ellipse 50%,50%,30,30,0,1,255 -ellipse 20%,20%,30,10,0,1,255 --inpaint.. [-1] -remove..
#@gmic : $ image.jpg 100%,100% -circle 30%,30%,30,1,255,0,255 -circle 70%,70%,50,1,255,0,255 --inpaint[0] [1],5,15,0.5,1,9,0 -remove[1]
#@gmic inpaint_flow : [mask],_nb_global_iter>=0,_nb_local_iter>=0,_dt>0,_alpha>=0,_sigma>=0
#@gmic : Apply iteration of the inpainting flow on selected images.
#@gmic : Default values: 'nb_global_iter=4', 'nb_global_iter=15', 'dt=10', 'alpha=1' and 'sigma=3'.
#@gmic : $ image.jpg 100%,100% -ellipse. 30%,30%,40,30,0,1,255 -inpaint_flow[0] [1]
inpaint_flow : -check ${-is_image_arg\ $1}" && ${2=10}>=0 && ${3=100}>=0 && ${4=5}>0 && ${5=1}>=0 && ${6=3}>=0"
-e[^-1] "Apply $2x$3 iterations of the inpainting flow on image$?, with mask $1, time step $4, alpha $5 and sigma $6."
-v - -repeat $! -pass$1 0 -l[$>,-1]
-r. [0],[0],[0],1,0 -inpaint.. [1]
-repeat $2
-progress {100*$>/($2-1)}
--diffusiontensors.. 0,1,$5,$6,0 -*. [-2] -smooth... [-1],$3,$4,0 -rm.
-done
-progress 100
-endl -rm. -done -v +
#@gmic inpaint_holes : maximal_area[%]>=0,_tolerance>=0,_is_high_connectivity={ 0 | 1 }
#@gmic : Inpaint all connected regions having an area less than specified value.
#@gmic : Default values: 'maximal_area=4', 'tolerance=0' and 'is_high_connectivity=0'.
#@gmic : $ image.jpg -noise 5%,2 --inpaint_holes 8,40
inpaint_holes : -check "${1=4}>=0 && ${2=0}>=0" -skip ${3=0}
-e[^-1] "Inpaint holes wih area less than $1 pixels in image$?, with tolerance $2 and "${-arg\ 1+!$3,high,low}" connectivity."
-v - -repeat $! -l[$>]
100%,100%,100%
area={if(${-is_percent\ $1},$1*w*h*d,$1)}
-repeat {0,s} -sh[0] $> --area. $2,$3 -<=. $1 -|[1,-1] -rm. -done
-if {im} -k[0] whd={w},{h},{d} -r 1,1,1,100%,2 -r $whd,100%
-else -inpaint[0] [1],0,{2*!$2+!!$3} -k[0] -endif
-endl -done -v +
#@gmic inpaint_morpho : [mask]
#@gmic : Inpaint selected images by specified mask using morphological operators.
#@gmic : $ image.jpg 100%,100% -ellipse. 30%,30%,40,30,0,1,255 --inpaint_morpho[0] [1]
inpaint_morpho : -check ${-is_image_arg\ $1}
-e[^-1] "Inpaint image$? by mask $1, using morphological operators."
-v - -repeat $! -pass$1 0 -l[$>,-1]
nm={0,n} im={0,im} iM={0,iM} im1={$im-1} iM1={$iM+1}
-channels. 0 -==. 0
--f[0] $im1 -j. [0],0,0,0,0,1,[-2]
-do
--dilate. 3
-replace.. $im1,$iM1
-erode.. 3
-replace.. $iM1,$im1
-+[-2,-1] -/. 2
-j. [-3],0,0,0,0,1,[-2]
-while {im==$im1}
-k. -nm $nm
-endl -done -v +
#@gmic inpaint_patchmatch : [mask],_nb_scales={ 0=auto | >0 },_patch_size>0,_nb_iterations_per_scale>0,_blend_size>=0,_allow_outer_blending={ 0 | 1 },_is_already_initialized={ 0 | 1 }
#@gmic : Inpaint selected images by specified binary mask, using a multi-scale patchmatch algorithm.
#@gmic : Default values: 'nb_scales=0', 'patch_size=9', 'nb_iterations_per_scale=10', 'blend_size=5', 'allow_outer_blending=1' and 'is_already_initialized=0'.
#@gmic : $ image.jpg 100%,100% -ellipse. 30%,30%,40,30,0,1,255 --inpaint_patchmatch[0] [1]
inpaint_patchmatch : -check ${-is_image_arg\ $1}"&& ${2=0}>=0 && isint(${3=9}) && $3>0 && isint(${4=10}) && $4>0 && isint(${5=5}) && $5>=0" -skip ${6=1},${7=0}
-e[^-1] "Inpaint image$? with mask $1, using a multiscale patchmatch algorithm with "${"-v - -if $2 -u \"$2 \" -else -u auto- -endif -v +"}\
"scales, $3x$3 patches, $4 iterations per scale and blending size $5."
-v - -repeat $! -pass$1 0 -l[$>,-1]
nm={0,n} -nms img,mask
nb_scales={max(1,round(if($2,$2,log2(min(w,h)/16)),1,1))}
visu_size=${-fitscreen[]" "{0,w},{0,h},1,25%,50%}
-slices[img] 0 -r[mask] [img],[img],1,1,0 -!=[mask] 0
-if {!$7} -inpaint_diffusion[img] [mask],75% -endif
im={img,im} --[img] $im
first_iter=1 iter=0
-repeat $nb_scales
scale={100*(0.5^$<)}
-v + -e[] "> Process scale "{1+$>}"/"$nb_scales" -> "$scale% -v -
-progress {100*$>/max(1,$nb_scales-1)}
--r[img,mask] $scale%,$scale%,1,100%,2 -nms[-2,-1] scaled_img,scaled_mask
-ge[scaled_mask] 0.95
-if {scaled_mask,!iM} -rm[scaled_img,scaled_mask] -continue -endif
--f[scaled_img] -4096 --j[scaled_img] [-1],0,0,0,0,1,[scaled_mask] -rm.. -nm. scaled_reference
coef={0.5^($nb_scales-$iter)}
patch_size={v=round(max(min($3,5),$3*$coef));v+(1-(v%2))}
patch_size={min(w,h,$patch_size)}
blend_size={v=if($5,round(max(3,$5*$coef)));v+(1-(v%2))}
iter+=1
-==[scaled_mask] 0
-if $first_iter
100%,100%,1,1,x --f. y -mv[scaled_mask] $! -a[-3--1] c
-patchmatch[scaled_img] [scaled_reference],$patch_size,$patch_size,1,4,4,0,[-1]
-rm[scaled_reference,-1]
-nm. correspondence
first_iter=0
-else
-*[correspondence] 2 -r[correspondence] 200%,200%,1,2 -r[correspondence] [scaled_img],[scaled_img],1,2,0,1
100%,100%,1,1,x --f. y -a[-2,-1] c
-f[scaled_mask] "*if(i,1,
upc = i(#"$correspondence",x-1,y,0,0); vpc = i(#"$correspondence",x-1,y,0,1);
ucp = i(#"$correspondence",x,y-1,0,0); vcp = i(#"$correspondence",x,y-1,0,1);
ucc = i(#"$correspondence",x,y,0,0); vcc = i(#"$correspondence",x,y,0,1);
i(#-1,x,y,0,0) = (ucc==upc && vcc==vpc)?upc + 1:ucc;
i(#-1,x,y,0,1) = (ucc==ucp && vcc==vcp)?vcp + 1:vcc;
0)"
-rm[correspondence] -nm. correspondence
-a[correspondence] [scaled_mask],c
nbs1={max(1,$nb_scales-1)}
nb_iter={round(max(1,$4*(($<+1)/$nbs1)^2))}
-repeat $nb_iter
-_inpaint_patchmatch[scaled_img] [correspondence],[scaled_mask],$blend_size,$6
--patchmatch[scaled_img] [scaled_reference],$patch_size,$patch_size,1,4,4,0,[correspondence]
-j[correspondence] [-1] -rm.
-if {*} -w[scaled_img] $visu_size,0 -endif
-if {*2} -w2[correspondence] $visu_size,1 -endif
-done
-rm[scaled_img,scaled_mask,scaled_reference] -channels[correspondence] 0,1
-endif
-done
-progress 100
-if $correspondence
-==[mask] 0
-_inpaint_patchmatch[img] [correspondence],[mask],$5,$6
-rm[correspondence]
-endif
-+[img] $im
-endl -rm[mask] -done -v +
_inpaint_patchmatch :
p1={int($3/2)} p2={$3-$p1-1}
-pass$1 1 -pass$2 {!$3" || "!$4}
-if {!$3}
-warp[0] [1],0,0,1
-else
-if $4 -erode. $3 -endif
-f[0] "*init(boundary=1);
if (i#2,i,
avg = norm = 0;
for (q = -"$p1", q<="$p2", ++q,
for (p = -"$p1", p<="$p2", ++p,
X = x + p;
Y = y + q;
u = i(#1,X,Y,0,0);
v = i(#1,X,Y,0,1);
X = u - p;
Y = v - q;
val = i(X,Y,0,c);
if (X>=0 && X<w && Y>=0 && Y<h,
avg+=val;
++norm;
)
)
);
avg/norm)"
-endif
-k[0]
#@gmic inpaint_diffusion : [mask],_nb_scales[%]>=0,_diffusion_type={ 0=isotropic | 1=delaunay-oriented | 2=edge-oriented },_diffusion_iter>=0
#@gmic : Inpaint selected images by specified mask using a multiscale transport-diffusion algorithm.
#@gmic : Default values: 'smoothness=75%', 'diffusion_type=1' and 'diffusion_iter=20'.
#@gmic : $ image.jpg 100%,100% -ellipse. 30%,30%,40,30,0,1,255 --inpaint_diffusion[0] [1]
inpaint_diffusion : -check ${-is_image_arg\ $1}" && ${2=75%}>=0 && isint(${3=1}) && $3>=0 && $3<=2 && ${4=20}>=0"
-v - s0="isotropic" s1="delaunay-oriented" s2="edge-oriented"
-v + -e[^-1] "Inpaint image$? by mask $1, using a multiscale diffusion algorithm with $2 scales and $4 iterations of "${s$3}" diffusion." -v -
-repeat $! nm={n} -pass$1 -l[$>,-1]
nb_scalesM={round(log2(max(w,h,d)))}
nb_scales={round(${"-is_percent $2"}?$nb_scalesM*$2:$2)}
nb_scales={max(1,min($nb_scales,$nb_scalesM))}
nb_iter={max(5,$4)}
-repeat $nb_scales
scale={2^$<}
width={0,max(1,round(w/$scale))}
height={0,max(1,round(h/$scale))}
depth={0,max(1,round(d/$scale))}
$width,$height,$depth,{0,s} 100%,100%,100%
-f[1] "init(
wl1 = w#-1 - 1;
hl1 = h#-1 - 1;
dl1 = d#-1 - 1;
w1 = max(1,w - 1);
h1 = max(1,h - 1);
d1 = max(1,d - 1);
);
if(i,i,
X = round(x*wl1/w1);
Y = round(y*hl1/h1);
Z = round(z*dl1/d1);
I(#-2,X,Y,Z) += I(#0,x,y,z);
++i(#-1,X,Y,Z);
0)"
--max. 1 -/[-3,-1] -!=. 0
-if {!$>}
im={-2,im} ---.. {$im-1} -*. [-2]
--distance.. 1 -*. -1 -watershed.. [-1] -rm.
-+. {$im-1} -mv. -3
-endif
-if {$>>0" || "$nb_scales==1}
-r... [-2],3
-if {$3==0}
-repeat $nb_iter -j... [-2],0,0,0,0,1,[-1] -b... 0.5 -done
-elif {$3==1}
--distance. 1 -g. -a[-{d==1?2:3}--1] c -orientation.
-repeat {$nb_iter}
-j[-4] [-3],0,0,0,0,1,[-2]
--warp[-4] [-1],1,2,1 -*.. -1 -warp[-5] [-2],1,2,1 -+[-5,-1] -/[-4] 2
-done -rm.
-else
-repeat $nb_iter
--diffusiontensors... 0,1,1.5,0.5
-j[-4] [-3],0,0,0,0,1,[-2]
-smooth[-4] [-1],1,10,0 -rm.
-done
-endif
-j[-3] [-2],0,0,0,0,1,[-1]
-endif
-rm[-2,-1]
-done
-nm. $nm -rv[0,-1] -rm.
-endl -rm. -done -v +
#@gmic kuwahara : size>0
#@gmic : Apply Kuwahara filter of specified size on selected images.
#@gmic : $ image.jpg --kuwahara 5
kuwahara : -check $1>0
-e[^-1] "Apply Kuwahara filter of size $1 on image$?."
-v - -repeat $! -l[$>]
s={s}
--dilate $1 -compose_channels. min
--erode[0] $1 -compose_channels. max
--[-2,-1]
$1,1,1,1,{1/$1} -convolve[0] [-1] -transpose. -convolve[0] [-1] -rm.
p={int($1/2)}
-a[-2,-1] c
-f "v1=i(x-"$p",y-"$p",0,"$s",0,1); \
v2=i(x+"$p",y-"$p",0,"$s",0,1); \
v3=i(x-"$p",y+"$p",0,"$s",0,1); \
v4=i(x+"$p",y+"$p",0,"$s",0,1); \
vm=min(v1,v2,v3,v4); \
if(c>="$s",i, \
if(vm==v1,i(x-"$p",y-"$p",0,c,0,1),
if(vm==v2,i(x+"$p",y-"$p",0,c,0,1),
if(vm==v3,i(x-"$p",y+"$p",0,c,0,1),
i(x+"$p",y+"$p",0,c,0,1)))))"
-channels 0,{s-2}
-endl -done -v +
#@gmic laplacian
#@gmic : Compute Laplacian of selected images.
#@gmic : $ image.jpg -laplacian
laplacian :
-e[^-1] "Compute Laplacian of image $?."
-v - -repeat $! -l[$>]
-hessian ${-arg\ 1+(d==1),xxyyzz,xxyy} -+
-endl -done -v +
#@gmic lic : _amplitude>0,_channels>0
#@gmic : Render LIC representation of selected vector fields.
#@gmic : Default values: 'amplitude=30' and 'channels=1'.
#@gmic : $ 400,400,1,2,'if(c==0,x-w/2,y-h/2)' --lic 200,3 -quiver.. [-2],10,-13,1,1,255
lic : -skip ${1=30},${2=1}
-e[^-1] "Render LIC representation of 2d vector field$?, with amplitude $1 and $2 channel(s)."
-v - -repeat $! -l[$>] nm={0,n}
-channels 0,1 -/ {max(abs(im),abs(iM))} -vector2tensor
100%,100%,100%,$2 -rand. 0,255 -smooth. [-2],$1 -rm..
-equalize
-nm $nm -endl -done -v +
#@gmic map_tones : _threshold>=0,_gamma>=0,_smoothness>=0,nb_iter>=0
#@gmic : Apply tone mapping operator on selected images, based on Poisson equation.
#@gmic : Default values: 'threshold=0.1', 'gamma=0.8', 'smoothness=0.5' and 'nb_iter=30'.
#@gmic : $ image.jpg --map_tones ,
map_tones : -skip ${1=0.1},${2=0.8},${3=0.5},${4=30}
-e[^-1] "Apply tone mapping operator on image$?, with threshold $1, gamma $2, smoothness $3 and $4 iterations."
-v - -repeat $! -l[$>]
--l -s c -repeat $! -l[$>]
-g xy,1 -a c --norm -orientation..
m={im} M={iM} -b. $3 -n. $m,$M
-*. 'alpha=$1*iM;(alpha/(1e-10+i))*(i/(1e-10+alpha))^$2'
-* -s c -g.. x,-1 -g. y,-1 -+
-endl -done -a c -* 0.25 -endl
-repeat $4 --laplacian.. -*. 0.25 -+. [-3] --. [-2] -*. 800 -+[-3,-1] -/.. 801 -c.. 0,255 -done -rm.
-endl -done  -v +
#@gmic map_tones_fast : _radius[%]>=0,_power>=0
#@gmic : Apply fast tone mapping operator on selected images.
#@gmic : Default values: 'radius=3%' and 'power=0.3'.
#@gmic : $ image.jpg --map_tones_fast ,
map_tones_fast : -check "${1=3%}>=0 && ${2=0.3}>=0"
-e[^-1] "Apply fast tone mapping operator on image$?, with radius $1 and power $2."
-v - -repeat $! -l[$>]
--luminance -b. $1 -n 0,1
--*. 2 --. 1 -abs. -*. {$2*log(10)} -exp.
-<=.. 0.5 -r. [-3]
--*... -1 -+. 1 -^. [-2] -*. -1 -+. 1 -*. [-3]
-^[-4,-2] -==.. 0 -*[-3,-2] -+
-endl -done -n 0,255 -v +
#@gmic meancurvature_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of the mean curvature flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --meancurvature_flow 20
meancurvature_flow : -skip ${1=10},${2=30},${3=0}
-e[^-1] "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
-v - -pde_flow $1,$2,iee,$3 -v +
#@gmic median : size>=0,_threshold>0 : (+)
#@gmic : Apply (opt. thresholded) median filter on selected images with structuring element size x size.
#@gmic : $ image.jpg --median 5
#@gmic nlmeans : _patch_radius>0,_spatial_bandwidth>0,_tonal_bandwidth>0,_patch_measure_command
#@gmic : Apply non local means denoising of Buades et al, 2005. on selected images.
#@gmic : The patch is a gaussian function of 'std _patch_radius'.
#@gmic : The spatial kernel is a rectangle of radius 'spatial_bandwidth'.
#@gmic : The tonal kernel is exponential (exp(-d^2/_tonal_bandwidth^2))
#@gmic : with d the euclidiean distance between image patches.
#@gmic : Default values: 'patch_radius=4', 'spatial_bandwidth=4', 'tonal_bandwidth=10' and 'patch_measure_command=-norm'.
#@gmic : $ image.jpg --noise 10 -nlmeans. 4,4,{0.6*${-std_noise}}
nlmeans: -check "${1=4}>0 && ${2=4}>0 && ${3=10}>0" -skip "${4=-norm}"
-e[^-1] "Apply non-local means denoising with patch size $1, spatial bandwidth $2, tonal bandwidth $3 and patch measure command '$4'."
-v - -repeat $! -l[$>]
--l $4 -k[0] -endl
100%,100%,100%,100%,{-1.0/($3*$3)}
-nlmeans_core[0] [1],[2],$1,$2
-rm[-1,-2]
-endl -done -v +
#@gmic nlmeans_core: _reference_image,_scaling_map,_patch_radius>0,_spatial_bandwidth>0
#@gmic : Apply non local means denoising using a image for weigth and a map for scaling
nlmeans_core: -check ${-is_image_arg\ $1}" && "${-is_image_arg\ $2}" && $3>0 && $4>0"
-e[^-1] "Apply non-local means denoising using weight images $1, scaling map $2, patch size $3 and spatial bandwidth $4."
-v - -pass$1 0 -pass$2 0
-repeat {$!-2} -l[$>,-1,-2]
100%,100%,100%,{0,s},0 100%,100%,100%,{1,s},0 100%,100%,100%,{1,s},0
-if {{0,d}==1}
-repeat {2*$4+1} j={$>-$4} -repeat {2*$4+1} i={$>-$4}
-if {$i!=0||$j!=0}
--shift[0,1] $i,$j,0,0,2 --[7] [1]
-sqr[7] -blur[7] $3 -*[7] [2] -exp[7]
-*[6] [7] -max[5] [7] -+[4,7] -+[3,6]
-endif
-done -done
-else
-repeat {2*$4+1} k={$>-$4} -repeat {2*$4+1} j={$>-$4} -repeat {2*$4+1} i={$>-$4}
-if {$i!=0||$j!=0||$k!=0}
--shift[0,1] $i,$j,0,0,2 --[7] [1]
-sqr[7] -blur[7] $3 -*[7] [2] -exp[7]
-*[6] [7] -max[5] [7] -+[4,7] -+[3,6]
-endif
-done -done -done
-endif
-max[5] 1e-6 -rm[1,2]
-*[0] [3] -+[1,0] -+[1,2]
-/
-endl -done -v +
#@gmic normalize_local : _amplitude>=0,_radius>0,_n_smooth>=0[%],_a_smooth>=0[%],_is_cut={ 0 | 1 },_min=0,_max=255
#@gmic : Normalize selected images locally.
#@gmic : Default values: 'amplitude=3', 'radius=16', 'n_smooth=4%', 'a_smooth=2%', 'is_cut=1', 'min=0' and 'max=255'.
#@gmic : $ image.jpg --normalize_local 8,10
normalize_local :
-check "${1=3}>=0 && ${2=16}>0 && isbool(${5=1})" -skip ${3=4%},${4=2%},${6=0},${7=255}
-e[^-1] "Normalize image$? locally, with amplitude $1, radius $2, neighborhood smoothness $3 and average smoothness $4."
-v - -repeat $! -l[$>]
--l -erode {2*$2+1} -s c -min -endl
--l.. -dilate {2*$2+1} -s c -max -endl
--b... $4 -b[-3,-2] $3
---.. [-3] -+. 0.01 --[-5] [-4] -/[-5,-1]
-*[-3,-2] {$1+1} -*. -$1 -+... [-1] -+[-2,-1]
-if $5 -max.. $6 -min. $7 -endif
--. [-2] -*[-3,-1] -+
-if $5 -c $6,$7 -endif
-endl -done -v +
#@gmic normalized_cross_correlation : [mask]
#@gmic : Compute normalized cross-correlation of selected images with specified mask.
#@gmic : $ image.jpg --shift -30,-20 --normalized_cross_correlation[0] [1]
normalized_cross_correlation : -check ${-is_image_arg\ $1}
-e[^-1] "Compute normalized cross-correlation of image$? with mask $1."
-v - -pass$1 0 -norm -repeat {$!-1} [-1] -l[$>,-1]
-fft.. -fft. [-2,-1] -*.. [-5] -*. [-6]
--[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] [-2,-1] -a[-2,-1] c -norm.
-/... [-1] -/[-2,-1] -ifft -rm.
-endl -done -rm. -v +
#@gmic peronamalik_flow : K_factor>0,_nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of the Perona-Malik flow on selected images.
#@gmic : Default values: 'K_factor=20', 'nb_iter=5', 'dt=5' and 'keep_sequence=0'.
#@gmic : $ image.jpg --heat_flow 20
peronamalik_flow : -check "${1=20}>0 && ${2=5}>=0" -skip ${3=5},${4=0}
-e[^-1] "Apply $2 iterations of the Perona-Malik flow on image$?, with K factor $1 and time step $3."
-v -
-m "_peronamalik_flow :
--gradient xy,0 -a[-2,-1] c -norm. -b. 0.8 -/. $1 -sqr. -*. -1 -exp. -a[-2,-1] c
-f. '\"s1=s-1;
C=i(x,y,z,s-1);
if(c>=s1,0,
(C+i(x+1,y,z,s-1,0,1))*(j(1,0,0,0,0,1)-i) -
(C+i(x-1,y,z,s-1,0,1))*(i-j(-1,0,0,0,0,1)) +
(C+i(x,y+1,z,s-1,0,1))*(j(0,1,0,0,0,1)-i) -
(C+i(x,y-1,z,s-1,0,1))*(i-j(0,-1,0,0,0,1)))\"'"
-pde_flow $2,$3,_peronamalik_flow,$4
-uncommand _peronamalik_flow
-v +
#@gmic phase_correlation : [destination]
#@gmic : Estimate translation vector between selected source images and specified destination.
#@gmic : $ image.jpg --shift -30,-20 --phase_correlation[0] [1] -unroll. y
phase_correlation : -check ${-is_image_arg\ $1}
-e[^-1] "Estimate shift between source image$? and destination $1."
-v - -repeat $! -pass$1
-normalized_cross_correlation[$>] [-1] -rm.
-l[$>]
({[xM,yM,zM,cM]}) -*. 2 -s. x -rm.
-if {{-3,^}>{-4,w}} --... {-4,w} --... {-4,w} -endif
-if {{-2,^}>{-4,h}} --.. {-4,h} --.. {-4,h} -endif
-if {{^}>{-4,d}} --. {-4,d} --. {-4,d} -endif
-a[-3--1] c -rm.. -/ 2 -* -1
-nm [phase\ correlation]
-endl -done -v +
#@gmic pde_flow : _nb_iter>=0,_dt,_velocity_command,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of a generic PDE flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30', 'velocity_command=laplacian' and 'keep_sequence=0'.
#@gmic : $ image.jpg --pde_flow 20
pde_flow : -skip ${1=10},${2=30},${3=laplacian},${4=0}
-e[^-1] "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
-v - -repeat $! -l[$<]
-repeat $1
--$3. -*. {$2/(0.01+max(abs(im),abs(iM)))}
-if $4 -+. [-2] -else -+[-2,-1] -endif
-done
-if $4 -rm[0] -endif
-a x
-endl -done
-if $4 -s x,$1 -endif -v +
#@gmic periodize_poisson
#@gmic : Periodize selected images using a Poisson solver in Fourier space.
#@gmic : $ image.jpg --periodize_poisson -array 2,2,2
periodize_poisson :
-e[^-1] "Periodize image$? using Poisson solver in Fourier space."
-v - -repeat $! -l[$>]
-s c -repeat $! -l[$>]
mM={im},{iM} sum={0,is}
-laplacian -fft.
-if {d==1} 100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
-else 100%,100%,100%,1,'-(6-2*cos(2*x*pi/w)-2*cos(2*y*pi/h)-2*cos(2*z*pi/d))'
-endif
-=. 1 -/[-3,-2] [-1] -rm. -=.. $sum -=. 0
-ifft -rm. -c $mM
-endl -done -a c
-endl -done -v +
#@gmic red_eye : 0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1
#@gmic : Attenuate red-eye effect in selected images.
#@gmic : Default values: 'threshold=75', 'smoothness=3.5' and 'attenuation=0.1'.
#@gmic : $ image.jpg --red_eye ,
red_eye : -skip ${1=75},${2=3.5},${3=0.1}
-e[^-1] "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
-v - -to_rgb -rgb2ycbcr -repeat $! -l[$>]
-s c --. 128 -->=. $1% -b. $2 -sqrt. -*. -1 -+. 1
-n. $3,1 -*[-2,-1] -+. 128 -a c -ycbcr2rgb
-endl -done -v +
#@gmic remove_hotpixels : _mask_size>0, _threshold[%]>0
#@gmic : Remove hot pixels in selected images.
#@gmic : Default values: 'mask_size=3' and 'threshold=10%'.
#@gmic : $ image.jpg -noise 10,2 --remove_hotpixels ,
remove_hotpixels : -check ${1=3}>0 -skip ${2=10%}
-e[^-1] "Remove hot pixels in image$?, with mask size $1 and threshold $2."
-v - -repeat $! -l[$>]
--median $1 --- -abs. ->=. $2
-*.. [-1] -==. 0 -*[-3,-1] -+
-endl -done -v +
#@gmic remove_pixels : number_of_pixels[%]>=0
#@gmic : Remove specified number of pixels (i.e. set them to 0) from the set of non-zero pixels in selected images.
#@gmic : $ image.jpg --remove_pixels 50%
remove_pixels : -check "$1>=0"
-e[^-1] "Remove $1 of the non-zero pixels in image$?."
-v - -repeat $! -l[$>]
--norm -!=. 0
N={is}
n={round(if(${"-is_percent $1"},$N*$1,$1))}
-if {$n<=0} -rm.
-elif {$n>=$N} -rm. -f 0
-elif {$n>int($N/2)}
-remove_pixels. {$N-$n} -==. 0 -*
-else
d={d} -r 100%,{d*h},1,100%,-1
100%,1,1,1,x 1,{-2,h},1,1,y -+[-2,-1] 1 -r[-2,-1] [-2],[-1]
-*[-2,-1] [-3] -rm...
-y[-2,-1] -a[-2,-1] x -discard. y,0
-do
1,100%,1,1 -rand. 0,{h} -<=. {$n*1.25}
-if {is>=$n} -break -else -rm. -endif
-while 1
-r. 2 -*[-2,-1] -discard. y,0
-i.. 1,100% -rand.. 0,1 -a[-2,-1] x -sort. +,y
-rows. 0,{$n-1} --. 1 -z. 1,3
-i.. ({'CImg3d'},{h},{h})
1,100%,1,1,1 1,100%,1,1,y -a[-2,-1] x
3,100% 1,100%,1,1,1 -y[-5--1] -a[-5--1] y
-if {0,s<=3} -j3d.. [-1],0,0,0,1,0,0,0,0
-else [0],[0],1,1,1 -j3d. [-2],0,0,0,1,0,0,0,0 -*[0,-1]
-endif
-rm.
-r 100%,{h/$d},$d,100%,-1
-endif
-endl -done -v +
#@gmic sharpen : amplitude>=0 : amplitude>=0,edge>=0,_alpha,_sigma : (+)
#@gmic : Sharpen selected images by inverse diffusion or shock filters methods.
#@gmic : 'edge' must be specified to enable shock-filter method.
#@gmic : Default values: 'alpha=0' and 'sigma=0'.
#@gmic : $ image.jpg --sharpen 300
#@gmic : $ image.jpg -blur 5 --sharpen. 300,1
#@gmic smooth : amplitude>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dl>0,_da>0,_precision>0,interpolation,_fast_approx={ 0 | 1 } : nb_iterations>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dt>0,0 : [tensor_field],_amplitude>=0,_dl>0,_da>0,_precision>0,_interpolation,_fast_approx={ 0 | 1 } : [tensor_field],_nb_iters>=0,_dt>0,0 : (+)
#@gmic : Smooth selected images anisotropically using diffusion PDE's, with specified field of
#@gmic : diffusion tensors.
#@gmic : 'anisotropy' must be in [0,1].
#@gmic : 'interpolation' can be { 0=nearest | 1=linear | 2=runge-kutta }.
#@gmic : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1', 'dl=0.8', 'da=30', 'precision=2', 'interpolation=0' and 'fast_approx=1'.
#@gmic : $ image.jpg [0] -repeat 3 -smooth. 20 -done
#@gmic : $ image.jpg 100%,100%,1,2 -rand. -100,100 -repeat 2 -smooth. 100,0.2,1,4,4 -done --warp[0] [-1],1,1
#@gmic : $$
#@gmic split_freq : smoothness>0[%]
#@gmic : Split selected images into low and high frequency parts.
#@gmic : $ image.jpg -split_freq 2%
split_freq :
-e[^-1] "Split image$? into low and high frequency parts, with smoothness $1."
-v - -repeat $! -l[$>] --b $1 --[0] [1] -rv -endl -done -v +
#@gmic solve_poisson : "laplacian_command",_nb_iterations>=0,_time_step>0,_nb_scales>=0
#@gmic : Solve Poisson equation so that applying '-laplacian[n]' is close to the result of '-laplacian_command[n]'.
#@gmic : Solving is performed using a multi-scale gradient descent algorithm.
#@gmic : If 'nb_scales=0', the number of scales is automatically determined.
#@gmic : Default values: 'nb_iterations=60', 'dt=5' and 'nb_scales=0'.
#@gmic : $ image.jpg -m "foo : -gradient x" --solve_poisson foo --foo[0] --laplacian[1]
solve_poisson : -check "${2=60}>=0 && ${3=5}>0 && ${4=0}>=0"
-e[^-1] "Solve Poisson equation for image$?, for laplacian command '$1', with $2 iterations, time step $3 and "${-arg\ 1+($4==0),$4,auto}" scales."
-v - -repeat $! -l[$>]
[0]
-repeat {if($4,$4,int(max(log2(max(w,h))-1,1)))}
f={2^$<}
-r[1] {0,max(1,w/$f)},{0,max(1,h/$f)},1,100%,3
--r[0] [1],2 -l. -$1 -k[0] -endl
-repeat $2 --laplacian.. --. [-2] -*. {$3/max(1e-8,abs(im),abs(iM))} -+[-3,-1] -done
-rm.
-done
-rm[0]
-endl -done -v +
#@gmic split_details : _nb_scales>0,_base_scale[%]>=0,_detail_scale[%]>=0
#@gmic : Split selected images into 'nb_scales' detail scales.
#@gmic : If 'base_scale'=='detail_scale'==0, the image decomposition is done with 'a trous' wavelets.
#@gmic : Otherwise, it uses laplacian pyramids with linear standard deviations.
#@gmic : Default values: 'nb_scales=4', 'base_scale=0' and 'detail_scale=0'.
#@gmic : $ image.jpg -split_details ,
split_details : -check "isint(${1=4}) && $1>0 && ${2=0}>=0 && ${3=0}>=0"
-if {($2)==0" && "($3)==0}
-e[^-1] "Split image$? using $1 spatial scales and 'a trous' wavelets."
-v - -repeat $! -l[$<]
-repeat {$1-1}
--f. "init(interpolation=0; boundary=1; d=2^"$>"; d2=d*2);
i(x - d2) + i(x + d2) + 4*i(x - d) + 4*i(x + d) + 6*i;"
-/. 16
-if {h>1}
-f. "init(interpolation=0; boundary=1; d=2^"$>"; d2=d*2);
i(x,y - d2) + i(x,y + d2) + 4*i(x,y - d) + 4*i(x,y + d) + 6*i;"
-/. 16
-endif
-if {d>1}
-f. "init(interpolation=0; boundary=1; d=2^"$>"; d2=d*2);
i(x,y,z - d2) + i(x,y,z + d2) + 4*i(x,y,z - d) + 4*i(x,y,z + d) + 6*i;"
-/. 16
-endif
--.. [-1]
-done -rv
-endl -done -v +
-else
-e[^-1] "Split image$? using $1 spatial scales with base scale $2 and detail scale $3."
-v - -repeat $! -l[$<]
ss={max(0.3,if(${-is_percent\ $2},$2*max(w,h),$2))}
se={max(0.3,if(${-is_percent\ $3},$3*max(w,h),$3))}
ds={$se-$ss}
-repeat {$1-1} --b. {$ss+$>*$ds/max(1,$1-2)} --.. [-1] -rv[-2,-1] -done
-endl -done -v +
-endif
#@gmic structuretensors : _scheme={ 0=centered | 1=forward/backward } : (+)
#@gmic : Compute the structure tensor field of selected images.
#@gmic : Default value: 'scheme=1'.
#@gmic : $ image.jpg -structuretensors -abs -pow 0.2
#@gmic : $$
#@gmic solidify : _smoothness[%]>=0,_diffusion_type={ 0=isotropic | 1=delaunay-oriented | 2=edge-oriented },_diffusion_iter>=0
#@gmic : Solidify selected transparent images.
#@gmic : Default values: 'smoothness=75%', 'diffusion_type=1' and 'diffusion_iter=20'.
#@gmic : $ image.jpg 100%,100% -circle. 50%,50%,25%,1,255 -append c --solidify , -display_rgba
solidify : -check "${1=75%}>=0 && isint(${2=1}) && $2>=0 && $2<=2 && ${3=20}>=0"
-v - s0="isotropic" s1="delaunay-oriented" s2="edge-oriented"
-v + -e[^-1] "Solidify transparent image$? with smoothness $1 and $3 iterations of "${s$2}" diffusion." -v -
-repeat $! -l[$>] -split_opacity
-if {$!>1} -le. 128 -inpaint_diffusion.. [1],${1-3} -rm. -endif
-endl -done -v +
#@gmic syntexturize : _width[%]>0,_height[%]>0
#@gmic : Resynthetize 'width'x'height' versions of selected micro-textures by phase randomization.
#@gmic : The texture synthesis algorithm is a straightforward implementation of the method described in :
#@gmic : http://www.ipol.im/pub/art/2011/ggm_rpn/
#@gmic : Default values: 'width=height=100%'.
#@gmic : $ image.jpg -crop 2,282,50,328 --syntexturize 320,320
syntexturize : -check "${1=100%}>0 && ${2=$1}>0"
-e[^-1] "Resynthetize $1x$2 versions of texture$? by phase randomization."
-v - -repeat $! -l[$>]
mM={im},{iM} -repeat {s} -sh. $> sum$>={is} var$>={iv} -rm. -done
nw={if(${-is_percent\ $1},$1*w,$1)}
nh={if(${-is_percent\ $2},$2*h,$2)}
-repeat {s} sum$>*={$nw*$nh/(w*h)} -done
-if {$nw>w||$nh>h}
-periodize_poisson
100%,100% -rectangle. 5,5,{w-6},{h-6},1,1 -b. 2 -n. 0,1
$nw,$nh,1,{-2,s} -fc. ${-average_color...}
-j. [-3],{(w-{-2,w})/2},{(h-{-2,h})/2},0,0,1,[-2]
-rm[-3,-2]
-else
-r $nw,$nh,1,100%,0,0,0.5,0.5
-periodize_poisson
-endif
-fft
100%,100% -rand. {-pi},{pi}
-=. 0
-if {!(w%2)} -=. {(u<0.5)*pi},{int(w/2)} -endif
-if {!(h%2)} -=. {(u<0.5)*pi},0,{int(h/2)} -endif
-if {!(h%2)&&!(h%2)} -=. {(u<0.5)*pi},{int(w/2)},{int(h/2)} -endif
--sin. -cos..
--*[-4,-1] --*[-4,-3] -+[-2,-1]
-*[-5,-3] -*[-3,-2] --[-3,-2]
-repeat {s} -=.. ${sum$>},0,0,0,$> -=. 0,0,0,0,$> -done
-ifft -rm.
-repeat {s} -sh. $> avg={ia} --. $avg -*. {sqrt(${var$>}/if(iv,iv,1))} -+. $avg -rm. -done
-c $mM
-endl -done -v +
#@gmic syntexturize_patchmatch : _width[%]>0,_height[%]>0,_nb_scales>=0,_patch_size>0,_blending_size>=0,_precision>=0
#@gmic : Resynthetize 'width'x'height' versions of selected micro-textures using a patch-matching algorithm.
#@gmic : If 'nbscales==0', the number of scales used is estimated from the image size.
#@gmic : Default values: 'width=height=100%', 'nb_scales=0', 'patch_size=7', 'blending_size=5' and 'precision=1'.
#@gmic : $ image.jpg -crop 2,282,50,328 --syntexturize_patchmatch 320,320
syntexturize_patchmatch : -check "${1=100%}>0 && ${2=$1}>0 && isint(${3=0}) && $3>=0 && isint(${4=7}) && $4>0 && ${5=5}>=0 && ${6=1}>=0"
-e[^-1] "Resynthetize $1x$2 version(s) of texture$? using a patch-matching algorithm with "${"-v - -if $3 -u \"$3 \" -else -u auto- -endif -v +"}"scales, $4x$4 patches, blending size $5 and precision $6."
-v - -repeat $! -l[$>]
nb_scales={round(if($3,$3,log2(min(w,h)/16)),1,1)}
width={if(${"-is_percent $1"},round(w*$1,1,1),$1)}
height={if(${"-is_percent $2"},round(h*$2,1,1),$2)}
-repeat $nb_scales
scale={100*(0.5^$<)}
--r[0] $scale%,$scale%,1,3,2
-if {!$>}
{1+round(w*$width/{0,w},1,1)},{1+round(h*$height/{0,h},1,1)},1,1
-noise. 0.2,2 --distance. 1 -*. -1
-label_fg.. 0 -watershed.. [-1] -rm.
100%,100%,1,1,x --f. y -a[-2,-1] c -channels. 0,2
--blend. [-2],shapeaverage --.. [-1] -rm.
-channels. 0,1
{-2,iM+1} -rand. 0,{-4,w} --rand. 0,{-4,h} -a[-2,-1] c
-map... [-1] -rm. -+[-2,-1] -round.
-s. c -%.. {-3,w} -%. {-3,h} -a[-2,-1] c
-else
-rv[-2,-1] -channels. 0,1
-*. 2 -r. 200%,200%,1,2,1
-f. "*upc = i(x-1,y,0,0);
vpc = i(x-1,y,0,1);
ucp = i(x,y-1,0,0);
vcp = i(x,y-1,0,1);
ucc = i(x,y,0,0);
vcc = i(x,y,0,1);
if (ucc==upc && vcc==vpc && c==0, upc + 1,
if (ucc==ucp && vcc==vcp && c==1, vcp + 1,i))"
-endif
psize={-2,min(w,h,$4)}
-repeat {1+$6*$<}
--_syntexturize_patchmatch.. [-1],{int(max(3,$5*$scale%))}
-patchmatch. [-3],$psize,$psize,1,4,4,0,[-2] -rm..
-done
-rm..
-done
-_syntexturize_patchmatch.. [-1],$5
-rm. -r $width,$height,1,100%,0,0,0.5,0.5
-endl -done -v +
_syntexturize_patchmatch : -check ${-is_image_arg\ $1}" && isint(${2=3}) && $2>=0"
-if {$2<=1} -pass$1 -warp[^-1] [-1],0 -rm[-1]
-else -repeat $! -pass$1 -l[$>,-1]
[1],[1],1,[0]
p1={int($2/2)} p2={$2-$p1-1}
-f. "*avg = norm = 0;
for (q = -"$p1", q<="$p2", ++q,
for (p = -"$p1", p<="$p2", ++p,
X = x + p;
Y = y + q;
u = i(#1,X,Y,0,0);
v = i(#1,X,Y,0,1);
X = u - p;
Y = v - q;
if (X>=0 && X<w#0 && Y>=0 && Y<h#0,
val = i(#0,X,Y,0,c,0,0);
avg+=val;
++norm;
)
)
); avg/norm"
-k.
-endl -done -endif
#@gmic tv_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of the total variation flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --tv_flow 40
tv_flow : -skip ${1=10},${2=30},${3=0}
-e[^-1] "Apply $1 iterations of the total variation flow on image$?, with time step $2."
-v - -pde_flow $1,$2,curvature,$3 -v +
#@gmic unsharp : radius[%]>=0,_amount>=0,_threshold[%]>=0
#@gmic : Apply unsharp mask on selected images.
#@gmic : Default values: 'amount=2' and 'threshold=0'.
#@gmic : $ image.jpg -blur 3 --unsharp 1.5,15 -cut 0,255
unsharp : -check "${2=2}>=0" -skip ${3=0}
-e[^-1] "Apply unsharp mask on image$?, with radius $1, amount $2 and threshold $3."
-v - -repeat $!
--b[$>] $1 --. [$>]
-if $3 --norm. ->=. $3 -*[-2,-1] -endif
-*. $2 --[$>,-1]
-done -v +
#@gmic unsharp_octave : _nb_scales>0,_radius[%]>=0,_amount>=0,threshold[%]>=0
#@gmic : Apply octave sharpening on selected images.
#@gmic : Default values: 'nb_scales=4', 'radius=1', 'amount=2' and 'threshold=0'.
#@gmic : $ image.jpg -blur 3 --unsharp_octave 4,5,15 -cut 0,255
unsharp_octave : -check "${1=4}>0 && ${3=2}>=0" -skip ${2=1},${4=0}
-e[^-1] "Apply octave sharpening on image$?, with $1 scales, radius $2, amount $3 and threshold $4."
-v - -repeat $! -l[$>] nm={0,n}
--f 0 weight=0
-repeat $1
--unsharp[0] {$2*2^-$<},$3,$4 -*. {2^-$>}
weight+={2^-$>}
-+[1,-1]
-done
-rm[0] -/ $weight
-nm $nm -endl -done -v +
#@gmic vanvliet : std_variation>=0[%],order={ 0 | 1 | 2 | 3 },axis={ x | y | z | c },_boundary : (+)
#@gmic : Apply Vanvliet recursive filter on selected images, along specified axis and with
#@gmic : specified standard deviation, order and boundary conditions.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --vanvliet 3,1,x
#@gmic : $ image.jpg --vanvliet 30,0,x -vanvliet.. 30,0,y -add
#@gmic watermark_fourier : text,_size>0
#@gmic : Add a textual watermark in the frequency domain of selected images.
#@gmic : Default value: 'size=33'.
#@gmic : $ image.jpg --watermark_fourier "Watermarked!" --display_fft -remove[-3,-1] -normalize 0,255 -append[-4,-2] y -append[-2,-1] y
watermark_fourier : -check ${2=33}>0
-e[^-1] "Add textual watermark '$1' with size $2 in the frequency domain of image$?."
-v - -i[0] 0 -t[0] "$1",0,0,$2,1,1 ->=[0] 0.5 -autocrop[0] 0
-repeat {$!-1} w2={int(w/2)} h2={int(h/2)}
-fft.
-shift[-2,-1] $w2,$h2,0,0,2
[0],[0],1,{s}
-j[-3,-2] [-1],3,3,0,0,1,[0]
-mirror[0] x
-j[-3,-2] [-1],{{-2,w}-2-{0,w}},3,0,0,1,[0]
-mirror[0] y
-j[-3,-2] [-1],{{-2,w}-2-{0,w}},{{-2,h}-2-{0,h}},0,0,1,[0]
-mirror[0] x
-j[-3,-2] [-1],3,{{-2,h}-2-{0,h}},0,0,1,[0]
-mirror[0] y
-rm.
-shift[-2,-1] -$w2,-$h2,0,0,2
-ifft[-2,-1] -rm.
-mv. 1 -done
-rm[0] -v +
#@gmic watershed : [priority_image],_is_high_connectivity={ 0 | 1 } : (+)
#@gmic : Compute the watershed transform of selected images.
#@gmic : Default value: 'is_high_connectivity=1'.
#@gmic : $ 400,400 -noise 0.2,2 --distance 1 -mul. -1 -label.. -watershed.. [-1] -mod.. 256 -map.. 0 -reverse
#@gmic :: Features extraction
#@gmic area : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Compute area of connected components in selected images.
#@gmic : Default values: 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -stencil. 1 --area 0
#@gmic : $$
area : -check "$1>=0" -skip ${2=0}
-e[^-1] "Compute area of connected components in image$?, with tolerance $1 and "${-arg\ 1+!$2,high,low}" connectivity."
-v - -repeat $! -l[$>] -s c
-repeat $! -label[$>] $1,$2 nb={$>,1+iM} --histogram[$>] $nb,0,{$nb-1} -map[$>] [-1] -rm. -done
-a c -endl -done -v +
#@gmic area_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Compute area of connected components for non-zero values in selected images.
#@gmic : Similar to '-area' except that 0-valued pixels are not considered.
#@gmic : Default values: 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -stencil. 1 --area_fg 0
area_fg : -check "$1>=0" -skip ${2=0}
-e[^-1] "Compute area of foreground connected components in image$?, with tolerance $1 and "${-arg\ 1+!$2,high,low}" connectivity."
-v - -repeat $! -l[$>] -s c
-repeat $! -label_fg[$>] $1,$2 nb={$>,1+iM} --histogram[$>] $nb,0,{$nb-1} -=. 0 -map[$>] [-1] -rm. -done
-a c -endl -done -v +
#@gmic at_line : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%]
#@gmic : Retrieve pixels of the selected images belonging to the specified line (x0,y0,z0)-(x1,y1,z1).
#@gmic : $ image.jpg --at_line 0,0,0,100%,100%,0
at_line : -check ${7=100%}>=0
-e[^-1] "Retrieve pixels of image$?, belonging to line ($1,$2,$3)-($4,$5,$6)."
-v - -repeat $! -l[$>]
x0={if(${-is_percent\ $1},(w-1)*$1,$1)}
y0={if(${-is_percent\ $2},(h-1)*$2,$2)}
z0={if(${-is_percent\ $3},(d-1)*$3,$3)}
x1={if(${-is_percent\ $4},(w-1)*$4,$4)}
y1={if(${-is_percent\ $5},(h-1)*$5,$5)}
z1={if(${-is_percent\ $6},(d-1)*$6,$6)}
($x0,$x1^$y0,$y1^$z0,$z1)
-r. {1+max(abs($x1-$x0),abs($y1-$y0),abs($z1-$z0))},1,1,3,3
-round. 1 -warp[0] [-1],0,0,0 -rm.
-endl -done -v +
#@gmic barycenter
#@gmic : Compute the barycenter vector of pixel values.
#@gmic : $ 256,256 -ellipse 50%,50%,20%,20%,0,1,1 -deform 20 --barycenter --ellipse.. {@0,1},5,5,0,10
barycenter :
-e[^-1] "Compute the barycenter vector of pixel values of image$?."
-v - -norm -repeat $! -l[$>] nm={0,b}
sum={is}
-if {$sum>0}
-if {d>1} --* 'z' z={is} -rm. -else z=0 -endif
-if {h>1} --* 'y' y={is} -rm. -else y=0 -endif
-* 'x' x={is} -rm.
({$x/$sum};{$y/$sum};{$z/$sum})
-else ({w/2},{h/2},{d/2}) -rm..
-endif
-nm "[barycenter of '"$nm"']" -endl -done -v +
#@gmic detect_skin : 0<=tolerance<=1,_skin_x,_skin_y,_skin_radius>=0
#@gmic : Detect skin in selected color images and output an appartenance probability map.
#@gmic : Detection is performed using CbCr chromaticity data of skin pixels.
#@gmic : If arguments 'skin_x', 'skin_y' and 'skin_radius' are provided, skin pixels are learnt
#@gmic : from the sample pixels inside the circle located at ('skin_x','skin_y') with radius 'skin_radius'.
#@gmic : Default value: 'tolerance=0.5' and 'skin_x=skiny=radius=-1'.
detect_skin : -check "${1=0.5}>=0 && $1<=1" -skip ${2=-1},${3=-1},${4=-1}
-if {$2<0||$3<=0||$4<=0}
-e[0--3] "Detect skin in image$?, using tolerance $1."
-v -
m0=120.9292108800069
m1=142.5745272918084
A=0.09749985486268997
B=0.06388871371746063
C=0.05250053107738495
-to_rgb -srgb2rgb -rgb2ycbcr -channels 1,2
-repeat $! -l[$>]
whd={w},{h},{d} -r {w*h*d},2,1,1,-1
-s y --[0] $m0 --[1] $m1 -a y
-i[0] ($A,$B;$B,$C) --** -rm[0]
-* -s y -+ -*. {$1-1} -exp.
-r $whd,1,-1
-endl -done
-else
-e[0--3] "Detect skin in image$?, using tolerance $1 and target circle at ($2,$3) with radius $4."
-v -
-to_rgb -srgb2rgb -rgb2ycbcr -channels 1,2
-repeat $! -l[$>]
100%,100% -circle[1] $2,$3,$4,1,1 --f[1] 'if(i,y,-1)' -f[1] 'if(i,x,-1)' -discard[1,2] -1 -a[1,2] c
--warp[0] [1],0,0 -rm[1]
-s[1] c
m0={1,ia} --[1] $m0
m1={2,ia} --[2] $m1
M={h} -a[1,2] x --transpose[1] -rv[1,2] -**[1,2] -/[1] $M -invert[1]
-rv whd={w},{h},{d} -r[1] {w*h*d},2,1,1,-1
-s[1] y --[1] $m0 --[2] $m1 -a[1,2] y --** -rm[0]
-* -s y -+ -*. {$1-1} -exp.
-r $whd,1,-1
-endl -done
-endif
-v +
#@gmic displacement : [source_image],_smoothness,_precision>=0,_nb_scales>=0,_iteration_max>=0,is_backward={ 0 | 1 },_[guide] : (+)
#@gmic : Estimate displacement field between specified source and selected target images.
#@gmic : If 'smoothness>=0', regularization type is set to isotropic, else to anisotropic.
#@gmic : If 'nbscales==0', the number of scales used is estimated from the image size.
#@gmic : Default values: 'smoothness=0.1', 'precision=5', 'nb_scales=0', 'iteration_max=10000', 'is_backward=1' and '[guide]=(unused)'.
#@gmic : $ image.jpg --rotate 3,1,0,50%,50%,0.9 --displacement. [-2] -quiver. [-1],15,-20,1,1,{1.5*iM}
#@gmic distance : isovalue[%],_metric : isovalue[%],[metric],_method : (+)
#@gmic : Compute the unsigned distance function to specified isovalue, opt. according to a custom metric.
#@gmic : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean | 3=squared-euclidean }.
#@gmic : 'method' can be { 0=fast-marching | 1=low-connectivity dijkstra | 2=high-connectivity dijkstra | 3=1+return path | 4=2+return path }.
#@gmic : Default value: 'metric=2' and 'method=0'.
#@gmic : $ image.jpg -threshold 20% -distance 0 -pow 0.3
#@gmic : $ 400,400 -set 1,50%,50% --distance[0] 1,2 --distance[0] 1,1 -distance[0] 1,0 -mod 32 -threshold 16 -append c
#@gmic : $$
#@gmic float2fft8
#@gmic : Convert selected float-valued images to 8bits fourier representations.
float2fft8 :
-e[^-1] "Convert float-valued image$? to 8bits fourier representations."
-v - -repeat $! -l[$>]
-fftpolar -+.. 1 -log.. -float2int8[-2,-1] -a y
-endl -done -v +
#@gmic fft82float
#@gmic : Convert selected 8bits fourier representations to float-valued images.
fft82float :
-e[^-1] "Convert float-valued image$? to 8bits fourier representations."
-v - -repeat $! -l[$>]
-s y,2 -int82float -exp.. --.. 1 -ifftpolar
-endl -done -v +
#@gmic fftpolar
#@gmic : Compute fourier transform of selected images, as centered magnitude/phase images.
#@gmic : $ image.jpg -fftpolar -ellipse 50%,50%,10,10,0,1,0 -ifftpolar
fftpolar :
-e[^-1] "Compute fourier transform of image$?, as centered magnitude/phase images."
-v - -repeat $! -l[$<]
-fft -complex2polar -shift {-round(w/2)},{-round(h/2)},{-round(d/2)},0,2
-endl -done -v +
#@gmic histogram : _nb_levels>0[%],_value0[%],_value1[%] : (+)
#@gmic : Compute the histogram of selected images.
#@gmic : If value range is set, the histogram is estimated only for pixels in the specified
#@gmic : value range. Argument 'value1' must be specified if 'value0' is set.
#@gmic : Default values: 'nb_levels=256', 'value0=0%' and 'value1=100%'.
#@gmic : $ image.jpg --histogram 64 -display_graph. 400,300,3
#@gmic histogram_nd : nb_levels>0[%],_value0[%],_value1[%]
#@gmic : Compute the 1d,2d or 3d histogram of selected multi-channels images (having 1,2 or 3 channels).
#@gmic : If value range is set, the histogram is estimated only for pixels in the specified
#@gmic : value range.
#@gmic : Default values: 'value0=0%' and 'value1=100%'.
#@gmic : $ image.jpg -channels 0,1 --histogram_nd 256
histogram_nd : -check $1>0 -skip ${2=0%},${3=100%}
-e[^-1] "Compute histogram of multi-channels image$?, using $1 levels in range [$1,$2]."
-v -
percent_nblevels=${"-is_percent $1"}
percent_min=${"-is_percent $2"}
percent_max=${"-is_percent $3"}
-repeat $! -l[$>] s={s}
-r {w*h*d},{min(3,s)},1,1,-1
vmin=$2 vmax=$3
-if {$percent_min||$percent_max}
im={im} iM={iM}
vmin={if($percent_min,$im+($iM-$im)*$2,$2)}
vmax={if($percent_max,$im+($iM-$im)*$3,$3)}
-endif
dv={$vmax-$vmin}
nb_levels={max(1,round(if($percent_nblevels,$1*(1+$vmax-$vmin),$1)))}
-f 'if(i>=$vmin&&i<=$vmax,if(i==$vmax,$nb_levels-1,int((i-$vmin)*$nb_levels/($vmax-$vmin))),-1)'
-pointcloud 1,$nb_levels,{if($s>1,$nb_levels,1)},{if($s>2,$nb_levels,1)}
-endl -done -v +
#@gmic histogram_cumul : _nb_levels>0,_is_normalized={ 0 | 1 },_val0[%],_val1[%]
#@gmic : Compute cumulative histogram of selected images.
#@gmic : Default values: 'nb_levels=256', 'is_normalized=0' and 'val0=val1=0'.
#@gmic : $ image.jpg --histogram_cumul 256 -histogram[0] 256 -display_graph 400,300,3
histogram_cumul : -check ${1=256}>0 -skip ${2=0} -skip ${3=0},${4=0}
-arg 1+!$2,"normalized ",""
-e[^-1] "Compute "${}"cumulative histogram of image$?, using $1 levels."
-v - -histogram $1,$3,$4 -cumulate -if $2 -repeat $! -/[$>] {$>,iM} -done -endif -v +
#@gmic histogram_pointwise : nb_levels>0[%],_value0[%],_value1[%]
#@gmic : Compute the histogram of each vector-valued point of selected images.
#@gmic : If value range is set, the histogram is estimated only for values in the specified
#@gmic : value range.
#@gmic : Default values: 'value0=0%' and 'value1=100%'.
histogram_pointwise : -skip ${2=0%},${3=100%}
-e[^-1] "Compute the pointwise histogram of vector-valued points in image$?, with $1 levels."
-v - -repeat $! -l[$>] nm={0,n}
nb_levels={round(if(${-is_percent\ $1},(iM-im)*$1,$1))}
value0={if(${-is_percent\ $2},im+(iM-im)*$2,$2)}
value1={if(${-is_percent\ $3},im+(iM-im)*$3,$3)}
-- $value0 -* {$nb_levels/max(1,abs($value1-$value0))} -c 0,{$nb_levels-1} -round
w={w} h={h} d={d} -r {w*h*d},{s},1,1,-1
-i.. (0,{w-1}) -r.. [-1],[-1],1,1,3 -round..
-r[-2,-1] 300%,100%,1,1,4 -shift. 1 -+[-2,-1] -y.
-i.. ({'CImg3d'},{h/3},{h/3})
(1,0;1,{h/3-1}) -r. 2,{-2,h/3},1,1,3 -round.
3,100%,1,1,1 1,100%,1,1,-1 -y[-5,-3,-2] -a[-5--1] y
{$w*$h*$d},$nb_levels -j3d. [-2],0,0,0,1,0,0,0 -rm..
-r $w,$h,$d,$nb_levels,-1
-nm $nm -endl -done -v +
#@gmic hough : _width>0,_height>0,gradient_norm_voting={ 0 | 1 }
#@gmic : Compute hough transform (theta,rho) of selected images.
#@gmic : Default values: 'width=512', 'height=width' and 'gradient_norm_voting=1'.
#@gmic : $ image.jpg --blur. 1.5 -hough. 400,400 -blur. 0.5 -+. 1 -log.
hough : -check "${1=512}>0 && ${2=$1}>0" -skip ${3=1}
-e[^-1] "Compute $1x$2 hough transform of image$?, "${-arg\ 1+!$3,with,without}" gradient norm voting."
-v - -slices 50% -luminance -repeat $! -l[$>] nm={0,n}
rhomax={sqrt(w^2+h^2)/2}
-g (0,{w-1}) (0;{{-2,h}-1}) -r[-2,-1] {-3,w},{-3,h},1,1,3 --.. {w/2} --. {h/2}
-complex2polar[-4--1] --. [-3] -polar2complex[-2,-1] -rm.
--<. 0 -*. {pi} -+[-3,-1] -abs. -%.. {2*pi}
-*. {$2/$rhomax} -*.. {0.5*$1/pi}
-y[-3--1] x {w} -mv[-4] $! -if {!$3} -f. 1 -endif
-a y -pointcloud 1 -r $1,$2,1,1,0
-nm $nm -endl -done -v +
#@gmic ifftpolar
#@gmic : Compute inverse fourier transform of selected images, from centered magnitude/phase images.
ifftpolar :
-e[^-1] "Compute inverse fourier transform of image$?, from centered magnitude/phase images."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-shift {round(w/2)},{round(h/2)},{round(d/2)},0,2 -polar2complex -ifft -rm.
-endl -done -v +
#@gmic isophotes : _nb_levels>0
#@gmic : Render isophotes of selected images on a transparent background.
#@gmic : Default value: 'nb_levels=64'
#@gmic : $ image.jpg -blur 2 -isophotes 6 -dilate_circ 5 -display_rgba
isophotes : -skip ${1=64}
-e[^-1] "Render isophote maps from images$?, with $1 levels."
-v - -to_rgba -repeat $! -l[$>]
--luminance -repeat $1 --isoline3d[1] {$>*255/($1-1)} -done -rm[1] -+3d[^0] -col3d. 1
[0],[0] -j3d. [-2],0,0,0,1,0,0,0 -rm.. -*
-endl -done -v +
#@gmic label : _tolerance>=0,is_high_connectivity={ 0 | 1 } : (+)
#@gmic : Label connected components in selected images.
#@gmic : Default values: 'tolerance=0' and 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -threshold 60% -label -normalize 0,255 -map 0
#@gmic : $ 400,400 -set 1,50%,50% -distance 1 -mod 16 -threshold 8 -label -mod 255 -map 2
#@gmic : $$
#@gmic label_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Label connected components for non-zero values (foreground) in selected images.
#@gmic : Similar to '-label' except that 0-valued pixels are not labeled.
#@gmic : Default value: 'is_high_connectivity=0'.
label_fg : -check "$1>=0" -skip ${2=0}
-e[^-1] "Label foreground connected components on image [1], with tolerance $1 and "${-arg\ 1+!$2,high,low}" connectivity."
-v - -repeat $! -l[$>]
-if {d>1} --z -1,-1,-1,{w-1},{h-1},{d-1} -label. $1,$2 -z. 1,1,1,{w-1},{h-1},{d-1}
-else --z -1,-1,{w-1},{h-1} -label. $1,$2 -z. 1,1,{w-1},{h-1}
-endif
-!=.. 0 -* --histogram {1+iM} -=. 0
->. 0 -cumulate. -map.. [-1] -rm.
-endl -done -v +
#@gmic max_patch : _patch_size>=1
#@gmic : Return locations of maximal values in local patch-based neighborhood of given size for selected images.
#@gmic : Default value: 'patch_size=16'.
#@gmic : $ image.jpg -norm --max_patch 16
max_patch : -check "isint(${1=16}) && $1>=1"
-e[^-1] "Return locations of maximal values in local patch neighborhood of size $1, in image$?."
-v - -repeat $! --dilate[$>] $1 -==[$>,-1] -done -v +
#@gmic min_patch : _patch_size>=1
#@gmic : Return locations of minimal values in local patch-based neighborhood of given size for selected images.
#@gmic : Default value: 'patch_size=16'.
#@gmic : $ image.jpg -norm --min_patch 16
min_patch : -check "isint(${1=16}) && $1>=1"
-e[^-1] "Return locations of minimal values in local patch neighborhood of size $1, in image$?."
-v - -repeat $! --erode[$>] $1 -==[$>,-1] -done -v +
#@gmic minimal_path : x0[%]>=0,y0[%]>=0,z0[%]>=0,x1[%]>=0,y1[%]>=0,z1[%]>=0,_is_high_connectivity={ 0 | 1 }
#@gmic : Compute minimal path between two points on selected potential maps.
#@gmic : Default value: 'is_high_connectivity=0'.
#@gmic : $ image.jpg --gradient_norm -fill. 1/(1+i) -minimal_path. 0,0,0,100%,100%,0 -pointcloud. 0 -*. 280 -to_rgb. -resize. [-2],0 -or
minimal_path : -check "$1>=0 && $2>=0 && $3>=0" -skip ${7=0}
-e[^-1] "Compute minimal path between points ($1,$2,$3) and ($4,$5,$6) for potential map$?, with "${-arg\ 1+$7,low,high}" connectivity."
-v - -repeat $! -l[$>] nm={0,n}
-- {im} -+ {iM/100}
100%,100% -= 1,${4-6} -distance. 1,[0],{if($7,4,3)} -k.
x={round(if(${-is_percent\ $1},$1*(w-1),$1))}
y={round(if(${-is_percent\ $2},$2*(h-1),$2))}
z={round(if(${-is_percent\ $3},$3*(d-1),$3))}
($x;$y;$z)
-do
p={0,i($x,$y,$z)}
-if {$p&1} x-=1
-elif {$p&2} x+=1
-endif
-if {$p&4} y-=1
-elif {$p&8} y+=1
-endif
-if {$p&16} z-=1
-elif {$p&32} z+=1
-endif
($x;$y;$z)
-while $p
-rm[0,-1] -a x
-nm $nm -endl -done -v +
#@gmic mse : : (+)
#@gmic : Compute MSE (Mean-Squared Error) matrix between selected images.
#@gmic : $ image.jpg --noise 30 --noise[0] 35 --noise[0] 38 -cut. 0,255 -mse
#@gmic patches : patch_width>0,patch_height>0,patch_depth>0,x0,y0,z0,_x1,_y1,_z1,...,_xN,_yN,_zN
#@gmic : Extract N+1 patches from selected images, centered at specified locations.
#@gmic : $ image.jpg --patches 64,64,1,153,124,0,184,240,0,217,126,0,275,38,0
patches : -check "isint($1) && $1>0 && isint($2) && $2>0 && isint($3) && $3>0"
-e[^-1] "Extract $1x$2x$3 patches from image$?, at locations (${4--1})."
-v -
(${4--1}) -r. 3,{w/3},1,1,-1 -permute. yzcx N={w}
H={int(sqrt(w))} W={round(w/$H,1,1)} -r. {$W*$H},1,1,3,0 -r. $W,$H,1,3,-1
-r. {w*$1},{h*$2},{d*$3}
$1,$2,$3,1,x-{int($1/2)} --f. y-{int($2/2)} --f. z-{int($3/2)} -a[-3--1] c -r. [-2],0,2 -+[-2,-1]
-repeat {$!-1} -warp[$>] [-1],0,0,0 -done -rm.
-repeat $! -l[$<] -s y,$H -s x,$W -k[0-{$N-1}] -endl -done
-v +
#@gmic patchmatch : [patch_image],patch_width>=1,_patch_height>=1,_patch_depth>=1,_nb_iterations>=0,_nb_randoms>=0,_output_score={ 0 | 1 },_[guide] : (+)
#@gmic : Estimate correspondence map between selected images and specified patch image, using
#@gmic : the patchmatch algorithm, as described in the paper :
#@gmic : "PatchMatch: A Randomized Correspondence Algorithm for Structural Image Editing", by
#@gmic : Connelly Barnes, Eli Shechtman, Adam Finkelstein, Dan B Goldman(2009).
#@gmic : Each pixel of the returned correspondence map gives the location (p,q) of the closest patch in
#@gmic : the specified patch image. If 'output_score=1', the third channel gives the corresponding
#@gmic : matching score for each patch as well.
#@gmic : Default values: 'patch_height=patch_width', 'patch_depth=1', 'nb_iterations=5', 'nb_randoms=5', 'output_score=0' and 'guide=(undefined)'.
#@gmic : $ image.jpg -testimage2d 320 --patchmatch[0] [1],3 --warp.. [-1],0
#@gmic plot2value
#@gmic : Retrieve values from selected 2d graph plots.
#@gmic : $ 400,300,1,1,'if(y>300*abs(cos(x/10+2*u)),1,0)' --plot2value --display_graph. 400,300
plot2value :
-e[^-1] "Retrieve values from 2d graph plot$?."
-v - -repeat $! -l[$>]
-s c ->= 50%
-repeat $! -l[$>] (1,{w}) -r[1] [0],3 -* -histogram {w},1,{w} -endl -done
-a c
-endl -done -v +
#@gmic pointcloud : _type = { -X=-X-opacity | 0=binary | 1=cumulative | 2=label },_width,_height>0,_depth>0
#@gmic : Convert a Nx1, Nx2, Nx3 or NxM image as a point cloud in a 1d/2d or 3d binary image.
#@gmic : If 'M'>3, the 3-to-M lines sets the (M-3)-dimensional color at each point.
#@gmic : Parameters 'width','height' and 'depth' are related to the size of the final image :
#@gmic :   - If set to 0, the size is automatically set along the specified axis.
#@gmic :   - If set to N>0, the size along the specified axis is N.
#@gmic :   - If set to N<0, the size along the specified axis is at most N.
#@gmic : Points with coordinates that are negative or higher than specified ('width','height','depth')
#@gmic : are not plotted.
#@gmic : Default values: 'type=0' and 'max_width=max_height=max_depth=0'.
#@gmic : $ 3000,2 -rand 0,400 --pointcloud 0 -dilate. 3
#@gmic : $ 3000,2 -rand 0,400 {w} {w},3 -rand. 0,255 -append y --pointcloud 0 -dilate. 3
pointcloud : -check "${1=0}<=2" -skip ${2=0},${3=0},${4=0}
-e[^-1] "Convert image$? to point clouds, in "${-arg\ 2+($1>=0)*$1-($1<0),{-$1}-opacity,binary,cumulative,labeling}" mode,"\
"with ($2,$3,$4) as maximal dimensions."
-v - -repeat $! -l[$>] nm={0,n}
-if {"d>1 || s>1"} -v + -error "Command '-pointcloud': Invalid input image "{w}x{h}x{d}x{s}". Should be NxMx1x1." -endif
-if {h<3} -r 100%,3,1,1,0 -endif
-if {h<4} 100%,1,1,1,1 -a[-2,-1] y -endif
-r {w},1,1,{h},-1
-sh. 0 -round. dx={round(if($2==0,iM+1,if($2<0,min(iM+1,-$2),$2)))}
-sh.. 1 -round. dy={round(if($3==0,iM+1,if($3<0,min(iM+1,-$3),$3)))}
-sh... 2 -round. dz={round(if($4==0,iM+1,if($4<0,min(iM+1,-$4),$4)))}
-rm[-3--1]
$dx,$dy,$dz,{$1!=2?s-3:1}
-if {$1<0}
-f.. ">V = I; P = V[0,2]; C = V[3,size(V) - 1]; I(#-1,P) = (1+$1)*I(#-1,P) - $1*C; V"
-elif {$1==0}
-f.. ">V = I; P = V[0,2]; C = V[3,size(V) - 1]; I(#-1,P) = C; V"
-elif {$1==1}
-f.. ">V = I; P = V[0,2]; C = V[3,size(V) - 1]; I(#-1,P) += C; V"
-else
-f.. ">init(l = 0); V = I; P = V[0,2]; C = V[3,size(V) - 1]; I(#-1,P) = ++l; V"
-endif
-k. -nm $nm -endl -done -v +
#@gmic psnr : _max_value
#@gmic : Compute PSNR (Peak Signal-to-Noise Ratio) matrix between selected images.
#@gmic : Default value: 'max_value=255'.
#@gmic : $ image.jpg --noise 30 --noise[0] 35 --noise[0] 38 -cut. 0,255 -psnr 255 -replace_inf 0
psnr : -skip ${1=255}
-e[^-1] "Compute the "$!x$!" matrix of PSNR values, from image$? with maximum value $1."
-v - -mse -log10 -- {log10($1*$1)} -* -10 -nm. [PSNR] -v +
#@gmic segment_watershed : _threshold>=0
#@gmic : Apply watershed segmentation on selected images.
#@gmic : Default values: 'threshold=2'.
#@gmic : $ image.jpg --segment_watershed 2
segment_watershed : -check "${1=2}>=0"
-e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
-v - -repeat $! -l[$>]
min={im}
-+ {1+$min} --gradient_norm
-if {d>1} --f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && i<j(0,0,1) && i<j(0,0,-1),1,0)"
-else --f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
-endif
-*[-3,-1] -*. -1 -watershed.. [-1] -rm.
-- {1+$min}
-endl -done -v +
#@gmic skeleton : _smoothness[%]>=0
#@gmic : Compute skeleton of binary shapes using distance transform.
#@gmic : Default value: 'smoothness=0'.
#@gmic : $ image.jpg -threshold 50% --skeleton 0
skeleton : -check ${1=0}>=0
-e[^-1] "Compute skeleton of binary image$?."
-v - ->= 50% -distance 0 -b $1 -sharpen 1e10 ->= 100%
-repeat $! --erode[$>] 2 --[$>,-1] -done -v +
#@gmic ssd_patch : [patch],_use_fourier={ 0 | 1 },_boundary_conditions={ 0=dirichlet | 1=neumann }
#@gmic : Compute fields of SSD between selected images and specified patch.
#@gmic : Argument 'boundary_conditions' is valid only when 'use_fourier=0'.
#@gmic : Default value: 'use_fourier=0' and 'boundary_conditions=0'.
#@gmic : $ image.jpg --crop 20%,20%,35%,35% --ssd_patch[0] [1],0,0
ssd_patch : -check ${-is_image_arg\ $1} -skip ${2=0},${3=0}
-e[^-1] "Compute field of SSD between image$? and patch $1 using "${-arg\ 1+!$2,fourier,spatial}" mode."
-v - -repeat $! -pass$1 0 -l[$>,-1]
-r 100%,100%,100%,${-max_s} -s c
-repeat {$!/2} -l[$>,{-1-$<}]
--sqr[1] val={is} -rm.
--sqr[0] --f[1] 1
-if $2
-convolve_fft.. [-1] -rm.
-mirror[1] xyz -convolve_fft[0] [1] -rm[1]
-else
-correlate.. [-1],$3 -rm.
-correlate[0] [1],$3 -rm[1]
-endif
-*[0] -2 -+[0,1] -+ $val
-endl -done -+
-endl -done -v +
#@gmic thinning
#@gmic : Compute skeleton of binary shapes using morphological thinning
#@gmic : (This is a quite slow iterative proces)
#@gmic : $ image.jpg -threshold 50% --thinning
thinning :
-e[^-1] "Compute skeleton of binary image$?, using morphological thinning."
-v - ->= 50% -* 2 -- 1
(-1,-1,-1;0,1,0;1,1,1) (0,-1,-1;1,1,-1;0,1,0) --rotate[-2,-1] 90 --rotate[-2,-1] 90 --rotate[-2,-1] 90
-repeat {$!-8}
bavg={-9,is}
-repeat 99999
--correlate[-9] [-8] ->=. 7 -*. 2 --[-10,-1]
--correlate[-9] [-7] ->=. 6 -*. 2 --[-10,-1]
--correlate[-9] [-6] ->=. 7 -*. 2 --[-10,-1]
--correlate[-9] [-5] ->=. 6 -*. 2 --[-10,-1]
--correlate[-9] [-4] ->=. 7 -*. 2 --[-10,-1]
--correlate[-9] [-3] ->=. 6 -*. 2 --[-10,-1]
--correlate[-9] [-2] ->=. 7 -*. 2 --[-10,-1]
--correlate[-9] [-1] ->=. 6 -*. 2 --[-10,-1]
aavg={-9,is} -if {$aavg==$bavg} -break -endif bavg=$aavg
-done
-mv[-9] 0 -done -rm[-8--1] -+ 1 -/ 2 -v +
#@gmic tones : N>0
#@gmic : Get N tones masks from selected images.
#@gmic : $ image.jpg --tones 3
tones : -check $1>0
-e[^-1] "Get $1 tones masks from image$?."
-v - -norm -n 0,{$1-1} -round 1 -repeat $! -l[$<]
-repeat {$1-1} --==[0] {1+$>} -done -==[0] 0
-endl -done -v +
#@gmic topographic_map : _nb_levels>0,_smoothness
#@gmic : Render selected images as topographic maps.
#@gmic : Default values: 'nb_levels=16' and 'smoothness=2'.
#@gmic : $ image.jpg --topographic_map 10
topographic_map : -check "isint(${1=16}) && $1>0" -skip ${2=2}
-e[^-1] "Render topographic maps from image$?, with $1 levels and smoothness $2."
-v - -repeat $! -l[$>]
--b $2 -isophotes. $1 -compose_channels. + -==. 0 -blend shapeaverage0
-endl -done -v +
#@gmic variance_patch : _patch_size>=1
#@gmic : Compute variance of each images patch centered at (x,y), in selected images.
#@gmic : Default value: 'patch_size=16'
#@gmic : $ image.jpg --variance_patch
variance_patch : -check "isint(${1=16}) && $1>=1"
-e[^-1] "Compute variance of image patches in image$?, with patch size $1."
-v -
$1,$1,1,1,1 -normalize_sum.
-repeat {$!-1} -l[$>,-1]
--sqr[0] -convolve[0,2] [1]
-sqr[0] -rv[0,2] --[0,2] -max[0] 0
-endl -done -rm. -v +
#@gmic :: Image drawing
#@gmic arrow : x0[%],y0[%],x1[%],y1[%],_thickness[%]>=0,_head_length[%]>=0,_head_thickness[%]>=0,_opacity,_pattern,_color1,...
#@gmic : Draw specified arrow on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the arrow is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'thickness=1%', 'head_length=10%', 'head_thickness=3%', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ 400,400,1,3 -repeat 100 -arrow 50%,50%,{u(100)}%,{u(100)}%,3,20,10,0.3,${-RGB} -done
arrow : -check "${5=1%}>=0 && ${6=10%}>=0 && ${7=3%}" -skip ${8=1}
-e[^-1] "Draw arrow in image$?, from ($1,$2) to ($3,$4), with thickness $5, head length $6, head_thickness $7 and opacity $8."
-v - -repeat $! -l[$>]
-polygon. 7,{"
x0 = "${"-is_percent $1"}"?(w-1)*$1:$1;
y0 = "${"-is_percent $2"}"?(h-1)*$2:$2;
x1 = "${"-is_percent $3"}"?(w-1)*$3:$3;
y1 = "${"-is_percent $4"}"?(h-1)*$4:$4;
p0 = [x0,y0];
dp = [x1,y1]-=p0;
l = norm2(dp);
t = "${"-is_percent $5"}"?l*$5:$5;
hl = "${"-is_percent $6"}"?l*$6:$6;
ht = "${"-is_percent $7"}"?l*$7:$7;
lmhl = l - hl;
X = mul([0,-t,lmhl,-t,lmhl,-ht,l,0,lmhl,ht,lmhl,t,0,t],rot(-atan2(dp[1],dp[0])),2);
X+=[p0,p0,p0,p0,p0,p0,p0]"},${8--1}
-endl -done -v +
#@gmic axes : x0,x1,y0,y1,_font_height>=0,_opacity,_pattern,_color1,...
#@gmic : Draw xy-axes on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : To draw only one x-axis at row Y, set both 'y0' and 'y1' to Y.
#@gmic : To draw only one y-axis at column X, set both 'x0' and 'x1' to X.
#@gmic : Default values: 'font_height=14', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ 400,400,1,3,255 -axes -1,1,1,-1
axes : -check "isint(${5=14}) && $5>=0 && ${6=1}>=0" -skip ${7=0},${8=0}
-if {same(['"$7"'],'0x',2)}
-e[0--3] "Draw xy-axes on image$?, with x-range ($1,$2), y-range ($3,$4), font height $5, opacity $6, pattern $7 and color (${8--1})."
-v - pattern=$7 color=${8--1}
-else
-e[0--3] "Draw xy-axes on image$?, with x-range ($1,$2), y-range ($3,$4), font height $5, opacity $6 and color (${7--1})."
-v - pattern=0xffffffff color=${7--1}
-endif
-if {!$5" || "!$6} -v + -return -endif
mx={min($1,$2)} Mx={max($1,$2)}
my={min($3,$4)} My={max($3,$4)}
-repeat $! -l[$>]
w1={0,w-1} h1={0,h-1}
-if {$1!=$2} u=${"-_axes[] $1,$2,{0.3*w/$5}"} offx={arg(1,$u)} deltax={arg(2,$u)} -endif
-if {$3!=$4} u=${"-_axes[] $3,$4,{0.3*h/$5}"} offy={arg(1,$u)} deltay={arg(2,$u)} -endif
is_0x=0
-if {$3==$4} y0=$3 -else y0={v=-$my*$h1/($My-$my);if($4>=$3,v,$h1-v)} -endif
sty={if($y0>$h1-$5,-1,1)}
-if {$1!=$2" && "$y0>=0" && "$y0<=$h1}
-line 0,$y0,$w1,$y0,$6,$pattern,$color
4,4,1,1,x<=y --mirror. y -rows. 1,3 -a[-2,-1] y [-1],[-1],1,[0] -fc. $color
-if {$2>=$1} -j[0] [-1],{$w1-3},{$y0-3},0,0,$6,[-2]
-else -mirror.. x -j[0] [-1],0,{$y0-3},0,0,$6,[-2]
-endif
-rm[-2,-1]
i=0 -do
val={_$offx+$i*$deltax} i+=1
-if {$val>=$mx" && "$val<=$Mx}
x={v=($val-$mx)*$w1/($Mx-$mx);if($2>=$1,v,$w1-v)}
-line $x,{$y0-1},$x,{$y0+1},$6,$pattern,$color
-if $val
0 -t. $val,0,0,$5,1,1 100%,100%,1,[0] -fc. $color
-j[0] [-1],{max(0,min($w1-w,$x-w/2))},{if($sty>0,$y0+3,$y0-h-3)},0,0,$6,[-2] -rm[-2,-1]
-else is_0x=1
-endif
-endif
-while {$val<$Mx}
-endif
is_0y=0
-if {$1==$2} x0=$1 -else x0={v=-$mx*$w1/($Mx-$mx);if($2>=$1,v,$w1-v)} -endif
stx={if($x0>$w1-$5,-1,1)}
-if {$3!=$4" && "$x0>=0" && "$x0<=$w1}
-line $x0,0,$x0,$h1,$6,$pattern,$color
4,4,1,1,x>=y --mirror. x -z. 1,3 -a[-2,-1] x [-1],[-1],1,[0] -fc. $color
-if {$4>=$3} -j[0] [-1],{$x0-3},{$h1-3},0,0,$6,[-2]
-else -mirror.. y -j[0] [-1],{$x0-3},0,0,0,$6,[-2]
-endif
-rm[-2,-1]
i=0 -do
val={_$offy+$i*$deltay} i+=1
-if {$val>=$my" && "$val<=$My}
y={v=($val-$my)*$h1/($My-$my);if($4>=$3,v,$h1-v)}
-line {$x0-1},$y,{$x0+1},$y,$6,$pattern,$color
-if $val
0 -t. $val,0,0,$5,1,1 100%,100%,1,[0] -fc. $color
-j[0] [-1],{if($stx>0,$x0+6,$x0-w-6)},{max(0,min($h1-h,$y-h/2))},0,0,$6,[-2] -rm[-2,-1]
-else is_0y=1
-endif
-endif
-while {$val<$My}
-endif
-if {$is_0x" || "$is_0y}
0 -t. 0,0,0,$5,1,1 100%,100%,1,[0] -fc. $color
-j[0] [-1],{if($stx>0,$x0+6,$x0-w-6)},{if($sty>0,$y0+3,$y0-h-3)},0,0,$6,[-2] -rm[-2,-1]
-endif
-endl -done
-v +
_axes :
n={max(1,round($3))}
d={abs($2-$1)/($n-1)}
s={10^round(log10($d))}
m={round(min($1,$2),$s,-1)}
M={round(max($1,$2),$s,1)}
-do N={1+round(($M-$m)/$s,1,1)} s={2*$s} -while {$N>$n}
-u $m,{$s/2}
#@gmic ball : _size>0, _R,_G,_B,0<=_specular_light<=8,0<=_specular_size<=8,_shadow>=0
#@gmic : Input a 2d RGBA colored ball sprite.
#@gmic : Default values: 'size=64', 'R=255', 'G=R', 'B=R', 'specular_light=0.8', 'specular_size=1' and 'shading=1.5'.
#@gmic : $ -repeat 9 -ball {1.5^($>+2)},${-RGB} -done -append x
ball : -check "${1=64}>0 && ${5=0.8}>=0 && $5<=8 && ${6=1}>=0 && $6<=8 && ${7=1.5}>=0" -skip ${2=255},${3=$2},${4=$3}
-e[^-1] "Input $1x$1 ball with color (${2-4}), specular light $5, specular size $6 and shadow factor $7."
-v - -l[]
{2*$1},{2*$1} -= 1,65%,30% -distance 1 -* -1
--n 0,1 -^[1] $7 -*[1] 1.4 --*[1] $3 --*[1] $4 -*[1] $2 -a[^0] c
->=[0] {100-10*$6}% -b[0] {3*$6}% -n[0] 0,{$5*255} -rv -+ -c 0,255
100%,100% -circle[1] 50%,50%,34%,1,1 -*[0] [1] -*. 255 -a c
-r $1,$1,1,4,2
-endl -v +
#@gmic chessboard : size1>0,_size2>0,_offset1,_offset2,_angle,_opacity,_color1,..,_color2,..
#@gmic : Draw chessboard on selected images.
#@gmic : Default values: 'size2=size1', 'offset1=offset2=0', 'angle=0', 'opacity=1', 'color1=0' and 'color2=255'.
#@gmic : $ image.jpg -chessboard 32,32,0,0,25,0.3,255,128,0,0,128,255
chessboard : -check "$1>0 && ${2=$1}>0" -skip ${3=0},${4=0},${5=0},${6=1},${7=0},${8=255}
-e[^-1] "Draw chessboard on image$?, with sizes ($1,$2), offsets ($3,$4), angle $5 deg., opacity $6 and colors (${7--1})."
-v - -i[0] (${7--1}) -r[0] {{0,w}/2},1,1,2,-1 -permute[0] cyzx
-repeat {$!-1}
w={w} h={h} theta={$5*pi/180}
($3,{$3+$w-1};$3,{$3+$w-1}^$4,$4;{$4+$h-1},{$4+$h-1}) -r. $w,$h,1,2,3
-r. {$w*$h},2,1,1,-1
-i.. ({cos($theta)},{-sin($theta)};{sin($theta)},{cos($theta)}) -**[-2,-1]
-r. $w,$h,1,2,-1
-%. {$1+$2} ->=. $1 -s. c -xor[-2,-1] -map. [0] -r. 100%,100%,1,[-2]
-j.. [-1],0,0,0,0,$6 -rm.
-mv. 1 -done -rm[0] -v +
#@gmic cie1931
#@gmic : Draw CIE-1931 chromaticity diagram on selected images.
#@gmic : $ 500,400,1,3 -cie1931
cie1931 :
-e[^-1] "Draw CIE-1931 chromaticity diagram on image$?."
-v -
(67.5;73.5;109.5;103.5;51.5;100.5;37;36)
(280,420,0;171,829,0;158,820,0;153,816,0;147,811,0;140,804,0;132,794,0;121,776,0;106,747,0;88,701,0;\
65,633,0;42,539,0;20,421,0;5,295,0;0,179,0;4,115,0;10,83,0;16,61,0;25,38,0;35,21,0;47,10,0;58,3,0;\
71,0,0;92,1,0;111,7,0;151,28,0;189,52,0;226,79,0;262,109,0;298,141,0;334,175,0;370,209,0;405,244,0;\
441,279,0;475,313,0;509,347,0;731,568,0)
xM=731 yM=829
2,{h-1},1,1,3,0 1,{h},1,1,'y' --+. 1 -%. {h} -+[-2,-1] 1 -a[-3--1] x
3,{h},1,1,160 1,{h},1,1,1
-y[-4--2] -a[-5--1] y -mv. 0
xR=636 yR=504 xG=297 yG=234 xB=147 yB=774
512,512,1,3 -triangle_shade. 0,0,{w-1},0,0,{h-1},""255,0,0,""0,255,0,""0,0,255 -rgb2srgb.
--compose_channels. max -+. 1e-8 -/[-2,-1] -*. 255
-i.. (67.5;73.5;109.5;103.5;51.5;100.5;3;1;$xR;$yR;-0.01;$xG;$yG;-0.01;$xB;$yB;-0.01;9;0;1;2;0;0;511;0;0;511;-128;512;512;3)
-y. (1) -a[-3--1] y -mv. 1
-repeat {$!-2}
-to_rgb. -fc. 255,255,255 -grid. 10%,10%,0,0,0.3,0xCCCCCCCC,1,0
100%,100%,1,3
--*3d[0,1] {(w-8)/$xM},{(h-32)/$yM}
-j3d... [-1],2,30,0,1,2
--!=... 0 -distance. 1 -*. -1 -watershed[-4] [-1] -rm. -/... 1.5
-j3d... [-1],2,30,0,1,2
-p3d. 1 -p3d. 2 -col3d. 128 -j3d... [-1],2,30,0,1,1 -rm.
{-2,w},{-2,h} -j3d. [-2],2,30,0,1,2 -rm..
--erode. 4 --. [-2] -==. 0 -*[-3,-1]
-a[-2,-1] c -blend[-2,-1] alpha
100%,100%,1,1,255 -axes. 0,0.75,0.85,0,14,1 --erode. 3 -negative. -to_rgb..
-j... [-2],0,0,0,0,1,[-1],400 -rm[-2,-1]
-mv. 2 -done -rm[0,1] -v +
#@gmic circle : x[%],y[%],R[%],_opacity,_pattern,_color1,..
#@gmic : Draw specified colored circle on selected images.
#@gmic : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the circle is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 300 -circle {u(100)}%,{u(100)}%,{u(30)},0.3,${-RGB} -done -circle 50%,50%,100,0.7,255
circle : -skip ${4=1},${5=0}
-if {same(['"$5"'],'0x',2)}
-e[0--3] "Draw outlined circle at ($1,$2) with radius $3 on image$?, with opacity $4, pattern $5 and color (${6--1})."
-else
-e[0--3] "Draw filled circle at ($1,$2) with radius $3 on image$?, with opacity $4 and color (${5--1})."
-endif
-v - -ellipse $1,$2,$3,$3,0,${4--1} -v +
#@gmic ellipse : x[%],y[%],R[%],r[%],_angle,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored ellipse on selected images.
#@gmic : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the ellipse is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 300 -ellipse {u(100)}%,{u(100)}%,{u(30)},{u(30)},{u(180)},0.3,${-RGB} -done -ellipse 50%,50%,100,100,0,0.7,255
#@gmic flood : x[%],_y[%],_z[%],_tolerance>=0,_is_high_connectivity={ 0 | 1 },_opacity,_color1,.. : (+)
#@gmic : Flood-fill selected images using specified value and tolerance.
#@gmic : Default values: 'y=z=0', 'tolerance=0', 'is_high_connectivity=0', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 1000 -flood {u(100)}%,{u(100)}%,0,20,0,1,${-RGB} -done
#@gmic gaussian : _sigma1[%],_sigma2[%],_angle
#@gmic : Draw a centered gaussian on selected images, with specified standard deviations and orientation.
#@gmic : Default values: 'sigma1=3', 'sigma2=sigma1' and 'angle=0'.
#@gmic : $ 400,400 -gaussian 100,30,45
#@gmic : $$
gaussian : -skip ${1=3},${2=$1},${3=0}
-e[^-1] "Draw centered gaussian on image$? with standard deviations ($1,$2) and angle $3 deg."
-v -
u={cos($3*pi/180)}
v={sin($3*pi/180)}
dmax={max(w,h)}
-if {isval($1)} l1=$1 -else l1={${1}10000*$dmax/100} -endif
-if {isval($2)} l2=$2 -else l2={${2}10000*$dmax/100} -endif
l1={1/(2*max(1/3,$l1)^2)}
l2={1/(2*max(1/3,$l2)^2)}
A={$l1*$u*$u+$l2*$v*$v}
B={($l1-$l2)*$u*$v}
C={$l1*$v*$v+$l2*$u*$u}
-repeat $! -l[$>] nm={0,n}
w={w} h={h} ds={d},{s} -rm
$w,$h,1,1,'X=x-{($w-1)/2};Y=y-{($h-1)/2};$A*X*X+2*$B*X*Y+$C*Y*Y'
-* -1 -exp -r $w,$h,$ds
-nm $nm -endl -done -v +
#@gmic graph : [function_image],_plot_type,_vertex_type,_ymin,_ymax,_opacity,_pattern,_color1,.. : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified function graph on selected images.
#@gmic : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@gmic : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'plot_type=1', 'vertex_type=1', 'ymin=ymax=0 (auto)', 'opacity=1', 'pattern=(undefined)'
#@gmic : and 'color1=0'.
#@gmic : $ image.jpg --rows 50% -blur. 3 -split. c -div[0] 1.5 -graph[0] [1],2,0,0,0,1,255,0,0 -graph[0] [2],2,0,0,0,1,0,255,0 -graph[0] [3],2,0,0,0,1,0,0,255 -keep[0]
#@gmic grid : size_x[%]>=0,size_y[%]>=0,_offset_x[%],_offset_y[%],_opacity,_pattern,_color1,..
#@gmic : Draw xy-grid on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'offset_x=offset_y=0', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -grid 10%,10%,0,0,0.5,255
#@gmic : $ 400,400,1,3,255 -grid 10%,10%,0,0,0.3,0xCCCCCCCC,128,32,16
grid : -check "$1>=0 && $2>=0" -skip ${3=0},${4=0},${5=1},${6=0},${7=0}
-if {same(['"$6"'],'0x',2)}
-e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, pattern $6 and color (${7--1})."
-v - pattern=$6 color=${7--1}
-else
-e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, and color (${6--1})."
-v - pattern=0xFFFFFFFF color=${6--1}
-endif
is_percentsx=${-is_percent\ $1} is_percentsy=${-is_percent\ $2}
is_percentox=${-is_percent\ $3} is_percentoy=${-is_percent\ $4}
-repeat $! -l[$>]
w={w} h={h} s={s}
size={if($is_percentsx,max(1,w*$1),$1)}
-if {$size>=1}
offset={if($is_percentox,$size*$3,$3)}
({'CImg3d'}) -+. 0.5
1,{1+int($w/$size)},1,1,'y' -*. $size -+. {$offset%$size}
1,{h},1,1,{$h/2} -a[-2,-1] x -z. 0,2 n={h} -i.. ($n;$n)
(1,0;1,{$n-1}) -r. 2,$n,1,1,3 -round.
(-128;1;$h;$s) 1,$h,1,$s -line. 0,0,0,100%,1,$pattern,$color
-if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
(-128;1;$h;1) 1,$h,1,1 -line. 0,0,0,100%,1,$pattern,1
-if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
-y[^0] -a[^0] y -j3d[0] [1],0,0,0,$5,0,0,0 -rm[1]
-endif
size={if($is_percentsy,max(1,h*$2),$2)}
-if {$size>=1}
offset={if($is_percentoy,$size*$4,$4)}
({'CImg3d'}) -+. 0.5
1,{1+int($h/$size)},1,1,'y' -*. $size -+. {$offset%$size}
-i.. 1,{h},1,1,{$w/2} -a[-2,-1] x -z. 0,2 n={h} -i.. ($n;$n)
(1,0;1,{$n-1}) -r. 2,$n,1,1,3 -round.
(-128;$w;1;$s) $w,1,1,$s -line. 0,0,100%,0,1,$pattern,$color
-if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
(-128;$w;1;1) $w,1,1,1 -line. 0,0,100%,0,1,$pattern,1
-if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
-y[^0] -a[^0] y -j3d.. [-1],0,0,0,$5,0,0,0 -rm.
-endif
-endl -done -v +
#@gmic j : eq. to '-image'. : (+)
#@gmic image : [sprite],_x[%],_y[%],_z[%],_c[%],_opacity,_[sprite_mask],_max_opacity_mask : (+)
#@gmic : Draw specified sprite image on selected images.
#@gmic : (eq. to '-j').
#@gmic : Default values: 'x=y=z=c=0', 'opacity=1', 'sprite_mask=(undefined)' and 'max_opacity_mask=1'.
#@gmic : $ image.jpg --crop 40%,40%,60%,60% -resize. 200%,200%,1,3,5 -frame. 2,2,0 -image[0] [-1],30%,30% -keep[0]
#@gmic line : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored line on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 500 -line 50%,50%,{u(w)},{u(h)},0.5,${-RGB} -done -line 0,0,100%,100%,1,0xCCCCCCCC,255 -line 100%,0,0,100%,1,0xCCCCCCCC,255
#@gmic mandelbrot : z0r,z0i,z1r,z1i,_iteration_max>=0,_is_julia={ 0 | 1 },_c0r,_c0i,_opacity : (+)
#@gmic : Draw mandelbrot/julia fractal on selected images.
#@gmic : Default values: 'iteration_max=100', 'is_julia=0', 'c0r=c0i=0' and 'opacity=1'.
#@gmic : $ 400,400 -mandelbrot -2.5,-2,2,2,1024 -map 0 --blur 2 -elevation3d. -0.2
#@gmic marble : _image_weight,_pattern_weight,_angle,_amplitude,_sharpness>=0,_anisotropy>=0,_alpha,_sigma,_cut_low>=0,_cut_high>=0
#@gmic : Render marble like pattern on selected images.
#@gmic : Default values: 'image_weight=0.2', 'pattern_weight=0.1', 'angle=45', 'amplitude=0', 'sharpness=0.4', 'anisotropy=0.8',
#@gmic : 'alpha=0.6', 'sigma=1.1' and 'cut_low=cut_high=0'.
#@gmic : $ image.jpg --marble ,
marble : -skip ${1=0.2},${2=0.1},${3=45},${4=0},${5=0.4},${6=0.8},${7=0.6},${8=1.1},${9=0%},${10=100%}
-e[^-1] "Render marble like pattern on image$?, with image weight $1, pattern weight $2, angle $3 deg., amplitude $4, "\
"sharpness $5, anisotropy $6, alpha $7, sigma $8, and cut ($9,$10)."
-v - sx={$2*sin($3*pi/180)} sy={$2*cos($3*pi/180)} -f sin(x*$sx+y*$sy+i*$1)
-if {$4} -smooth $4,$5,$6,$7,$8 -endif
-c $9,$10 -n 0,255
-v +
#@gmic maze : _width>0,_height>0,_cell_size>0
#@gmic : Input maze with specified size.
#@gmic : $ -maze 30,20 -negative -normalize 0,255
maze : -check "isint(${1=15}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=24}) && $3>0"
-e[^-1] "Input $1x$2 maze."
-v -
({round(u($1-1))},{round(u($2-1))})
$1,$2,1,1,15 --f. 0 -a[-2,-1] c
-_generate_maze $1,$2
-_render_maze. $3 -nm. [maze]
-v +
_generate_maze :
-do
x={-2,@-2} y={-2,@-1}
-=. 1,$x,$y,0,1
is_candidate=0
up=-1 -if {i($x,$y)&8" && "$y>0" && "!i($x,$y-1,0,1)} up=$x,{$y-1},8 is_candidate=1 -endif
down=-1 -if {i($x,$y)&4" && "$y<$2-1" && "!i($x,$y+1,0,1)} down=$x,{$y+1},4 is_candidate=1 -endif
left=-1 -if {i($x,$y)&2" && "$x>0" && "!i($x-1,$y,0,1)} left={$x-1},$y,2 is_candidate=1 -endif
right=-1 -if {i($x,$y)&1" && "$x<$1-1" && "!i($x+1,$y,0,1)} right={$x+1},$y,1 is_candidate=1 -endif
-if $is_candidate
($up,$down,$left,$right) -discard. -1 -r. 3,{h/3},1,1,-1 -shift. 0,{round(u(4))},0,0,2 -rows. 0,0 -mv. -2
-endif
-if $is_candidate
-if {{-2,@-1}==8}   -=. {i($x,$y)&7},$x,$y -=. {i($x,$y-1)&11},$x,{$y-1}
-elif {{-2,@-1}==4} -=. {i($x,$y)&11},$x,$y -=. {i($x,$y+1)&7},$x,{$y+1}
-elif {{-2,@-1}==2} -=. {i($x,$y)&13},$x,$y -=. {i($x-1,$y)&14},{$x-1},$y
-else               -=. {i($x,$y)&14},$x,$y -=. {i($x+1,$y)&13},{$x+1},$y
-endif
-z.. 0,1 -a[-3,-2] y
-else
-if {{-2,h}==1} -break -endif
-rows.. 0,{{-2,h}-2}
-endif
-while 1
-rm.. -channels. 0
_render_maze :
-i[0] $1,$1 -i[1] [0]x15
-line[8-15] 0,0,100%,0,1,1
-line[4-7,12-15] 0,100%,100%,100%,1,1
-line[2-3,6-7,10-11,14-15] 0,0,0,100%,1,1
-line[1-15:2] 100%,0,100%,100%,1,1
-a[0-15] x -r. {w*$1},{h*$1} -*. $1 -channels. 0,1
$1,$1,1,1,x $1,$1,1,1,y -a[-2,-1] c -r. [-2],[-2],1,2,0,2 -+[-2,-1]
-warp.. [-1],0,0,0 -rm.
#@gmic maze_mask : _cellsize>0
#@gmic : Input maze according to size and shape of selected mask images.
#@gmic : Mask may contain disconnected shapes.
#@gmic : $ 0 -text "G'MIC",0,0,53,1,1 -dilate 3 -autocrop 0 -frame 1,1,0 -maze_mask 8 -dilate 3 -negative -* 255
maze_mask : -check "isint(${1=24}) && $1>0"
-e[^-1] "Input masked maze from image$? with cell size $1."
-v - -norm ->= 50% -repeat $! -l[$>]
-do
--rand[0] 0,1 -*. [0] ({xM},{yM}) -rm..
--flood[0] {^},0,0,0,1,2 ->=. 2 --negative. -*.. 15 -a[-2,-1] c
-flood[0] {-2,^},0,0,0,1,0
-_generate_maze {w},{h}
-while {0,iM}
-rm[0] -+ -_render_maze. $1 -nm. [maze]
-endl -done -v +
#@gmic j3d : eq. to '-object3d'. : (+)
#@gmic object3d : [object3d],_x[%],_y[%],_z,_opacity,_rendering_mode,_is_double_sided={ 0 | 1 },_is_zbuffer={ 0 | 1 },_focale,_light_x,_light_y,_light_z,_specular_lightness,_specular_shininess : (+)
#@gmic : Draw specified 3d object on selected images.
#@gmic : (eq. to '-j3d').
#@gmic : 'rendering_mode' can be { 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@gmic : Default values: 'x=y=z=0', 'opacity=1' and 'is_zbuffer=1'. All other arguments take their default values from the 3d environment variables.
#@gmic : $ image.jpg -torus3d 100,10 -cone3d 30,-120 -add3d[-2,-1] -rotate3d. 1,1,0,60 -object3d[0] [-1],50%,50% -keep[0]
#@gmic pack_sprites : _nb_scales>=0,0<=_min_scale<=100,_allow_rotation={ 0=0 deg. | 1=180 deg. | 2=90 deg. | 3=any },_spacing,_precision>=0,max_iterations>=0
#@gmic : Try to randomly pack as many sprites as possible onto the 'empty' areas of an image.
#@gmic : Sprites can be eventually rotated and scaled during the packing process.
#@gmic : First selected image is the canvas that will be filled with the sprites.
#@gmic : Its last channel must be a binary mask whose zero values represent potential locations for drawing the sprites.
#@gmic : All other selected images represent the sprites considered for packing.
#@gmic : Their last channel must be a binary mask that represents the sprite shape (i.e. a 8-connected component).
#@gmic : The order of sprite packing follows the order of specified sprites in the image list.
#@gmic : Sprite packing is done on random locations and iteratively with decreasing scales.
#@gmic : 'nb_scales' sets the number of decreasing scales considered for all specified sprites to be packed.
#@gmic : 'min_scale' (in %) sets the minimal size considered for packing (specified as a percentage of the original sprite size).
#@gmic : 'spacing' can be positive or negative.
#@gmic : 'precision' tells about the desired number of failed trials before ending the filling process.
#@gmic : Default values: 'nb_scales=5', 'min_scale=25', 'allow_rotation=3', 'spacing=1', 'precision=7' and 'max_iterations=256'.
#@gmic : $ 512,512,1,3,"min(255,y*c/2)" 100%,100% -circle 50%,50%,100,1,255 -append c image.jpg -resize2dy. 24 -to_rgba -pack_sprites 3,25
pack_sprites : -check "isint(${1=5}) && $1>=0 && ${2=25}>=0 && $2<=100 && isint(${3=3}) && $3>=0 && $3<=3 && isint(${4=1}) && isint(${5=7}) && $5>=0 && isint(${6=256}) && $6>=0"
-e[^-1] "Randomly pack image$? with $1 scales, minimum scale $2%, "${-arg\ 1+$3,no,180\"\ \"deg.,90\"\ \"deg.,any}" rotation, spacing $4, precision $5 and $6 maximum iterations."
-v - N={$!-1} is_first_time=1
-repeat $! -r[$>] 100%,100%,1,{$>,max(2,s)} -done
-repeat $1
-rprogress {$>*100/$1}
nb_attempts=0
ratio={if($1>1,$2+(100-$2)*$</($1-1),100)}%
-repeat $N --l[{1+$>}]
w={w*$ratio} h={h*$ratio}
-if {$w<1||$h<1} -rm
-else -r $w,$h,1,100%,2 -sh. 100% -!=. 0 area{1+$>}={is} -rm.
-endif
-endl -done
-l[0,{$N+1}--1] -repeat $6
ind={1+($>%$N)} area=${area$ind}
-if {$3==0} [$ind]
-elif {$3==1} --rotate[$ind] {round(u)*180}
-elif {$3==2} --rotate[$ind] {round(u(3))*90}
-else --rotate[$ind] {u*360} -sh. 100% -!=. 0 area={is} -rm.
-endif
--channels[0] 100% -==. 0
-if {$4>1} -erode. {2*$4-1}
-elif {$4<1} -dilate. {-2*$4+3}
-endif
--rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
-if $is_first_time -noise. 0.1,2 -endif
-distance. 0 -noise. 1,1
-max_patch. {$ind,round(1.5*max(w,h))}
-*. [-2] -pointcloud3d.
-if {$N>1} -l.
-s3d -/[1] $N -round[1] -max[1] 1 n={1,@0}
-r[2] 3,{{2,h}/3},1,1,-1
-i[2] 1,{2,h} -rand[2] 0,1 -a[2,3] x -sort[2] +,y -z[2] 1,3 -r[2] 3,$n,1,1 -y[2]
-r[3] 1,{2*$n},1,1,0 -r[4] 1,{3*$n},1,1,0 -r[5] 1,$n,1,1,0 -a y
-endl -endif
n={@7}
-if $n
-s3d. -rm[-2,-1]
-if {$3==0}
[-6] -i.. (-128;{w};{h};{s})
-if {$n>1} 4,{$n-1},1,1,-128,0,0,0 -endif
--channels.. 100% -i.. (-128;{w};{h};{s})
-if {$n>1} [-3] -endif
-elif {$3==1}
--rotate[-6] {round(u(1))*180} -i.. (-128;{w};{h};{s})
-if {$n>1} --rotate. 180 -i.. (-128;{w};{h};{s}) -endif
-if {$n>2} 4,{$n-2},1,1,-128,0,0,0 1,100% -rand. 0,1 -round. 1 -j.. [-1],1 -rm. -endif
--channels[-4] 100% -i.. (-128;{w};{h};{s})
-if {$n>1} --channels[-4] 100% -i.. (-128;{w};{h};{s}) -endif
-if {$n>2} [-5] -endif
-else
--rotate[-6] {round(u(3))*90} -i.. (-128;{w};{h};{s})
-if {$n>1} --rotate. 90 -i.. (-128;{w};{h};{s}) -endif
-if {$n>2} --rotate. 90 -i.. (-128;{w};{h};{s}) -endif
-if {$n>3} --rotate. 90 -i.. (-128;{w};{h};{s}) -endif
-if {$n>4} 4,{$n-4},1,1,-128,0,0,0 1,100% -rand. 0,3 -round. 1 -j.. [-1],1 -rm. -endif
--channels[-8] 100% -i.. (-128;{w};{h};{s})
-if {$n>1} --channels[-8] 100% -i.. (-128;{w};{h};{s}) -endif
-if {$n>2} --channels[-8] 100% -i.. (-128;{w};{h};{s}) -endif
-if {$n>3} --channels[-8] 100% -i.. (-128;{w};{h};{s}) -endif
-if {$n>4} [-9] -endif
-endif
-y[{$N+3}--1] -a[{$N+3}--1] y
-endif
-rm...
[0] -sh. 100% -f. 1 --. [-4]
-j3d.. [-3],0,0,0,1,2,0,0 -rm[-3,-1]
-sh. 100% -area_fg. 0,1 -==. $area
-*. [-3] -rm... -sh.. 0,{-2,s-2} -*. [-2] -rm.
-if {iM} -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
-else
-rm[-2,-1]
nb_attempts+=1
-if {$nb_attempts>$5} -break -else -continue -endif
-endif
-done -k[0] -endl
-done -k[0] -v +
#@gmic piechart : label_height>=0,label_R,label_G,label_B,"label1",value1,R1,G1,B1,...,"labelN",valueN,RN,GN,BN
#@gmic : Draw pie chart on selected (RGB) images.
#@gmic : $ image.jpg -piechart 25,0,0,0,"Red",55,255,0,0,"Green",40,0,255,0,"Blue",30,128,128,255,"Other",5,128,128,128
piechart : -check $1>=0
-e[^-1] "Draw pie chart on image$?, with label height $1 and color ($2,$3,$4)."
-v - $=arg -repeat $! -l[$>]
-ellipse 50%,50%,{w/2-1},{h/2-1},0,1,1
-ellipse 50%,50%,{w/2-1},{h/2-1},0,1,0xFFFFFFFF
(${6--1:5}) -normalize_sum.
theta=0
-if {w>1} -repeat {w}
xe={0.5*{-2,w}*(1+cos($theta))}
ye={0.5*{-2,h}*(1+sin($theta))}
-line.. 50%,50%,$xe,$ye
theta-={2*pi*i($>)}
-done -endif
theta=0
-repeat {w} -if {i($>)}
ntheta={$theta-2*pi*i($>)}
xc={0.5*{-2,w}*(1+0.5*cos(0.5*($ntheta+$theta)))}
yc={0.5*{-2,h}*(1+0.5*sin(0.5*($ntheta+$theta)))}
xf={0.5*{-2,w}*(1+0.8*cos(0.5*($ntheta+$theta)))}
yf={0.5*{-2,h}*(1+0.8*sin(0.5*($ntheta+$theta)))}
-flood.. $xf,$yf,0,0,0,1,${arg{7+5*$>}},${arg{8+5*$>}},${arg{9+5*$>}}
-if {abs($ntheta-$theta)>0.1}
0 -t. ${arg{5+5*$>}},0,0,$1,1,1
($2^$3^$4) -r. [-2],[-2],1,3 -*. [-2]
-j[-4] [-1],{$xc-w/2},{$yc-h/2},0,0,1,[-2]
-rm[-2,-1]
-endif
theta=$ntheta
-endif -done
-rm.
-endl -done -v +
#@gmic plasma : _alpha,_beta,_scale>=0 : (+)
#@gmic : Draw a random colored plasma fractal on selected images.
#@gmic : This command implements the so-called 'Diamond-Square' algorithm.
#@gmic : Default values: 'alpha=1', 'beta=1' and 'scale=8'.
#@gmic : $ 400,400,1,3 -plasma
#@gmic : $$
#@gmic point : x[%],y[%],_z[%],_opacity,_color1,.. : (+)
#@gmic : Set specified colored pixel on selected images.
#@gmic : Default values: 'z=0', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 10000 -point {u(100)}%,{u(100)}%,0,1,${-RGB} -done
#@gmic polka_dots : diameter>=0,_density,_offset1,_offset2,_angle,_aliasing,_shading,_opacity,_color,...
#@gmic : Draw dots pattern on selected images.
#@gmic : Default values: 'density=20', 'offset1=offset2=50', 'angle=0', 'aliasing=10', 'shading=1', 'opacity=1' and 'color=255'.
#@gmic : $ image.jpg -polka_dots 10,15,0,0,20,10,1,0.5,0,128,255
polka_dots : -check $1>=0 -skip ${2=20},${3=50},${4=50},${5=0},${6=10},${7=1},${8=1},${9=255}
-e[^-1] "Draw polka dots on image$?, with diameter $1, density $2, angle $3 deg., shift ($4,$5), aliasing $6 and shading $7."
-v - theta={$5*pi/180} ct={cos($theta)} st={sin($theta)} mid1={$1/2} mid2={$2/2}
-i[0] (${9--1}) -y[0] c
-repeat {$!-1}
WH={max(w,h)}
100%,100%,100%,1,"xn = 100*x/"$WH"-$3; yn = 100*y/"$WH"-$4; \
xr = xn*"$ct"-yn*"$st"; yr = xn*"$st"+yn*"$ct"; \
xc = xr%$2-"$mid2"; yc = yr%$2-"$mid2"; \
"$mid1"-sqrt(xc*xc+yc*yc)"
-*. $6 -c. 0,$7 -n. 0,$8 (${9--1}) -y. c -r. [-2],[-2],[-2]
-j... [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-mv. 1 -done -rm[0] -v +
#@gmic polygon : N>=1,x1[%],y1[%],..,xN[%],yN[%],_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored N-vertices polygon on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the polygon is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,0.3,0,255,0 -polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,1,0xCCCCCCCC,255
#@gmic : $ image.jpg 2,16,1,1,'u(if(x,{h},{w}))' -polygon.. {h},{^},0.6,255,0,255 -remove.
#@gmic quiver : [function_image],_sampling>0,_factor,_is_arrow={ 0 | 1 },_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified 2d vector/orientation field on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'sampling=25', 'factor=-20', 'is_arrow=1', 'opacity=1', 'pattern=(undefined)'
#@gmic : and 'color1=0'.
#@gmic : $ 100,100,1,2,'if(c==0,x-w/2,y-h/2)' 500,500,1,3,255 -quiver. [-2],10
#@gmic : $ image.jpg --resize2dy 600 -luminance[0] -gradient[0] -mul[1] -1 -reverse[0,1] -append[0,1] c -blur[0] 8 -orientation[0] -quiver[1] [0],10,10,1,0.8,255
#@gmic rectangle : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,..
#@gmic : Draw specified colored rectangle on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the rectangle is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 30 -rectangle {u(100)}%,{u(100)}%,{u(100)}%,{u(100)}%,0.3,${-RGB} -done
rectangle : -skip ${5=1},${6=0}
-if {same(['"$5"'],'0x',2)}
-e[0--3] "Draw outlined rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${7--1})."
-else
-e[0--3] "Draw filled rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${6--1})."
-endif
-v - -polygon 4,$1,$2,$3,$2,$3,$4,$1,$4,${5--1} -v +
#@gmic rorschach : 'smoothness[%]>=0','mirroring={ 0=none | 1=x | 2=y | 3=xy }
#@gmic : Render rorschach-like inkblots on selected images.
#@gmic : Default values: 'smoothness=5%' and 'mirroring=1'.
#@gmic : $ 400,400 -rorschach 3%
rorschach : -check "${1=5%}>=0 && isint(${2=1}) && $2>=0 && $2<=3"
-e[^-1] "Render rorschach-like inkblots on image$?, with smoothness $1 and "${-arg\ 1+$2,no,x,y,xy}"-mirroring."
-v -
-if {$2==0}
-rand -1,1 -b $1 ->= 0
-elif {$2==1}
-repeat $! -l[$>]
w={w}
-columns 0,{w/2-1} -rand -1,1 -b $1 ->= 0
--mirror x -if {$w%2} -columns. 1,100% -endif -a x
-endl -done
-elif {$2==2}
-repeat $! -l[$>]
h={h}
-rows 0,{h/2-1} -rand -1,1 -b $1 ->= 0
--mirror y -if {$h%2} -rows. 1,100% -endif -a y
-endl -done
-elif {$2==3}
-repeat $! -l[$>]
w={w} h={h}
-z 0,0,{w/2-1},{h/2-1} -rand -1,1 -b $1 ->= 0
--mirror x -if {$w%2} -columns. 1,100% -endif -a x
--mirror y -if {$h%2} -rows. 1,100% -endif -a y
-endl -done
-endif
-v +
#@gmic sierpinski : recursion_level>=0
#@gmic : Draw Sierpinski triangle on selected images.
#@gmic : Default value: 'recursion_level=7'.
#@gmic : $ image.jpg -sierpinski 7
sierpinski : -check ${1=7}>=0 -skip ${2=50},${3=0},${4=0},${5=100},${6=100},${7=100}
-e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
-v - -_sierpinski ${2-7},$1  -v +
_sierpinski :
-if {$7<=0} -polygon 3,$1%,$2%,$3%,$4%,$5%,$6%,1,255 -return -endif
-_sierpinski $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},{$7-1}
-_sierpinski {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},{$7-1}
-_sierpinski {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},{$7-1}
#@gmic spiralbw
#@gmic : Draw (squared) spiral on selected images.
#@gmic : $ 16,16 -spiralbw
spiralbw :
-e[^-1] "Draw (squared) black and white spiral on image$?."
-v - -channels 0
-f "r=min(x,y,w-1-x,h-1-y); 2*r*(w+h-2*r-1) + if(min(x,h-1-y)>=min(w-1-x,y),x+y,2*(w+h-2-2*r)-x-y)"
-v +
#@gmic spline : x0[%],y0[%],u0[%],v0[%],x1[%],y1[%],u1[%],v1[%],_nb_vertices>=2,_opacity,_color1,..
#@gmic : Draw specified colored spline curve on selected images (cubic hermite spline).
#@gmic : Default values: 'nb_vertices=256', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 30 -spline {u(100)}%,{u(100)}%,{u(-600,600)},{u(-600,600)},{u(100)}%,{u(100)}%,{u(-600,600)},{u(-600,600)},256,0.3,255 -done
spline : -skip ${9=256},${10=1},${11=0}
-e[^-1] "Draw spline from ($1,$2) [$3,$4] to ($5,$6) [$7,$8] on image$?, with $9 vertices, opacity $10 and color (${11--1})."
-v -
-l[] (${11--1}) -s x,-{min(w,3)} N=$! -repeat $! col$>={$>,^} -done -rm -endl
-repeat $! -l[$>]
x0={if(${"-is_percent $1"},$1*(w-1),$1)}
y0={if(${"-is_percent $2"},$2*(h-1),$2)}
u0={if(${"-is_percent $3"},$3*(w-1),$3)}
v0={if(${"-is_percent $4"},$4*(h-1),$4)}
x1={if(${"-is_percent $5"},$5*(w-1),$5)}
y1={if(${"-is_percent $6"},$6*(h-1),$6)}
u1={if(${"-is_percent $7"},$7*(w-1),$7)}
v1={if(${"-is_percent $8"},$8*(h-1),$8)}
-spline3d $x0,$y0,0,$u0,$v0,0,$x1,$y1,0,$u1,$v1,0,$9
-sh. 8,{8+3*$9-1},0,0 -round. -rm.
-repeat $N -col3d[1] ${col$>} -sh[0] {3*$>},{0,min(s-1,3*$>+2)} -j3d. [1],0,0,0,$10,1,0,0 -rm. -done
-rm[1]
-endl -done -v +
#@gmic tetraedron_shade : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,...,R3,G3,B3,...
#@gmic : Draw tetraedron with interpolated colors on selected (volumetric) images.
tetraedron_shade :
-e[^-1] "Draw tetraderon ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12) with interpolated colors in image$?."
-v -
xm={round(min($1,$4,$7,$10),1,-1)} xM={round(max($1,$4,$7,$10),1,1)}
ym={round(min($2,$5,$8,$11),1,-1)} yM={round(max($2,$5,$8,$11),1,1)}
zm={round(min($3,$6,$9,$12),1,-1)} zM={round(max($3,$6,$9,$12),1,1)}
-l[] (${1-3},1;${4-6},1;${7-9},1;${10-12},1) (${13--1}) -r. {w/4},4,1,1,-1 -s. x -solve[^0] [0] -rm[0] -a c -endl
-f[^-1] "*
init(
x0 = $1; y0 = $2; z0 = $3;
x1 = $4; y1 = $5; z1 = $6;
x2 = $7; y2 = $8; z2 = $9;
x3 = $10; y3 = $11; z3 = $12;
u01 = x1 - x0; v01 = y1 - y0; w01 = z1 - z0;
u02 = x2 - x0; v02 = y2 - y0; w02 = z2 - z0;
u03 = x3 - x0; v03 = y3 - y0; w03 = z3 - z0;
u12 = x2 - x1; v12 = y2 - y1; w12 = z2 - z1;
u13 = x3 - x1; v13 = y3 - y1; w13 = z3 - z1;
u23 = x3 - x2; v23 = y3 - y2; w23 = z3 - z2;
nx012 = v01*w02 - w01*v02; ny012 = w01*u02 - u01*w02; nz012 = u01*v02 - v01*u02;
if (nx012*u03 + ny012*v03 + nz012*w03<0, nx012*=-1; ny012*=-1; nz012*=-1);
nx013 = v01*w03 - w01*v03; ny013 = w01*u03 - u01*w03; nz013 = u01*v03 - v01*u03;
if (nx013*u02 + ny013*v02 + nz013*w02<0, nx013*=-1; ny013*=-1; nz013*=-1);
nx023 = v02*w03 - w02*v03; ny023 = w02*u03 - u02*w03; nz023 = u02*v03 - v02*u03;
if (nx023*u01 + ny023*v01 + nz023*w01<0, nx023*=-1; ny023*=-1; nz023*=-1);
nx123 = v12*w13 - w12*v13; ny123 = w12*u13 - u12*w13; nz123 = u12*v13 - v12*u13;
if (-nx123*u01 - ny123*v01 - nz123*w01<0, nx123*=-1; ny123*=-1; nz123*=-1);
);
if (x<"$xm" || x>"$xM" || y<"$ym" || y>"$yM" || z<"$zm" || z>"$zM",i,
dx0 = x - x0; dy0 = y - y0; dz0 = z - z0;
dx1 = x - x1; dy1 = y - y1; dz1 = z - z1;
is_in = dx0*nx012 + dy0*ny012 + dz0*nz012>=0 &&
dx0*nx013 + dy0*ny013 + dz0*nz013>=0 &&
dx0*nx023 + dy0*ny023 + dz0*nz023>=0 &&
dx1*nx123 + dy1*ny123 + dz1*nz123>=0;
is_in? i(#-1,0,0,0)*x + i(#-1,0,1,0)*y + i(#-1,0,2,0)*z + i(#-1,0,3,0) :i
)
"
-rm.
-v +
#@gmic t : eq. to '-text'. : (+)
#@gmic text : text,_x[%],_y[%],_font_height[%]>=0,_opacity,_color1,.. : (+)
#@gmic : Draw specified colored text string on selected images.
#@gmic : (eq. to '-t').
#@gmic : Exact pre-defined sizes are '13','23','53' and '103'. Using these sizes ensures you draw binary letters without anti-aliasing.
#@gmic : Any other font size is interpolated from an exact size (the upper when possible).
#@gmic : Specifying an empty target image resizes it to new dimensions such that the image contains
#@gmic : the entire text string.
#@gmic : Default values: 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -resize2dy 600 y=0 -repeat 30 -text {2*$>}" : This is a nice text, isn't it ?",10,$y,{2*$>},0.9,255 y+={2*$>} -done
#@gmic : $ 0 -text "G'MIC",0,0,23,1,255
#@gmic text_outline : text,_x[%],_y[%],_font_height>0,_outline>=0,_opacity,_color1,..
#@gmic : Draw specified colored and outlined text string on selected images.
#@gmic : Default values: 'x=y=2', 'font_height=13', 'outline=2', 'opacity=1' and 'color1=255'.
#@gmic : $ image.jpg -text_outline "Hi there!",10,10,63,3
text_outline : -skip ${2=2},${3=2},${4=13},${5=2},${6=1},${7=255}
-e[^-1] "Draw outlined text '$1' at position ($2,$3) on image$?, with font height $4, outline $5, opacity $6 and color ${7--1}."
-v - -if $5
0 -t. "$1",0,0,$4,1,${7--1},1 -expand_xy. {1+$5},0
-s. c,{-narg(${7--1})} -dilate. {2*$5+1}
-repeat {$!-2} -l[$>,-2,-1]
-if {0,w}
-if {{0,s}=={1,s}} -j[0] [1],$2,$3,0,0,$6,[2]
-else --r[1] 100%,100%,1,{0,s},0,1 -j[0] [3],$2,$3,0,0,$6,[2] -rm[3]
-endif
-else -rm[0] -i[0] [0] -endif
-endl -done
-rm[-2,-1]
-else -t "$1",${2-4},${6--1}
-endif -v +
#@gmic triangle_shade : x0,y0,x1,y1,x2,y2,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,....
#@gmic : Draw triangle with interpolated colors on selected images.
#@gmic : $ image.jpg -triangle_shade 20,20,400,100,120,200,255,0,0,0,255,0,0,0,255
triangle_shade :
-e[^-1] "Draw triangle ($1,$2)-($3,$4)-($5,$6) with interpolated colors on image$?."
-v -
-l[] ($1,$2,1;$3,$4,1;$5,$6,1) (${7--1}) -r. {w/3},3,1,1,-1 -s. x -solve[^0] [0] -rm[0] -a c -endl
invarea={(-$4*$5+$2*(-$3+$5)+$1*($2-$6)+$3*$6)^-1}
s1={$2*$5-$1*$6} s2={$6-$2} s3={$1-$5}
t1={$1*$4-$2*$3} t2={$2-$4} t3={$3-$1}
-repeat {$!-1} -l[$>,-1] -repeat {0,s}
a={i(0,0,0,$>)} b={i(0,1,0,$>)} c={i(0,2,0,$>)}
-sh[0] $>
-f. "s = "$invarea"*("$s1" + "$s2"*x + "$s3"*y); t = "$invarea"*("$t1" + "$t2"*x + "$t3"*y); s>=0 && t>=0 && t+s<=1 ? "$a"*x+"$b"*y+"$c":i"
-rm.
-done -endl -done
-rm. -v +
#@gmic truchet : _scale>0,_radius>=0,_pattern_type={ 0=straight | 1=curved }
#@gmic : Fill selected images with random truchet patterns.
#@gmic : Default values: 'scale=32', 'radius=5' and 'pattern_type=1'.
#@gmic : $ 400,300 -truchet ,
truchet : -check "isint(${1=32}) && $1>0 && ${2=3}>=0" -skip ${3=1}
-e[^-1] "Render "${-arg\ 1+!$3,curved,straight}" truchet patterns in image$?, with scale $1 and radius $2."
-v - -repeat $! -l[$>] nm={0,n}
w={w} h={h} s={s} -rm
$1,$1 -= 1,0,0 -= 1,100%,100% -distance 1,{1+$3} M={int(iM/2)}
-ir {$M-$2/2-($1%2)},{$M+$2/2} --mirror y -a x
{round($w/$1,1,1)},{round($h/$1,1,1)} -rand. 0,1 ->=. 50% -r. {w*$1},{h*$1} -*. $1
-channels. 0,1 (0,{$1-1}) -r. $1,$1,1,1,3 --transpose. -a[-2,-1] c -r. [-2],0,2 -+[-2,-1]
-warp.. [-1] -rm. ->= 50% -r $w,$h,1,1,0 -r 100%,100%,1,$s
-nm $nm -endl -done -v +
#@gmic turbulence : _radius>0,_octaves={1,2,3...,12},_alpha>0,_difference={-10,10},_mode={0,1,2,3}
#@gmic : Render fractal noise or turbulence on selected images.
#@gmic : Default values: 'radius=32', 'octaves=6', 'alpha=3', 'difference=0' and 'mode=0'.
#@gmic : $ 400,400,1,3 -turbulence 16
#@gmic : $$
turbulence : -check "${1=32}>0 && ${2=6}>0" -skip ${3=3},${4=0},${5=0}
-e[^-1] "Render fractal noise or turbulence on image$?, with radius $1, octaves $2, damping per octave $3, difference $4 and mode $5."
-v - -repeat $! -l[$>] nm={0,n}
-if {$4} [-1] -endif
-f. 0 --noise. 10,0 -b. $1,0
-if {$5==0||$5==1} --. {ia} -abs.
-elif {$5==3||$5==4} -^. 2
-elif {$5==5} -^. 3
-endif
-repeat {$2-1}
--noise.. 10,0 -b. {$1/2^$>},0
-if {$5==0} --. {ia} -abs.
-elif {$5==4} -^. 2
-elif {$5==5} -^. 3
-endif
-*.. $3 -+[-2--1]
-done
-n. 0,255
-rm..
-if {$4} -*. $4 -mv.. 2 -- -n. 0,255 -endif
-nm $nm -endl -done -v +
#@gmic yinyang
#@gmic : Draw a yin-yang symbol on selected images.
#@gmic : $ 400,400 -yinyang
yinyang :
-e[^-1] "Draw yin-yang symbol on image$?."
-v - -f 0 -repeat $! -l[$>]
s={s} -channels 0
r={round(0.95*min(w,h)/4)}
--line 50%,0,50%,50%,1,2 -ellipse. 50%,{h/2-$r},$r,$r,0,1,2
-line. 50%,50%,50%,100%,1,1 -ellipse. 50%,{h/2+$r},$r,$r,0,1,1
-flood. {w/2-$r},50%,0,0,0,1,2
-flood. {w/2+$r},50%,0,0,0,1,1
-ellipse.. 50%,50%,{2*$r},{2*$r},0,1,1
-*
-ellipse. 50%,{h/2-$r},{$r/3},{$r/3},0,1,1
-ellipse. 50%,{h/2+$r},{$r/3},{$r/3},0,1,2
-r 100%,100%,1,$s
-endl -done -v +
#@gmic :: Matrix computation
#@gmic dijkstra : starting_node>=0,ending_node>=0 : (+)
#@gmic : Compute minimal distances and pathes from specified adjacency matrices by the Dijkstra algorithm.
#@gmic eigen : (+)
#@gmic : Compute the eigenvalues and eigenvectors of selected symmetric matrices or matrix fields.
#@gmic : If one selected image has 3 or 6 channels, it is regarded as a field of 2x2 or 3x3 symmetric matrices,
#@gmic : whose eigen elements are computed at each point of the field.
#@gmic : $ (1,0,0;0,2,0;0,0,3) --eigen
#@gmic : $ image.jpg -structuretensors -blur 2 -eigen -split[0] c
#@gmic : $$
#@gmic invert : (+)
#@gmic : Compute the inverse of the selected matrices.
#@gmic : $ (0,1,0;0,0,1;1,0,0) --invert
#@gmic solve : [image] : (+)
#@gmic : Solve linear system AX = B for selected B-matrices and specified A-matrix.
#@gmic : If the system is under- or over-determined, the least square solution is returned.
#@gmic : $ (0,1,0;1,0,0;0,0,1) (1;2;3) --solve. [-2]
#@gmic svd : (+)
#@gmic : Compute SVD decomposition of selected matrices.
#@gmic : $ 10,10,1,1,'if(x==y,x+u(-0.2,0.2),0)' --svd
#@gmic transpose
#@gmic : Transpose selected matrices.
#@gmic : $ image.jpg --transpose
transpose :
-e[^-1] "Transpose image$?."
-v - -permute yxzc -v +
#@gmic trisolve : [image] : (+)
#@gmic : Solve tridiagonal system AX = B for selected B-vectors and specified tridiagonal A-matrix.
#@gmic : Tridiagonal matrix must be stored as a 3 column vector, where 2nd column contains the
#@gmic : diagonal coefficients, while 1st and 3rd columns contain the left and right coefficients.
#@gmic : $ (0,0,1;1,0,0;0,1,0) (1;2;3) --trisolve. [-2]
#@gmic :: 3d rendering
#@gmic +3d : eq. to '-add3d'. : (+)
#@gmic add3d : tx,_ty,_tz : [object3d] : (no arg) : (+)
#@gmic : Shift selected 3d objects with specified displacement vector, or merge them with specified
#@gmic : 3d object, or merge all selected 3d objects together.
#@gmic : (eq. to '-+3d').
#@gmic : Default values: 'ty=tz=0'.
#@gmic : $ -sphere3d 10 -repeat 5 --add3d. 10,{u(-10,10)},0 -color3d. ${-RGB} -done -add3d
#@gmic : $ -repeat 20 -torus3d 15,2 -color3d. ${-RGB} -mul3d. 0.5,1 -if {$>%2} -rotate3d. 0,1,0,90 -endif -add3d. 70 -add3d -rotate3d. 0,0,1,18 -done -double3d 0
#@gmic animate3d : _width>0,_height>0,_angle_dx,_angle_dy,_angle_dz,_zoom_factor>=0,_filename
#@gmic : Animate selected 3d objects in a window.
#@gmic : If argument 'filename' is provided, each frame of the animation is saved as a numbered filename.
#@gmic : Default values: 'width=640', 'height=480', 'angle_dx=0', 'angle_dy=1', 'angle_dz=0', 'zoom_factor=1' and 'filename=(undefined)'.
animate3d : -skip ${1=640},${2=480},${3=0},${4=1},${5=0},"${7=""}" -check ${6=1}>=0
-e[^-1] "Animate 3d object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
-v - is_multi={$!>1} -repeat $! --l[$>]
-n3d -*3d {$6*min($1,$2)/1.5} -c3d
ax=0 ay=0 az=0 frame=0 vfact=1
-do
--r3d 1,0,0,$ax -r3d. 0,1,0,$ay -r3d. 0,0,1,$az
ax+=$3 ay+=$4 az+=$5
$1,$2,1,3,-1 -j3d. [-2],50%,50%,0,1
-if {narg("$7")}
-to_rgba. -replace_color. 0,0,-1,-1,-1,255,64,64,64,0
-if $is_multi filename=${-filename\ "$7",$>,$frame} -else filename=${-filename\ "$7",$frame} -endif
-o. $filename frame+=1
-else
-replace. -1,64
-endif
-w. {$vfact*w},{$vfact*h},0,0,-1,-1,{0,n} -wait 20 -k[0]
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-D}} vfact=1.5 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-C}} vfact={1/1.5} -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,-R}} vfact=1 -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}} -rm -w 0
-endl -done -v +
#@gmic apply_camera3d : pos_x,pos_y,pos_z,target_x,target_y,target_z,up_x,up_y,up_z
#@gmic : Apply 3d camera matrix to selected 3d objects.
#@gmic : Default values: 'target_x=0', 'target_y=0', 'target_z=0', 'up_x=0', 'up_y=-1' and 'up_z=0'.
apply_camera3d : -skip ${4=0},${5=0},${6=0},${7=0},${8=-1},${9=0}
-e[^-1] "Apply 3d camera matrix to 3d object$?, with camera position ($1,$2,$3), target position ($4,$5,$6) and up-vector ($7,$8,$9)."
-v -
({$4-$1}^{$5-$2}^{$6-$3})
($7^$8^$9)
-orientation[-2,-1]
-_cross3d {-2,^},{^}
-_cross3d {^},{-3,^}
-rm... -y[-3--1] x -mv[-2,-1] -3
-a[-3--1] y -z. 0,3
--3d[^-1] $1,$2,$3 -pose3d[^-1] {^} -rm. --3d 0,0,800
-v +
_cross3d :
({$2*$6-$3*$5}^{$3*$4-$1*$6}^{$1*$5-$2*$4}) -orientation. -y.
#@gmic array3d : size_x>=1,_size_y>=1,_size_z>=1,_offset_x[%],_offset_y[%],_offset_y[%]
#@gmic : Duplicate a 3d object along the X,Y and Z axes.
#@gmic : Default values: 'size_y=1', 'size_z=1' and 'offset_x=offset_y=offset_z=100%'.
#@gmic : $ -torus3d 10,1 --array3d 5,5,5,110%,110%,300%
array3d : -check "isint($1) && $1>0 && isint(${2=1}) && $2>0 && isint(${3=1}) && $3>0" -skip ${4=100%},${5=100%},${6=100%}
-e[^-1] "Duplicate 3d object$? along X,Y,Z axes with factors ($1,$2,$3) and offsets ($4,$5,$6)."
-v - -repeat $! -l[$>]
--rows 8,{8+3*i[6]} -r. 3,{h/3},1,1,-1 -s. x,3
dx={-3,if(${-is_percent\ $4},$4*(iM-im),$4)}
dy={-2,if(${-is_percent\ $5},$5*(iM-im),$5)}
dz={if(${-is_percent\ $6},$6*(iM-im),$6)}
-rm[-3--1]
off=0 -repeat {int(log2($1))}
--+3d. {2^$>*$dx} -+3d. [-2]
-if {!($1&(2^$>))} -rm.. -else -+3d.. $off off+={2^$>*$dx} -endif
-done -+3d. $off -+3d
off=0 -repeat {int(log2($2))}
--+3d. 0,{2^$>*$dy} -+3d. [-2]
-if {!($2&(2^$>))} -rm.. -else -+3d.. 0,$off off+={2^$>*$dy} -endif
-done -+3d. 0,$off -+3d
off=0 -repeat {int(log2($3))}
--+3d. 0,0,{2^$>*$dz} -+3d. [-2]
-if {!($3&(2^$>))} -rm.. -else -+3d.. 0,0,$off off+={2^$>*$dz} -endif
-done -+3d. 0,0,$off -+3d
-endl -done -v +
#@gmic arrow3d : x0,y0,z0,x1,y1,z1,_radius[%]>=0,_head_length[%]>=0,_head_radius[%]>=0
#@gmic : Input 3d arrow with specified starting and ending 3d points.
#@gmic : Default values: 'radius=5%', 'head_length=25%' and 'head_radius=15%'.
#@gmic : $ -repeat 10 a={$>*2*pi/10} -arrow3d 0,0,0,{cos($a)},{sin($a)},-0.5 -done -+3d
arrow3d : -check "${7=5%}>=0 && ${8=25%}>=0 && ${9=15%}>=0"
-e[^-1] "Input 3d arrow, from (${1-3}) to (${4-6}), with radius $7, head length $8 and head radius $9."
-v -
L={sqrt(($4-$1)^2+($5-$2)^2+($6-$3)^2)}
R={if(${-is_percent\ $7},$7*$L,$7)}
l={if(${-is_percent\ $8},$8*$L,$8)}
r={if(${-is_percent\ $9},$9*$L,$9)}
L-=$l -cylinder3d $R,$L -cone3d $r,$l -+3d. 0,0,$L -+3d[-2,-1]
({$4-$1}^{$5-$2}^{$6-$3}) (0.01^-0.02^0.03) -orientation[-2,-1]
-_cross3d {-2,^},{^} -_cross3d {^},{-3,^} -rm... -y[-3--1] x -mv[-2,-1] -3
-a[-3--1] y
-s3d.. -r[-5] 3,{-5,h/3},1,1,-1 -**[-5,-1]
-y[-4] -a[-6--1] y -+3d. ${1-3} -rv3d.
-v +
#@gmic axes3d : _size_x,_size_y,_size_z,_font_size>0,_label_x,_label_y,_label_z
#@gmic : Input 3d axes with specified sizes along the x,y and z orientations.
#@gmic : Default values: 'size_x=size_y=size_z=1', 'font_size=23', 'label_x=X', 'label_y=Y' and 'label_z=Z'.
#@gmic : $ -axes3d ,
axes3d : -check ${4=23}>0 -skip ${1=1},${2=$1},${3=$2},"${5=X},${6=Y},${7=Z}"
-e[^-1] "Input 3d axes with sizes ($1,$2,$3)."
-v - -l[]
m={max(abs($1),abs($2),abs($3))/40} m2={2*$m} m3={1.2*$m2}
-_axes3d "O",$4 --3d. $m3,$m3,$m3
-if $1
-line3d 0,0,0,$1,0,0
-cone3d $m,{2*$m},16 -r3d. 0,1,0,-90 -+3d. {$1-$m2},0,0
-_axes3d "$5",$4 -+3d. {$1+$m3},0,0
-endif
-if $2
-line3d 0,0,0,0,$2,0
-cone3d $m,{2*$m},16 -r3d. 1,0,0,90 -+3d. 0,{$2-$m2},0
-_axes3d "$6",$4 -+3d. 0,{$2+$m3},0
-endif
-if $3
-line3d 0,0,0,0,0,$3
-cone3d $m,{2*$m},16 -+3d. 0,0,{$3-$m2}
-_axes3d "$7",$4 -+3d. 0,0,{$3+$m3}
-endif
-+3d -nm [3d\ axes]
-endl -v +
_axes3d :
0 -t. "$1",2,0,$2,1,1 --dilate. 3 -*.. 255 -r.. 100%,100%,1,3
-i... (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};3)
-i.. (-128;{w};{h};1) -y[-3,-1] -a[-4--1] y
#@gmic box3d : _size_x,_size_y,_size_z
#@gmic : Input 3d box at (0,0,0), with specified geometry.
#@gmic : Default values: 'size_x=1' and 'size_z=size_y=size_x'.
#@gmic : $ -box3d 100,40,30 --primitives3d 1 -color3d.. ${-RGB}
box3d : -skip ${1=1},${2=$1},${3=$2}
-e[^-1] "Input 3d box, with size ($1,$2,$3)."
-v -
1,86,1,1,\
67.5,73.5,109.5,103.5,51.5,100.5,8,6,\
0,0,0,$1,0,0,$1,$2,0,0,$2,0,\
0,0,$3,$1,0,$3,$1,$2,$3,0,$2,$3,\
4,0,3,2,1,4,4,5,6,7,4,0,1,5,4,4,3,7,6,2,4,0,4,7,3,4,1,2,6,5,\
200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,\
1,1,1,1,1,1
-nm. [3d\ box]
-v +
#@gmic c3d : eq. to '-center3d'.
c3d :
-_center3d
#@gmic center3d
#@gmic : Center selected 3d objects at (0,0,0).
#@gmic : (eq. to '-c3d').
#@gmic : $ -repeat 100 -circle3d {u(100)},{u(100)},{u(100)},2 -done -add3d -color3d. 255,0,0 --center3d -color3d. 0,255,0 -add3d
center3d :
-_$0
_center3d :
-e[0--3] "Center 3d object$?."
-v - -check3d 0 -repeat $! -l[$>]
-if {i[6]}
-s3d -r[2] 3,{2,h/3},1,1,-1 -s[2] x
--[2] {2,(iM+im)/2} --[3] {3,(iM+im)/2} --[4] {4,(iM+im)/2}
-a[2-4] x -y[2] -a y
-endif
-endl -done -v +
#@gmic circle3d : _x0,_y0,_z0,_radius>=0
#@gmic : Input 3d circle at specified coordinates.
#@gmic : Default values: 'x0=y0=z0=0' and 'radius=1'.
#@gmic : $ -repeat 500 a={$>*pi/250} -circle3d {cos(3*$a)},{sin(2*$a)},0,{$a/50} -color3d. ${-RGB},0.4 -done -add3d
circle3d : -skip ${1=0},${2=0},${3=0},${4=1}
-e[^-1] "Input 3d circle at position ($1,$2,$3) with radius $4."
-v -
r={$4/sqrt(3)}
1,24,1,1,\
67.5,73.5,109.5,103.5,51.5,100.5,2,1,\
{$1-$r},{$2-$r},{$3-$r},\
{$1+$r},{$2+$r},{$3+$r},\
5,0,1,0,0,0,200,200,200,1
-nm. [3d\ circle]
-v +
#@gmic circles3d : _radius>=0,_is_filled={ 0 | 1 }
#@gmic : Convert specified 3d objects to sets of 3d circles with specified radius.
#@gmic : Default values: 'radius=1' and 'is_filled=1'.
#@gmic : $ image.jpg -luminance -resize2dy 40 -threshold 50% -* 255 -pointcloud3d -color3d. 255,255,255 -circles3d 0.7
circles3d : -check ${1=1}>=0 -skip ${2=1}
-e[^-1] "Convert 3d object$? to sets of 3d "${-arg\ 1+$2,wireframe,filled}" circles with radius $1."
-v - -p3d 0 -repeat $! -l[$>]
nbv={@6} nbp={@7}
-if {$nbv&&$nbp}
--3d {$1/2},0,0 --+3d $1,0,0 -+3d nbp2={@7}
-s3d -=[1] $nbp,0,1
-r[3] 2,$nbp2,1,1,-1 -columns[3] 1,1 -s[3] y,2 -i[3] 1,$nbp,1,1,5
-i[6] 1,$nbp,1,1,{!$2} -a[3-6] x -columns[3] 0,5
-y[3]
-rows[4] 0,{3*$nbp-1} -rows[5] 0,{$nbp-1} -a y
-endif
-endl -done -v +
#@gmic col3d : eq. to '-color3d'. : (+)
#@gmic color3d : R,_G,_B,_opacity : (+)
#@gmic : Set color and opacity of selected 3d objects.
#@gmic : (eq. to '-col3d').
#@gmic : Default value: 'B=G=R' and 'opacity=(undefined)'.
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d. 1,0,0,20 -color3d. ${-RGB} -done -add3d
#@gmic colorcube3d
#@gmic : Input 3d color cube.
#@gmic : $ -colorcube3d -mode3d 2 --primitives3d 1
colorcube3d :
-e[^-1] "Input 3d RGB-color cube."
-v -
(67.5;73.5;109.5;103.5;51.5;100.5;8;6)
(0;0;0;\
255;0;0;\
255;255;0;\
0;255;0;\
0;0;255;\
255;0;255;\
255;255;255;\
0;255;255)
(12;0;3;2;1;0;0;0;63;63;63;63;0;\
12;1;2;6;5;0;0;0;63;63;63;63;0;\
12;0;4;7;3;0;0;63;0;63;63;0;63;\
12;4;5;6;7;0;0;63;0;63;63;0;63;\
12;0;1;5;4;0;0;63;0;63;63;0;63;\
12;3;7;6;2;0;0;0;63;63;63;63;0)
(0,255;0,255^0,0;255,255^0,0;0,0)
(255,255;255,255^0,0;255,255^0,255;0,255)
(0,0;0,0^0,0;255,255^0,255;0,255)
(0,255;0,255^0,0;255,255^255,255;255,255)
(0,255;0,255^0,0;0,0^0,0;255,255)
(0,255;0,255^255,255;255,255^0,0;255,255)
-r[-6--1] 64,64,1,3,3 -y[-6--1] -i[-7--2] (-128;64;64;3)
(1;1;1;1;1;1)
-a[-16--1] y -nm. [3d\ colorcube]
-v +
#@gmic cone3d : _radius,_height,_nb_subdivisions>0
#@gmic : Input 3d cone at (0,0,0), with specified geometry.
#@gmic : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@gmic : $ -cone3d 10,40 --primitives3d 1 -color3d.. ${-RGB}
cone3d : -check ${3=24}>0 -skip ${1=1},${2=1}
-e[^-1] "Input 3d cone, with radius $1, height $2 and $3 subdivisions."
-v -
(67.5;73.5;109.5;103.5;51.5;100.5)
({$3+2};{2*$3})
(0,0,0;0,0,$2)
(0;{2*pi}) -r. 1,{$3+1},1,1,3 -rows. 0,{$3-1} --sin. -cos.. -*[-2,-1] $1 -a[-2,-1] x -z. 0,2 -a[-2,-1] y
1,$3,1,1,'y' --shift. 0,-1 -+[-2,-1] 2
2,$3,1,1,3,0 [-2] [-4] -a[-3--1] x
-i[-4] 2,$3,1,1,3,1 -a[-4--2] x
-a[-2,-1] y
3,{h},1,1,200
1,{h},1,1,1
-y[-4--2] -a[-6--1] y -nm. [3d\ cone]
-v +
#@gmic cubes3d : _size>=0
#@gmic : Convert specified 3d objects to sets of 3d cubes with specified size.
#@gmic : Default value: 'size=1'.
#@gmic : $ image.jpg -luminance -resize2dy 40 -threshold 50% -* 255 -pointcloud3d -color3d. 255,255,255 -cubes3d 1
cubes3d : -check ${1=1}>=0
-e[^-1] "Convert 3d object$? to sets of 3d cubes with size $1."
-v - -p3d 0 -repeat $! -l[$>]
nbv={@6} nbp={@7}
-if {$nbv&&$nbp}
-s3d
-l[1] -= {8*i[0]} -= {6*i[1]},0,1 -endl
-l[2] -r 3,{h/3},1,1,-1
half={$1/2}
-- '$half,0,0' --+ '$1,0,0' -a x
-- '0,$half,0' --+ '0,$1,0' -a x
-- '0,0,$half' --+ '0,0,$1' -a x
-endl
-l[3] -r 2,{h/2},1,1,-1
-z 1,1 -* 8 -r 4,100% -i[0] 1,100%,1,1,4 -a x [-1]x5 -a x
-+ '"0,0,2,3,1, 0,4,5,7,6, 0,0,1,5,4, 0,2,6,7,3, 0,0,4,6,2, 0,1,3,7,5"'
-endl
-l[4] -r 3,{h/3},1,1,-1 -r 18,100%,1,1,0,2 -endl -r[5] 6,100%
-y -a y
-endif
-endl -done -v +
#@gmic cup3d : _resolution>0
#@gmic : Input 3d cup object.
#@gmic : $ -cup3d ,
cup3d : -check ${1=128}>0
-e[^-1] "Input 3d cup, with resolution $1."
-v -
100,200
-ellipse. 0%,0%,40%,40%,0,1,1
-ellipse. 0,0,35%,35%,0,1,0
-polygon. 4,0,45%,8%,45%,20%,90%,0,90%,1,1
-ellipse. 0%,100%,30%,10%,0,1,1 -b. 0.1%
-lathe3d. $1,2 -nm. [3d\ cup]
-v +
#@gmic cylinder3d : _radius,_height,_nb_subdivisions>0
#@gmic : Input 3d cylinder at (0,0,0), with specified geometry.
#@gmic : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@gmic : $ -cylinder3d 10,40 --primitives3d 1 -color3d.. ${-RGB}
cylinder3d : -check ${3=24}>0 -skip ${1=1},${2=1}
-e[^-1] "Input 3d cylinder, with radius $1, height $2 and $3 subdivisions."
-v -
(67.5;73.5;109.5;103.5;51.5;100.5)
({2*$3+2};{3*$3})
(0,0,0;0,0,$2)
(0;{2*pi}) -r. 1,{$3+1},1,1,3 -rows. 0,{$3-1} --sin. -cos.. -*[-2,-1] $1 -a[-2,-1] x
--z. 0,2 1,$3,1,1,$2 -a[-3,-1] x
-a[-3--1] y
1,$3,1,1,'y' --shift. 0,-1 -+[-2,-1] 2
2,$3,1,1,3,1 [-3] [-3] -a[-3--1] x
2,$3,1,1,3,0 [-3] [-5] -+[-2,-1] $3 -a[-3--1] x
--+[-4,-3] $3 -i[-7] 1,$3,1,1,4 -rv[-6,-5] -a[-7--5,-2,-1] x
3,{3*$3},1,1,200
1,{h},1,1,1
-y[-6--2] -a[-8--1] y -nm. [3d\ cylinder]
-v +
#@gmic delaunay3d
#@gmic : Generate 3d delaunay triangulations from selected images.
#@gmic : One assumes that the selected input images are binary images containing the set of points to mesh.
#@gmic : The output 3d object is a mesh composed of non-oriented triangles.
#@gmic : $ 500,500 -noise 0.05,2 -* 255 --delaunay3d -color3d[1] 255,128,0 -dilate_circ[0] 5 -to_rgb[0] --object3d[0] [1],0,0,0,1,1 -max. [0]
delaunay3d :
-e[^-1] "Generate 3d delaunay triangulation from image$?."
-v - -repeat $! -l[$>]
-channels 0 -neq 0
whd={w},{h},{d} --r 1,{w*h*d},1,1,-1 -cumulate. -*. [-2] -r. $whd,1,-1
--distance[0] 1 -*[2] -1 -watershed[1] [2] -rm[2]
-r[1] 100%,100%,100%,3
-if {d>1}
--_delaunay3d[1] 1,0,0,0,0,1 --_delaunay3d[1] -1,0,0,0,0,-1
--_delaunay3d[1] 0,1,0,0,0,1 --_delaunay3d[1] 0,-1,0,0,0,-1
-endif
--_delaunay3d[1] 1,0,0,0,1,0 -_delaunay3d[1] -1,0,0,0,-1,0
-a[^0] x -transpose. --. 1
-pointcloud3d[0]
-s3d[0] -rm[3-5] -i.. 1,100%,1,1,3 -a[-2,-1] x
3,100%,1,1,200 1,100%,1,1,1 -=[1] {h},0,1 -y -a y
-endl -done -v +
_delaunay3d :
-f. "A=j($1,$2,$3,0,0,1); B=j($4,$5,$6,0,0,1);
if(i!=A && i!=B && A!=B, kth(1+c,i,A,B),0)"
-discard. 0 -r. {h/3},3,1,1,-1
#@gmic distribution3d
#@gmic : Get 3d color distribution of selected images.
#@gmic : $ image.jpg -distribution3d -colorcube3d -primitives3d. 1 -add3d
distribution3d :
-e[^-1] "Get 3d color distribution of image$?."
-v - -to_rgb -permute "cxyz" -y
-repeat $! -l[$>]
nbp={round(h/3)}
-i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
$nbp;$nbp)
1,$nbp,1,1,1 --f. y -a[-2,-1] x -y.
[-2]
1,$nbp,1,1,1
-a y -nm. [3d\ distribution]
-endl -done -v +
#@gmic /3d : eq. to '-div3d'. : (+)
#@gmic div3d : factor : factor_x,factor_y,_factor_z : (+)
#@gmic : Scale selected 3d objects isotropically or anisotropically, with the inverse of specified
#@gmic : factors.
#@gmic : (eq. to '-/3d').
#@gmic : Default value: 'factor_z=0'.
#@gmic : $ -torus3d 5,2 -repeat 5 --add3d. 12,0,0 -div3d. 1.2 -color3d. ${-RGB} -done -add3d
#@gmic db3d : eq. to '-double3d'. : (+)
#@gmic double3d : _is_double_sided={ 0 | 1 } : (+)
#@gmic : Enable/disable double-sided mode for 3d rendering.
#@gmic : (eq. to '-db3d').
#@gmic : Default value: 'is_double_sided=1'.
#@gmic : $ -mode3d 1 -repeat 2 -torus3d 100,30 -rotate3d. 1,1,0,60 -double3d $> -snapshot3d. 400 -done
#@gmic elevation3d : z-factor : [elevation_map] : 'formula' : (no arg) : (+)
#@gmic : Build 3d elevation of selected images, with a specified elevation map.
#@gmic : When invoked with (no arg) or 'z-factor', the elevation map is computed as the pointwise L2 norm of the
#@gmic : pixel values. Otherwise, the elevation map is taken from the specified image or formula.
#@gmic : $ image.jpg -blur 5 -elevation3d 0.5
#@gmic : $ 128,128,1,3,u(255) -plasma 10,3 -blur 4 -sharpen 10000 -elevation3d. 'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'
#@gmic empty3d
#@gmic : Input empty 3d object.
#@gmic : $ -empty3d
empty3d :
-e[^-1] "Input empty 3d object."
-v - (67.5;73.5;109.5;103.5;51.5;100.5;0;0) -nm. [3d\ empty] -v +
#@gmic extrude3d : _depth>0,_resolution>0,_smoothness[%]>=0
#@gmic : Generate extruded 3d object from selected binary XY-profiles.
#@gmic : Default values: 'depth=16', 'resolution=1024' and 'smoothness=0.5%'.
#@gmic : $ image.jpg -threshold 50% -extrude3d 16
extrude3d : -check "${1=16}>0 && ${2=1024}>0 && ${3=0.5%}>=0"
-e[^-1] "Generate extruded 3d object from XY-profile$?, with depth $1, resolution $2 and smoothness $3."
-v - -norm -n 0,1 -autocrop 0 -repeat $! -l[$>] nm={0,n}
wr={round(max(1,if(w>h,min($2,w),min($2,h)*w/h)))}
hr={round(max(1,if(w>h,min($2,w)*h/w,min($2,h))))}
fact={$1/max(w/$wr,h/$hr)}
-b $3,0 -r $wr,$hr,1,1,2 -expand_xyz 1,0
-isosurface3d 50% -*3d 1,1,$fact -rv3d
-nm $nm -endl -done -v +
#@gmic f3d : eq. to '-focale3d'. : (+)
#@gmic focale3d : focale : (+)
#@gmic : Set 3d focale.
#@gmic : (eq. to '-f3d').
#@gmic : Set 'focale' to 0 to enable parallel projection (instead of perspective).
#@gmic : Set negative 'focale' will disable 3d sprite zooming.
#@gmic : Default value: 'focale=700'.
#@gmic : $ -repeat 5 -torus3d 100,30 -rotate3d. 1,1,0,60 -focale3d {$<*90} -snapshot3d. 400 -done -remove[0]
#@gmic gaussians3d : _size>0,_opacity
#@gmic : Convert selected 3d objects into set of 3d gaussian-shaped sprites.
#@gmic : $ image.jpg -r2dy 32 -distribution3d -gaussians3d 20 -colorcube3d -primitives3d. 1 -+3d
gaussians3d : -check "${1=32}>0" -skip ${2=0.3}
-e[^-1] "Convert 3d object$? into sets of gaussian-shaped 3d sprites, with size $1 and opacity $2."
-v - -p3d 2 -p3d 0 -repeat $! -l[$>] nm={0,n} -s3d
nbv={h} -rm. (-128;$1;$1;1)
$1,$1 -gaussian. 35%,35%,0 -c. 30%,100% -n. 0,$2 -y. -a[-2,-1] y
-if {$nbv>1} 4,{$nbv-1},1,1,-128,0,0,0 -y[-2,-1] -a[-2,-1] y -endif
-a y
-nm $nm -endl -done -v +
#@gmic gmic3d
#@gmic : Input a 3d G'MIC logo.
#@gmic : $ -gmic3d --primitives3d 1
gmic3d :
-e[^-1] "Input 3d G\47MIC logo."
-v -
-text3d G,60,20,2 -col3d. 16,64,255
-text3d \',60,20,2 -+3d. 40 -col3d. 64,128,255
-text3d M,60,20,2 -+3d. 50 -col3d. 96,196,255
-text3d I,60,20,2 -+3d. 90 -col3d. 64,128,255
-text3d C,60,20,2 -+3d. 100 -col3d. 16,64,255
-sphere3d 8 -+3d. 102,-3,20 -col3d. 192,128,255
-+3d[-6--1] -c3d.
-repeat 30
-box3d {min(3+$</2,10)} -col3d. {30*$>},{20+80*$>},{10*$>},0.5
-r3d. 1,1,1,{$>*12}
-+3d. {80*cos(0.5+1.02*$>*12*pi/180)},{30*sin(0.8+$>*12*pi/180)},{2*$>-60}
-done
-+3d[-30--1] -+3d. 0,5,30 -+3d[-2--1] -nm. [3d\ gmic]
-v +
#@gmic gyroid3d : _resolution>0,_zoom
#@gmic : Input 3d gyroid at (0,0,0), with specified resolution.
#@gmic : Default values: 'resolution=32' and 'zoom=5'.
#@gmic : $ -gyroid3d 48 --primitives3d 1
gyroid3d : -check ${1=32}>0 -skip ${2=5}
-e[^-1] "Input 3d gyroid, with resolution $1 and range $2."
-v -
-isosurface3d "'0.49*(\
cos( 2*x + y + z - pi) + cos( 2*x - y + z - pi)\
+ cos(- 2*x + y - z - pi) + cos(- 2*x - y - z - pi)\
+ cos( x + 2*y + z - pi) + cos( x + 2*y - z - pi)\
+ cos(- x - 2*y + z - pi) + cos(- x - 2*y - z - pi)\
+ cos( x + y + 2*z - pi) + cos(- x + y + 2*z - pi)\
+ cos( x - y - 2*z - pi) + cos(- x - y - 2*z - pi)\
+ cos(- 2*x + y + z) + cos( 2*x + y - z)\
+ cos(- 2*x - y + z) + cos( 2*x - y - z)\
+ cos(- x + 2*y + z) + cos( x - 2*y + z)\
+ cos(- x + 2*y - z) + cos( x - 2*y - z)\
+ cos( x - y + 2*z) + cos( x + y - 2*z)\
+ cos(- x - y + 2*z) + cos(- x + y - 2*z)\
) + 0.27*( \
cos(- 2*x + 2*y - pi) + cos( 2*x - 2*y - pi)\
+ cos( 2*x + 2*y - pi) + cos(- 2*x - 2*y - pi)\
+ cos(- 2*y + 2*z - pi) + cos( 2*y - 2*z - pi)\
+ cos( 2*y + 2*z - pi) + cos(- 2*y - 2*z - pi)\
+ cos(- 2*z + 2*x - pi) + cos( 2*z - 2*x - pi)\
+ cos( 2*z + 2*x - pi) + cos(- 2*z - 2*x - pi)\
) - 0.69'",0,{-$2},{-$2},{-$2},$2,$2,$2,$1,$1,$1
-c3d. -n3d. -nm. [3d\ gyroid]
-v +
#@gmic histogram3d
#@gmic : Get 3d color histogram of selected images.
#@gmic : $ image.jpg -histogram3d -colorcube3d -primitives3d. 1 -add3d
histogram3d :
-e[^-1] "Get 3d color histogram of image$?."
-v - -to_rgb -repeat $! -l[$>]
-r {w*h},3,1,1,-1 -pointcloud 1 -n 0,255 -map 3 -pointcloud3d -nm "[3d histogram]"
-endl -done -v +
#@gmic image6cube3d
#@gmic : Generate 3d mapped cubes from 6-sets of selected images.
#@gmic : $ image.jpg -animate flower,"30,0","30,5",6 -image6cube3d
image6cube3d :
-e[^-1] "Generate 3d mapped cubes from image$?."
-v - M={max(${-max_wh})} -r $M,$M,1,3 -imageplane3d -n3d -c3d -repeat {int($!/6)}
-+3d[-6] 0,0,-0.5
-r3d[-5] 1,0,0,180 -+3d[-5] 0,0,0.5
-r3d[-4] 0,1,0,-90 -+3d[-4] -0.5,0,0
-r3d... 0,1,0,90 -+3d... 0.5,0,0
-r3d.. 1,0,0,90 -+3d.. 0,-0.5,0
-r3d. 1,0,0,-90 -+3d. 0,0.5,0
-+3d[-6--1] -nm. "[3d image cube]"
-mv. 0 -done -v +
#@gmic imageblocks3d : _maximum_elevation,_smoothness[%]>=0
#@gmic : Generate 3d blocks from selected images.
#@gmic : Transparency of selected images is taken into account.
#@gmic : Default values: 'maximum_elevation=10' and 'smoothness=0'.
#@gmic : $ image.jpg -resize2dy 32 -imageblocks3d -20 -m3d 3
imageblocks3d : -check ${2=0}>=0 -skip ${1=10},${3=0}
-e[^-1] "Generate 3d blocks from image$?, with maximum elevation $1 and smoothness $2."
-v - -repeat $! -l[$>]
w={w} h={h}
-split_opacity -to_rgb[0] is_opacity={$!==2}
-l[] -box3d 1,1,0
-repeat {$w-1} --+3d. 1,0,0 -done -+3d
-repeat {$h-1} --+3d. 0,1,0 -done -+3d
-endl
-s3d.
--norm[0] -b. $2
-y. -n. 0,$1
-r[-5] 24,{-5,round(w*h/24)},1,1,-1
-if {$1<0} -j[-5] [-1],2 -j[-5] [-1],5 -j[-5] [-1],8 -j[-5] [-1],11
-else -j[-5] [-1],14 -j[-5] [-1],17 -j[-5] [-1],20 -j[-5] [-1],23
-endif
-rm. -y[-4]
-rm.. -r[0] {0,wh},1,1,100%,-1 -permute[0] cxyz -r[0] 600%,100%,1,1,0,2 -y[0] -mv[0] -1
-if $is_opacity -rm. -mv[0] $! -/. 255 -y. -r. 6,100%,1,1 -y. -endif
-a y
-endl -done -v +
#@gmic imagecube3d
#@gmic : Generate 3d mapped cubes from selected images.
#@gmic : $ image.jpg -imagecube3d
imagecube3d :
-e[^-1] "Generate 3d mapped cubes from image$?."
-v - -slices 50% -to_rgb -repeat $! -l[$>] nm={0,n}
-i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
8;6;\
-0.5;-0.5;-0.5;\
0.5;-0.5;-0.5;\
0.5;0.5;-0.5;\
-0.5;0.5;-0.5;\
-0.5;-0.5;0.5;\
0.5;-0.5;0.5;\
0.5;0.5;0.5;\
-0.5;0.5;0.5;\
12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\
12;1;2;6;5;0;0;0;{h};{w};{h};{w};0;\
12;5;6;7;4;0;0;0;{h};{w};{h};{w};0;\
12;4;7;3;0;0;0;0;{h};{w};{h};{w};0;\
12;4;0;1;5;0;0;0;{h};{w};{h};{w};0;\
12;3;7;6;2;0;0;0;{h};{w};{h};{w};0;\
-128;{w};{h};{s})
-y.
(-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1;1)
-a y
-nm $nm -endl -done -v +
#@gmic imageplane3d
#@gmic : Generate 3d mapped planes from selected images.
#@gmic : $ image.jpg -imageplane3d
imageplane3d :
-e[^-1] "Generate 3d mapped planes from image$?."
-v - -slices 50% -to_color -repeat $! -l[$>] nm={0,n}
-i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
4;1;\
0;0;0;\
{w};0;0;\
{w};{h};0;\
{0};{h};0;\
12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\
-128;{w};{h};{s})
-y.
(1)
-a y
-nm $nm -endl -done -v +
#@gmic imagepyramid3d
#@gmic : Generate 3d mapped pyramides from selected images.
#@gmic : $ image.jpg -imagepyramid3d
imagepyramid3d :
-e[^-1] "Generate 3d mapped pyramids from image$?."
-v - -to_rgb -repeat $! -l[$>] nm={0,n}
w2={w/2}
-i.. (67.5;73.5;109.5;103.5;51.5;100.5;\
5;5;\
-0.5;-0.5;-0.5;\
0.5;-0.5;-0.5;\
0.5;0.5;-0.5;\
-0.5;0.5;-0.5;\
0;0;0.5;\
12;0;3;2;1;0;0;0;{h};{w};{h};{w};0;\
9;0;4;3;0;{h};$w2;0;{w};{h};\
9;1;4;0;0;{h};$w2;0;{w};{h};\
9;2;4;1;0;{h};$w2;0;{w};{h};\
9;3;4;2;0;{h};$w2;0;{w};{h};\
-128;{w};{h};{s})
-y.
(-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1)
-a y
-nm $nm -endl -done -v +
#@gmic imagerubik3d : _xy_tiles>=1,0<=xy_shift<=100,0<=z_shift<=100
#@gmic : Generate 3d mapped rubik's cubes from selected images.
#@gmic : Default values: 'xy_tiles=3', 'xy_shift=5' and 'z_shift=5'.
#@gmic : $ image.jpg -imagerubik3d ,
imagerubik3d : -check "${1=3}>=1 && ${2=5}>=0 && $2<=100 && ${3=5}>=0 && $3<=100"
-e[^-1] "Generate 3d mapped rubik\47s cubes from image$? with $1 xy-tiles, xy-shift $2 and z-shift $3."
-v - -repeat $! -l[$>] nm={0,n}
({'CImg3d'}) -+. 0.5
(8,5)
(0,0,0;\
100,0,0;\
100,100,0;\
0,100,0;\
$2,$2,{-$3};\
{100-$2},$2,{-$3};\
{100-$2},{100-$2},{-$3};\
$2,{100-$2},{-$3})
(4,4,7,6,5;\
4,0,4,5,1;\
4,3,2,6,7;\
4,0,3,7,4;\
4,1,5,6,2)
3,5,1,1,200
1,5,1,1,1
-y[-6--1] -a[-6--1] y
-repeat {$1-1} --+3d. 100 -done -+3d[-$1--1]
-repeat {$1-1} --+3d. 0,100 -done -+3d[-$1--1]
-t3d. [-2] -rm..
-/3d. $1 --3d. 50,50,50
--r3d. 0,1,0,-90 --r3d. 0,1,0,-90 --r3d. 0,1,0,-90
--r3d. 0,0,1,-90 --r3d. 0,0,1,180
-+3d
-nm $nm -endl -done -v +
#@gmic imagesphere3d : _resolution1>=3,_resolution2>=3
#@gmic : Generate 3d mapped sphere from selected images.
#@gmic : Default values: 'resolution1=32' and 'resolutions2=16'.
#@gmic : $ image.jpg -imagesphere3d 32,16
imagesphere3d : -check "${1=32}>=3 && ${2=16}>=3"
-e[^-1] "Generate 3d mapped sphere from image$?, with resolutions ($1,$2)."
-v - -to_rgb -repeat $! -l[$>] nm={0,n}
tw={w-1} th={h-1}
nbv={2+$1*($2-2)}
nbp={$1*($2-1)}
(67.5;73.5;109.5;103.5;51.5;100.5;\
$nbv;$nbp)
(0;0;1) (0;0;-1) (0,{2*pi};0,{2*pi}^0,0;{pi},{pi})
-r. {$1+1},$2,1,2,3 -z. 0,1,{w-2},{h-2} -s. c
--sin. --sin... -*[-2,-1] --cos.. -sin... -cos[-4] -*[-4,-3]
-a[-3--1] c -permute. cxyz -y. -a[-3--1] y
-repeat $1,v
tx0={$v*$tw/$1} tx1={($v+1)*$tw/$1} ty1={$th/($2-1)}
(9;0;{2+$v};{2+($v+1)%$1};{$tw/2};0;$tx0;$ty1;$tx1;$ty1)
-repeat {$2-3},u
ty0=$ty1 ty1={($u+2)*$th/($2-1)} i0={2+$u*$1+$v} i1={2+$u*$1+($v+1)%$1}
(12;$i0;{$i0+$1};{$i1+$1};$i1;$tx0;$ty0;$tx0;$ty1;$tx1;$ty1;$tx1;$ty0)
-done
(9;1;{2+$1*($2-3)+($v+1)%$1};{2+$1*($2-3)+$v};{$tw/2};$th;$tx1;$ty1;$tx0;$ty1)
-done
-a[-$nbp--1] y
-mv[-4] $! -i.. (-128;{w};{h};3) -y. 1,{4*($nbp-1)},1,1,-128,0,0,0 1,$nbp,1,1,1 -a y
-nm $nm -endl -done -v +
#@gmic isoline3d : isovalue[%] : 'formula',value,_x0,_y0,_x1,_y1,_size_x>0[%],_size_y>0[%] : (+)
#@gmic : Extract 3d isolines with specified value from selected images or from specified formula.
#@gmic : Default values: 'x0=y0=-3', 'x1=y1=3' and 'size_x=size_y=256'.
#@gmic : $ image.jpg -blur 1 -isoline3d 50%
#@gmic : $ -isoline3d 'X=x-w/2;Y=y-h/2;(X^2+Y^2)%20',10,-10,-10,10,10
#@gmic isosurface3d : isovalue[%] : 'formula',value,_x0,_y0,_z0,_x1,_y1,_z1,_size_x>0[%],_size_y>0[%],_size_z>0[%] : (+)
#@gmic : Extract 3d isosurfaces with specified value from selected images or from specified formula.
#@gmic : Default values: 'x0=y0=z0=-3', 'x1=y1=z1=3' and 'size_x=size_y=size_z=32'.
#@gmic : $ image.jpg -resize2dy 128 -luminance -threshold 50% -expand_z 2,0 -blur 1 -isosurface3d 50% -mul3d 1,1,30
#@gmic : $ -isosurface3d 'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))',3
#@gmic label3d : "text",font_height>=0,_opacity,_color1,...
#@gmic : Generate 3d text label.
#@gmic : Default values: 'font_height=13', 'opacity=1' and 'color=255,255,255'.
label3d : -check ${2=13}>=0 -skip ${3=1},${4=255},${5=$4},${6=$5}
-e[^-1] "Generate 3d label '$1' with font height $2, opacity $3 and color (${4--1})."
-v - -l[] 0 -t "$1",0,0,$2,1,${4--1},255 -sprite3d -endl -v +
#@gmic label_points3d : _label_size>0,_opacity
#@gmic : Add a numbered label to all vertices of selected 3d objects.
#@gmic : Default values: 'label_size=13' and 'opacity=0.8'.
#@gmic : $ -torus3d 100,40,6,6 -label_points3d 23,1 -mode3d 1
label_points3d : -check ${1=13}>0 -skip ${2=0.8}
-e[^-1] "Label vertices of 3d object$?."
-v - -repeat $!
--p3d[$>] 0 -l. -s3d -rm[-3--1]
nbp={-2,@0} -=.. $nbp,0,1
(1,0;1,{$nbp-1}) -r. 2,$nbp,1,1,3 -r. 1,{2*h},1,1,-1
-repeat $nbp
0 -t. $>,0,0,$1,1,255,255,255 -autocrop. 0
-i.. (-128;{w};{h};3) -y.
-done
-repeat $nbp
0 -t. $>,0,0,$1,1,$2 -autocrop. 0
-i.. (-128;{w};{h};1) -y.
-done
-a y
-endl
-+3d[$>,-1]
-done -v +
#@gmic lathe3d : _resolution>0,_smoothness[%]>=0,_max_angle>=0
#@gmic : Generate 3d object from selected binary XY-profiles.
#@gmic : Default values: 'resolution=128', 'smoothness=0.5%' and 'max_angle=361'.
#@gmic : $ 300,300 -rand -1,1 -blur 40 -sign -normalize 0,255 -lathe3d ,
lathe3d : -check "${1=128}>0 && ${2=0.5%}>=0 && ${3=361}>=0"
-e[^-1] "Generate lathed 3d object from XY-profile$?, with resolution $1, smoothness $2 and maximum angle $3 deg."
-v - tmax={($3-180)*pi/180} -norm -n 0,1 -autocrop 0
-repeat $! -l[$>]
wr={max(1,w2=2*w;if(w2>h,min($1,w2),min($1,h)*w2/h))}
hr={max(1,w2=2*w;if(w2>h,min($1,w2)*h/w2,min($1,h)))}
rmax={sqrt(($wr)^2+($hr)^2)/2}
$wr,1,$wr,1,"xc=x-w/2; zc=z-d/2; t=atan2(zc,xc); if(t>"$tmax","$rmax",sqrt(xc*xc+zc*zc))"
-*. {2*({-2,w}-1)/(w-1)} -r. $wr,$hr,$wr
(0;{{-2,h}-1}) -r. $wr,$hr,$wr,1,3 -a[-2--1] c
-warp.. [-1],0,1,0 -rm.
-expand_xyz 10,0 -b $2 -isosurface3d 50% -rv3d
-endl -done -v +
#@gmic l3d : eq. to '-light3d'. : (+)
#@gmic light3d : position_x,position_y,position_z : [texture] : (no arg) : (+)
#@gmic : Set the light coordinates or the light texture for 3d rendering.
#@gmic : (eq. to '-l3d').
#@gmic : (no arg) resets the 3d light to default.
#@gmic : $ -torus3d 100,30 -double3d 0 -specs3d 1.2 -repeat 5 -light3d {$>*100},0,-300 --snapshot3d[0] 400 -done -remove[0]
#@gmic line3d : x0,y0,z0,x1,y1,z1
#@gmic : Input 3d line at specified coordinates.
#@gmic : $ -repeat 100 a={$>*pi/50} -line3d 0,0,0,{cos(3*$a)},{sin(2*$a)},0 -color3d. ${-RGB} -done -add3d
line3d :
-e[^-1] "Input 3d line (${1-3})-(${4-6})."
-v - 1,21,1,1,67.5,73.5,109.5,103.5,51.5,100.5,2,1,${1-6},2,0,1,200,200,200,1 -nm. [3d\ line] -v +
#@gmic lissajous3d : resolution>1,a,A,b,B,c,C
#@gmic : Input 3d lissajous curves (x(t)=sin(a*t+A*2*pi),y(t)=sin(b*t+B*2*pi),z(t)=sin(c*t+C*2*pi)).
#@gmic : Default values: 'resolution=1024', 'a=2', 'A=0', 'b=1', 'B=0', 'c=0' and 'C=0'.
#@gmic : $ -lissajous3d ,
lissajous3d : -check ${1=1024}>1 -skip ${2=2},${3=0},${4=1},${5=0},${6=0},${7=0}
-e[^-1] "Input 3d lissajous curve, with resolution $1, (a,A)=($2,$3), (b,B)=($4,$5) and (c,C)=($6,$7)."
-v -
res={round($1)}
(67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
(0,{2*pi}) -r. $res,1,1,1,3 [-1]x2
-*... $2 -+... {$3*2*pi} -*.. $4 -+.. {$5*2*pi} -*. $6 -+. {$7*2*pi}
-a[-3--1] y -sin. -transpose. -r. 1,{w*h},1,1,-1
1,{$res-1},1,1,2 (0;{$res-2}) -r. 1,{$res-1},1,1,3 --+. 1 -a[-3--1] x -round. 1 -r. 1,{w*h},1,1,-1
1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 -a[-5--1] y -nm. [3d\ lissajou]
-v +
#@gmic m3d : eq. to '-mode3d'. : (+)
#@gmic mode3d : _mode : (+)
#@gmic : Set static 3d rendering mode.
#@gmic : (eq. to '-m3d').
#@gmic : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.");
#@gmic : Bounding-box mode ('mode==-1') is active only for the interactive 3d viewer.
#@gmic : Default value: 'mode=4'.
#@gmic : $ (0,1,2,3,4,5) -double3d 0 -repeat {w} -torus3d 100,30 -rotate3d. 1,1,0,60 -mode3d {0,@$>} -snapshot3d. 300 -done -remove[0]
#@gmic md3d : eq. to '-moded3d'. : (+)
#@gmic moded3d : _mode : (+)
#@gmic : Set dynamic 3d rendering mode for interactive 3d viewer.
#@gmic : (eq. to '-md3d').
#@gmic : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@gmic : Default value: 'mode=-1'.
#@gmic *3d : eq. to '-mul3d'. : (+)
#@gmic mul3d : factor : factor_x,factor_y,_factor_z : (+)
#@gmic : Scale selected 3d objects isotropically or anisotropically, with specified factors.
#@gmic : (eq. to '-*3d').
#@gmic : Default value: 'factor_z=0'.
#@gmic : $ -torus3d 5,2 -repeat 5 --add3d. 10,0,0 -mul3d. 1.2 -color3d. ${-RGB} -done -add3d
#@gmic n3d : eq. to '-normalize3d'.
n3d :
-_normalize3d
#@gmic normalize3d
#@gmic : Normalize selected 3d objects to unit size.
#@gmic : (eq. to '-n3d').
#@gmic : $ -repeat 100 -circle3d {u(3)},{u(3)},{u(3)},0.1 -done -add3d -color3d. 255,0,0 --normalize3d. -color3d. 0,255,0 -add3d
normalize3d :
-_$0
_normalize3d :
-e[0--3] "Normalize size of 3d object$?."
-v - -check3d 0 -repeat $! -l[$>]
-if {i[6]}
-s3d -r[2] 3,{2,h/3},1,1,-1 -s[2] x
factor={v=max({2,iM-im},{3,iM-im},{4,iM-im});if(v,v,1)}
-a[2-4] x -/[2] $factor -y[2] -a y
-endif
-endl -done -v +
#@gmic o3d : eq. to '-opacity3d'. : (+)
#@gmic opacity3d : _opacity : (+)
#@gmic : Set opacity of selected 3d objects.
#@gmic : (eq. to '-o3d').
#@gmic : Default value: 'opacity=1'.
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d. 1,0,0,20 -opacity3d. {u} -done -add3d
#@gmic parametric3d : _x(a,b),_y(a,b),_z(a,b),_amin,_amax,_bmin,_bmax,_res_a>0,_res_b>0,_res_x>0,_res_y>0,_res_z>0,_smoothness>=0,_isovalue>=0
#@gmic : Input 3d object from specified parametric surface (x(a,b),y(a,b),z(a,b)).
#@gmic : Default values: 'x=(2+cos(b))*sin(a)', 'y=(2+cos(b))*cos(a)', 'c=sin(b)', 'amin=-pi', 'amax='pi', 'bmin=-pi', 'bmax='pi',
#@gmic : 'res_a=512', 'res_b=res_a', 'res_x=64', 'res_y=res_x', 'res_z=res_y', 'smoothness=2%' and 'isovalue=10%'.
#@gmic : $ -parametric3d ,
parametric3d : -skip "${1=(2+cos(b))*sin(a)}","${2=(2+cos(b))*cos(a)}","${3=sin(b)}"
-skip ${4={-pi}},${5={pi}},${6={-pi}},${7={pi}}
-check "${8=512}>0 && ${9=$8}>0 && ${10=64}>0 && ${11=$10}>0 && ${12=$11}>0 && \
${13=2%}>=0 && ${14=10%}>=0"
-e[^-1] "Input 3d object from parametric surface ($1,$2,$3)."
-v -
($4,$5;$4,$5^$6,$6;$7,$7) -r. $8,$9,1,2,3 -channels. 0,2
-f. "a=i(x,y,0,0);b=i(x,y,0,1);if(c==0,$1,if(c==1,$2,$3))"
-sh. 0 xmin={im} xmax={iM} -n. 16,{$10-17} -rm.
-sh. 1 ymin={im} ymax={iM} -n. 16,{$11-17} -rm.
-sh. 2 zmin={im} zmax={iM} -n. 16,{$12-17} -rm.
-r. {w*h},3,1,1,-1
-pointcloud. 1 -r. $10,$11,$12,1,0 -b. $13,0
-isosurface3d. $14
-c3d. -n3d. -*3d. {$xmax-$xmin},{$ymax-$ymin},{$zmax-$zmin} -nm. [3d\ parametric]
-v +
#@gmic pca_patch3d : _patch_size>0,_M>0,_N>0,_normalize_input={ 0 | 1 },_normalize_output={ 0 | 1 },_lambda_xy
#@gmic : Get 3d patch-pca representation of selected images.
#@gmic : The 3d patch-pca is estimated from M patches on the input image, and displayed as a cloud of N 3d points.
#@gmic : Default values: 'patch_size=7', 'M=1000', 'N=3000', 'normalize_input=1', 'normalize_output=0', and 'lambda_xy=0'.
#@gmic : $ image.jpg -pca_patch3d 7
pca_patch3d : -check "isint(${1=7}) && $1>0 && isint(${2=1000}) && $2>0 && isint(${3=3000}) && $3>0" -skip ${4=1},${5=0},${6=0}
-e[^-1] "Get 3d patch-pca representation"${-arg\ 1+($!>1),s,""}" of image$?, from $2 $1x$1 input patchs, "\
"with $3 output patchs, input normalization "${-arg\ 1+!$4,enabled,disabled}", output normalization "\
${-arg\ 1+!$5,enabled,disabled}" and lambda_xy $6."
-v -
P1={int($1/2)}
P2={$1-$P1-1}
-n 0,255 -round 1
-repeat $! -l[$>] nm={0,n}
s={s}
1,$2 -rand. 0,{0,w-1} --rand. 0,{0,h-1} --f. 0 -a[-3--1] x -round. 1 --patches[0] $1,$1,1,{^} -y[2--1] -a[2--1] x
-z[1] 0,1 -transpose[1] -*[1] $6 -a[1,2] y -s[^0] x
--+[^0] -/. $2 --[1--2] [-1] -rm.
-a[^0] x
-if $4 -l. -s y -/ 'sqrt(1e-8+iv)' -a y -endl -endif
--transpose. -**[-2,-1]
-eigen. -rows.. 0,2 -columns. 0,2 -transpose.
-if $5 -sqrt.. -/.. {-2,iM} -r.. [-1] -/. [-2] -endif
-rm..
-repeat $3
x={round(u({0,w}))}
y={round(u({0,h}))}
({$6*$x};{$6*$y})
--z[0] {$x-$P1},{$y-$P1},{$x+$P2},{$y+$P2},1
-y. -a[-2,-1] y
-done
--a[2--1] x -**[1,-1] -transpose[1]
-rows[2--1] 2,100%
-if {$s!=3}
-r[2--1] $1,$1,1,{min(3,$s)},-1
-r[2--1] $1,$1,1,3,{if($s!=1,0,1)}
-y[2--1]
-endif
-i[2--2] (-128;$1;$1;3) -a[2--1] y
-rm[0]
-i[0] ({'CImg3d'})
-i[1] ($3;$3)
-i[3] 2,$3,1,1,if(x==0,1,y)
1,$3,1,1,1
-y -a[-6--1] y
-nm $nm -endl -done -v +
#@gmic plane3d : _size_x,_size_y,_nb_subdivisions_x>0,_nb_subdisivions_y>0
#@gmic : Input 3d plane at (0,0,0), with specified geometry.
#@gmic : Default values: 'size_x=1', 'size_y=size_x' and 'nb_subdivisions_x=nb_subdivisions_y=24'.
#@gmic : $ -plane3d 50,30 --primitives3d 1 -color3d.. ${-RGB}
plane3d : -check "${3=24}>0 && ${4=24}>0" -skip ${1=1},${2=$1}
-e[^-1] "Input 3d plane, with size (${1,2}) and subdivisions (${3,4})."
-v - {$3+1},{$4+1} -elevation3d. 0 -*3d. {$1/$3},{$2/$4} -col3d. 200 -nm. [3d\ plane] -v +
#@gmic point3d : x0,y0,z0
#@gmic : Input 3d point at specified coordinates.
#@gmic : $ -repeat 1000 a={$>*pi/500} -point3d {cos(3*$a)},{sin(2*$a)},0 -color3d. ${-RGB} -done -add3d
point3d :
-e[^-1] "Input 3d point ($1,$2,$3)."
-v - 1,17,1,1,67.5,73.5,109.5,103.5,51.5,100.5,1,1,${1-3},1,0,200,200,200,1 -nm. [3d\ point] -v +
#@gmic pointcloud3d
#@gmic : Convert selected planar or volumetric images to 3d point clouds.
#@gmic : $ image.jpg -luminance -resize2dy 100 -threshold 50% -* 255 -pointcloud3d -color3d. 255,255,255
pointcloud3d :
-e[^-1] "Convert image$? to 3d point clouds."
-v - -repeat $! -l[$>] nm={0,n}
-s z -repeat $! -l[$>]
--norm -!=. 0
-i.. (1,{w};1,{w}^1,1;{h},{h}) -r.. [-1],[-1],1,2,3 -*[-2,-1] -round. -permute. cxyz
-l. -s -,0 -a y is_points=$! -endl
-if $is_points
--. 1 -r. 2,{h/2},1,1,-1 -permute. cyzx --warp.. [-1],0,0 -rm...
-permute.. cyzx -i.. 1,{h},1,1,$> -a[-3,-2] x
-i... ({'CImg3d'}) -i... ({h},{h})
-i.. 1,{h},1,1,1 -i.. 1,{h},1,1,y -a[-3,-2] x
-permute. cyzx
-if {w==1} -r. 3,{h},1,1
-elif {w>3} -i.. 4,{h},1,1,-128,1,1,{w} -a[-2,-1] x
-else -r. 3,{h},1,1,0
-endif
1,{h},1,1,1
-y[-6--1] -a[-6--1] y
-else -rm -empty3d
-endif
-endl -done
-+3d
-nm $nm -endl -done -v +
#@gmic pose3d : p1,..,p12
#@gmic : Apply 3d pose matrix to selected 3d objects.
#@gmic : $ -torus3d 100,20 -pose3d 0.152437,1.20666,-0.546366,0,-0.535962,0.559129,1.08531,0,1.21132,0.0955431,0.548966,0,0,0,-206,1 -snapshot3d 400
pose3d :
-e[^-1] "Apply 3d pose matrix [ $1,$2,$3,$4; $5,$6,$7,$8; $9,$10,$11,$12 ] to 3d object$?."
-v - -repeat $! -l[$>] -if ${-_is_3d}
-s3d -r[2] 3,{2,h/3},1,1,-1 -i[3] 1,{2,h},1,1,1 -a[2,3] x
-i[3] ($1,$5,$9;$2,$6,$10;$3,$7,$11;$4,$8,$12) -**[2,3]
-r[2] 1,{2,3*h},1,1,-1 -a y
-else -v + -error "Command '-pose3d': Image ["{$!-$>-1}"] does not represent a 3d object."
-endif -endl -done -v +
#@gmic p3d : eq. to '-primitives3d'. : (+)
#@gmic primitives3d : mode : (+)
#@gmic : Convert primitives of selected 3d objects.
#@gmic : (eq. to '-p3d').
#@gmic : 'mode' can be { 0=points | 1=segments | 2=non-textured }.
#@gmic : $ -sphere3d 30 -primitives3d 1 -torus3d 50,10 -color3d. ${-RGB} -add3d
#@gmic projections3d : _x[%],_y[%],_z[%],_is_bounding_box={ 0 | 1 }
#@gmic : Generate 3d xy,xz,yz projection planes from specified volumetric images.
projections3d : -skip ${1=50%},${2=50%},${3=50%},${4=1}
-e[^-1] "Generate 3d xy,xz,yz projection planes from image$?."
-v - -n 0,255 -repeat $! -l[$>]
w={w} h={h} d={d}
x={if(${-is_percent\ $1},$1*w,$1)}
y={if(${-is_percent\ $2},$2*h,$2)}
z={if(${-is_percent\ $3},$3*d,$3)}
--rows $2,$2 -r. {w},{d},1,100%,-1
--columns.. $1,$1 -permute. zyxc
-slices... $3,$3 -r[-3--1] 100%,100%,1,3
-imageplane3d[-3--1]
-r3d. 0,1,0,90 -r3d.. 1,0,0,-90
-+3d... 0,0,$z -+3d.. 0,$y,0 -+3d. $x,0,0
-+3d[-3--1] -o3d. 0.8
-if $4 -box3d $w,$h,$d -p3d. 1 -o3d. 0.4 -+3d[-2,-1] -endif
-endl -done -v +
#@gmic pyramid3d : width,height
#@gmic : Input 3d pyramid at (0,0,0), with specified geometry.
#@gmic : $ -pyramid3d 100,100 --primitives3d 1 -color3d.. ${-RGB}
pyramid3d :
-e[^-1] "Input new 3d pyramid, with width $1 and height $2."
-v -
(67.5;73.5;109.5;103.5;51.5;100.5;\
5;5;\
{-$1/2};{-$1/2};{-$2/2};\
{$1/2};{-$1/2};{-$2/2};\
{$1/2};{$1/2};{-$2/2};\
{-$1/2};{$1/2};{-$2/2};\
0;0;{$2/2};\
4;0;3;2;1;\
3;0;4;3;\
3;1;4;0;\
3;2;4;1;\
3;3;4;2)
1,15,1,1,200 1,5,1,1,1 -a[-3--1] y -nm. [3d\ pyramid]
-v +
#@gmic quadrangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3
#@gmic : Input 3d quadrangle at specified coordinates.
#@gmic : $ -quadrangle3d -10,-10,10,10,-10,10,10,10,10,-10,10,10 -repeat 10 --rotate3d. 0,1,0,30 -color3d. ${-RGB},0.6 -done -add3d -mode3d 2
quadrangle3d :
-e[^-1] "Input 3d quadrangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12)."
-v - 1,29,1,1,67.5,73.5,109.5,103.5,51.5,100.5,4,1,${1-12},4,0,1,2,3,200,200,200,1 -nm. [3d\ quadrangle] -v +
#@gmic random3d : nb_points>=0
#@gmic : Input random 3d point cloud in [0,1]^3.
#@gmic : $ -random3d 100 -circles3d 0.1 -opacity3d 0.5
random3d : -check "$1>=0"
-e[^-1] "Input random 3d point cloud, with $1 points."
-v -
-if {$1<0.5} -empty3d
-else -l[]
N={round($1)}
({'CImg3d'},$N,$N)
3,$N -rand. 0,1
1,$N,1,1,1 1,$N,1,1,y -a[-2,-1] x
3,$N,1,1,200 1,$N,1,1,1
-y -a y
-endl -endif
-nm. [3d\ random\ pointcloud]
-v +
#@gmic rv3d : eq. to '-reverse3d'. : (+)
#@gmic reverse3d : (+)
#@gmic : Reverse primitive orientations of selected 3d objects.
#@gmic : (eq. to '-rv3d').
#@gmic : $ -torus3d 100,40 -double3d 0 --reverse3d
#@gmic r3d : eq. to '-rotate3d'. : (+)
#@gmic rotate3d : u,v,w,angle : (+)
#@gmic : Rotate selected 3d objects around specified axis with specified angle (in deg.).
#@gmic : (eq. to '-r3d').
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d. 1,0,0,20 -done -add3d
#@gmic rotation3d : u,v,w,angle
#@gmic : Input 3x3 rotation matrix with specified axis and angle (in deg).
#@gmic : $ -rotation3d 1,0,0,0 -rotation3d 1,0,0,90 -rotation3d 1,0,0,180
rotation3d :
-e[^-1] "Input 3d rotation matrix around axis ($1,$2,$3) with angle $4 deg."
-v -
($1^$2^$3^0) -orientation. -y. x -*. {sin($4*pi/360)} -=. {cos($4*pi/360)},3
xx={i(0)*i(0)} xy={i(0)*i(1)} xz={i(0)*i(2)} xw={i(0)*i(3)}
yy={i(1)*i(1)} yz={i(1)*i(2)} yw={i(1)*i(3)}
zz={i(2)*i(2)} zw={i(2)*i(3)}
-rm.
({1-2*($yy+$zz)},{2*($xy+$zw)},{2*($xz-$yw)};\
{2*($xy-$zw)},{1-2*($xx+$zz)},{2*($yz+$xw)};\
{2*($xz+$yw)},{2*($yz-$xw)},{1-2*($xx+$yy)})
-nm. [3d\ rotation]
-v +
#@gmic sierpinski3d : _recursion_level>=0,_width,_height
#@gmic : Input 3d Sierpinski pyramid.
#@gmic : $ -sierpinski3d 3 --primitives3d 1 -color3d.. ${-RGB}
sierpinski3d : -check ${1=4}>=0 -skip ${2=1},${3=1}
-e[^-1] "Input 3d Sierpinski pyramid of degree $1, with width $2 and height $3."
-v - -l[] -_sierpinski3d {-$2/2},{-$2/2},{-$3/2},{$2/2},{-$2/2},{-$3/2},{$2/2},{$2/2},{-$3/2},{-$2/2},{$2/2},{-$3/2},0,0,{$3/2},$1 -+3d -endl
-nm. [3d\ sierpinski] -v +
_sierpinski3d :
-if {$16<=0}
(67.5;73.5;109.5;103.5;51.5;100.5;\
5;5;\
$1;$2;$3;\
$4;$5;$6;\
$7;$8;$9;\
$10;$11;$12;\
$13;$14;$15;\
4;0;3;2;1;\
3;0;4;3;\
3;1;4;0;\
3;2;4;1;\
3;3;4;2)
1,15,1,1,200 1,5,1,1,1 -a[-3--1] y
-return -endif
-_sierpinski3d $1,$2,$3,\
{($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
{($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
{($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
{$16-1}
-_sierpinski3d {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
$4,$5,$6,\
{($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
{($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
{$16-1}
-_sierpinski3d {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
$7,$8,$9,\
{($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
{($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
{$16-1}
-_sierpinski3d {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
{($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
{($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
$10,$11,$12,\
{($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
{$16-1}
-_sierpinski3d {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
{($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
{($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
{($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
$13,$14,$15,\
{$16-1}
#@gmic size3d
#@gmic : Return bounding box size of the last selected 3d object.
size3d :
-v - --rows. 8,{8+3*i[6]} -r. 3,{h/3},1,1,-1 -s. x,3
-u {-3,iM-im},{-2,iM-im},{iM-im}
-rm[-3--1] -v +
#@gmic skeleton3d : _metric,_frame_type={ 0=squares | 1=diamonds | 2=circles | 3=auto },_skeleton_opacity,_frame_opacity,_is_frame_wireframe={ 0 | 1 }
#@gmic : Build 3d skeletal structure object from 2d binary shapes located in selected images.
#@gmic : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean }.
#@gmic : Default values: 'metric=2', 'bones_type=3', 'skeleton_opacity=1' and 'frame_opacity=0.1'.
#@gmic : $ -shape_cupid 480 --skeleton3d ,
skeleton3d : -check "isint(${1=2}) && $1>=0 && $1<=2 && isint(${2=3}) && $2>=0 && $2<=3" -skip ${3=1},${4=0.1},${5=1}
-e[^-1] "Build 3d skeletal structure object from image$?, with "${-arg\ 1+$1,chebyshev,manhattan,euclidean}" metric, "\
${-arg\ 1+$2,squares,diamonds,circles,auto}" bones, skeleton opacity $3 and frame opacity $4 ."
-v - -repeat $! -l[$>] -channels 0
--distance 0,$1
--f. "(i>j(-1)&&i>j(1)) || (i>j(0,-1)&&i>j(0,1)) || (i>j(-1,-1)&&i>j(1,1)) || (i>j(-1,1)&&i>j(1,-1))"
-if $3 --slices. -1,0 -isosurface3d. 0.5 -o3d. $3 -col3d. 255,0,0 -endif
-*[0-2] -pointcloud3d[0]
-if $4 -l[0] -s3d 1
n={1,@0}
-if $n
-r[2] 3,$n,1,1,-1 -r[3] 2,$n,1,1,-1 -r[4] 3,$n,1,1,-1
-if {$2==0" || "($2==3" && "$1==0)}
-=[1] {4*$n}
-i[3] [2]x3 --z.. 0,1 -z. 0,2 --[2] [-1] -+[4] [-1]
-s. x -*.. -1 -a[-3--1] x -+[3] [-1] --[5,-1] -a[2-5] x
-rm[3] 1,$n,1,1,4 --f. 4*y --+. 1 --+. 1 --+. 1 -rv[-3,-1] -a[-5--1] x -mv. 3
-elif {$2==1" || "($2==3" && "$1==1)}
-=[1] {4*$n}
-i[3] [2]x3 --z.. 0,0 -z. 0,2 --[2] [-1] -+[4] [-1]
-shift. 1,0 --[3] [-1] -+[5,-1] -a[2-5] x
-rm[3] 1,$n,1,1,4 --f. 4*y --+. 1 --+. 1 --+. 1 -rv[-3,-1] -a[-5--1] x -mv. 3
-elif {$2==2" || "($2==3" && "$1==2)}
-=[1] {2*$n}
--z[4] 0,0 -z. 0,2 --+[2,-1] --[2,-2] -a[2,-1] x
-rm[3] 1,$n,1,1,5 --f. 2*y --+. 1 3,100% -a[-4--1] x -mv. 3
-endif
-y -a y -o3d $4 -if $5 -p3d 1 -endif -col3d 200
-else -rm -empty3d -endif
-endl -else -rm[0] -endif
-+3d
-endl -done -v +
#@gmic snapshot3d : _size>0,_zoom>=0,_backgroundR,_backgroundG,_backgroundB,_backgroundA : [background_image],zoom>=0
#@gmic : Take 2d snapshots of selected 3d objects.
#@gmic : Set 'zoom' to 0 to disable object auto-scaling.
#@gmic : Default values: 'size=512', 'zoom=1' and '[background_image]=(default)'.
#@gmic : $ -torus3d 100,20 -rotate3d 1,1,0,60 -snapshot3d 400,1.2,128,64,32
#@gmic : $ -torus3d 100,20 -rotate3d 1,1,0,60 -testimage2d 400 --snapshot3d[0] [1],1.2
snapshot3d : -check "${2=1}>=0" -skip ${1=512},${3=""}
-if ${"-is_image_arg $1"}
-e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2 and background image $3."
-v - -pass$1 0 -to_color.
-elif {isval($3)}
-e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2 and background color ${3--1}."
-v - (${3--1}) -y. c -r. $1,$1 -to_color.
-else
-e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2 and default background."
-v - 1,2,1,3,32,64,32,116,64,96 -r. $1,$1,1,3,3
-endif
-repeat {$!-1} [-1] -l[$>,-1]
-if {$2!=0} -c3d[0] -n3d[0] -*3d[0] {3*min(w,h)*$2/4} -endif
-if {s>3}
100%,100%,1,3,-1 -j3d. [0],50%,50%,0,1
-to_rgba. -replace_color. 0,0,-1,-1,-1,255,0,0,0,0 -blend[-2,-1] alpha
-else
-j3d[1] [0],50%,50%,0,1
-endif
-nm[1] {-2,n} -rm[0]
-endl -done -rm. -v +
#@gmic sl3d : eq. to '-specl3d'. : (+)
#@gmic specl3d : value>=0 : (+)
#@gmic : Set lightness of 3d specular light.
#@gmic : (eq. to '-sl3d').
#@gmic : Default value: 'value=0.15'.
#@gmic : $ (0,0.3,0.6,0.9,1.2) -repeat {w} -torus3d 100,30 -rotate3d. 1,1,0,60 -color3d. 255,0,0 -specl3d {0,@$>} -snapshot3d. 400 -done -remove[0]
#@gmic ss3d : eq. to '-specs3d'. : (+)
#@gmic specs3d : value>=0 : (+)
#@gmic : Set shininess of 3d specular light.
#@gmic : (eq. to '-ss3d').
#@gmic : Default value: 'value=0.8'.
#@gmic : $ (0,0.3,0.6,0.9,1.2) -repeat {w} -torus3d 100,30 -rotate3d. 1,1,0,60 -color3d. 255,0,0 -specs3d {0,@$>} -snapshot3d. 400 -done -remove[0]
#@gmic sphere3d : radius,_nb_recursions>=0 : (+)
#@gmic : Input 3d sphere at (0,0,0), with specified geometry.
#@gmic : Default value: 'nb_recursions=3'.
#@gmic : $ -sphere3d 100 --primitives3d 1  -color3d.. ${-RGB}
#@gmic spherical3d : _nb_azimuth>=3,_nb_zenith>=3,_radius_function(phi,theta)
#@gmic : Input 3d spherical object at (0,0,0), with specified geometry.
#@gmic : Default values: 'nb_zenith=nb_azimut=64' and 'radius_function="abs(1+0.5*cos(3*phi)*sin(4*theta))"'.
#@gmic : $ -spherical3d 64 --primitives3d 1
spherical3d : -check "${1=64}>=3 && ${2=$1}>=3" -skip "${3=abs(1+0.5*cos(3*phi)*sin(4*theta))}"
-e[^-1] "Input 3d spherical object, with subdivisions ($1,$2) and height function '$3'."
-v -
({'CImg3d'}) -y.
n1={round($1)} n2={round($2)}
$n1,{$n2-1},1,3,"phi = 2*pi*(x+0.5)/w;\
theta = -pi/2+pi*(y+0.5)/h;\
cp = cos(phi);\
sp = sin(phi);\
ct = cos(theta);\
($3)*if(c==0,ct*cp,if(c==1,ct*sp,sin(theta)))"
-r. {w*h},3,1,1,-1 -permute. yxzc
-i.. (0,0,{phi=0;theta=-pi/2;-$3};0,0,{phi=0;theta=pi/2;$3}) -a[-2,-1] y
nbv={h} -y.
$n1,{$n2-2},1,4,"nx=(x+1)%w;ny=(y+1);2+if(c==0,x+y*"$n1",if(c==1,nx+y*"$n1",if(c==2,nx+ny*"$n1",x+ny*"$n1")))"
-r. {w*h},4,1,1,-1 -permute. yxzc -i.. 1,{h},1,1,4 -a[-2,-1] x
2,$n1,1,1,3,0 1,$n1,1,1,'y' --+. 1 -%. {h} 2,$n1,1,1,3,1 [-3,-2]
-+[-5,-4] 2 -rv[-5,-4] -+[-2,-1] {$nbv-$n1} -a[-3--1] x -a[-4--2] x
nbp={h+{-2,h}+{-3,h}}
-y[-3--1] -a[-3--1] y
-i... ($nbv;$nbp)
1,{3*$nbp},1,1,200 1,$nbp,1,1,1 -a[-2,-1] y
-a[-5--1] y -nm. "[3d spherical surface '$3']"
-v +
#@gmic spline3d : x0[%],y0[%],z0[%],u0[%],v0[%],w0[%],x1[%],y1[%],z1[%],u1[%],v1[%],w1[%],_nb_vertices>=2
#@gmic : Input 3d spline with specified geometry.
#@gmic : Default values: 'nb_vertices=128'.
#@gmic : $ -repeat 100 -spline3d {u},{u},{u},{u},{u},{u},{u},{u},{u},{u},{u},{u},128 -color3d. ${-RGB} -done -box3d 1 -primitives3d. 1 -+3d
spline3d : -check ${13=128}>=2
-e[^-1] "Input new 3d spline from (${1-3}) [${4-6}] to (${7-9}) [${10-12}] with $13 vertices."
-v -
({'CImg3d'}) -+. 0.5
($13;{$13-1})
1,$13,1,1,1 (0;1) -r. 1,$13,1,1,3 --sqr. --*[-2,-1] -a[-4--1] x
--*. '$2,$5,{3*(($8)-($2))-2*($5)-($11)},{($5)+($11)+2*(($2)-($8))}' -l. -s x -+ -endl
--*.. '$3,$6,{3*(($9)-($3))-2*($6)-($12)},{($6)+($12)+2*(($3)-($9))}' -l. -s x -+ -endl
-*... '$1,$4,{3*(($7)-($1))-2*($4)-($10)},{($4)+($10)+2*(($1)-($7))}' -l... -s x -+ -endl
-a[-3--1] x
1,{$13-1},1,1,2 (0,1;{$13-2},{$13-1}) -r. 2,[-2],1,1,3 -round. -a[-2,-1] x
1,{3*($13-1)},1,1,200 1,{$13-1},1,1,1
-y[-3,-4,-6] -a[-6--1] y
-v +
#@gmic s3d : eq. to '-split3d'. : (+)
#@gmic split3d : _keep_shared_data={ 0 | 1 } : (+)
#@gmic : Split selected 3d objects into 6 feature vectors :
#@gmic : { header, sizes, vertices, primitives, colors, opacities }.
#@gmic : (eq. to '-s3d').
#@gmic : To recreate the 3d object, append these 6 images along the y-axis.
#@gmic : Default value: 'keep_shared_data=1'.
#@gmic : $ -box3d 100 --split3d
#@gmic sprite3d
#@gmic : Convert selected images as 3d sprites.
#@gmic : Selected image with alpha channels are managed.
#@gmic : $ image.jpg -sprite3d
sprite3d :
-e[^-1] "Convert image$? as 3d sprites."
-v - -repeat $! -l[$>] nm={0,n}
-split_opacity
-i[0] (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};{0,s}) -y[1]
-if {$!==2} (1) -a y
-else -/. 255 -i.. (-128;{w};{h};{s}) -y.
-endif
-a y
-nm $nm -endl -done -v +
#@gmic sprites3d : [sprite],_sprite_has_alpha_channel={ 0 | 1 }
#@gmic : Convert selected 3d objects as a sprite cloud.
#@gmic : Set 'sprite_has_alpha_channel' to 1 to make the last channel of the selected sprite be a transparency mask.
#@gmic : Default value: 'mask_has_alpha_channel=0'.
#@gmic : $ -torus3d 100,20 image.jpg -resize2dy. 64 100%,100% -gaussian. 30%,30% -*. 255 -append[-2,-1] c --sprites3d[0] [1],1 -display_rgba..
sprites3d : -check ${-is_image_arg\ $1} -skip ${2=0}
-e[^-1] "Convert image$? as 3d sprites clouds, using sprite $1 ("${"-arg {1+!$2},with,without"}" alpha-channel)."
-v - -repeat $!
-if {!{$>,i(0,7)}} -continue -endif
-pass$1 0
-if {!w} -empty3d -rv[$>,-1] -nm[$>] {n} -rm. -continue -endif
-l[$>,-1]
-s3d[0] N={1,@0} -=[1] $N,0,1
-rm[3-5] -i[3] (1,0;1,{$N-1}) -r[3] 2,$N,1,1,3 -round[3]
-if $2
-if {s==1}
-i.. 3,$N,1,1,200 -/. 255
-i.. (-128;{w};{h};1)
-if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 -endif
-else
-s. c,-{s-1} -/. 255
-i... (-128;{w};{h};{-2,s})
-if {$N>1} -i.. 1,{4*($N-1)},1,1,-128,0,0,0 -endif
-i.. (-128;{w};{h};1)
-if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 -endif
-endif
-else
-i.. (-128;{w};{h};{s}) -y[-3,-1]
-if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 -endif
1,$N,1,1,1
-endif
-y -a y
-endl -done -v +
#@gmic star3d : _nb_branches>0,0<=_thickness<=1
#@gmic : Input 3d star at (0,0,0), with specified geometry.
#@gmic : Default values: 'nb_branches=5' and 'thickness=0.38'.
#@gmic : $ -star3d , --primitives3d 1 -color3d.. ${-RGB}
star3d : -check "${1=5}>0 && ${2=0.38}>=0 && $2<=1"
-e[^-1] "Input 3d star, with $1 branches and thickness $2."
-v -
N={2*$1} ({'CImg3d'}) -+. 0.5 ({$N+1};$N)
({-pi/2};{3*pi/2}) -r. 1,{$N+1},1,1,3 -rows. 0,{h-2} --sin. -cos.. -a[-2,-1] x
(1,1;$2,$2) -*[-2,-1] -z. 0,2 -r. 3,{h+1},1,1,0
(3,$N,1,0;3,$N,$N,{$N-1}) -r. 4,$N,1,1,3 -round. -=. 0,2,100%
3,$N,1,1,200 1,$N,1,1,1 -y[-6,-4--2] -a[-6--1] y -nm. [3d\ star]
-v +
#@gmic streamline3d : x[%],y[%],z[%],_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : 'formula',x,y,z,_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : (+)
#@gmic : Extract 3d streamlines from selected vector fields or from specified formula.
#@gmic : 'interpolation' can be { 0=nearest integer | 1=1st-order | 2=2nd-order | 3=4th-order }.
#@gmic : Default values: 'dl=0.1', 'interpolation=2', 'is_backward=0' and 'is_oriented=0'.
#@gmic : $ 100,100,100,3 -rand -10,10 -blur 3 -repeat 300 --streamline3d[0] {u(100)},{u(100)},{u(100)},1000,1,1 -color3d. ${-RGB} -done -remove[0] -box3d 100 -primitives3d. 1 -add3d
#@gmic -3d : eq. to '-sub3d'. : (+)
#@gmic sub3d : tx,_ty,_tz : (+)
#@gmic : Shift selected 3d objects with the opposite of specified displacement vector.
#@gmic : (eq. to '--3d').
#@gmic : Default values: 'ty=tz=0'.
#@gmic : $ -sphere3d 10 -repeat 5 --sub3d. 10,{u(-10,10)},0 -color3d. ${-RGB} -done -add3d
#@gmic superformula3d : resolution>1,m>=1,n1,n2,n3
#@gmic : Input 2d superformula curve as a 3d object.
#@gmic : Default values: 'resolution=1024', 'm=8', 'n1=1', 'n2=5' and 'n3=8'.
#@gmic : $ -superformula3d ,
superformula3d : -check "${1=1024}>1 && ${2=8}>=1" -skip ${3=1},${4=5},${5=8}
-e[^-1] "Input 2d superformula curve, with resolution $1, m=$2 and (n1,n2,n3)=($3,$4,$5)."
-v -
res={round($1)}
(67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
(0,{2*pi}) -r. $res,1,1,1,3 [-1]
-*. {$2/4} --sin. -cos.. -abs[-2,-1]
-^.. $4 -^. $5 -+[-2,-1] -^. {-1/$3}
--sin.. -cos... -*. [-2] -*[-3,-2] -n[-2,-1] -1,1
-a[-2,-1] y -rows. 0,2 -transpose. -r. 1,{w*h},1,1,-1
1,{$res-1},1,1,2 (0;{$res-2}) -r. 1,{$res-1},1,1,3 --+. 1 -a[-3--1] x -round. 1 -r. 1,{w*h},1,1,-1
1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 -a[-5--1] y -nm. [3d\ superformula]
-v +
#@gmic text_pointcloud3d : _"text1",_"text2",_smoothness
#@gmic : Input 3d text pointcloud from the two specified strings.
#@gmic : Default values: 'text1="text1"', 'text2="text2"' and 'smoothness=1'.
#@gmic : $ -text_pointcloud3d "G'MIC","Rocks!"
text_pointcloud3d : -skip ${1="text1"},${2="text2"},${3=1}
-e[^-1] "Input 3d pointcloud text object from strings '$1' and '$2', with smoothness $3."
-v -
0 -t. "$1",0,0,53,1,1
0 -t. "$2",0,0,53,1,1 -mirror. y
-autocrop[-2,-1] 0
-expand_xy[-2,-1] 2,0 -dilate[-2,-1] 2
-permute. zyxc -r[-2,-1] ${-max_whd} -&[-2,-1]
100%,100% -rand. 0,{{-2,d}-1} -round. -r. [-2] -f. 'if(z==i,1,0)'
-distance. 1 -+. 1 --f. 1 -rv[-2,-1] -/[-2,-1] -*. [-2]
--dilate. 0,0,{d} -==[-2,-1] -*. [-2]
1,100%,100% -rand. 0,{{-2,w}-1} -round. -r. [-2] -f. 'if(x==i,1,0)'
-distance. 1 -+. 1 --f. 1 -rv[-2,-1] -/[-2,-1] -*. [-3]
--dilate. 0,0,{d} -==[-2,-1] -*[-3,-1]
-|[-2,-1]
-b. $3 -isosurface3d. 25%
-c3d. -n3d. -nm. "[3d text pointcloud]" -v +
#@gmic text3d : text,_font_height>0,_depth>0,_smoothness
#@gmic : Input a 3d text object from specified text.
#@gmic : Default values: 'font_height=53', 'depth=10' and 'smoothness=1.5'.
#@gmic : $ -text3d "G'MIC as a\n3D logo!"
text3d : -skip ${2=53},${3=10},${4=1.5}
-e[^-1] "Input 3d text object '$1' with size $2, depth $3 and smoothness $4."
-v - 0 -t. "$1",0,0,$2,1,1 -autocrop. 0 -r. 100%,100%,$3 -expand_xyz. 10,0
-b. $4 -isosurface3d. 40% -rv3d. -nm. "[3d text '$1']" -v +
#@gmic t3d : eq. to '-texturize3d'. : (+)
#@gmic texturize3d : [ind_texture],_[ind_coords] : (+)
#@gmic : Texturize selected 3d objects with specified texture and coordinates.
#@gmic : (eq. to '-t3d').
#@gmic : When '[ind_coords]' is omitted, default XY texture projection is performed.
#@gmic : Default value: 'ind_coords=(undefined)'.
#@gmic : $ image.jpg -torus3d 100,30 -texturize3d. [-2] -keep.
#@gmic torus3d : _radius1,_radius2,_nb_subdivisions1>2,_nb_subdivisions2>2
#@gmic : Input 3d torus at (0,0,0), with specified geometry.
#@gmic : Default values: 'radius1=1', 'radius2=0.3', 'nb_subdivisions1=24' and 'nb_subdivisions2=12'.
#@gmic : $ -torus3d 10,3 --primitives3d 1 -color3d.. ${-RGB}
torus3d : -check "${3=24}>2 && ${4=12}>2" -skip ${1=1},${2=0.3}
-e[^-1] "Input 3d torus, with radii ($1,$2) and subdivisions ($3,$4)."
-v -
nbp={$3*$4}
1,8,1,1,67.5,73.5,109.5,103.5,51.5,100.5,$nbp,{$4*$3}
(0;{2*pi}) --y. x
-r.. 1,{$3+1},1,1,3 -z.. 0,0,0,{$3-1}
-r. {$4+1},1,1,1,3 -z. 0,{$4-1}
--sin[-2,-1] -cos[-4,-3] -r[-4--1] $4,$3
-*... $2 -+... $1 -*. $2 -*[-4] [-3] -*[-3,-2]
-y[-3--1] -a[-3--1] x
1,$3,1,1,'y' -*. $4 --shift. 0,-1 $4,1,1,1,'x' --shift. -1 -r[-4--1] $4,$3
--+[-4,-1] -+.. [-4] -+[-5] [-3] -+[-4,-3] -y[-4--1] -i[-5] 1,{h},1,1,4 -a[-5--1] x
3,{h},1,1,200 1,{h},1,1,1 -y[-4--2] -a[-5--1] y
-nm. [3d\ torus]
-v +
#@gmic triangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2
#@gmic : Input 3d triangle at specified coordinates.
#@gmic : $ -repeat 100 a={$>*pi/50} -triangle3d 0,0,0,0,0,3,{cos(3*$a)},{sin(2*$a)},0 -color3d. ${-RGB} -done -add3d
triangle3d :
-e[^-1] "Input 3d triangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)."
-v - 1,25,1,1,67.5,73.5,109.5,103.5,51.5,100.5,3,1,${1-9},3,0,1,2,200,200,200,1 -nm. [3d\ triangle] -v +
#@gmic volume3d
#@gmic : Transform selected 3d volumetric images as 3d parallelepipedic objects.
#@gmic : $ image.jpg -animate blur,0,5,30 -a z -volume3d
volume3d :
-e[^-1] "Transform image$? as 3d parallelepipedic objects."
-v - -repeat $! -l[$>]
w={w} h={h} d={d}
--slices 0 --slices[0] 100% -mirror. y
--columns[0] 0 --columns[0] 100% -permute[-2,-1] zyxc -mirror.. x
--rows[0] 0 --rows[0] 100% -permute[-2,-1] xzyc -mirror.. y
-rm[0] -image6cube3d -*3d $w,$h,$d
-endl -done -v +
#@gmic weird3d : _resolution>0
#@gmic : Input 3d weird object at (0,0,0), with specified resolution.
#@gmic : Default value: 'resolution=32'.
#@gmic : $ -weird3d 48 --primitives3d 1 -color3d.. ${-RGB}
weird3d : -skip ${1=32}
-e[^-1] "Input 3d weird object, with resolution $1."
-v -
-isosurface3d "'\
T = 1.61803399;\
2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x))\
'",0,-4.7,-4.7,-4.7,4.7,4.7,4.7,$1,$1,$1
-c3d. -n3d. -nm. [3d\ weird]
-v +
#@gmic :: Program control
#@gmic ap : eq. to '-apply_parallel'.
ap :
-v - _gmic_s="$?" -v +
-_apply_parallel "$*"
#@gmic apply_parallel : "command"
#@gmic : Apply specified command on each of the selected images, by parallelizing it for all image of the list.
#@gmic : (eq. to '-ap').
#@gmic : $ image.jpg --mirror x --mirror y -apply_parallel "-blur 3"
apply_parallel :
-v - _gmic_s="$?" -v +
-_$0 "$*"
_apply_parallel :
-e[0--3] "Apply command '$*' on all image"$_gmic_s" in parallel, using "$_cpus" threads."
-v -
-if {$!" && "narg("$*")}
-m "_ap : -repeat $! -l[$>] $* -if $! -k[0] -else 0 -endif -endl -done"
command=
N={min($!,$_cpus)} S=0 sep=""
-repeat $N
E={round(($>+1)*$!/$N)-1}
command=$command$sep-_ap[$S-$E]
S={$E+1} sep=,
-done
-parallel $command
-uncommand _ap
-endif
-v +
#@gmic apc : eq. to '-apply_parallel_channels'.
apc :
-v - _gmic_s="$?" -v +
-_apply_parallel_channels "$*"
#@gmic apply_parallel_channels : "command"
#@gmic : Apply specified command on each of the selected images, by parallelizing it for all channel of the images independently.
#@gmic : (eq. to '-apc').
#@gmic : $ image.jpg -apply_parallel_channels "-blur 3"
apply_parallel_channels :
-v - _gmic_s="$?" -v +
-_$0 "$*"
_apply_parallel_channels :
-e[0--3] "Apply command '$*' on all channels of image"$_gmic_s" in parallel, using "$_cpus" threads."
-v - N=$! -repeat $N s$>={$>,s} -done -s c
-ap "$1"
-repeat $N -a[$>-{$>+${s$>}-1}] c -done -v +
#@gmic apo : eq. to '-apply_parallel_overlap'.
apo : -check "${2=0}>=0 && isint(${3=0}) && $3>=0"
-v - _gmic_s="$?" -v +
-_apply_parallel_overlap "$1",${2--1}
#@gmic apply_parallel_overlap : "command",overlap[%],nb_threads={ 0=auto | 1 | 2 | 4 | 8 | 16 }
#@gmic : Apply specified command on each of the selected images, by parallelizing it on 'nb_threads' overlapped sub-images.
#@gmic : (eq. to '-apo').
#@gmic : 'nb_threads' must be a power of 2.
#@gmic : Default values: 'overlap=0','nb_threads=0'.
#@gmic : $ image.jpg --apply_parallel_overlap "-smooth 500,0,1",1
apply_parallel_overlap : -check "${2=0}>=0 && isint(${3=0}) && $3>=0"
-v - _gmic_s="$?" -v +
-_$0 "$1",${2--1}
_apply_parallel_overlap : -check "${2=0}>=0 && isint(${3=0}) && $3>=0"
-v - N={if($3,max(1,round($3)),$_cpus)} N={2^int(log2(min(16,$N)))} -v +
-e[0--3] "Apply parallelized command '$1' on image"$_gmic_s", with overlap $2 and "$N" threads."
-v -
__apo_exception=""
-m "_check1 : -if {$!!=1} -rm 0 __apo_exception=\"Command '-apply_parallel_overlap': Specified command '$1' changes the size of the image stack.\" -endif"
-repeat $! -l[$>]
-_apply_parallel_overlap$N "$1",$2
-endl -done
-uncommand _check1
-v +
_apply_parallel_overlap1 :
$1
-if {narg($__apo_exception)} -v + -error[0--12] $__apo_exception -endif
_apply_parallel_overlap2 :
-if {w>=h}
ovx={round(if(${"-is_percent $2"},w*$2,$2))} w2={int(w/2)}
--z[0] {$w2-$ovx},100% -z[0] 0,{$w2+$ovx-1}
-parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl"
-if {narg($__apo_exception)} -v + -error[0--12] $__apo_exception -endif
-z[0] 0,{0,w-1-$ovx} -z[1] $ovx,100% -a x
-else
ovy={round(if(${"-is_percent $2"},h*$2,$2))} h2={int(h/2)}
--rows[0] {$h2-$ovy},100% -rows[0] 0,{$h2+$ovy-1}
-parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl"
-if {narg($__apo_exception)} -v + -error[0--12] $__apo_exception -endif
-rows[0] 0,{0,h-1-$ovy} -rows[1] $ovy,100% -a y
-endif
_apply_parallel_overlap4 :
-if {max(w,h)/min(w,h)>=3}
-_apply_parallel_overlap2 "-_apply_parallel_overlap2 \"$1\",$2",$2
-else
ovx={round(if(${"-is_percent $2"},w*$2,$2))} w2={int(w/2)}
ovy={round(if(${"-is_percent $2"},h*$2,$2))} h2={int(h/2)}
--z[0] {$w2-$ovx},0,100%,{$h2+$ovy-1} --z[0] 0,{$h2-$ovy},{$w2+$ovx-1},100%
--z[0] {$w2-$ovx},{$h2-$ovy},100%,100% -z[0] 0,0,{$w2+$ovx-1},{$h2+$ovy-1}
-parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl","-l[2] $1 -_check1 -endl","-l[3] $1 -_check1 -endl"
-if {narg($__apo_exception)} -v + -error[0--12] $__apo_exception -endif
-z[0] 0,0,{0,w-1-$ovx},{0,h-1-$ovy} -z[1] $ovx,0,100%,{1,h-1-$ovy}
-z[2] 0,$ovy,{2,w-1-$ovx},100% -z[3] $ovx,$ovy,100%,100%
-a[0,1] x -a[1,2] x -a y
-endif
_apply_parallel_overlap8 :
-_apply_parallel_overlap2 "-_apply_parallel_overlap4 \"$1\",$2",$2
_apply_parallel_overlap16 :
-_apply_parallel_overlap2 "-_apply_parallel_overlap8 \"$1\",$2",$2
#@gmic apply_timeout : "command",_timeout={ 0=no timeout | >0=with specified timeout (in seconds) }
#@gmic : Apply a command with a timeout.
apply_timeout :
-if {!$2}
-e[0--3] "Apply command '$1' on image$?, with no timeout."
-v - $1 -v +
-else
-e[0--3] "Apply command '$1' on image$?, with a timeout of $2 seconds."
-v -
-l[] ({'$/'}) id={is} -rm -endl
__done$id=0 __is_timeout$id=0
-l
-parallel "$1 __done"$id"=1",\
"-do -if {$|>$2} __is_timeout"$id"=1 -error \"\" -endif -wait 500 -while {!$__done"$id"}"
-onfail
-v +
-if ${__is_timeout$id} -v + -error[0--5] "Command '-apply_timeout': Time out ($2 seconds) for command '$1'."
-else -v + -error[0--5] "Command '-apply_timeout': "${}
-endif
-endl
-v +
-endif
#@gmic check : expression : (+)
#@gmic : Evaluate specified expression and display an error message if evaluated to false.
#@gmic : If 'expression' is not evaluable, it is regarded as a filename and checked if it exists.
#@gmic check3d : _is_full_check={ 0 | 1 } : (+)
#@gmic : Check validity of selected 3d vector objects, and display an error message
#@gmic : if one of the selected image is not a valid 3d vector object.
#@gmic : Full 3d object check is slower but more precise.
#@gmic : Default value: 'is_full_check=1'.
#@gmic continue : (+)
#@gmic : Go to end of current block 'repeat..done', 'do..while' or 'local..endlocal'.
#@gmic : $ image.jpg -repeat 10 -blur 1 -if {1==1} -continue -endif -deform 10 -done
#@gmic break : (+)
#@gmic : Break current 'repeat..done', 'do..while' or 'local..endlocal' block.
#@gmic : $ image.jpg -repeat 10 -blur 1 -if {1==1} -break -endif -deform 10 -done
#@gmic do : (+)
#@gmic : Start a 'do..while' block.
#@gmic : $ image.jpg -luminance i={ia+2} -do -set 255,{u(100)}%,{u(100)}% -while {ia<$i}
#@gmic done : (+)
#@gmic : End a 'repeat..done' block, and go to associated '-repeat' position, if iterations remain.
#@gmic elif : boolean : filename : (+)
#@gmic : Start a 'elif..[else]..endif' block if previous '-if' was not verified
#@gmic : and test if specified boolean is true, or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.
#@gmic else : (+)
#@gmic : Execute following commands if previous '-if' or '-elif' conditions failed.
#@gmic endif : (+)
#@gmic : End a 'if..[elif]..[else]..endif' block.
#@gmic endl : eq. to '-endlocal'. : (+)
#@gmic endlocal : (+)
#@gmic : End a 'local..endlocal' block.
#@gmic : (eq. to '-endl').
#@gmic error : message : (+)
#@gmic : Print specified error message on the standard error (stderr) and exit interpreter, except
#@gmic : if error is caught by a '-onfail' command.
#@gmic : Command selection (if any) stands for displayed call stack subset instead of image indices.
#@gmic x : eq. to '-exec'. : (+)
#@gmic exec : command : (+)
#@gmic : Execute external command using a system call.
#@gmic : The status value is then set to the error code returned by the system call.
#@gmic : (eq. to '-x').
#@gmic if : boolean : filename : (+)
#@gmic : Start a 'if..[elif]..[else]..endif' block and test if specified boolean is true,
#@gmic : or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.
#@gmic : $ image.jpg -if {ia<64} -add 50% -elif {ia<128} -add 25% -elif {ia<192} -sub 25% -else -sub 50% -endif -cut 0,255
#@gmic l : eq. to '-local'. : (+)
#@gmic local : (+)
#@gmic : Start a 'local..[onfail]..endlocal' block, with selected images.
#@gmic : (eq. to '-l').
#@gmic : $ image.jpg -local[] 300,300,1,3 -rand[0] 0,255 -blur 4 -sharpen 1000 -endlocal
#@gmic : $ image.jpg --local -repeat 3 -deform 20 -done -endlocal
#@gmic : $$
#@gmic mutex : indice,_action={ 0=unlock | 1=lock } : (+)
#@gmic : Lock or unlock specified mutex for multi-threaded programming.
#@gmic : A locked mutex can be unlocked only by the same thread. All mutexes are unlocked by default.
#@gmic : 'indice' designates the mutex indice, in [0,255].
#@gmic : Default value: 'action=1'.
#@gmic noarg : (+)
#@gmic : Used in a custom command, '-noarg' tells the command that its argument list have not been used
#@gmic : finally, and so they must be evaluated next in the G'MIC pipeline, just as if the custom
#@gmic : command takes no arguments at all.
#@gmic : Use this command to write a custom command which can decide if it takes arguments or not.
#@gmic onfail : (+)
#@gmic : Execute following commands when an error is encountered in the body of the 'local..endlocal' block.
#@gmic : The status value is set with the corresponding error message.
#@gmic : $ image.jpg --local -blur -3 -onfail -mirror x -endlocal
#@gmic parallel : _wait_threads,"command1","command2",... : (+)
#@gmic : Execute specified commands in parallel, each in a different thread.
#@gmic : Parallel threads share the list of images.
#@gmic : 'wait_threads' can be { 0=when current environment ends | 1=immediately }.
#@gmic : Default value: 'wait_threads=1'.
#@gmic : $ image.jpg [0] -parallel "-blur[0] 3","-mirror[1] c"
parallel :
-if {$1==0||$1==1||$1==2} -e[0--3] "Execute "{$#-1}" commands '${2--1}' in parallel on image$?."
-else -e[0--3] "Execute "$#" commands '$*' in parallel on image$?."
-endif
-v - -parallel $"*" -v +
#@gmic progress : 0<=value<=100 : -1 : (+)
#@gmic : Set the progress indice of the current processing pipeline.
#@gmic : This command is useful only when G'MIC is used by an embedding application.
#@gmic q : eq. to '-quit'. : (+)
#@gmic quit : (+)
#@gmic : Quit interpreter.
#@gmic : (eq. to '-q').
#@gmic repeat : nb_iterations,_variable_name : (+)
#@gmic : Start iterations of a 'repeat..done' block.
#@gmic : $ image.jpg -split y -repeat $!,n -shift[$n] $<,0,0,0,2 -done -append y
#@gmic : $ image.jpg -mode3d 2 -repeat 4 -imagecube3d -rotate3d 1,1,0,40 -snapshot3d 400,1.4 -done
#@gmic : $$
#@gmic return : (+)
#@gmic : Return from current custom command.
#@gmic rprogress : 0<=value<=100 | -1 | "command",0<=value_min<=100,0<=value_max<=100
#@gmic : Set the progress indice of the current processing pipeline (relatively to
#@gmic : previously defined progress bounds), or call the specified command with
#@gmic : specified progress bounds.
rprogress : -skip ${2=""}
-v -
-if {!narg($_progress_bounds)} _progress_bounds=0,100 -endif
m={arg(-2,$_progress_bounds)} M={arg(-1,$_progress_bounds)}
-if {$#==2&&!narg($2)}
-v + -e[0--3] "Set relative progress indice to $1%." -v -
-progress {if($1<0,-1,min(100,max(0,$m+($M-$m)*$1%)))}
-elif {$#==3}
nm={min($2,$-1)} nM={max($2,$-1)}
-v + -e[0--3] "Call command '$1' with progress bounds ["$nm,$nM"]." -v -
-progress $m _progress_bounds=$_progress_bounds,{$m+$nm*($M-$m)/100},{$m+$nM*($M-$m)/100}
-_rprogress "$1"
-progress $M ($_progress_bounds) _progress_bounds={@0--3} -rm.
-else -v + -error[0--3] "Command '-rprogress': Invalid argument '$*'."
-endif
-v +
_rprogress : $*
#@gmic skip : item : (+)
#@gmic : Do nothing but skip specified item.
#@gmic u : eq. to '-status'. : (+)
#@gmic status : status_string : (+)
#@gmic : Set the current status. Used to define a returning value in a function.
#@gmic : (eq. to '-u').
#@gmic : $ image.jpg -command "foo : u0=Dark u1=Bright -status ${u{ia>=128}}" -text_outline ${-foo},2,2,23,2,1,255
#@gmic while : boolean : filename : (+)
#@gmic : End a 'do..while' block and go back to associated '-do'
#@gmic : if specified boolean is true or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.
#@gmic :: Arrays, tiles and frames
#@gmic array : M>0,_N>0,_expand_type={ 0=min | 1=max | 2=all }
#@gmic : Create MxN array from selected images.
#@gmic : Default values: 'N=M' and 'expand_type=0'.
#@gmic : $ image.jpg -array 3,2,2
array : -check "isint($1) && $1>0 && isint(${2=$1}) && $2>0" -skip ${3=0}
-e[^-1] "Create $1x$2 array from image$?, with expand type $3."
-v - r0={100/max($1,$2)} r1={100/min($1,$2)} r2=100
-r ${r$3}%,${r$3}%,1,100%,2 -r {$1*100}%,{$2*100}%,1,100%,0,2 -v +
#@gmic array_fade : M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0=min | 1=max | 2=all}
#@gmic : Create MxN array from selected images.
#@gmic : Default values: 'N=M', 'fade_start=60', 'fade_end=90' and 'expand_type=1'.
#@gmic : $ image.jpg -array_fade 3,2
array_fade : -skip ${2=$1},${3=60},${4=90},${5=1}
-e[^-1] "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
-v - -repeat $! -l[$>] [-1] -shift.. {round(w/2)},{round(h/2)},1,1,2 -fade_diamond $3,$4 -endl -done
-array $1,$2,$5
-v +
#@gmic array_mirror : N>=0,_dir={ 0=x | 1=y | 2=xy | 3=tri-xy },_expand_type={ 0 | 1 }
#@gmic : Create 2^Nx2^N array from selected images.
#@gmic : Default values: 'dir=2' and 'expand_type=0'.
#@gmic : $ image.jpg -array_mirror 2
array_mirror : -skip ${2=2},${3=0}
-e[^-1] "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
-v - -repeat $1
-if {$3==0}
-if {$2>=3} -r 33%,33%,100%,100%,2
-else -r 50%,50%,100%,100%,2
-endif
-endif
-repeat $! -l[$>]
-if {$2==0} --mirror x -a x
-elif {$2==1} --mirror y -a y
-else --mirror x -a x --mirror y -a y -if {$2==3} -r 150%,150%,1,100%,0,2,1,1 -endif
-endif
-endl -done
-done -v +
#@gmic array_random : Ms>0,_Ns>0,_Md>0,_Nd>0
#@gmic : Create MdxNd array of tiles from selected MsxNs source arrays.
#@gmic : Default values: 'Ns=Ms', 'Md=Ms' and 'Nd=Ns'.
#@gmic : $ image.jpg --array_random 8,8,15,10
array_random : -skip ${2=$1},${3=$1},${4=$2}
-e[^-1] "Create $3x$4 array of tiles from $1x$2 array$?."
-v - -repeat $! -l[$>] nm={0,n}
-split_tiles $1,$2
-repeat $3 -repeat $4 [{u($1*$2-1)}] -done -done
-rm[0-{$1*$2-1}] -append_tiles $3,$4
-nm $nm -endl -done -v +
#@gmic frame : eq. to '-frame_xy'.
frame : -skip ${2=$1}>=0,${3=255},${4=$3},${5=$4},${6=255}
-v - _gmic_s="?" -v +
-_frame_xy ${1--1}
#@gmic frame_blur : _sharpness>0,_size>=0,_smoothness,_shading,_blur
#@gmic : Draw RGBA-colored round frame in selected images.
#@gmic : Default values: 'sharpness=10', 'size=30', 'smoothness=0', 'shading=1' and 'blur=3%'.
#@gmic : $ image.jpg -frame_blur 3,30,8,10%
frame_blur : -skip ${1=10},${2=30},${3=0},${4=1},${5=3%}
-e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and blur $5."
-v - -to_rgba -repeat $! -l[$>] nm={0,n}
100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" ->=. $2%
-if $4 -distance. 1 -n. 0,1 -*. -1 -+. 1 -^. {1/$4} -endif
-b. $3 --b.. $5 -mv. -3 -blend_fade[0,1] [-1] -rm.
-nm $nm -endl -done -v +
#@gmic frame_cube : _depth>=0,_centering_x,_centering_y,_left_side={0=normal | 1=mirror-x | 2=mirror-y | 3=mirror-xy},_right_side,_lower_side,_upper_side
#@gmic : Insert 3d frames in selected images.
#@gmic : Default values: 'depth=1', 'centering_x=centering_y=0' and 'left_side=right_side,lower_side=upper_side=0'.
#@gmic : $ image.jpg -frame_cube ,
frame_cube : -check "${1=1}>=0" -skip ${2=0},${3=0},${4=0},${5=0},${6=0},${7=0}
-e[^-1] "Insert 3d frame in image$?, with depth $1, centering point ($2,$3) and orientations (${4--1})."
-v - -repeat $! -l[$>] nm={0,n} -split_opacity
-if {$!==2} -frame_cube ${1--1} -a c
-else
m={max(w,h)} w={w} h={h} s={s}
-imageplane3d -c3d -/3d. $w,$h,1
--_frame_cube[0] $4 -r3d. 0,1,0,90 -+3d. -0.5,0,-0.5
--_frame_cube[0] $5 -r3d. 0,1,0,-90 -+3d. 0.5,0,-0.5
--_frame_cube[0] $6 -r3d. 1,0,0,90 -+3d. 0,0.5,-0.5
--_frame_cube[0] $7 -r3d. 1,0,0,-90 -+3d. 0,-0.5,-0.5
-+3d 0,0,1 -+3d -*3d $w,$h,$m
f=1000
cx=$2*$w/2*($f+$m*$1)/$f
cy=$3*$h/2*($f+$m*$1)/$f
-s3d -r[2] 3,{{2,h}/3},1,1,-1
-f[2] "if(i(2,y)<0.5,i,i+if(x==0,"$cx",if(x==1,"$cy",($1-1)*"$m")))"
-y[2] -a y
-*3d 2 {2*$w},{2*$h},1,$s -f3d {2*$f}
-j3d. [-2],50%,50%,0,1,2,0,0 -rm..
-r $w,$h,1,100%,2
-endif
-nm $nm -endl -done
-v +
_frame_cube :
-if {$1==1} -r3d. 0,1,0,180 -rv3d.
-elif {$1==2} -r3d. 1,0,0,180 -rv3d.
-elif {$1==3} -r3d. 0,0,1,180
-endif
#@gmic frame_fuzzy : size_x[%]>=0,_size_y[%]>=0,_fuzzyness>=0,_smoothness[%]>=0,_R,_G,_B,_A
#@gmic : Draw RGBA-colored fuzzy frame in selected images.
#@gmic : Default values: 'size_y=size_x', 'fuzzyness=5', 'smoothness=1' and 'R=G=B=A=255'.
#@gmic : $ image.jpg -frame_fuzzy 20
frame_fuzzy : -skip ${2=$1},${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
-e[^-1] "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
-v - -to_rgba -repeat $! -l[$>]
100%,100%,1,1,1
padx={if(${"-is_percent $1"},$1*(w-1)/2,$1)}
pady={if(${"-is_percent $2"},$2*(h-1)/2,$2)}
-rectangle. $padx,$pady,{w-1-$padx},{h-1-$pady}
-spread. $3 -b. $4 100%,100%,1,4 -fc. ${5-8}
-j[0] [2],0,0,0,0,1,[1] -k[0]
-endl -done -v +
#@gmic frame_painting : _size[%]>=0,0<=_contrast<=1,_profile_smoothness[%]>=0,_R,_G,_B,_vignette_size[%]>=0,_vignette_contrast>=0,_defects_contrast>=0,0<=_defects_density<=100,_defects_size>=0,_defects_smoothness[%]>=0,_serial_number
#@gmic : Add a painting frame to selected images.
#@gmic : Default values: 'size=10%', 'contrast=0.4', 'profile_smoothness=6%', 'R=225', 'G=200', 'B=120', 'vignette_size=2%', 'vignette_contrast=400', 'defects_contrast=50', 'defects_density=10', 'defects_size=1', 'defects_smoothness=0.5%' and 'serial_number=123456789'.
#@gmic : $ image.jpg -frame_painting ,
frame_painting :
-check "${1=10%}>=0 && ${2=0.4}>=0 && $2<=1 && ${3=6%}>=0 && ${7=2%}>=0 && ${8=400}>=0 && ${9=50}>=0 && ${10=10}>=0 && $10<=100 && ${11=1}>=0 && ${12=0.5%}>=0"
-skip ${4=225},${5=200},${6=120},${13=123456789}
-e[^-1] "Add painting frame to image$?, with size $1, contrast $2, profile smoothness $3, color (${4-6}), vignette size $7, "\
"vignette strength $8, defects contrast $9, defects density $10, defects size $11, defects smoothness $12 and serial number $13."
-v - -repeat $! -l[$>]
-if {!$1} -return -endif
$1,$1 s={max(w,h)} -rm.
({'${-dec2bin\ $13}'}) --. {'0'} -r. $s
-transpose. -b. $3 -n. {1-$2},{1+$2}
--r. {{-2,w}+2*$s},100%,1,1
--mirror. y
-mv... $! -transpose. -r. 100%,{-4,h+2*$s},1,1
--mirror. x
[-3],[-3],1,1,1 -polygon. 3,0,0,{$s-1},{$s-1},0,{$s-1},1,0 -polygon. 3,100%,0,{w-$s},100%,100%,100%,1,0
[-2],[-2],1,1,1 -polygon. 3,1,0,100%,{$s-2},100%,0 -polygon. 3,1,100%,100%,{h-$s+1},100%,100%,1,0
-_frame_painting[-6--3] ${4-6},${9-12}
{-7,w+2*$s},{-7,h+2*$s},1,3
-j. [-7],0,0,0,0,1,[-3],1 -rm[-7] -mirror... y
-j. [-6],0,{h-$s},0,0,1,[-3],1 -rm[-6,-3]
-j. [-4],0,0,0,0,1,[-2],1 -rm[-4] -mirror.. x
-j. [-3],{w-$s},0,0,0,1,[-2],1 -rm[-3,-2]
[-2],[-2],1,1,-255 -r. [-2],[-2],1,1,0,0,0.5,0.5 -+. 255 --b. $7 -n. 0,$8 -max[-2,-1] -c. 0,255
-a[-2--1] c
-r.. [-1],[-1],1,100%,0,0,0.5,0.5 -blend alpha
-endl -done -v +
_frame_painting :
-repeat $! -l[$>]
--*. $2 --*.. $3 -*... $1 -a[-3--1] c
100%,100%
i=0 -do -rand. 0,1 -remove_pixels. {100-$5}% -b. $6 ->=. 50% i+=1 -while {"m=$5/200;(ia<m-0.2 || ia>m+0.2) && "$i"<10"}
-b. $7 -g. -+[-2,-1] -n. -$4,$4
-+[-2,-1] -c. 0,255
-endl -done
#@gmic frame_pattern : M>=3,_constrain_size={ 0 | 1 } : M>=3,_[frame_image],_constrain_size={ 0 | 1 }
#@gmic : Insert selected pattern frame in selected images.
#@gmic : Default values: 'pattern=0' and 'constrain_size=0'.
#@gmic : $ image.jpg -frame_pattern 8
frame_pattern : -check $1>=3 -skip ${2=0},${3=}
-v - -to_colormode 0
-if ${"-is_image_arg $2"}
-v + -e[^-1] "Insert $1x$1 pattern frame on image$?, using frame image$2." -v -
-pass$2 0 -repeat {$!-1} -l[$>,-1]
wh={0,w},{0,h}
--r[1] {0,max(1,w/($1-2))},{0,max(1,h/($1-2))},1,100%,2
-r[0] {{0,w}+2*w},{{0,h}+2*h},1,100%,0,0,0.5,0.5
[-1]x{$1+2} -a[{-$1-2}--1] x -j[0] [-1],0,0 -j[0] [-1],0,{{0,h}-1-h} -rm.
[-1]x{$1+1} -a[{-$1-2}--1] y -j[0] [-1],0,0 -j[0] [-1],{{0,w}-1-w} -rm.
-if $3 -r[0] $wh,1,100%,2 -endif
-endl -done -rm.
-else
-v + -e[^-1] "Insert $1x$1 self-pattern frame on image$?." -v -
-repeat $! -l[$>]
wh={w},{h}
--r {max(1,w/($1-2))},{max(1,h/($1-2))},1,100%,2 -r.. {$1*w},{$1*h},1,100%,0,0,0.5,0.5
[-1]x{$1+2} -a[{-$1-2}--1] x -j... [-1],0,0 -j... [-1],0,{{-3,h}-1-h} -rm.
[-1]x{$1+1} -a[{-$1-2}--1] y -j.. [-1],0,0 -j.. [-1],{{-2,w}-1-w} -rm.
-if $3 -r $wh,1,100%,2 -endif
-endl -done
-endif
-v +
#@gmic frame_round : _sharpness>0,_size>=0,_smoothness,_shading,_R,_G,_B,_A
#@gmic : Draw RGBA-colored round frame in selected images.
#@gmic : Default values: 'sharpness=10', 'size=10', 'smoothness=0', 'shading=0' and 'R=G=B=A=255'.
#@gmic : $ image.jpg -frame_round 10
frame_round : -skip ${1=10},${2=10},${3=0},${4=0},${5=255},${6=$5},${7=$6},${8=255}
-e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and RGBA color ($5,$6,$7,$8)."
-v - -to_rgba -repeat $! -l[$>] nm={0,n}
100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" ->=. $2%
-if $4 -distance. 1 -n. 0,1 -*. -1 -+. 1 -^. {1/$4} -endif
-b. $3 -i... 100%,100%,1,4 -fc... $5,$6,$7,$8 -blend_fade[0,1] [-1] -rm.
-nm $nm -endl -done -v +
#@gmic frame_seamless : frame_size>=0,_patch_size>0,_blend_size>=0,_frame_direction={ 0=inner (preserve image size) | 1=outer }
#@gmic : Insert frame in selected images, so that tiling the resulting image makes less visible seams.
#@gmic : Default values: 'patch_size=7', 'blend_size=5' and 'frame_direction=1'.
#@gmic : $ image.jpg --frame_seamless 30 -array 2,2
frame_seamless : -check "$1>=0 && isint(${2=7}) && $2>0 && isint(${3=5}) && $3>=0" -skip ${4=1}
-v - s0="inner" s1="outer"
-v + -e[^-1] "Insert "${s{!!$4}}" seamless frame in image$?, with size $1, patch size $2 and blend size $3." -v -
-repeat $! -l[$>]
w2={round(w/2)} h2={round(h/2)}
w4={round(w/4)} h4={round(h/4)}
-if {!$4} -r {max(1,w-$1)},{max(1,h-$1)},1,100%,0,0,0.5,0.5 -endif
100%,100%,1,1,-1 -r[-2,-1] {w+$1},{h+$1},1,100%,0,0,0.5,0.5 -n. 0,1
-shift -$w2,-$h2,0,0,2
-inpaint_patchmatch.. [1],0,$2,10,$3
-rectangle. $1,$1,{w-1-$1},{h-1-$1}
-shift -$w4,-$h4,0,0,2
-inpaint_patchmatch.. [1],0,$2,10,$3
-rm.
-shift {$w4+$w2},{$h4+$h2},0,0,2
-endl -done -v +
#@gmic frame_x : size_x[%],_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@gmic : $ image.jpg -frame_x 20,255,0,255
frame_x : -skip ${2=255},${3=$2},${4=$3},${5=255}
-e[^-1] "Insert $1 outer frame in image$? along the x-axis, with color (${2--1})."
-_frame $1,0,0,${2--1}
#@gmic frame_xy : size_x[%],_size_y[%],_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'size_y=size_x', 'col1=col2=col3=255' and 'col4=255'.
#@gmic : (eq. to '-frame').
#@gmic : $ image.jpg -frame_xy 1,1,0 -frame_xy 20,10,255,0,255
frame_xy : -skip ${2=$1},${3=255},${4=$3},${5=$4},${6=255}
-v - _gmic_s="$?" -v +
-_$0 ${1--1}
_frame_xy :
-e[0--3] "Insert $1x$2 outer frame in image"$_gmic_s" along the xy-axes, with color (${3--1})."
-_frame $1,$2,0,${3--1}
#@gmic frame_xyz : size_x[%],_size_y[%],_size_z[%]_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'size_y=size_x=size_z', 'col1=col2=col3=255' and 'col4=255'.
frame_xyz : -skip ${2=$1},${3=$2},${4=255},${5=$4},${6=$5},${7=255}
-e[^-1] "Insert $1x$2x$3 outer frame in image$? along the xyz-axes, with color (${4--1})."
-_frame $1,$2,$3,${4--1}
#@gmic frame_y : size_y[%],_col1,...,_colN
#@gmic : Insert colored frame along the y-axis in selected images.
#@gmic : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@gmic : $ image.jpg -frame_y 20,255,0,255
frame_y : -skip ${2=255},${3=$2},${4=$3},${5=255}
-e[^-1] "Insert $1 outer frame in image$? along the y-axis, with color (${2--1})."
-_frame 0,$1,0,${2--1}
_frame :
-v - -repeat $! -l[$>]
nm={0,n}
w={round($1*if(${-is_percent\ $1},w,1))}
h={round($2*if(${-is_percent\ $2},h,1))}
d={round($3*if(${-is_percent\ $3},d,1))}
{w+2*$w},{h+2*$h},{d+2*$d},100% -fc[1] ${4--1}
-j[1] [0],$w,$h,$d -rm[0] -nm $nm
-endl -done -v +
#@gmic img2ascii : _charset,_analysis_scale>0,_analysis_smoothness[%]>=0,_synthesis_scale>0,_output_ascii_filename
#@gmic : Render selected images as binary ascii art.
#@gmic : This command returns the corresponding the list of widths and heights (expressed as a number of characters) for each selected image.
#@gmic : Default values: 'charset=[ascii charset]', 'analysis_scale=16', 'analysis_smoothness=20%', 'synthesis_scale=16' and '_output_ascii_filename=[undefined]'.
#@gmic : $ image.jpg --img2ascii , -r[0] [1],[1],1,3 --mul
img2ascii : -skip "${1= !\042#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~}","${5=}" -check "${2=16}>0 && ${3=20%}>=0 && ${4=16}>0"
-e[^-1] "Render image$? as binary ascii art, with charset '$1', analysis scale $2, analysis smoothness $3, synthesis scale $4 and output ascii filename '$5'."
-v -
is_multi={$!>1}
-l[]
({'"$1"'}) -repeat {w}
C={`92`}${-dec2oct\ {0,@$>}}
0 -t. $C,0,0,$2,1,1
0 -t. $C,0,0,$4,1,1
-done -rm[0]
-= -1 -= -1,0,100% -autocrop -= 0 -= 0,0,100%
-l[0--2:2] -r {${-max_w}+1},100%,1,1,0,0,0.5 -b $3 -n 0,255 -a z -endl
-l[1--1] -r {${-max_w}+1},100%,1,1,0,0,0.5 -a z -endl
-endl
w={-2,w} h={-2,h}
-repeat {$!-2} -l[$>,-2,-1]
-luminance[0] -n[0] 0,255
nw={0,round(w/$w,1,1)}
nh={0,round(h/$h,1,1)}
-if $> list_wh=$list_wh,$nw,$nh -else list_wh=$nw,$nh -endif
-s[0] y,-$h -s[0--3] x,-$w -r[0--3] $w,$h,1,1,0,0
-repeat {$!-2} -l[$>,-2,-1]
-rprogress {$>*100/($!-2)}
-r[0] [1] --[0] [1] -sqr[0] -r[0] 1,1,100%,1,2 -y[0]
C={0,ym} -rm[0]
--slices[1] $C -mv. 0
-if {narg("$5")} --f[0] $C -a[0,-1] c -endif
-endl -done
-append_tiles[0--2] $nw,$nh
-if {narg("$5")} -s[0] c -l[1]
-r $nw,$nh,1,1,1
({'"$1"'}) -map[0] [-1] -k[0]
-s y -i[1-$!] ({'\n'})
-a x
-if $is_multi filename=${-filename\ "$5",$>} -else filename="$5" -endif
-o raw:$filename,char -rm
-endl -endif
-endl -done
-rm[-2,-1] -u $list_wh -v +
#@gmic imagegrid : M>0,_N>0
#@gmic : Create MxN image grid from selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg -imagegrid 16
imagegrid : -skip ${2=$1}
-e[^-1] "Create $1x$2 image grid from image$?."
-v - -repeat $! -l[$>]
({w},{h}) ($1,$2) -/[-2,-1] -round. 1 -r.. {^},[-2],[-2],2 -rm.
({w},{h}) ($1,$2) -*[-2,-1] -r.. {^},[-2],[-2],2 -rm.
$1,$2,1,[-1],1 -shift. 1,1 -r. [-2],0,2 -*
-endl -done -v +
#@gmic imagegrid_hexagonal : _resolution>0,0<=_outline<=1
#@gmic : Create hexagonal grids from selected images.
#@gmic : Default values: 'resolution=32', 'outline=0.1' and 'is_antialiased=1'.
#@gmic : $ image.jpg -imagegrid_hexagonal 24
imagegrid_hexagonal : -check "isint(${1=32}) && $1>0 && ${2=0.1}>=0 && $2<=1"
-e[^-1] "Create hexagonal grid(s) from image$?, with resolution $1 and outline $2."
-v - -repeat $! -l[$>]
-l[]
({'CImg3d'},6,6)
(0;{2*pi}) --. {pi/2} -r. 1,7,1,1,3 --sin. -cos.. -a[-2,-1] x -rows. 0,5 -z. 0,2
2,6,1,1,3,0 1,100%,1,1,y --+. 1 -%. 6 -rv[-2,-1] -a[-3--1] x
3,100%,1,1,1 1,100%,1,1,1 -y -a y
-*3d. {1-$2}
--+3d {sqrt(3)} --+3d {sqrt(3)/2},1.5
-col3d... 2 -col3d.. 3 -col3d. 4 -+3d
-/3d 1.5
-endl
ny={1+round(0.5*$1,1,1)}
nx={0,1+round($1*w/h*3/(sqrt(3)*4),1,1)}
-array3d. $nx,$ny,1,{4*sqrt(3)/3},2
-c3d. -*3d. {0,h/$1}
[0],[0] -j3d. [-2],50%,50%,0,1,2,0,0 -rm..
-blend shapeaverage0
-endl -done -v +
#@gmic imagegrid_triangular : pattern_width>=1,_pattern_height>=1,_pattern_type,0<=_outline_opacity<=1,_outline_color1,...
#@gmic : Create triangular grids from selected images.
#@gmic : 'pattern type' can be { 0=horizontal | 1=vertical | 2=crossed | 3=cube | 4=decreasing | 5=increasing }.
#@gmic : Default values: 'pattern_width=24', 'pattern_height=pattern_width', 'pattern_type=0', 'outline_opacity=0.1' and 'outline_color1=0'.
#@gmic : $ image.jpg -imagegrid_triangular 6,10,3,0.5
imagegrid_triangular : -check "$1>=1 && ${2=$1}>=1 && isint(${3=0}) && $3>=0 && $3<=5" -skip ${4=0},${5=0}
-v - s0="horizontal" s1="vertical" s2="crossed" s3="cube" -v +
-e[^-1] "Create triangular grid(s) from image$?, with pattern width $1, height $2, pattern type '"${s$3}"', "\
"outline opacity $4 and outline color (${5--1})."
-v -
M={max($1,$2)}
-if {$3==4" || "$3==5}
$M,$M,1,1,x>y --+. 2 -a[-2,-1] x --+. 4 -a[-2,-1] y
$M,$M,1,1,"!x || !y || x==y" -r. 200%,200%,1,1,0,2
-a[-2,-1] c
-if {$3==5} -mirror. y -endif
-elif {$3==3}
$M,$M,1,1,x>y 100%,100%,1,1,w-1-x>=y -a[-2,-1] x --+. 2 -mirror. y -a[-2,-1] y
--+. 4 -=. 4,50%,50% -=.. 2 -a[-2,-1] x -label. 0,0
(2,2,2,0,1,2,1,1,3,3,3,1,1,0) -map.. [-1] -rm.
100%,100%,1,1
-line. 0,0,{$M-1},{$M-1},1,1 -line. {$M-1},$M,0,100%,1,1
-line. {$M-1},{$M-1},{3*$M-1},{$M-1},1,1 -line. {2*$M},0,0,0,1,1
-line. {2*$M},0,100%,100%,1,1 -line. {2*$M},100%,100%,0,1,1
-a[-2,-1] c
-elif {$3==2}
$M,$M,1,1,x>y --+. 2 -mirror. x -a[-2,-1] x --+. 4 -mirror. y -a[-2,-1] y
100%,100%,1,1,"!x || !y || x==int(w/2) || y==int(h/2) || x==y || w-1-x==y"
-a[-2,-1] c
-elif {$3==1}
$M,$M,1,1,x>y 100%,100%,1,1,w-1-x<=y -a[-2,-1] y --+. 2 -mirror. x -a[-2,-1] x
100%,100%,1,1,"!x || x==int(w/2) || x==y || w-1-x==y"
-a[-2,-1] c
-else
$M,$M,1,1,x>y 100%,100%,1,1,w-1-x>=y -a[-2,-1] x --+. 2 -mirror. y -a[-2,-1] y
100%,100%,1,1,"!y || y==int(h/2) || x==y || w-1-x==y"
-a[-2,-1] c
-endif
-repeat {$!-1}
wh={$>,w},{$>,h}
-if {$1>$2} -r[$>] 100%,{$>,$1*h/$2} -elif {$1<$2} -r[$>] {$>,$2*w/$1} -endif
--r. [$>],[$>],1,2,0,2,0.5,0.5
-s. c
-blend[$>,-2] shapeaverage
--fc[$>] ${5--1} -j[$>] [-1],0,0,0,0,$4,[-2] -rm[-2,-1]
-r[$>] $wh,1,100%,2
-done
-rm.
-v +
#@gmic linearize_tiles : M>0,_N>0
#@gmic : Linearize MxN tiles on selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg --linearize_tiles 16
linearize_tiles : -check "$1>0 && ${2=$1}>0"
-e[^-1] "Linearize $1x$2 tiles on image$?."
-v - -repeat $! -l[$>] nm={0,n}
s={s} -split_tiles $1,$2 -s c
-repeat $! -l[$>]
wh={w},{h}
--f x --f. y --f. 1 -y -a[^0] x -solve.. [-1] -rm.
$wh,1,1,{@0}"*x + "{@1}"*y + "{@2} -rm..
-endl -done
-repeat {int($!/$s)} -a[-$s--1] c -mv. 0 -done -append_tiles $1,$2
-nm $nm -endl -done -v +
#@gmic map_sprites : _nb_sprites>=1,_allow_rotation={ 0=none | 1=90 deg. | 2=180 deg. }
#@gmic : Map set of sprites (defined as the 'nb_sprites' latest images of the selection) to other selected images,
#@gmic : according to the luminosity of their pixel values.
#@gmic : $ image.jpg -r2dy 48 -repeat 16 -ball {8+2*$>},${-RGB} -*. {(1+$>)/16} -done -map_sprites 16
map_sprites : -check "isint($1) && $1>0 && isint(${2=0}) && $2>=0 && $2<=2"
-e[^-1] "Map set of $1 sprites to image selection$?."
-v - -norm[0--{$1+1}] -quantize[0--{$1+1}] $1,0,1
-slices[-$1--1] 0 -r[-$1--1] ${-max_wh[-$1--1]},1,100%,0,0,0.5,0.5
-if {$2==1}
N={4*$1}
-repeat {$!-$1} -*[$>] 4 --rand[$>] 0,3 -round. -+[$>,-1] -done
-repeat $1 -l[{1+$<}] --mirror xy --rotate 90 -endl -done
-elif {$2==2}
N={2*$1}
-repeat {$!-$1} -*[$>] 2 --rand[$>] 0,1 -round. -+[$>,-1] -done
-repeat $1 -l[{1+$<}] --mirror xy -endl -done
-else N=$1 -endif
-r[-$N--1] 100%,100%,1,${-max_s[-$N--1]} w={w} h={h} -a[-$N--1] x
-r[^-1] ${w}00%,${h}00%,1,1 -*[^-1] $w
(0,{$w-1};0,{$w-1}^0,0;{$h-1},{$h-1}) -r. $w,$h,1,2,3 -round.
-repeat {$!-2} --r. [$>],[$>],1,2,0,2 -r[$>] 100%,100%,1,2,0 -+[$>,-1] --warp.. [$>],0,0 -rv[$>,-1] -rm. -done -rm[-2,-1] -v +
#@gmic pack : is_ratio_constraint={ 0 | 1 },_sort_criterion
#@gmic : Pack selected images into a single image.
#@gmic : The returned status contains the list of new (x,y) offsets for each input image.
#@gmic : Parameter 'is_ratio_constraint' tells if the resulting image must tend to a square image.
#@gmic : Default values: 'is_ratio_constraint=0' and 'sort_criterion=max(w,h)'.
#@gmic : $ image.jpg -repeat 10 --resize2dx. 75% -balance_gamma. ${-RGB} -done -pack 0
pack : -skip ${1=0},${2=max(w,h)}
-e[^-1] "Pack image$? into a single image."
-if {$!<2} -return -endif
-if {${-max_d}>1} -error[0--3] "Command '-pack': Selected images contain at least one volumetric image (depth>1). Should all be 2d." -endif
-v -
nm={0,n} -to_colormode 0
-repeat $! nm$>={0,n} -nm[$>] $> -done
-sort_list -,"$2"
offsets{0,n}=0,0
N=$!
-i[0] 0
-do -l[0,1,2]
w1={1,w} h1={1,h} w2={2,w} h2={2,h}
slot=-1 min_slot_area=inf
-repeat {0,h}
x={0,i(0,$>)} y={0,i(1,$>)} w={0,i(2,$>)} h={0,i(3,$>)}
slot_area={$w*$h}
-if {$w>=$w2" && "$h>=$h2" && "$slot_area<=$min_slot_area}
slot=$> min_slot_area=$slot_area
-endif
-done
-if {$slot>=0}
x={0,i(0,$slot)} y={0,i(1,$slot)} w={0,i(2,$slot)} h={0,i(3,$slot)}
-j[1] [2],$x,$y offsets{2,n}=$x,$y
-l[0]
-s y -rm[$slot]
area1={max(($w-$w2)*$h,$w2*($h-$h2))}
area2={max(($w-$w2)*$h2,$w*($h-$h2))}
-if {$area1>=$area2}
-if {$w2<$w} -i[$slot] ({$x+$w2},$y,{$w-$w2},$h) -endif
-if {$h2<$h} -i[$slot] ($x,{$y+$h2},$w2,{$h-$h2}) -endif
-else
-if {$w2<$w} -i[$slot] ({$x+$w2},$y,{$w-$w2},$h2) -endif
-if {$h2<$h} -i[$slot] ($x,{$y+$h2},$w,{$h-$h2}) -endif
-endif
-a y -if {!$!} 0 -endif
-endl
-rm[2]
-else
-if $1
metric_h={abs($w1+$w2-max($h1,$h2))}
metric_v={abs($h1+$h2-max($w1,$w2))}
-else
metric_h={if($h2<$h1,$w2*($h1-$h2),$w1*($h2-$h1))}
metric_v={if($w2<$w1,($w1-$w2)*$h2,($w2-$w1)*$h1)}
-endif
-if {$metric_h<=$metric_v}
offsets{2,n}=$w1,0
-a[1,2] x,0
-if {$h2<$h1} ($w1,$h2,$w2,{$h1-$h2}) -a[0,-1] y
-elif {$h2>$h1} (0,$h1,$w1,{$h2-$h1}) -a[0,-1] y
-endif
-else
offsets{2,n}=0,$h1
-a[1,2] y,0
-if {$w2<$w1} ($w2,$h1,{$w1-$w2},$h2) -a[0,-1] y
-elif {$w2>$w1} ($w1,0,{$w2-$w1},$h1) -a[0,-1] y
-endif
-endif
-endif
-endl -while {$!>2}
-rm[0]
status=
-repeat $N -if {narg($status)} status=$status,${offsets$>} -else status=${offsets$>} -endif -done
-nm $nm -u $status
-v +
#@gmic puzzle : _width>0,_height>0,_M>=1,_N>=1,_curvature,_centering,_connectors_variability,_resolution>=1
#@gmic : Input puzzle binary mask with specified size and geometry.
#@gmic : Default values: 'width=height=512', 'M=N=5', 'curvature=0.5', 'centering=0.5', 'connectors_variability=0.5' and 'resolution=64'.
#@gmic : $ -puzzle ,
puzzle : -check "isint(${1=512}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=5}) && $3>0 && isint(${4=$3}) && $4>0 && isint(${8=64}) && $8>0"
-skip ${5=0.5},${6=0.5},${7=0.5}
-e[^-1] "Draw $3x$4 puzzle pattern on image$?, with curvature $5, centering $6, connectors variability $7 and resolution $8."
-v - -l[]
-if {$4>=2} -_puzzle[] $3,{$4-1},${5-8} -+3d. 0,1 -endif
-if {$3>=2} -_puzzle[] $4,{$3-1},${5-8} -r3d. 0,0,1,90 -+3d. 1,$4 -endif
-*3d {$1/$3},{$2/$4} -quadrangle3d 0,0,0,{$1-1},0,0,{$1-1},{$2-1},0,0,{$2-1},0 -p3d. 1 -+3d -col3d 1
$1,$2 -j3d. [-2],0,0,0,1,1,0,0 -rm..
-endl -v +
_puzzle :
R={$6*$1}
-repeat $2
({'CImg3d'},$R,{$R-1})
-repeat $1
sign={if(u<=0.5,-1,1)}
center={$4*u(-0.25,0.25)}
knob={$5*u(-0.05,0.12)}
($>,0;\
{0.2+$center+$>},{-$sign*$3*0.1};\
{0.4+$center+$>},0;\
{0.35+$center+$>},{0.1*$sign};\
{0.45+$center+$>},{(0.15+$knob)*$sign};\
{0.55+$center+$>},{(0.15+$knob)*$sign};\
{0.65+$center+$>},{0.1*$sign};\
{0.6+$center+$>},0;\
{0.8+$center+$>},{-$sign*$3*0.1})
-done
($1,0) -a[-{$1+1}--1] y -r. 2,$R,1,1,5 -z. 0,2
(2,0,1;2,{$R-2},{$R-1}) -r. 3,{$R-1},1,1,3 -round.
3,{h},1,1,255 1,{h},1,1,255 -y[-5--1] y -a[-5--1] y -+3d. 0,$>
-done -+3d
#@gmic quadratize_tiles : M>0,_N>0
#@gmic : Quadratize MxN tiles on selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg --quadratize_tiles 16
quadratize_tiles : -check "$1>0 && ${2=$1}>0"
-e[^-1] "Quadratize $1x$2 tiles on image$?."
-v - -repeat $! -l[$>] nm={0,n}
s={s} -split_tiles $1,$2 -s c
-repeat $! -l[$>]
wh={w},{h}
--f x^2 --f. y^2 --f. x*y --f. x --f. y --f. 1 -y -a[^0] x
-solve.. [-1] -rm.
$wh,1,1,{@0}"*x^2 + "{@1}"*y^2 + "{@2}"*x*y +"{@3}"*x + "{@4}"*y + "{@5} -rm..
-endl -done
-repeat {int($!/$s)} -a[-$s--1] c -mv. 0 -done -append_tiles $1,$2
-nm $nm -endl -done -v +
#@gmic rotate_tiles : angle,_M>0,N>0
#@gmic : Apply MxN tiled-rotation effect on selected images.
#@gmic : Default values: 'M=8' and 'N=M'.
#@gmic : $ image.jpg -to_rgba -rotate_tiles 10,8 -drop_shadow 10,10 -display_rgba
rotate_tiles : -skip ${2=8},${3=$2}
-e[^-1] "Apply $2x$3 tiled-rotation effect on image$?, with angle $1 deg."
-v - -split_tiles $2,$3,1 -rotate $1 -append_tiles $2,$3 -v +
#@gmic shift_tiles : M>0,_N>0,_amplitude
#@gmic : Apply MxN tiled-shift effect on selected images.
#@gmic : Default values: 'N=M' and 'amplitude=20'.
#@gmic : $ image.jpg --shift_tiles 8,8,10
shift_tiles : -check "${2=$1}>=0" -skip ${3=20}
-e[^-1] "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
-v - -repeat $! -l[$>]
$1,$2,1,2 -noise. $3 -r. [-2],[-2],1,2 -warp.. [-1],1,1,0 -rm.
-endl -done -v +
#@gmic taquin : M>0,_N>0,_remove_tile={ 0=none | 1=first | 2=last | 3=random },_relief,_border_thickness[%],_border_outline[%],_outline_color
#@gmic : Create MxN taquin puzzle from selected images.
#@gmic : Default value: 'N=M', 'relief=50', 'border_thickness=5', 'border_outline=0' and 'remove_tile=0'.
#@gmic : $ image.jpg --taquin 8
taquin : -check "isint($1) && $1>0 & isint(${2=$1}) && $2>0" -skip ${3=0},${4=50},${5=5%},${6=0},${7=0},${8=$7},${9=$8},${10=255}
-e[^-1] "Create $1x$2 taquin puzzle from image $?, with relief $4, border thickness $5, border outline $6 and outline color (${7--1})."
-v - -repeat $! -l[$>] nm={0,n}
-split_tiles $1,$2 -r ${-min_wh},100%,100%,0
100%,100%,1,1,1
-if ${"-is_percent $5"} -rectangle. {100*$5/2}%,{100*$5/2}%,{100-50*$5}%,{100-50*$5}%,1,0
-else -rectangle. $5,$5,{w-1-$5},{h-1-$5},1,0 -endif
-*. '1-2*(x/w<y/h)' -*. $4
-repeat {$!-1} -l[$>,-1] -split_opacity[0] -+[0] [-1] -a[^-1] c -endl -done -rm. -c 0,255
-frame $6,$6,${7-10}
-if {$3==3} -f. 0 -endif
-repeat $! -mv[$>] {u($!)} -done
-if {$3==1} -f[0] 0 -elif {$3==2} -f. 0 -endif
-append_tiles $1,$2
-nm $nm -endl -done -v +
#@gmic tunnel : _level>=0,_factor>0,_centering_x,_centering_y,_opacity,_angle
#@gmic : Apply tunnel effect on selected images.
#@gmic : Default values: 'level=9', 'factor=80%', 'centering_x=centering_y=0.5', 'opacity=1' and 'angle=0'
#@gmic : $ image.jpg --tunnel 20
tunnel : -check "${1=9}>=0 && ${2=80%}>0" -skip ${3=0.5},${4=0.5},${5=0.1},${6=0}
-e[^-1] "Apply tunnel effect on image$?, with depth $1, factor $2, centering ($3,$4), opacity $5 and angle $6."
-v - -repeat $! -l[$>]
-repeat $1 --r. $2,$2,1,100%,5
-if $6 100%,100%,1,1,1 -rotate[-2,-1] $6,1,0 -erode. 3 -j... [-2],{({-3,w}-w)*$3},{({-3,h}-h)*$4},0,0,$5,[-1] -rm[-2,-1]
-else -j.. [-1],{({-2,w}-w)*$3},{({-2,h}-h)*$4},0,0,$5 -rm. -endif
-done
-endl -done -c 0,255 -v +
#@gmic :: Artistic
#@gmic boxfitting : _min_box_size>=1,_max_box_size>=0,_initial_density>=0,_nb_attempts>=1
#@gmic : Apply box fitting effect on selected images, as displayed the web page:
#@gmic : [http://www.complexification.net/gallery/machines/boxFittingImg/]
#@gmic : Default values: 'min_box_size=1', 'max_box_size=0', 'initial_density=0.1' and 'nb_attempts=3'.
#@gmic : $ image.jpg --boxfitting ,
boxfitting : -check "isint(${1=3}) && $1>=1 && isint(${2=0}) && $2>=0 && ${3=0.1}>=0 && isint(${4=3}) && $4>=1"
-e[^-1] "Apply box fitting effect on image$?, with box sizes ($1,$2), density $3 and $4 attempts."
-v -
min_size=$1
max_size={if($2,$2,max(w,h))}
-repeat $! -l[$>]
nb_attempts=0 prec=5
100%,100%
-repeat 1e8
-if {$><1}
100%,100% -noise. {max(1e-3,$3)},2
-else
--distance. 1 --rand. 0,1 -*[-2,-1] -max_patch. {round($prec*$min_size)}
prec={max(1,$prec*0.9)}
-endif
-dilate. $min_size -area_fg. 0,1 -==. {($min_size)^2}
--dilate.. 3 -==. 0 -*[-2,-1] -area_fg. 0,1 -==. {($min_size)^2}
-if {!iM} nb_attempts+=1 -if {$nb_attempts>$4} -rm. -break -endif
-else nb_attempts=0 -endif
-+[-2,-1]
-repeat {int(($max_size-$min_size)/2)}
--dilate. 3 -area_fg. 0,1 -==. {($min_size+2*$>+2)^2}
-if {!iM} -rm. -break -endif
-|[-2,-1]
-done
-done
-blend shapeaverage0
-endl -done -v +
#@gmic brushify : [brush],_brush_nb_sizes>=1,0<=_brush_min_size_factor<=1,_brush_nb_orientations>=1,_brush_light_type,0<=_brush_light_strength<=1,_brush_opacity,_painting_density[%]>=0,0<=_painting_contours_coherence<=1,0<=_painting_orientation_coherence<=1,_painting_coherence_alpha[%]>=0,_painting_coherence_sigma[%]>=0,_painting_primary_angle,0<=_painting_angle_dispersion<=1
#@gmic : Apply specified brush to create painterly versions of specified images.
#@gmic : 'brush_light_type' can be { 0=none | 1=flat | 2=darken | 3=lighten | 4=full }.
#@gmic : Default values: 'brush_nb_sizes=3', 'brush_min_size_factor=0.66', 'brush_nb_orientations=12', 'brush_light_type=0', 'brush_light_strength=0.25', 'brush_opacity=0.8', 'painting_density=20%', 'painting_contours_coherence=0.9', 'painting_orientation_coherence=0.9', 'painting_coherence_alpha=1', 'painting_coherence_sigma=1', 'painting_primary_angle=0', 'painting_angle_dispersion=0.2'
#@gmic : $ image.jpg 40,40 -gaussian. 8,2 -spread. 4,0 --brushify[0] [1]
brushify : -check ${"-is_image_arg $1"}" &&"\
"isint(${2=4}) && $2>=1 &&"\
"${3=0.25}>=0 && $3<=1 &&"\
"isint(${4=12}) && $4>=1 &&"\
"isint(${5=4}) && $5>=0 &&"\
"${6=0.07}>=0 && $6<=1 &&"\
"isval(${7=0.75}) &&"\
"${8=40%}>=0 && $8>=0 &&"\
"${9=0.7}>=0 && $9<=1 &&"\
"${10=1}>=0 && $10<=1 &&"\
"${11=1}>=0 && ${12=0.5%}>=0 &&"\
"isval(${13=45}) &&"\
"${14=0.2}>=0 && $14<=1"
-e[^-1] "Brushify image$?, with brush $1."
-v -
-pass$1 0 -l.
-slices 0 -norm -n 0,1 -threshold 0.1,1 -autocrop.
-repeat $4 --rotate[0] {360*$>/$4} -done
-rm[0] -n 0,1 -threshold 0.1,1 -autocrop -r ${-max_wh},1,1,0,0,0.5,0.5
-a z -nm brush
wb={w} hb={h} whb={wh} ls={255*$6}
-if {$5==0} --f. 0
-elif {$5==1} --n. -$ls,0
-elif {$5==2} --g xy -+[-2,-1] -min. 0 -n. -$ls,0
-elif {$5==3} --g xy -+[-2,-1] -max. 0 -n. 0,$ls
-else --g xy -+[-2,-1] -n. -$ls,$ls
-endif
-nm. brushlight
-repeat {$2-1}
ratio={v=(1+$>)/max(1,$2-1);100*((1-v)+$3*v)}%
--r[brush,brushlight] $ratio,$ratio,100%,1,2
-r[-2,-1] [brush],0,0,0.5,0.5
-done
-a[^:2] z -a[^0] z
-endl
-repeat {$!-2} -l[$>,brush,brushlight]
s={0,s} nm={0,n} -to_rgb[0] -nm[0] img
--diffusiontensors[img] $9,$10,$11,$12 -nm. geometry
--channels[geometry] 0 -sh[geometry] 2 -+[-2,-1] -pow. 0.3 -quantize. $2,0 -*. -1 -+. $2 --. 1 -nm. contours
1,{img,max(1,${"-is_percent $8"}?wh*$8:$8)} -rand. 0,{img,w-1} --rand. 0,{img,h-1} -a[-2,-1] c -nm. pts
--to_rgba[img] -nm. res
-f[pts] "*
init(
S2 = round(0.5*["$wb","$hb"]);
brush_r = brush_g = brush_b = brush_a = vector"$whb"(255);
ang = $13*pi/180;
cu = [ cos(ang),sin(ang) ];
cv = [ -cu[1],cu[0] ];
T = mul(cu,cu,2) + $14*mul(cv,cv,2);
);
P = I;
G = I(#"$geometry",P);
ang = u(pi);
V = [ G[0],G[1],G[1],G[2] ]**(T**[ cos(ang),sin(ang) ]);
amp = i(#"$contours",P);
ang = round(((atan2(V[1],V[0])%(2*pi))*$4/(2*pi)))%$4;
col = I(#"$img",P);
ind = amp*$4 + ang;
brush = crop(#"$brush",0,0,ind,0,"$wb","$hb",1,1);
brushlight = crop(#"$brushlight",0,0,ind,0,"$wb","$hb",1,1);
brush_r = cut(col[0] + brushlight,0,255);
brush_g = cut(col[1] + brushlight,0,255);
brush_b = cut(col[2] + brushlight,0,255);
draw(#"$res",[brush_r,brush_g,brush_b,brush_a],P - S2,"$wb","$hb",1,4,$7,brush,1);
P"
-k[res,brush,brushlight] -mv[res] 0 -nm[0] $nm -to_colormode[0] {$s+($s%2)}
-endl -done -rm[brush,brushlight] -v +
#@gmic cartoon : _smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0
#@gmic : Apply cartoon effect on selected images.
#@gmic : Default values: 'smoothness=3', 'sharpening=150', 'threshold=20', 'thickness=0.25', 'color=1.5' and 'quantization=8'.
#@gmic : $ image.jpg --cartoon 3,80,15
cartoon : -skip ${1=3},${2=150},${3=20},${4=0.25},${5=1.5},${6=8}
-e[^-1] "Apply cartoon effect on image$?, with smoothness $1, sharpening $2, threshold $3, thickness $4, color $5 and quantization $6."
-v - -repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-b $1 -sharpen $2,1 -c 0,255 -n 0,255
--edges $3 -b. $4 ->=. 0.9
-rgb2lab.. -s.. c -*[-3,-2] $5 -a[-4--2] c -lab2rgb.. -quantize.. $6,1,0 -n.. 0,255 -*
-endl -a c -endl -done -v +
#@gmic color_ellipses : _count>0,_radius>=0,_opacity>=0
#@gmic : Add random color ellipses to selected images.
#@gmic : Default values: 'count=400', 'radius=5' and 'opacity=0.1'.
#@gmic : $ image.jpg --color_ellipses ,,0.15
color_ellipses : -skip ${1=1400},${2=5},${3=0.1}
-e[^-1] "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
-v - -repeat $1 -ellipse {u(0,100)}%,{u(0,100)}%,{u(0,$2)}%,{u(0,$2)}%,{u(0,360)},$3,{u(60,255)},{u(60,255)},{u(60,255)},255 -done -v +
#@gmic cubism : _density>=0,0<=_thickness<=50,_max_angle,_opacity,_smoothness>=0
#@gmic : Apply cubism effect on selected images.
#@gmic : Default values: 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'.
#@gmic : $ image.jpg --cubism ,
cubism : -check "${1=50}>=0 && ${2=10}>=0 && $2<=50 && ${5=0}>=0" -skip ${3=75},${4=0.7}
-e[^-1] "Apply cubism effect on image$?, with density $1, thickness $2, maximum angle $3 deg., opacity $4 and smoothness $5."
-if {"!$1 || !$2 || !$3 || !$4"} -return -endif
-v - -repeat $! -l[$>]
w={w} h={h} s={s}
P={round($2*max(w,h)/200)}
N={round(1.5*$1*w*h/(4*$P)/100)}
({'CImg3d'}) -+. 0.5 ({4*$N};$N)
1,$N -rand. $P,{$w-1-$P} --rand. $P,{$h-1-$P} -a[-2,-1] x -round.
--+. '-$P,-$P' --+.. '$P,-$P' --+... '$P,$P' --+[-4] '-$P,$P'
-a[-4--1] x -i.. (12,0,1,2,3;12,{4*($N-1)},{4*($N-1)+1},{4*($N-1)+2},{4*($N-1)+3})
-r.. 5,$N,1,1,3 -round.. 1 -a[-2,-1] x
1,$N -rand. {225-$3},{225+$3} -*. {pi/180}
--sin. -cos.. --*. -1 [-3] -a[-4--3] x -a[-2,-1] x -z[-4,-2,-1] 0,2 --*[-2,-1] -1 -a[-4--1] x -*. {sqrt(2)*$P}
-r... 400%,100%,1,1,0,2 -+[-3,-1]
(-128;$w;$h;$s) --b[0] $5
-if {$N>1} 4,{$N-1},1,1,-128,0,0,0 -endif
1,$N,1,1,1
-y[1--1] -a[1--1] y -rv3d.
-if {$4>=1} -j3d[0] [1],0,0,0,1,2,0,0 -rm[1]
-else --j3d[0] [1],0,0,0,1,2,0,0 -rm[1] -blend alpha,$4
-endif
-endl -done -v +
#@gmic draw_whirl : _amplitude>=0
#@gmic : Apply whirl drawing effect on selected images.
#@gmic : Default value: 'amplitude=100'.
#@gmic : $ image.jpg --draw_whirl ,
draw_whirl : -skip ${1=100}
-e[^-1] "Apply whirl drawing effect on image$? with amplitude $1."
-v - -repeat $! -l[$>]
100%,100% -noise. 70,2 -*. 255 -r. [-2] -&[-1,-2] -smooth. $1,0,1,2,2
-sqrt. -n. 0,255 -equalize.
-endl -done -v +
#@gmic drawing : _amplitude>=0
#@gmic : Apply drawing effect on selected images.
#@gmic : Default value: 'amplitude=200'.
#@gmic : $ image.jpg --drawing ,
drawing : -skip ${1=200}
-e[^-1] "Apply drawing effect on image$? with amplitude $1."
-v - -repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-smooth $1,0.2,1,3,3 -b 2 -sharpen 1000 [0]
-r[0] 20,20,1,3,2 -equalize[0] -index[1] [0],1,1
-nm[1] {0,n},1 -rm[0]
-endl -a c -endl -done -v +
#@gmic drop_shadow : _offset_x[%],_offset_y[%],_smoothness[%]>=0,0<=_curvature<=1,_expand_size={ 0 | 1 }
#@gmic : Drop shadow behind selected images.
#@gmic : Default values: 'offset_x=20', 'offset_y=offset_x', 'smoothness=5', 'curvature=0' and 'expand_size=1'.
#@gmic : $ image.jpg -drop_shadow 10,20,5,0.5 -expand_xy 20,0 -display_rgba
drop_shadow : -check "${3=5}>=0 && ${4=0}>=0 && $4<=1" -skip ${1=20},${2=$1},${5=1}
-e[^-1] "Drop shadow behind image$?, with offsets ($1,$2), smoothness $3 and curvature $4."
-v - -to_a -repeat $! -l[$>]
nm={0,n}
dx={if(${-is_percent\ $1},w*$1,$1)}
dy={if(${-is_percent\ $2},h*$2,$2)}
sigma={if(${-is_percent\ $3},max(w,h)*$3,$3)}
w={w} h={h} s={s} --channels 100% coords=${-autocrop_coords.\ 0} -rm. -z $coords
-r {w+abs($dx)},{h+abs($dy)},1,100%,0,0,{if($dx>0,0,1)},{if($dy>0,0,1)} -r. {w+4*$sigma},{h+4*$sigma},1,100%,0,0,0.5,0.5
--channels. 100%
-if {!$4} -shift. $dx,$dy
-else
(0;{pi}) -r. [-2],3 -sin. -*. -$4 -+. 1 -*. $dx
(0,{pi}) -r. [-2],3 -sin. -*. -$4 -+. 1 -*. $dy
-a[-2,-1] c -warp.. [-1],1,0,0 -rm.
-endif
-b. $sigma,0
-r. 100%,100%,1,2,0,0,0,0,0,1 -mv. 0 -blend alpha
--channels. 100% ->=. 1 -* -autocrop 0
-if {!$5} $w,$h,1,$s -j. [-2],{arg(1,$coords)},{arg(2,$coords)} -rm.. -endif
-nm $nm
-endl -done -v +
#@gmic ellipsionism : _R>0[%],_r>0[%],_smoothness>=0[%],_opacity,_outline>0,_density>0
#@gmic : Apply ellipsionism filter to selected images.
#@gmic : Default values: 'R=10', 'r=3', 'smoothness=1%', 'opacity=0.7', 'outlise=8' and 'density=0.6'.
#@gmic : $ image.jpg --ellipsionism ,
ellipsionism : -check "${1=10}>0 && ${2=3}>0 && ${5=8}>0 && ${6=0.6}>0" -skip ${3=1%},${4=0.7}
-e[^-1] "Apply ellipsionism filter to image$?, with radii ($1,$2), smoothness $3, opacity $4 and outline $5."
-v - -to_rgba -repeat $! -l[$>]
--luminance -g. xy -a[-2,-1] c -b. $3 -orientation.
-sh. 0 -sh.. 1 -atan2. [-2] -*. {180/pi} -+. 90 -rm[-2,-1] -channels. 1,1
[-2],[-2],1,[-2]
-repeat {$6*w*h/max($1,$2)}
xy={u(w)},{u(h)}
-ellipse. $xy,$1,$2,{-2,i($xy)},$4,\
{-3,i($xy,0,0)},{-3,i($xy,0,1)},{-3,i($xy,0,2)},{-3,i($xy,0,3)}
-ellipse. $xy,$1,$2,{-2,i($xy)},$4,0x1,\
{-3,i($xy,0,0)/$5},{-3,i($xy,0,1)/$5},{-3,i($xy,0,2)/$5},{-3,i($xy,0,3)/$5}
-done -rm..
-n. [-2] -blend alpha
-endl -done -v +
#@gmic fire_edges : _edges>=0,0<=_attenuation<=1,_smoothness>=0,_threshold>=0,_nb_frames>0,_starting_frame>=0,frame_skip>=0
#@gmic : Generate fire effect from edges of selected images.
#@gmic : Default values: 'edges=0.7', 'attenuation=0.25', 'smoothness=0.5', 'threshold=25', 'nb_frames=1', 'starting_frame=20' and 'frame_skip=0'.
#@gmic : $ image.jpg -fire_edges ,
fire_edges : -check "${1=0.7}>=0 && ${2=0.25}>=0 && $2<=1 && ${3=0.5}>=0 && ${4=25}>=0 && ${5=1}>0 && ${6=20}>=0 && ${7=0}>=0"
-e[^-1] "Generate fire effect from edges of image$?, with edges $1, attenuation $2, smoothness $3, threshold $4, "\
"$5 frames, starting frame $6 and frame skip $7."
-v - -repeat $! -l[$>] nm={0,n}
-norm --gradient_norm -n. 0,1 -roundify. $1 -f[0] 0
(0,0,0;0,0,0;1,1,1;0,1,0) -*. {(1-$2^4)/4}
-repeat {$5*(1+$7)+$6}
{0,w},{0,h} -rand. 0,255 -*. [1]
-b. $3
-if $4 ->=. $4% -else -equalize. -endif
-n. 0,255
-j[0] [-1],0,0,0,0,1,[1],1 -rm.
-correlate[0] [2]
-if {$>>=$6" && "($>-$6)%($7+1)==0} [0] -endif
-done -rm[0-2]
-nm $nm -endl -done
(0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) -r. 256,1,1,3,3
-map[^-1] [-1] -rm. -v +
#@gmic fractalize : 0<=detail_level<=1
#@gmic : Randomly fractalize selected images.
#@gmic : Default value: 'detail_level=0.8'
#@gmic : $ image.jpg --fractalize ,
fractalize : -check "${1=0.8}>=0 && $1<=1"
-e[^-1] "Randomly fractalize image$?, with detail level $1."
-v -
xc=0.4433
yc=0.2645
delta=0.1
c0r=0.317
c0i=0.03
-repeat $! -l[$>] nm={0,n}
-luminance -equalize 256 -b 0.25% -n 0,255
100%,100%
dx={$delta*w/max(w,h)}
dy={$delta*h/max(w,h)}
x0={$xc-$dx/2}
y0={$yc-$dy/2}
x1={$xc+$dx/2}
y1={$yc+$dy/2}
-mandelbrot. $x0,$y0,$x1,$y1,256,1,$c0r,$c0i
--==. 0 -inpaint.. [-1] -rm.
-n. 0,256
16,1,1,3 -rand. 0,255 -r. 256,1,1,3,3 -map.. [-1] -rm.
-s. c
-i[2,3] [0]
s={0.1*(1-$1)}
-parallel "-register_nonrigid[1] [0],"$s",5","-register_nonrigid[3] [2],"$s",5","-register_nonrigid[5] [4],"$s",5"
-rm[0,2,4] -a c -nm $nm
-endl -done -v +
#@gmic glow : _amplitude>=0
#@gmic : Add soft glow on selected images.
#@gmic : Default value: 'amplitude=1%'.
#@gmic : $ image.jpg --glow ,
glow : -skip ${1=1%}
-e[^-1] "Add soft glow on image$?, with amplitude $1."
-v - -repeat $! -l[$>] -split_opacity --b[0] $1 -n. [0] -blend_edges[0,-1] 1 -a c -endl -done -v +
#@gmic halftone : nb_levels>=2,_size_dark>=2,_size_bright>=2,_shape={ 0=square | 1=diamond | 2=circle | 3=inv-square | 4=inv-diamond | 5=inv-circle },_smoothness[%]>=0
#@gmic : Apply halftone dithering to selected images.
#@gmic : Default values: 'nb_levels=5', 'size_dark=8', 'size_bright=8', 'shape=5' and 'smoothnesss=0'.
#@gmic : $ image.jpg --halftone ,
halftone : -check "${1=5}>=2 && ${2=8}>=2 && ${3=8}>=2 && ${5=0}>=0" -skip ${4=5}
-v - s0="square" s1="diamond" s2="circle" s3="inv-square" s4="inv-diamond" s5="inv-circle" -v +
-e[^-1] "Apply halftone dithering to image$?, with $1 levels, dark size $3, bright size $4, "${s$4}" shape and smoothness $5."
-v - -repeat $! -l[$>] -s c -repeat $! -l[$>]
(0,255) -a y -quantize $1,0 -rows 0,{h-2}
-repeat $1
s={round(($2*$<+$3*$>)/($1-1))}
$s,$s -=. 1,50%,50% -distance. 1,{$4%3} --shift. {round(w/2)},{round(h/2)},0,0,2 -min[-2,-1]
-if {$4>=3} -<. {100*$</($1-1.1)}% -*. {-255} -+. {255-$>}
-else -<. {100*$>/($1-1.1)}% -*. 255 --. $>
-endif
-r. [-2],0,2 -b. $5 --==.. $> -*[-2,-1] -+[-2,-1]
-done -endl -done -a c
-endl -done -v +
#@gmic hardsketchbw : _amplitude>=0,_density>=0,_opacity,0<=_edge_threshold<=100,_is_fast={ 0 | 1 }
#@gmic : Apply hard B&W sketch effect on selected images.
#@gmic : Default values: 'amplitude=1000', 'sampling=3', 'opacity=0.1', 'edge_threshold=20' and 'is_fast=0'.
#@gmic : $ image.jpg --hardsketchbw 200,70,0.1,10 -median. 2 --local -reverse -blur. 3 -blend[-2,-1] overlay -endlocal
hardsketchbw : -skip ${1=300},${2=50},${3=0.1},${4=20},${5=0}
-e[^-1] "Apply hard B&W sketch effect on image$?, with amplitude $1, density $2, opacity $3 and edge threshold $4."
-if {!$2} -channels 0 -f 255 -return -endif
-v - -luminance -n 0,1
-if $5
-repeat $! -l[$>] nm={0,n}
-g xy -rv -*.. -1 -a c
-if $4 --norm ->=. $4% -* -endif
100%,100%,1,1,255 -quiver. [-2],{max(1,10-$2/6)},$1,0,$3 -rm..
-nm $nm -endl -done
-else
-repeat $! -l[$>] nm={0,n}
w={w} h={h} -g xy -rv -*.. -1 -a c -* $1
--norm ->=. $4% 100%,100% -noise. $2,2 -*[-2,-1]
-pointcloud3d. -s3d. -rm[-6--5,-3--1] -r. 3,{h/3},1,1,-1 -s. x -rm. -a[-2,-1] c
-warp.. [-1],0,0 ---. [-2] -+[-3,-2] -s[-2,-1] c
-i... 1,{h} 1,{h} -a[-6--1] x
-i.. ({'CImg3d'}) -i.. ({2*h},{h})
1,{h},1,1,2 1,{h},1,1,2*y --+. 1 -a[-3--1] x
3,{h} 1,{h},1,1,$3 -y[-6--1] -a[-6--1] y
$w,$h,1,1,255 -j3d. [-2],0,0,0,1,1,0,0 -rm..
-nm $nm -endl -done
-endif -v +
#@gmic hearts : _density>=0
#@gmic : Apply heart effect on selected images.
#@gmic : Default value: 'density=10'.
#@gmic : $ image.jpg --hearts ,
hearts : -skip ${1=10}
-e[^-1] "Apply heart filter on image$?, with density $1."
-v - -repeat $! -l[$>]
100%,100%,1 -noise. $1,2 -r. [-2] -n. 0,1 -*[-1,-2] -_heart9x7
-mirror. y -dilate.. [-1] -rm.
-endl -done -v +
_heart9x7 :
(0,1,1,0,0,0,1,1,0;1,1,1,1,0,1,1,1,1;1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,0,0;0,0,0,1,1,1,0,0,0;0,0,0,0,1,0,0,0,0)
#@gmic houghsketchbw : _density>=0,_radius>0,0<=_threshold<=100,0<=_opacity<=1,_votesize[%]>0
#@gmic : Apply hough B&W sketch effect on selected images.
#@gmic : Default values: 'density=8', 'radius=5', 'threshold=80', 'opacity=0.1' and 'votesize=100%'.
#@gmic : $ image.jpg --houghsketchbw ,
houghsketchbw : -check "${1=8}>=0 && ${2=5}>=0 && ${3=80}>=0 && $3<=100 && ${4=0.1}>=0 && $4<=1 && ${5=100%}>0"
-e[^-1] "Apply hough B&W sketch effect on image$?, with density $1, radius $2, threshold $3, opacity $4 and votesize $5."
-v - -luminance -repeat $! -l[$>] nm={0,n}
res={round(if(${-is_percent\ $5},$5*max(w,h),$5))} w={w} h={h} rhomax={sqrt(w^2+h^2)/2}
-hough $res,$res -n 0,255
-normalize_local. $1,$2 ->=. $3% -pointcloud3d.
-s3d. -rm[-6--5,-3--1] -r. 3,{h/3},1,1,-1 -columns. 0,1
-s. x,2
-*.. {2*pi/$res}
-*. {$rhomax/$res}
--cos.. -*. [-2] -+. {$w/2}
--sin... -*. [-3] -+. {$h/2}
-rm...
-i... [-3]
-cos[-4] -sin... -*[-4,-3] 10000
--+.. [-3]
---.. [-5]
--[-4] [-5]
-+... [-6]
-rm[-6,-5]
-i... 1,{h} 1,{h} -a[-6--1] x
-i.. ({'CImg3d'}) -i.. ({2*h},{h})
1,{h},1,1,2 1,{h},1,1,2*y --+. 1 -a[-3--1] x
3,{h},1,1,0 1,{h},1,1,$4
-y[-6--1] -a[-6--1] y
$w,$h,1,1,255 -j3d. [-2],0,0,0,1,1,0,0 -rm..
-nm $nm -endl -done -v +
#@gmic lightrays : 100<=_density<=0,_center_x[%],_center_y[%],_ray_length>=0,_ray_attenuation>=0
#@gmic : Generate ray lights from the edges of selected images.
#@gmic : Defaults values : 'density=50%', 'center_x=50%', 'center_y=50%', 'ray_length=0.9' and 'ray_attenuation=0.5'.
#@gmic : $ image.jpg --lightrays , -+ -c 0,255
lightrays : -check "${1=50}>=0 && $1<=100 && ${4=1}>=0 && ${5=1}>=0" -skip ${2=50%},${3=50%}
-e[^-1] "Generate ray lights from image$?, with density $1, center point ($2,$3), ray length $4 and attenuation $5."
-v - -repeat $! -l[$>]
-gradient_norm -* -1 -< $1% -euclidean2polar $2,$3
-repeat {log2(w)} --shift. {2^$>} -+[-2,-1] -done
-function1d 0.5,0,1,{$4*w},1,{1+($4+1-$5)*w},0 -r. {-2,w},1,1,1,0
(1,{w}) -r. {-2,w},1,1,1,3 -/[-2,-1]
-r. [-2] -*[-2,-1] -polar2euclidean $2,$3 -n 0,255
-endl -done -v +
#@gmic light_relief : _ambient_light,_specular_lightness,_specular_size,_light_smoothness,_darkness,_xl,_yl,_zl,_zscale,_opacity_is_heightmap={ 0 | 1 }
#@gmic : Apply relief light to selected images.
#@gmic : Default values(s) : 'ambient_light=0.3', 'specular_lightness=0.5', 'specular_size=0.2', 'darkness=0', 'xl=0.2', 'yl=zl=0.5',
#@gmic : 'zscale=1', 'opacity=1' and 'opacity_is_heightmap=0'.
#@gmic : $ image.jpg --blur 2 -light_relief. 0.3,4,0.1,0
light_relief : -skip ${1=0.3},${2=0.5},${3=0.2},${4=0},${5=0.2},${6=0.5},${7=0.5},${8=1},${9=1},${10=0}
-e[^-1] "Apply relief light to image$?."
-v - -repeat $! -l[$>]
({-$6},{1-$6};{-$6},{1-$6}^{-$7},{-$7};{1-$7},{1-$7}^$8,$8;$8,$8) -r. [-2],[-2],1,3,3
-if $10 --channels.. 3 -to_rgb... -else --to_rgb.. -norm. -endif
-b. $5% -g. xy 100%,100%,1,1,$9  -a[-3--1] c
-orientation[-2,-1] -*[-2,-1] -s. c -+[-3--1]
100%,100% -=. 1,{$6*100}%,{$7*100}% -distance. 1 -sqr. -*. -1
-/. {($3*max(w,h))^2} -exp. -*. $2 -+. $1
-*[-2,-1] --. $4 -*. {-2,iM}
-split_opacity[0] -+[0,-1] -a c -c 0,255
-endl -done -v +
#@gmic mosaic : _density>=0
#@gmic : Create random mosaic from selected images.
#@gmic : Default values: 'density=0.8'.
#@gmic : $ image.jpg --mosaic ,
mosaic : -skip ${1=0.8}
-e[^-1] "Apply mosaic effect on image$?, with density $1."
-v - -repeat $! -l[$>]
label0={1+im} -+ $label0
100%,100% -noise. {$1*2},2 -*.. [-1] -distance. 1 -*. -1 -watershed.. [-1] -rm.
-endl -done -v +
#@gmic old_photo
#@gmic : Apply old photo effect on selected images.
#@gmic : $ image.jpg --old_photo
old_photo :
-e[^-1] "Apply old photo effect on image$?."
-v - -noise 20 -bilateral 30,60 -b 2 -sharpen 100 -frame_fuzzy 8%,8%,6,3 -to_rgb -shadow_patch 0.75 -n 0,255 -sepia -v +
#@gmic pencilbw : _size>=0,_amplitude>=0
#@gmic : Apply B&W pencil effect on selected images.
#@gmic : Default values: 'size=0.3' and 'amplitude=60'.
#@gmic : $ image.jpg --pencilbw ,
pencilbw : -skip ${1=0.3},${2=60}
-e[^-1] "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
-v - -repeat $! -l[$>] -split_opacity -l[0] -norm -b $1 -sharpen 4000 -smooth $2,0,1 -equalize -sqrt -n 0,255 -endl -a c -endl -done -v +
#@gmic pixelsort : _ordering={ + | - },_axis={ x | y | z | xy | yx },_[sorting_criterion],_[mask]
#@gmic : Apply a 'pixel sorting' algorithm on selected images, as described in the page :
#@gmic : http://satyarth.me/articles/pixel-sorting/
#@gmic : $ image.jpg --norm --ge. 30% --pixelsort[0] +,y,[1],[2]
pixelsort : -check "(str1='${1=+}'; str1=='+' || str1=='-') && "\
"(str2='${2=x}'; str2=='x' || str2=='y' || str2=='z' || str2=='xy' || str2=='yx') && "\
"('${3=}'==0 || "${"-is_image_arg $3"}") && "\
"('${4=}'==0 || "${"-is_image_arg $4"}")"
-v - s0="descending" s1="ascending" -v +
-if {'$3'!=0" && "'$4'!=0}
-e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with sorting criterion $3 and mask $4."
-elif {'$3'!=0" && "'$4'==0}
-e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with sorting criterion $3."
-elif {'$3'==0" && "'$4'!=0}
-e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2, with mask $4."
-else
-e[^-1] "Apply 'pixelsort' effect to image$? in "${s{['$1']=='+'}}" order, along axis $2."
-endif
-v - -repeat $!
-if {'$3'!=0} -pass$3 0 -else --compose_channels[$>] + -endif
-if {'$4'!=0} -pass$4 0 -else [$>],[$>],[$>],1,1 -endif
-l[$>,-2,-1]
nm={0,n} -ge. 50% -mv.. 0 -a c
order={`";'$1'=='+'?'<':'>'"`}
-if {'$2'=='x';}
-_pixelsort $order -channels 1,{s-2}
-elif {'$2'=='y';}
-permute yxzc -_pixelsort $order -channels 1,{s-2} -permute yxzc
-elif {'$2'=='z';}
-permute zxyc -_pixelsort $order -channels 1,{s-2} -permute yzxc
-elif {'$2'=='xy';}
-_pixelsort $order -permute yxzc -_pixelsort $order -channels 1,{s-2} -permute yxzc
-elif {'$2'=='yx';}
-permute yxzc -_pixelsort $order -permute yxzc -_pixelsort $order -channels 1,{s-2}
-endif
-nm $nm
-endl
-done -v +
_pixelsort :
1,{h},{d}
-f. ":
quicksort(x0,x1,y,z) = (
stack = vector"{0,2*w}"();
stacksize = 0;
push(elt0,elt1) = (stack[stacksize++] = elt0; stack[stacksize++] = elt1);
pop() = (_s1 = stack[--stacksize]; _s0 = stack[--stacksize]; [_s0,_s1]);
push(x0,x1);
whiledo (stacksize>0,
range = pop();
lo = range[0];
hi = range[1];
pivot = i(#0,int((lo + hi)/2),y,z,0);
whiledo (lo<=hi,
whiledo (i(#0,lo,y,z,0)$1pivot, ++lo);
whiledo (pivot$1i(#0,hi,y,z,0), --hi);
if (lo<=hi, tmp = I(#0,lo,y,z); I(#0,lo++,y,z) = I(#0,hi,y,z); I(#0,hi--,y,z) = tmp);
);
if (range[0]<hi,push(range[0],hi));
if (lo<range[1],push(lo,range[1]));
)
);
s1 = s#0 - 1;
for (x0 = 0, x0<w#0, ++x0,
if (i(#0,x0,y,z,s1),
for (x1 = x0, x1<w#0 && i(#0,x1,y,z,s1)==1, ++x1);
quicksort(x0,min(x1,w#0-1),y,z);
x0 = ++x1;
)
)"
-rm.
#@gmic polaroid : _size1>=0,_size2>=0
#@gmic : Create polaroid effect in selected images.
#@gmic : Default values: 'size1=10' and 'size2=20'.
#@gmic : $ image.jpg -to_rgba -polaroid 5,30 -rotate 20 -drop_shadow , -display_rgba
polaroid : -check "${1=10}>=0 && ${2=20}>=0"
-e[^-1] "Create polaroid effect in image$?, with borders sizes $1 and $2."
-v - -- 255 -r {100+$1}%,{100+$1}%,1,100%,0,0,0.5,0.5 -r 100%,{100+$2}%,1,100%,0,0,0 -+ 255 -v +
#@gmic polygonize : _warp_amplitude>=0,_smoothness[%]>=0,_min_area[%]>=0,_resolution_x[%]>0,_resolution_y[%]>0
#@gmic : Apply polygon effect on selected images.
#@gmic : Default values: 'warp_amplitude=300', 'smoothness=2%', 'min_area=0.1%', 'resolution_x=resolution_y=10%'.
#@gmic : $ image.jpg --polygonize ,
polygonize : -check "${1=300}>=0 && ${2=2%}>=0 && ${3=0.1%}>=0 && ${4=10%}>0 && ${5=$4}>0"
-e[^-1] "Polygonize image$? with warp amplitude $1, smoothness $2, minimal area $3 and resolutions ($4,$5)."
-v -  -repeat $! -l[$>]
--b $2 -gradient_norm. -g. -a[-2,-1] c -channels. 0,2 -*. {1/0.1+max(abs(im),abs(iM))}
resx={max(1,round(if(${-is_percent\ $4},w*$4,w/$4)-1))}
resy={max(1,round(if(${-is_percent\ $5},h*$5,h/$5)-1))}
-plane3d 1,1,$resx,$resy -*3d. {0,w-1},{0,h-1},1
-s3d. -rm.. -i.. (0;{h-1}) -r.. 3,{h},1,1,3 -round.. -y..
[-4] -a[-7--2] y -r. 3,{h/3},1,1,-1 -z. 0,1 -permute. yzcx
-repeat $1 --warp[1] [-1],0,0 -+[-2,-1] -done
-permute. cxyz -z. 0,2 -y. -j[2] [-1],0,8 -rm[-3,-1]
[0],[0] -j3d. [1],0,0,0,1,2 -rm[1]
-if {$3>0}
min_area={0,if(${-is_percent\ $3},$3*w*h,$3)}
--area. 0,1 ->=. $min_area -+.. 1 -*.. [-1] -distance. 1 -*. -1 -watershed.. [-1] -rm.
-endif
-blend shapeaverage
-endl -done -v +
#@gmic poster_edges : 0<=_edge_threshold<=100,0<=_edge_shade<=100,_edge_thickness>=0,_edge_antialiasing>=0,0<=_posterization_level<=15,_posterization_antialiasing>=0
#@gmic : Apply poster edges effect on selected images.
#@gmic : Default values: 'edge_threshold=40', 'edge_shade=5', 'edge_thickness=0.5', 'edge_antialiasing=10', 'posterization_level=12' and 'posterization_antialiasing=0'.
#@gmic : $ image.jpg --poster_edges ,
poster_edges : -check "${1=40}>=0 && $1<=100 && ${2=5}>=0 && $2<=100 && ${3=0.5}>=0 && ${4=10}>=0 && ${5=12}>=0 && $5<=15 && ${6=0}>=0"
-e[^-1] "Apply poster edge on image$?, with edge threshold $1, edge shade $2, edge thickness $3, edge antialiasing $4, $5 level of posterization and posterization antialiasing $6."
-v - -repeat $! -l[$>] -split_opacity -l[0]
--g xy,1 -a[-2,-1] c -norm. -b. $3 -n. 0,255
-apply_curve. 1,0,1,{max(0,(100-($1%)^0.1*100)*255%)},0.99,{min(255,(101-($1%)^0.1*100+$2)*255%)},0.01,255,0 -c. 0,1
-if $4 -smooth. {min(50,$4)},0,1,{$4/40},{$4/40},0.8,90 -endif
-if $5 -autoindex[0] {round((4-sqrt($5+1))*32+2)} -endif
-if $6 -smooth[0] {min(50,$6)},0,1,{$6/40},{$6/40},0.8,90 -endif
-*
-endl -a c -endl -done -v +
#@gmic poster_hope : _smoothness>=0
#@gmic : Apply Hope stencil poster effect on selected images.
#@gmic : Default value: 'smoothness=3'.
#@gmic : $ image.jpg --poster_hope ,
poster_hope : -check "${1=3}>=0"
-e[^-1] "Apply Hope stencil poster effect on image$?, with smoothness $1."
-v - -repeat $! -l[$>] -to_rgb
-apc "-smooth 200,0,1,$1,1"
-quantize 7,0 -f 'if(i!=5,i,i+1-2*(y%2))'
(0,32,47;0,32,47;209,1,23;209,1,23;90,141,145;-1,-1,-1;253,221,138) -permute. yzcx
-map[0] [1] -rm[1]
-endl -done -v +
#@gmic rodilius : 0<=_amplitude<=100,_0<=thickness<=100,_sharpness>=0,_nb_orientations>0,_offset,_color_mode={ 0=darker | 1=brighter }
#@gmic : Apply rodilius (fractalius-like) filter on selected images.
#@gmic : Default values: 'amplitude=10', 'thickness=10', 'sharpness=400', 'nb_orientations=7', 'offset=0' and 'color_mode=1'.
#@gmic : $ image.jpg --rodilius 12,10,300,10 -normalize_local. 10,6
rodilius : -check "${1=10}>=0 && $1<=200 && ${2=10}>=0 && $2<=100 && ${3=400}>=0 && ${4=7}>0" -skip ${5=0},${6=1}
-e[^-1] "Apply rodilius filter on image$? with amplitude $1, thickness $2, sharpness $3, $4 orientations, offset $5 and "\
${-arg\ 1+!$6,brighter,darker}" color mode."
-v - -repeat $! -l[$>] -split_opacity -rv
-if {!$6} -negative. -endif
--f. 0 -nm. {-2,n}
-repeat {round($4)}
angle={$5+$>*180/round($4)}
--blur_linear.. $1%,{$1*$2/100}%,$angle,1 -b. 0.7 -sharpen. $3 -max[-2,-1]
-done -rm..
-if {!$6} -negative. -endif
-rv -a c -endl -done -v +
#@gmic stained_glass : _edges[%]>=0, shading>=0, is_thin_separators={ 0 | 1 }
#@gmic : Generate stained glass from selected images.
#@gmic : Default values: 'edges=40%', 'shading=0.2' and 'is_precise=0'.
#@gmic : $ image.jpg --stained_glass ,
stained_glass : -check "${1=40%}>=0 && ${2=0.2}>=0" -skip ${3=0}
-e[^-1] "Apply stained glass effect on image$?, with edges $1, shading $2 and thin-separators "${-arg\ 1+!$3,enabled,disabled}"."
-v - -repeat $! -l[$>]
im={im-1} -- $im
--gradient_norm ->=. $1 -*.. [-1]
-distance. 1 -sharpen. 1e10 -!=. 0
-if $3 -skeleton. 0 -endif
-distance. 1 -watershed.. [-1] -+.. $im
-n. 0,1  -^. $2 -*
-endl -done -v +
#@gmic stars : _density[%]>=0,_depth>=0,_size>0,_nb_branches>=1,0<=_thickness<=1,_smoothness[%]>=0,_R,_G,_B,_opacity
#@gmic : Add random stars to selected images.
#@gmic : Default values: 'density=10%', 'depth=1', 'size=32', 'nb_branches=5', 'thickness=0.38', 'smoothness=0.5', 'R=G=B=200' and 'opacity=1'.
#@gmic : $ image.jpg -stars ,
stars : -check "${1=10%}>=0 && ${2=1}>=0 && ${3=32}>0 && ${4=5}>=1 && ${5=0.38}>=0 && $5<=1 && ${6=0.5}>=0" -skip ${7=200},${8=$7},${9=$8},${10=1}
-e[^-1] "Add $1 random stars to image$?, with depth $2, size $3, $4 branches, thickness $5, smoothness $6, color ($7,$8,$9) and opacity $10."
-if {!$1} -return -endif
-v -
-star3d $4,$5 -col3d. 255 -*3d. $3
-l. -repeat 4 {round(2*$3)},{round(2*$3)} -j3d. [0],50%,50%,0,1,2,0,0 -r3d[0] 0,0,1,90 -done -rm[0] -endl
-autocrop[-4--1] 0 -r2dy[-4--1] $3 -b[-4--1] $6,0 -r[-4--1] 100%,100%,1,4
-repeat 4 -sh[{-1-$>}] 0,2 -fc. $7,$8,$9 -rm. -done
-repeat {$!-1} [-4--1] -l[$>,-4--1]
N={round(if(${-is_percent\ $1},w*h*$1,$1)/4,1,1)}
-repeat 4
2,$N -rand. -1,1 1,$N -rand. 0,1 -a[-2,-1] x
-i.. ({'CImg3d'}) -+.. 0.5 -i.. ($N;$N)
(1,0;1,{$N-1}) -r. 2,$N,1,1,3 -round. 4,$N,1,1,1 -y[-5,-3--1] -a[-5--1] y
-rv[-2,-1] -sprites3d.. [-1],1 -rm. -*3d. {0.75*{0,w}},{0.75*{0,h}},{1000*$2}
-j3d[0] [-1],50%,50%,0,$10,0,0,0 -rm.
-done
-endl -done
-rm[-4--1] -v +
#@gmic sketchbw : _nb_orients>0,_start_angle,_angle_range>=0,_length>=0,_threshold>=0,_opacity,_bgfactor>=0,_density>0,_sharpness>=0,_anisotropy>=0,_smoothness>=0,_coherence>=0,_is_boost={ 0 | 1 },_is_curved={ 0 | 1 }
#@gmic : Apply sketch effect to selected images.
#@gmic : Default values: 'nb_orients=2', 'start_angle=45', 'angle_range=180', 'length=30', 'threshold=1', 'opacity=0.03',
#@gmic : 'bgfactor=0', 'density=0.6', 'sharpness=0.1', 'anisotropy=0.6', 'smoothness=0.25', 'coherence=1', 'is_boost=0' and 'is_curved=1'.
#@gmic : $ image.jpg --sketchbw 1 --local -reverse -blur. 3 -blend[-2,-1] overlay -endlocal
sketchbw :
-check "${1=2}>0 && ${3=180}>=0 && ${4=30}>=0 && ${5=1}>=0 && ${7=0}>=0 && ${8=0.6}>0 && ${9=0.1}>=0 && ${10=0.6}>=0 && ${11=0.25}>=0 && ${12=1}>=0"
-skip ${2=45},${6=0.03},${13=0},${14=1}
-e[^-1] "Apply B&W sketch effect on image$?."
-v - -diffusiontensors $9,$10,$11,$12
-m3d 0
-repeat $! -l[$>]
-/. {max(iM,im)} -s. c
100%,100%,1,1,255 -nm. {-4,n}
{$8*w*h/($1*sqrt($4))}
--rand. 0,{{-2,h}-1} -rand.. 0,{{-3,w}-1} -a[-2,-1] y -mv. 0
-if {0,w>=$_cpus} -s[0] x,$_cpus -endif
com=-skip -repeat {$!-4} com=$com,"-_sketchbw$14[] ${1--1},"$> -done
-repeat $1
alpha={($2+$>*$3/$1)*pi/180}
--*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
--*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
-a[-2,-1] c
-if $13 -orientation. -endif
-if $14 -channels. 0,2 -endif
-parallel $com
-rm.
-done
-k.
-endl -done -v +
_sketchbw1 :
-pass[^]
-repeat {$-1,w}
xy={$-1,i($>,0)},{$-1,i($>,1)}
-if {{-5,i($xy)}+{-3,i($xy)}<$5} opac=$6 -else opac={$7*$6} -endif
-if $opac
--streamline3d. $xy,0,$4,0.8,0,0,1 -col3d. 0 -j3d... [-1],0,0,0,$opac,1,0,0 -rm.
--streamline3d. $xy,0,$4,0.8,0,1,1 -col3d. 0 -j3d... [-1],0,0,0,$opac,1,0,0 -rm.
-endif
-done
-rm
_sketchbw0 :
-pass[^]
-repeat {$-1,w}
x={$-1,i($>,0)} y={$-1,i($>,1)}
-if {{-5,i($x,$y)}+{-3,i($x,$y)}<$5} opac=$6 -else opac={$7*$6} -endif
-if $opac
-line.. {$x-$4*i($x,$y,0,0)},{$y-$4*i($x,$y,0,1)},\
{$x+$4*i($x,$y,0,0)},{$y+$4*i($x,$y,0,1)},\
{3*$opac},0
-endif
-done
-rm
#@gmic sponge : _size>0
#@gmic : Apply sponge effect on selected images.
#@gmic : Default value: 'size=13'.
#@gmic : $ image.jpg --sponge ,
sponge : -skip ${1=13}
-e[^-1] "Apply sponge filter on image$?, with brush size $1."
-v - -repeat $! -l[$>]
100%,100%,1,1 -noise. 20,2 -r. [-2] -n. 0,1 -*[-1,-2]
-_circle $1 -dilate.. [-1] -rm.
-endl -done -v +
_circle :
-if {$1%2==0} -i 2,2 -else -i 1 -endif
-+. 1 -r. $1,$1,1,1,0,0,0.5,0.5 -distance. 1 -n. 0,1 -sqrt. -c. 0.85,0.86 -*. -1 -n. 0,1
#@gmic stencil : _radius[%]>=0,_smoothness>=0,_iterations>=0
#@gmic : Apply stencil filter on selected images.
#@gmic : Default values: 'radius=3', 'smoothness=1' and 'iterations=8'.
#@gmic : $ image.jpg --stencil 1,10,3
stencil : -check "${1=3}>=0 && ${2=1}>=0 && ${3=8}>=0"
-e[^-1] "Apply stencil filter on image$?, with radius $1, smoothness $2 and $3 iterations."
-v - -n 0,1 -repeat $3 -b $1 -unsharp {$1+$2},1000 -c 0,255 -done -v +
#@gmic stencilbw : _edges>=0,_smoothness>=0
#@gmic : Apply B&W stencil effect on selected images.
#@gmic : Default values: 'edges=15' and 'smoothness=10'.
#@gmic : $ image.jpg --stencilbw 40,4
stencilbw : -skip ${1=15},${2=10}
-e[^-1] "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
-v - -repeat $! -l[$>] -split_opacity -luminance[0] -n[0] 0,255
--edges[0] $1 -quantize[0] 3,0,1 -b[0] $2
-sharpen[0] 1000000 -n[0] 0,1 -*[0,-1] -n[0] 0,255
-a c -endl -done -v +
#@gmic tetris : _scale>0
#@gmic : Apply tetris effect on selected images.
#@gmic : Default value: 'scale=10'.
#@gmic : $ image.jpg --tetris 10
tetris : -skip ${1=10}
-e[^-1] "Apply tetris effect on image$?, with scale $1."
-v - -repeat $! -l[$>]
wh={w},{h},1,{s} -r $1%,$1%,$1%,100%,2 -n 0,255 -quantize 10,1,0 -r $wh -b 2 -sharpen 300,1
-endl -done -v +
#@gmic warhol : _M>0,_N>0,_smoothness>=0,_color>=0
#@gmic : Create MxN Andy Warhol-like artwork from selected images.
#@gmic : Default values: 'M=3', 'N=M', 'smoothness=2' and 'color=20'.
#@gmic : $ image.jpg --warhol 5,3,3,40
warhol : -skip ${1=3},${2=$1},${3=2},${4=20}
-e[^-1] "Create $1x$2 Andy Warhol-like artwork from image$?."
-v - r0={100/max($1,$2)}
-repeat $! -l[$>]
-norm -b $3 -r $r0%,$r0%,1,100%,2 -quantize 6 -n 0,5 -round 1
-repeat $1 -repeat $2
(0,1,2,3,4,5) -n. 32,224 6,1,1,2,128 -noise. $4,0 -c. 0,255 -a[-2,-1] c -ycbcr2rgb. --map[0] [-1] -rm..
-done -done -append_tiles[^0] $1,$2 -nm[1] {0,n} -rm[0]
-endl -done -v +
#@gmic weave : _density>=0,0<=_thickness<=100,0<=_shadow<=100,_shading>=0,_fibers_amplitude>=0,_fibers_smoothness>=0,_angle,-1<=_x_curvature<=1,-1<=_y_curvature<=1
#@gmic : Apply weave effect to the selected images.
#@gmic : 'angle' can be { 0=0 deg. | 1=22.5 deg. | 2=45 deg. | 3=67.5 deg. }.
#@gmic : Default values: 'density=6', 'thickness=65', 'shadow=40', 'shading=0.5', 'fibers_amplitude=0', 'fibers_smoothness=0', 'angle=0' and 'curvature_x=curvature_y=0'
#@gmic : $ image.jpg --weave ,
weave : -check "${1=6}>=0 && ${2=65}>=0 && $2<=100 && ${3=40}>=0 && $3<=100 && ${4=0.5}>=0"
-check "${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && $7<=3 && ${8=0}>=-1 && $8<=1 && ${9=0}>=-1 && $9<=1"
-e[^-1] "Apply weave effect to image$?, with $1 strips, thickness $2, shadow $3, shading $4, "\
"fibers amplitude $5 and fibers smoothness $6, angle "{$7*22.5}" deg. and curvatures ($8,$9)."
-v - -repeat $! -l[$>] -split_opacity -l[0]
w={round(max(w,h)/$1,1,1)} h=$w s={(100-$3)*255%} p={max(0.01,$4)}
1,$h -=. 1,0,50% -distance. 1 -^. $p -c. 50%,100% -r. {max(1,round($2*$w%))},100%
$w,1 -=. 1,50% -distance. 1 -^. $p -c. 50%,100% -*. -1 -r. 100%,{max(1,round($2*$h%))}
--*. -1 --*... -1 -n[-4,-2] 0,$s -n[-3,-1] $s,255
{w},1 1,[-3] -rand[-2,-1] 0,1 -b[-2,-1] $6% -n[-2,-1] -$5,$5 -r. [-4] -+[-5] [-1] -+[-4,-1] -+[-5] [-1] -+[-2,-1]
--f... 255 -a[-4,-1] c --f. 255 -a[-2,-1] c
amp_x={$8*($w-w)/2} amp_y={$9*($w-w)/2}
-r[-4--1] $w,$h,1,100%,0,0,0.5,0.5
-f[-4] 'i(x+$amp_x*sin(y/h*pi),y,0,c,1,2)' -f. 'i(x-$amp_x*sin(y/h*pi),y,0,c,1,2)'
-f... 'i(x,y+$amp_y*sin(x/w*pi),0,c,1,2)' -f.. 'i(x,y-$amp_y*sin(x/w*pi),0,c,1,2)'
-blend[-4,-3] alpha -blend[-2,-1] alpha -c[-2,-1] 0,255
-/[-2,-1] 255 [-1] [-3] -a[-4,-2] x -a[-2,-1] x -a[-2,-1] y -rotate_tileable. {$7*22.5} -r. [-2],[-2],1,1,0,2 -*[-2,-1]
-endl -a c -endl -done -v +
#@gmic whirls : _texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0
#@gmic : Add random whirl texture to selected images.
#@gmic : Default values: 'texture=3', 'smoothness=6', 'darkness=0.5' and 'lightness=1.8'.
#@gmic : $ image.jpg --whirls ,
whirls : -skip ${1=3},${2=6},${3=0.5},${4=1.8}
-e[^-1] "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
-v - -repeat $! -l[$>]
100%,100% -noise. 0.3,2 -repeat $1 -b. $2 -gradient_norm. -^. 0.2 -done
-n. $3,$4 -r. [-2] -* -c 0,255
-endl -done -v +
#@gmic :: Warpings
#@gmic deform : _amplitude>=0
#@gmic : Apply random smooth deformation on selected images.
#@gmic : Default value: 'amplitude=10'.
#@gmic : $ image.jpg --deform[0] 10 --deform[0] 20
deform : -skip ${1=10}
-e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
-v - -repeat $! -l[$>]
2%,2%,1,2 -noise. $1 -r. [-2],[-2],1,2,5 -warp.. [-1],1,1,1 -rm.
-endl -done -v +
#@gmic euclidean2polar : _center_x[%],_center_y[%],_stretch_factor>0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply euclidean to polar transform on selected images.
#@gmic : Default values: 'center_x=center_y=50%', 'stretch_factor=1' and 'boundary=1'.
#@gmic : $ image.jpg --euclidean2polar ,
euclidean2polar : -skip ${1=50%},${2=50%} -check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=2"
-e[^-1] "Apply euclidean to polar transform on image$?, with center point ($1,$2), stretch factor $3 and "${-arg\ 1+$4,dirichlet,neumann,periodic}" boundary conditions."
-v - -repeat $! -l[$>]
cx={if(${-is_percent\ $1},$1*(w-1),$1)}
cy={if(${-is_percent\ $2},$2*(h-1),$2)}
R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
-f 'r=$R*(x/(w-1))^$3;a=y*2*pi/(h-1);i($cx+r*cos(a),$cy+r*sin(a),z,c,1,$4)'
-endl -done -v +
#@gmic equirectangular2nadirzenith
#@gmic : Transform selected equirectangular images to nadir/zenith rectilinear projections.
equirectangular2nadirzenith :
-e[^-1] "Transform equirectangular image$? to nadir/zenith rectilinear projections."
-v - -repeat $! -l[$>]
100%,100%,1,2
-sh. 100%
-f. "
X = 2*x/(w-1) - 1;
Y = y/(h-1) - 0.5;
if (X<0,
sinphi1 = 1; X+=0.5,
sinphi1 = -1; X-=0.5
);
rr = sqrt(X*X + Y*Y);
cc = atan(2*rr);
phi = rr==0?0:asin(cos(cc)*sinphi1);
X = atan2(X,-Y*sinphi1)/pi;
Y = phi/pi;
(++X)*=0.5*w;
(Y+=0.5)*=h;
i(#-2) = X; Y;"
-warp[0] [1],0,0,1 -k...
-endl -done -v +
#@gmic fisheye : _center_x,_center_y,0<=_radius<=100,_amplitude>=0
#@gmic : Apply fish-eye deformation on selected images.
#@gmic : Default values: 'x=y=50', 'radius=50' and 'amplitude=1.2'.
#@gmic : $ image.jpg --fisheye ,
fisheye : -skip ${1=50},${2=50},${3=50},${4=1.2}
-e[^-1] "Apply Fish-eye effect on image$?, centered at ($1%,$2%) with radius $3% and amplitude $4."
-if {$4==0} -return -endif
-v - -repeat $! -l[$>]
100%,100%,1,1 -=. 1,$1%,$2% -distance. 1 -c. 0,$3% -*. -1 -n. 0,1 -^. {1/$4}
-i.. ({-$1/100},{1-$1/100};{-$1/100},{1-$1/100}^{-$2/100},{-$2/100};{1-$2/100},{1-$2/100}) -r.. [-1],[-1],1,2,3
-n. 0,{max(w,h)} -*[-2,-1]
-warp.. [-1],1,1,1 -rm.
-endl -done -v +
#@gmic flower : _amplitude,_frequency,_offset_r[%],_angle,_center_x[%],_center_y[%],_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply flower deformation on selected images.
#@gmic : Default values: 'amplitude=30', 'frequency=6', 'offset_r=0', 'angle=0', 'center_x=center_y=50%' and 'boundary=2'.
#@gmic : $ image.jpg -flower ,
flower : -skip ${1=30},${2=6},${3=0},${4=0},${5=50%},${6=50%},${7=2}
-e[^-1] "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 deg. and center point ($1,$2)."
-v - -if ${-is_percent\ $3}
-transform_polar "r + (R*$3) + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
-else
-transform_polar "r + $3 + R*$1/100*cos(a*$2+$4*pi/180)","a",$5,$6,$7
-endif -v +
#@gmic kaleidoscope : _center_x[%],_center_y[%],_radius,_angle,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Create kaleidoscope effect from selected images.
#@gmic : Default values: 'center_x=center_y=50%', 'radius=100', 'angle=30' and 'boundary=1'.
#@gmic : $ image.jpg --kaleidoscope ,
kaleidoscope : -skip ${1=50%},${2=50%},${3=100},${4=30},${5=1}
-e[^-1] "Create kaleidoscope effect from image$?, with center point ($1,$2), radius $3, angle $4 deg."
-v - -euclidean2polar $1,$2,1,$5 -repeat $! -l[$>]
--columns 0,$3% -rows. 0,$4% -r. [-2],0,2 -nm[1] {0,n} -rm[0]
-endl -done -polar2euclidean $1,$2,1,$5 -v +
#@gmic map_sphere : _width>0,_height>0,_radius,_dilation>0,_fading>=0,_fading_power>=0
#@gmic : Map selected images on a sphere.
#@gmic : Default values: 'width=height=512', 'radius=100', 'dilation=0.5', 'fading=0' and 'fading_power=0.5'.
#@gmic : $ image.jpg --map_sphere ,
map_sphere : -check "${1=512}>0 && ${2=512}>0 && ${5=0}>=0 && ${6=0.5}>=0" -skip ${3=100},${4=0.5}
-e[^-1] "Map image$? on spheres in $1x$2 images, with radius $3, dilation $4 and fading $5."
-v - r2={($3*min($1,$2)/200)^2}
-repeat $! -l[$>]
-i.. 100%,1,1,100%,0 -nm[0] {1,n} -a y
({-$1/2},{$1/2}) ({-$2/2};{$2/2}) -r[-2,-1] $1,$2,1,1,3 -atan2. [-2] -rm..
$1,$2 -=. 1,50%,50% -distance. 1,3 -/. $r2 -sqrt. -c. 0,1
-asin.
-+.. {pi} -*.. {({-3,w}-1)/(2*pi)}
-*. {2/pi} -^. $4 -*. {{-3,h}-1} -*. -1 -+. {{-3,h}-1}
-if $5 -->=. 1 -distance. 1 -c. 0,$5% -n. 0,1 -^. $6 -c.. 1,100% --[-2,-1] -endif
-r[-1,-2] 100%,100%,{-3,d}
--f. z -a[-3--1] c
-warp.. [-1],0,1,1 -rm.
-endl -done -v +
#@gmic nadirzenith2equirectangular
#@gmic : Transform selected nadir/zenith rectilinear projections to equirectangular images.
nadirzenith2equirectangular :
-e[^-1] "Transform nadir/zenith rectilinear projection$? to equirectangular images."
-v - -repeat $! -l[$>]
100%,100%,1,2
-sh. 100%
-f. "
X = 2*x/(w-1) - 1;
Y = y/(h-1) - 0.5;
output = 1;
if (Y>0.125,
sinphi1 = 1; xc = -0.5,
if (Y<-0.125,
sinphi1 = -1; xc = 0.5,
output = 0
));
cosc = sinphi1*sin(Y*pi);
xx = cos(Y*pi)*sin(X*pi)/cosc;
yy = -sinphi1*cos(Y*pi)*cos(X*pi)/cosc;
if (abs(xx)>1, output=0);
(xx*=0.5)+=xc;
yy*=0.5;
if (!output, xx = yy = -1);
(++xx)*=0.5*w;
(yy+=0.5)*=h;
i(#-2) = xx; yy;"
-to_a[0] -warp[0] [1],0,0,0 -k...
-endl -done -v +
#@gmic polar2euclidean : _center_x[%],_center_y[%],_stretch_factor>0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply euclidean to polar transform on selected images.
#@gmic : Default values: 'center_x=center_y=50%', 'stretch_factor=1' and 'boundary=1'.
#@gmic : $ image.jpg --euclidean2polar ,
polar2euclidean : -skip ${1=50%},${2=50%} -check "${3=1}>0 && isint(${4=1}) && $4>=0 && $4<=2"
-e[^-1] "Apply polar to euclidean transform on image$?, with center point ($1,$2), stretch factor $3 and "${-arg\ 1+$4,dirichlet,neumann,periodic}" boundary conditions."
-v - -repeat $! -l[$>]
cx={if(${-is_percent\ $1},$1*(w-1),$1)}
cy={if(${-is_percent\ $2},$2*(h-1),$2)}
R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
-f 'X=sqrt((x-$cx)^2+(y-$cy)^2);tmp=atan2((y-$cy),(x-$cx));Y=if(tmp<0,tmp+2*pi,tmp);i((X/$R)^(1/$3)*(w-1),Y*(h-1)/(2*pi),z,c,1,$4)'
-endl -done -v +
#@gmic raindrops : _amplitude,_density>=0,_wavelength>=0,_merging_steps>=0
#@gmic : Apply raindrops deformation on selected images.
#@gmic : Default values: 'amplitude=80','density=0.1', 'wavelength=1' and 'merging_steps=0'.
#@gmic : $ image.jpg --raindrops ,
raindrops : -check "${2=0.1}>=0 && ${3=1}>=0 && isint(${4=0}) && $4>=0" -skip ${1=80}
-e[^-1] "Apply raindrops deformation on image$?, with amplitude $1, density $2, wavelength $3 and $4 merging steps."
-v - -repeat $! -l[$>]
100%,100% -noise. $2,2 -distance. 1 -f. 'cos(i)/(1+i/(1e-8+$3))'
-if $4
-i.. (0,1,0;1,0,1;0,1,0) -/.. 2 [-1]
-repeat $4 --convolve. [-3],1 --. [-3] -rm... -done -rm[-3,-2]
-endif
-g. -a[-2,-1] c -*. {$1/(1e-5+max(abs(im),abs(iM)))}
-warp.. [-1],1 -rm.
-endl -done -v +
#@gmic ripple : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@gmic : Apply ripple deformation on selected images.
#@gmic : Default values: 'amplitude=10', 'bandwidth=10', 'shape=2', 'angle=0' and 'offset=0'.
#@gmic : $ image.jpg --ripple ,
ripple : -skip ${1=10},${2=20},${3=2},${4=0},${5=0}
-e[^-1] "Apply ripple deformation on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
-v -
theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
-repeat $! -l[$>]
100%,100%,1,1,"x" --. {w/2} 100%,100%,1,1,'y'
--. {h/2-$5} -*.. $S -*. $C -+[-2,-1]
-_ripple$3. $1,$2
--*. {-$S} -*.. $C -a[-2,-1] c
-warp.. [-1],1 -rm.
-endl -done -v +
_ripple0 : -f {$1/2}*"(1-2*(i%"{2*$2}"<$2))"
_ripple1 : -f "I=(i%$2)/$2;$1*(2*if(I<0.5,I,1-I)-0.5)"
_ripple2 : -f {-$1/2}*"cos(i*"{2*pi/$2}")"
_ripple3 : -f {-$1/2}*"abs(cos(i*"{2*pi/$2}"))"
_ripple4 : -skip $* -n 0,{h-1} 1,{h} -rand. {-$1/2},{$1/2} m={im} M={iM} -b. {$2/10} -n. $m,$M -map.. [-1] -rm.
#@gmic rotoidoscope : _center_x[%],_center_y[%],_tiles>0,_smoothness[%]>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Create rotational kaleidoscope effect from selected images.
#@gmic : Default values: 'cx=cy=50%', 'tiles=10', 'smoothness=1' and 'boundary=1'.
#@gmic : $ image.jpg --rotoidoscope ,
rotoidoscope : -skip ${1=50%},${2=50%},${5=1} -check "${3=10}>0 && ${4=1}>=0"
-e[^-1] "Create rotational kaleidoscope effect from image$?, with center point ($1,$2), $3 tiles and smoothness $4."
-v - -repeat $! -l[$>]
-repeat $3 --rotate[0] {360/$3},1,$5,$1,$2 -blend_edges $4 -done
-endl -done -v +
#@gmic symmetrize : _x[%],_y[%],_angle,_boundary={ 0=dirichlet | 1=neumann | 2=periodic },_is_antisymmetry={ 0 | 1 },_swap_sides={ 0 | 1 }
#@gmic : Symmetrize selected image regarding specified axis.
#@gmic : Default values: 'x=y=50%', 'angle=90', 'boundary=1', 'is_antisymmetry=0' and 'swap_sides=0'.
#@gmic : $ image.jpg --symmetrize 50%,50%,45 --symmetrize. 50%,50%,-45
symmetrize : -skip ${1=50%},${2=50%},${3=90},${4=1},${5=0},${6=0}
-e[^-1] "Symmetrize image$?, regarding axis ($1,$2,$3 deg.)."
-v -
theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
-if $6 symmetry_cond=A<0 -else symmetry_cond=A>0 -endif
-repeat $! -l[$>]
x0={if(${-is_percent\ $1},w*$1,$1)}
y0={if(${-is_percent\ $2},h*$2,$2)}
-if $5 -f 'A=($y0-y)*$u-($x0-x)*$v;X=x+2*($x0-x);Y=y+2*($y0-y);if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
-else -f 'A=($y0-y)*$u-($x0-x)*$v;X=x-2*$v*A;Y=y+2*$u*A;if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
-endif
-endl -done
-v +
#@gmic transform_polar : "expr_radius",_"expr_angle",_center_x[%],_center_y[%],_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Apply user-defined transform on polar representation of selected images.
#@gmic : Default values: 'expr_radius=R-r', 'expr_rangle=a', 'center_x=center_y=50%' and 'boundary=1'.
#@gmic : $ image.jpg --transform_polar[0] R*(r/R)^2,a --transform_polar[0] r,2*a
transform_polar : -skip "${1=R-r}","${2=a}",${3=50%},${4=50%},${5=1}
-e[^-1] "Apply custom polar transform with 'new_r = $1', 'new_a = $2', center point ($3%,$4%)."
-v - -repeat $! -l[$>]
cx={if(${-is_percent\ $3},$3*(w-1),$3)}
cy={if(${-is_percent\ $4},$4*(h-1),$4)}
R={sqrt(max($cx^2,(w-1-$cx)^2)+max($cy^2,(h-1-$cy)^2))}
-f "R ="$R";
r = sqrt((x-"$cx")^2 + (y-"$cy")^2);
a = atan2(y-"$cy",x-"$cx");
nr = $1;
na = $2;
i("$cx" + nr*cos(na), "$cy" + nr*sin(na), z, c,1,$5)"
-endl -done -v +
#@gmic twirl : _amplitude,_center_x[%],_center_y[%],_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply twirl deformation on selected images.
#@gmic : Default values: 'amplitude=1', 'center_x=center_y=50%' and 'boundary=1'.
#@gmic : $ image.jpg --twirl 0.6
twirl : -skip ${1=1},${2=50%},${3=50%},${4=1}
-e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center point at ($2%,$3%)."
-v - -euclidean2polar $2,$3,1,$4 -repeat $!
[$>],[$>],1,1,$1*x -channels. -1,0 -warp[$>] [-1],1,1,2 -rm.
-done -polar2euclidean $2,$3,1,1 -v +
#@gmic warp_perspective : _x-angle,_y-angle,_zoom>0,_x-center,_y-center,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Warp selected images with perspective deformation.
#@gmic : Default values: 'x-angle=1.5', 'y-angle=0', 'zoom=1', 'x-center=y-center=50' and 'boundary=2'.
#@gmic : $ image.jpg --warp_perspective ,
warp_perspective : -skip ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
-e[^-1] "Apply perspective warp on image$?, with angles ($1 deg.,$2 deg.), zoom $3 and offsets ($4,$5)."
-v - -repeat $! -l[$>]
(0,100) --. $4 -/. 100 (0;100) --. $5 -/. 100 -r[-2,-1] [-3],[-3],[-3],1,3
--*.. $2 --*.. $1 -+[-2,-1] -+. $3 -/... [-1] -/[-2,-1]
-*.. 100 -+.. $4 -/.. 100 -*.. {-3,w}
-*. 100 -+. $5 -/. 100 -*. {-3,h}
-a[-2,-1] c -warp.. [-1],0,1,$6 -rm.
-endl -done -v +
#@gmic water : _amplitude>=0,_smoothness>=0
#@gmic : Apply water deformation on selected images.
#@gmic : Default values: 'amplitude=30' and 'smoothness=1.5'.
#@gmic : $ image.jpg --water ,
water : -skip ${1=30},${2=1.5}
-e[^-1] "Apply water deformation on image$?, with amplitude $1 and smoothness $2."
-v - -repeat $! -l[$>]
25%,25%,25%,1 -noise. $1 -g. xyz -+[-1,-2,-3] -b. $2 -*. 2 -r. [-2],[-2],1,2,3 -warp.. [-1],1 -rm.
-endl -done -v +
#@gmic wave : _amplitude>=0,_frequency>=0,_center_x,_center_y
#@gmic : Apply wave deformation on selected images.
#@gmic : Default values: 'amplitude=4', 'frequency=0.4' and 'center_x=center_y=50'.
#@gmic : $ image.jpg --wave ,
wave : -skip ${1=4},${2=0.4},${3=50},${4=50}
-e[^-1] "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center point at ($3%,$4%)."
-v - -repeat $! -l[$>]
100%,100% -=. 1,$3%,$4% -distance. 1
-*. $2 --sin. -cos.. -a[-2,-1] c -*. $1
-warp.. [-1],1 -rm.
-endl -done -v +
#@gmic wind : _amplitude>=0,_angle,0<=_attenuation<=1,_threshold
#@gmic : Apply wind effect on selected images.
#@gmic : Default values: 'amplitude=20', 'angle=0', 'attenuation=0.7' and 'threshold=20'.
#@gmic : $ image.jpg --wind ,
wind : -check "isint(${1=20}) && $1>=0 && ${3=0.7}>=0 && $3<=1" -skip "${2=0},${4=20}"
-e[^-1] "Apply wind effect on image$?, with amplitude $1, angle "{round($2/45)*45}" deg., attenuation $3 and threshold $4."
-v -
-if {!$1} -return -endif
dxdy=${-_wind{round($2/45)%8}}
fact={(1-$3)^(1/$1)}
-repeat $! -l[$>]
--gradient_norm ->=. $4%
-r. 100%,100%,1,[-2] -*. [-2]
-repeat $1
-shift. $dxdy,0,0,0 -max.. [-1] -*. $fact
-remove_pixels. {100/$1}%
-done -rm.
-endl -done -v +
_wind0 : -u 1,0
_wind1 : -u 1,1
_wind2 : -u 0,1
_wind3 : -u -1,1
_wind4 : -u -1,0
_wind5 : -u -1,-1
_wind6 : -u 0,-1
_wind7 : -u 1,-1
#@gmic zoom : _factor,_cx,_cy,_cz,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Apply zoom factor to selected images.
#@gmic : Default values: 'factor=1', 'cx=cy=cz=0.5' and 'boundary=0'.
#@gmic : $ image.jpg --zoom[0] 0.6 --zoom[0] 1.5
zoom : -skip ${1=2},${2=0.5},${3=0.5},${4=0.5},${5=0}
-e[^-1] "Apply zoom effect on image$?, with factor $1 and center ($2,$3)."
-v - -repeat $! -l[$>]
-if {d==1}
({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
({({-2,h}-1)*$3*(1-1/$1)};{({-2,h}-1)*($3+(1-$3)/$1)})
-r[-2--1] [-3],[-3],1,1,3 -a[-2--1] c -warp.. [-1],0,1,$5
-else
({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
({({-2,h}-1)*$3*(1-1/$1)};{({-2,h}-1)*($3+(1-$3)/$1)})
({({-3,d}-1)*$4*(1-1/$1)}/{({-3,d}-1)*($4+(1-$4)/$1)})
-r[-3--1] [-4],[-4],[-4],1,3 -a[-3--1] c -warp.. [-1],0,1,$5
-endif
-rm.
-endl -done -v +
#@gmic :: Degradations
#@gmic cracks : _density>=0,_amplitude,_relief={ 0 | 1 }
#@gmic : Add random cracks to selected images.
#@gmic : Default values: 'density=0.2', 'amplitude=40' and 'relief=0'.
#@gmic : $ image.jpg --cracks 0.2,60,1
cracks : -skip ${1=0.2},${2=40},${3=0}
-e[^-1] "Add random cracks to image$?, with density $1."
-v - -repeat $! -l[$>]
({im},{iM}) [-2],[-2],1,1 -noise. $1,2 -distance. 1 -sharpen. 10000
-if $3 -g. xy -+[-2,-1] -n. -1,1 -else -n. 0,1 -endif
-*. $2 -+[-3,-1] -c.. {^} -rm.
-endl -done -v +
#@gmic light_patch : _density>0,_darkness>=0,_lightness>=0
#@gmic : Add light patches to selected images.
#@gmic : Default values: 'density=10', 'darkness=0.9' and 'lightness=1.7'.
#@gmic : $ image.jpg --light_patch 20,0.9,4
light_patch : -skip ${1=10},${2=0.9},${3=1.7}
-e[^-1] "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
-v - -repeat $! -l[$>]
-n 0,255 $1,$1 -noise. 40 -r. [-2],5 -c. 0,255
-n. $2,$3 -* -c 0,255
-endl -done -v +
#@gmic noise_hurl : _amplitude>=0
#@gmic : Add hurl noise to selected images.
#@gmic : Default value: 'amplitude=10'.
#@gmic : $ image.jpg --noise_hurl ,
noise_hurl : -skip ${1=10}
-e[^-1] "Add hurl noise to image$?, with amplitude $1%."
-v - -repeat $! -l[$>]
--f 0 -noise. 10 -n. {-2,im},{-2,iM} 100%,100%,1,1,-2
-noise. $1,2 ->=. 0 -r. [-2]
-*.. [-1] -*. -1 -+. 1 -*[-3,-1] -+
-endl -done -v +
#@gmic pixelize : _scale_x>0,_scale_y>0,_scale_z>0
#@gmic : Pixelize selected images with specified scales.
#@gmic : Default values: 'scale_x=20' and 'scale_y=scale_z=scale_x'.
#@gmic : $ image.jpg --pixelize ,
pixelize : -skip ${1=20},${2=$1},${3=$1}
-e[^-1] "Pixelize image$? with scales ($1%,$2%,$3%)."
-v - -repeat $! -l[$>] whd={w},{h},{d} -r $1%,$2%,$3%,100%,2 -r $whd -endl -done -v +
#@gmic scanlines : _amplitude,_bandwidth,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@gmic : Apply ripple deformation on selected images.
#@gmic : Default values: 'amplitude=60', 'bandwidth=2', 'shape=0', 'angle=0' and 'offset=0'.
#@gmic : $ image.jpg --ripple ,
scanlines : -skip ${1=60},${2=2},${3=0},${4=0},${5=0}
-e[^-1] "Apply scanlines effect on image$?, with amplitude $1, bandwidth $2, shape $3, angle $4 deg. and offset $5."
-v -
theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
-repeat $! -l[$>]
100%,100%,1,1,"x" --. {w/2} 100%,100%,1,1,'y'
--. {h/2-$5} -*.. $S -*. $C -+[-2,-1]
-_ripple$3. $1,$2
-n. {-$1},$1
-+ -cut 0,255
-endl -done -v +
#@gmic shade_stripes : _frequency>=0,_direction={ 0=horizontal | 1=vertical },_darkness>=0,_lightness>=0
#@gmic : Add shade stripes to selected images.
#@gmic : Default values: 'frequency=5', 'direction=1', 'darkness=0.8' and 'lightness=2'.
#@gmic : $ image.jpg --shade_stripes 30
shade_stripes : -skip ${1=5},${2=1},${3=0.8},${4=2}
-e[^-1] "Add "${-arg\ 1+!$2,vertical,horizontal}" shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4."
-v - -n 0,255 -repeat $! -l[$>]
{max(1,w*($2!=0))},{max(1,h*($2==0))} -noise. $1,2 -distance. 1 -r. [-2] -n. $3,$4 -* -c 0,255
-endl -done -v +
#@gmic shadow_patch : _opacity>=0
#@gmic : Add shadow patches to selected images.
#@gmic : Default value: 'opacity=0.7'.
#@gmic : $ image.jpg --shadow_patch 0.4
shadow_patch : -skip ${1=0.7}
-e[^-1] "Apply shadow patches to image$?, with opacity $1."
-v - -repeat $! -l[$>]
100%,100%,1,1 -shift. -2,-2 -shift. 1,1
-plasma. 3,0.3,8 -abs. -b. 1 -c. 3%,15% -r. [-2]
-n. $1,1 -*
-endl -done -v +
#@gmic spread : _dx>=0,_dy>=0,_dz>=0
#@gmic : Spread pixel values of selected images randomly along x,y and z.
#@gmic : Default values: 'dx=3', 'dy=dx' and 'dz=0'.
#@gmic : $ image.jpg --spread 3
spread : -skip ${1=3},${2=$1},${3=0}
-e[^-1] "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
-v - -repeat $! -l[$>]
100%,100%,100%,3
-sh. 0 -rand. {-$1},$1 -rm.
-sh. 1 -rand. {-$2},$2 -rm.
-sh. 2 -rand. {-$3},$3 -rm.
-warp.. [-1],1 -rm.
-endl -done -v +
#@gmic stripes_y : _frequency>=0
#@gmic : Add vertical stripes to selected images.
#@gmic : Default value: 'frequency=10'.
#@gmic : $ image.jpg --stripes_y ,
stripes_y : -skip ${1=10}
-e[^-1] "Add vertical stripes to image$?, with frequency $1."
-v - -repeat $! -l[$>]
100% -noise. $1,2 -*. 255 -r. [-2]
-*. 0.15 -+ -c 0,255
-endl -done -v +
#@gmic texturize_canvas : _amplitude>=0,_fibrousness>=0,_emboss_level>=0
#@gmic : Add paint canvas texture to selected images.
#@gmic : Default values: 'amplitude=20', 'fibrousness=3' and 'emboss_level=0.6'.
#@gmic : $ image.jpg --texturize_canvas ,
texturize_canvas : -check "${1=20}>=0 && ${2=3}>=0 && ${3=0.6}>=0 && ${4=80}"
-e[^-1] "Add canvas texture to image$?, with amplitude $1, fibrousness $2 and emboss level $3."
-v -
-repeat $! -l[$>]
{w},{h} -rand. 0,255 --blur_x. $2 -blur_y.. $2 -+[-2,-1] -g. -a[-2,-1] c
--compose_channels. + -orientation.. -compose_channels.. + -n.. $3,1 -n. 0,255
-sharpen. 80 -*[-2,-1] -n. -$1,$1 -+ -c 0,255
-endl -done -v +
#@gmic texturize_paper
#@gmic : Add paper texture to selected images.
#@gmic : $ image.jpg --texturize_paper
texturize_paper :
-e[^-1] "Add paper texture to image$?."
-v - -repeat $! -l[$>]
[-1] 30%,30% -noise. 1,2 -r. [-2],[-2],[-2],1,0 -ifft.
-rm. -shift. {round(w/2)},{round(h/2)},{round(d/2)},0,2 -sharpen. 1 -n. 1,1.2 -r. [-2]
-*[-2,-1] -c. [-2],[-2] -rm..
-endl -done -v +
#@gmic vignette : _strength>=0,0<=_radius_min<=100,0<=_radius_max<=100
#@gmic : Add vignette effect to selected images.
#@gmic : Default values: 'strength=100', 'radius_min=70' and 'radius_max=90'.
#@gmic : $ image.jpg --vignette ,
vignette : -check "${1=100}>=0 && ${2=70}>=0 && $2<=100 && ${3=90}>=0 && $3<=100"
-e[^-1] "Add vignette effect to image$?, with strength $1 and size $2."
-v - -repeat $! -l[$>]
mM={im},{iM} d={max(w,h)}
$d,$d -=. 1,50%,50% -distance. 1 -r. [-2],2
-c. $2%,$3% -n. 0,$1 -- -c $mM
-endl -done -v +
#@gmic watermark_visible : _text,0<_opacity<1,_size>0,_angle,_mode={ 0=remove | 1=add },_smoothness>=0
#@gmic : Add or remove a visible watermark on selected images (value range must be [0,255]).
#@gmic : Default values: 'text=(c) G'MIC', 'opacity=0.3', 'size=53', 'angle=25', 'mode=1' and 'smoothness=0'.
#@gmic : $ image.jpg --watermark_visible ,0.7
watermark_visible : -skip "${1=\251\ G\47MIC}" -check "${2=0.3}>0 && $2<1 && ${3=53}>0 && ${6=0.5}>=0" -skip ${4=25},${5=1}
-e[^-1] ${-arg\ 1+!$5,Add,Remove}" visible watermark '$1' on image$?, with opacity $2, size $3, angle $4 deg."
-v - -repeat $! -l[$>]
0 -t. "$1",0,0,$3,1,255 -rotate. $4,0,0 -b. $6 -n. 0,255
-r. [-2],0,2 -+. [-2] -c. 0,255
-if $5 -*. $2 -*.. {1-$2} -+
-else -*. $2 -- -/ {1-$2}
-endif
-c 0,255
-endl -done -v +
#@gmic :: Blending and fading
#@gmic blend : [layer],blending_mode,0<=_opacity<=1,_selection_is={ 0=base-layers | 1=top-layers } : blending_mode,0<=_opacity<=1
#@gmic : Blend selected G,GA,RGB or RGBA images by specified layer or blend all selected images together, using specified blending mode.
#@gmic : 'blending_mode' can be { add | alpha | and | average | blue | burn | darken | difference |
#@gmic : divide | dodge | edges | exclusion | freeze | grainextract | grainmerge | green | hardlight |
#@gmic : hardmix | hue | interpolation | lighten | lightness | linearburn | linearlight | luminance |
#@gmic : multiply | negation | or | overlay | pinlight | red | reflect | saturation | seamless | seamless_mixed |
#@gmic : screen | shapeaverage | shapeaverage0 | softburn | softdodge | softlight | stamp | subtract | value |
#@gmic : vividlight | xor }.
#@gmic : Default values: 'blending_mode=alpha', 'opacity=1' and 'selection_is=0'.
#@gmic : $ image.jpg --drop_shadow , -resize2dy. 200 -rotate. 20 --blend alpha -display_rgba..
#@gmic : $ image.jpg -testimage2d {w},{h} -blend overlay
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline. Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex add,alpha,and,average,blue,burn,darken
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline. Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex difference,divide,dodge,exclusion,freeze,grainextract,grainmerge
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline. Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex green,hardlight,hardmix,hue,interpolation,lighten,lightness
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline. Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex linearburn,linearlight,luminance,multiply,negation,or,overlay
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline. Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex pinlight,red,reflect,saturation,screen,shapeaverage,softburn
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline. Mode:\" \"${arg{$>+1}},2,2,23,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex softdodge,softlight,stamp,subtract,value,vividlight,xor
blend : -skip ${1=alpha},${2=1},${3=1},${4=0}
-v -
-if {arg(1,{'$1'})==_'['}
n={narg($*)} mode=${-arg\ 1+($n>=2),alpha,$2}
-v + -e[^-1] "Blend image$? with "${-arg\ 1+$4,base,top}" layer $1, using '"$mode"' mode and opacity $3." -v -
-repeat $! -pass$1 -l[$>,-1] -if $4 -rv -endif -blend $mode,$3 -endl -done -v + -return
-endif
-v + -e[^-1] "Blend all image$? together, using '$1' mode and opacity $2." -v -
-repeat {$!-1} -l[0,1]
-r[1] [0],[0],[0],100%,0,0,0.5,0.5
s={s0=if({0,s}<3,1,3);s1=if(s<3,1,3);max(s0,s1)}
-to_colormode[0] {$s+1-({0,s}%2)}
-to_colormode[1] {$s+1-(s%2)}
-if {{0,s}==2||{0,s}==4}
-if {s==2||s==4}
-sh[0,1] 0,{s-2} -_blend_$1[2,3] -rm[2,3]
-if {['"$1"']=='alpha'}
-sh[0,1] 0,{{0,s}-2} -sh[0,1] 100% -*[2,4] -*[3,4] -rm[2,3]
--channels[1] 100% -sh[1] 100% -f[3] 255 -rm[3]
-j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 -rm[1,2]
-sh[0] 0,{s-2} -sh[0] 100% -+[2] 1e-10 -/[1,2] -rm[1] -c 0,255
-else
-sh[1] 0,{s-2} -sh[1] 100% -j[0] [2],0,0,0,0,{max(0,min(1,$2))},[3],255 -rm[^0]
-endif
-else
-sh[0] 0,{{0,s}-2} -rv[1,2] -_blend_$1[1,2] -j[1] [2],0,0,0,0,{max(0,min(1,$2))} -rm[^0]
-endif
-else
-if {s==2||s==4}
-sh[1] 0,{s-2} -_blend_$1[0,2] -rm[2]
-sh[1] 100% -j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 -rm[^0]
-else
-_blend_$1 -j[0] [1],0,0,0,0,{max(0,min(1,$2))} -rm[1]
-endif
-endif
-endl -done -v +
_blend_alpha :
_blend_normal :
_blend_and :
-&[1] [0]
_blend_add :
-+[1] [0] -c[1] 0,255
_blend_average :
-+[1] [0] -/[1] 2
_blend_blue :
-sh[0] 0,1 -j[1] [2] -rm[2]
_blend_burn :
---[0] 255 -+[1] 0.1 -/[2] [1] -rm[1] -+[1] 1 -*[1] 255 -c[1] 0,255
_blend_darken :
-min[1] [0]
_blend_difference :
--[1] [0] -abs[1]
_blend_divide :
-+[1] 0.1 -^[1] -1 -*[1] [0] -*[1] 255 -c[1] 0,255
_blend_dodge :
--[1] 255.1 -^[1] -1 -*[1] [0] -*[1] -255 -c[1] 0,255
_blend_edges :
--blend_edges 0.5 -rm[1]
_blend_exclusion :
--*[0,1] -/[2] -127.5 -+[1,2] -+[1] [0]
_blend_freeze :
-*[1] -255 --[1] 0.1 ---[0] 255 -sqr[2] -/[2] [1] -rm[1] -+[1] 1 -*[1] 255 -c[1] 0,255
_blend_grainextract :
--[1] [0] -*[1] -1 -+[1] 128 -c[1] 0,255
_blend_grainmerge :
-+[1] [0] --[1] 128 -c[1] 0,255
_blend_green :
-sh[0] 0 -sh[0] 2 -j[1] [2] -j[1] [3],0,0,0,2 -rm[2,3]
_blend_hardlight :
--*[0,1] -/[2] 127.5 --+[0,1] -*[3] 2 --[3] 255 --[3] [2] ->[1] 128
-j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255
_blend_hardmix :
-+[1] [0] ->=[1] 255 -*[1] 255
_blend_hue :
-to_color -sh 0,2 -rgb2hsv[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -hsv2rgb[2,3] -rm[2,3]
_blend_interpolation :
--*[0] {pi/255} -*[1] {pi/255} -cos[1,2] -+[1,2] --[1] 2 -*[1] -63.75 -c[1] 0,255
_blend_lighten :
-max[1] [0]
_blend_lightness :
-to_color -sh 0,2 -rgb2lab[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -lab2rgb[2,3] -rm[2,3]
_blend_luminance :
-to_color -sh 0,2 -rgb2ycbcr[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -ycbcr2rgb[2,3] -rm[2,3]
_blend_linearburn :
-+[1] [0] --[1] 255 -c. 0,255
_blend_linearlight :
-*[1] 2 -+[1] [0] --[1] 255 -c[1] 0,255
_blend_multiply :
-*[1] [0] -/[1] 255
_blend_negation :
-+[1] [0] --[1] 255 -abs[1] -*[1] -1 -+[1] 255
_blend_or :
-|[1] [0]
_blend_overlay :
--*[0,1] -/[2] 127.5 -+[1] [0] -*[1] 2 --[1] 255 --[1] [2] --<[0] 128 -j[1] [2],0,0,0,0,1,[3] -rm[2,3] -c[1] 0,255
_blend_pinlight :
-*[1] 2 --blend darken --[1] 256 --blend[0,1] lighten ->=[1] 0
-j[2] [3],0,0,0,0,1,[1] -rm[1,3]
_blend_reflect :
--[1] 255.1 -*[1] -1 --sqr[0] -/[2] [1] -rm[1] -c[1] 0,255
_blend_red :
-sh[0] 1,100% -j[1] [2],0,0,0,1 -rm[2]
_blend_saturation :
-to_color -sh 0,2 -rgb2hsv[2,3] -shift[2,3] 0,0,0,-1,2 -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -shift[2,3] 0,0,0,1,2 -hsv2rgb[2,3] -rm[2,3]
_blend_screen :
---[0] 255 --[1] 255 -*[1,2] -/[1] 255 -*[1] -1 -+[1] 255
_blend_shapeaverage :
-norm[1] -label[1] 0 {iM+1},1,1,{0,s}
-f[0] ">i(#2,i(#1,x,y,z,0),0,0,c)+=i;i"
--histogram[1] {w},0,{w-1} -/[-2,-1] -map[1] [-1] -rm.
_blend_shapeaverage0 :
-norm[1] -label_fg[1] 0 {iM+1},1,1,{0,s}
-f[0] ">i(#2,i(#1,x,y,z,0),0,0,c)+=i;i"
--histogram[1] {w},0,{w-1} -/[-2,-1] -point. 0,0,0,1,0 -map[1] [-1] -rm.
_blend_softburn :
---[0] 255.1 -^[2] -1 -*[2] [1] -*[2] -127.5 ---[0] 255 --+[1] 0.1 -/[3,4] -*[3] 127.5 -+[3] 255 -+[1] [0] ->[1] 255
-j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255
_blend_softdodge :
---[1] 255.1 -^[2] -1 -*[2] [0] -*[2] -127.5 ---[1] 255 --+[0] 0.1 -/[3,4] -*[3] 127.5 -+[3] 255 -+[1] [0] ->[1] 255
-j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255
_blend_softlight :
--/[0] 255 -/[1] 255 --sqr. -*[2] [1] -*[1] [3] -*[1] -2 -*[2] 2 -+[1-3] -*[1] 255 -c[1] 0,255
_blend_stamp :
-*[1] 2 -+[1] [0] --[1] 255 -c[1] 0,255
_blend_subtract :
--[1] [0] -*[1] -1 -c[1] 0,255
_blend_value :
-to_color -sh 0,2 -rgb2hsv[2,3] -sh[2] 0,1 -j[1] [4] -rm[4] -hsv2rgb[2,3] -rm[2,3]
_blend_vividlight :
-*[1] 2 --blend burn --[1] 256 --blend[0,1] dodge ->=[1] 0
-j[2] [3],0,0,0,0,1,[1] -rm[1,3]
_blend_xor :
-xor[1] [0]
#@gmic blend_edges : smoothness[%]>=0
#@gmic : Blend selected images togethers using 'edges' mode.
#@gmic : $ image.jpg -testimage2d {w},{h} --blend_edges 0.8
blend_edges : -check {$1>=0}
-e[^-1] "Blend image$? using 'edges' mode, with smoothness $1."
-if {$!>1} -v - -to_rgb -r[^0] [0],0,0,0.5,0.5 -repeat $! -l[$>]
--gradient_norm -+. 1 -b. $1 -n. 1,10 -sqr. -s.. c -*[-4--2] [-1] -a[-4--1] c
-endl -done -r[^0] [0],0,0,0.5,0.5 -+ -s. c -/[-4--2] [-1] -rm. -a[-3--1] c -v + -endif
#@gmic blend_fade : [fading_shape]
#@gmic : Blend selected images together using specified fading shape.
#@gmic : $ image.jpg -testimage2d {w},{h} 100%,100%,1,1,'cos(y/10)' -normalize. 0,1 --blend_fade[0,1] [2]
blend_fade :
-e[^-1] "Blend image$? together using fading pattern $1."
-v - -r ${-max_whds},0
-pass$1 0 -r. [0],[0],[0],100%,1 -max. 0 -min. {$!-2}
-repeat {$!-1} ---. $> -abs. --. 1 -*. -1 -max. 0 -*[$>,-1] -done -rm.
-+ -v +
_fade :
-r.. [-3],5 -r. [-2],3 -c. $1%,$2% -n. 0,1 -j... [-2],0,0,0,0,1,[-1] -rm[-2,-1]
#@gmic blend_median
#@gmic : Blend selected images together using 'median' mode.
#@gmic : $ image.jpg -testimage2d {w},{h} --mirror[0] y --blend_median
blend_median :
-e[^-1] "Blend image$? using 'median' mode."
-v -
-if {$!<2} -v + -return -endif
-to_colormode 0 -r ${-max_whd},100%,0,0,0.5,0.5,0.5 whd={w},{h},{d} -r 100%,{h*d},1,100%,-1
-if {$!==2} -+ -/ 2
-elif {$!%2}
-repeat {$!/2} -repeat {$!-1-$>} -l[$>,{$>+1}] --max -min[0,1] -endl -done -done
-k[{int($!/2)}]
-elif {!($!%2)}
-repeat {$!/2+1} -repeat {$!-1-$>} -l[$>,{$>+1}] --max -min[0,1] -endl -done -done
-k[{int($!/2-1)},{$!/2}]
-+ -/ 2
-endif
-r $whd,100%,-1 -v +
#@gmic blend_seamless : _is_mixed_mode={ 0 | 1 },_inner_fading[%]>=0,_outer_fading[%]>=0
#@gmic : Blend selected images using a seamless blending mode (Poisson-based).
#@gmic : Default values: 'is_mixed=0', 'inner_fading=0' and 'outer_fading=100%'.
blend_seamless : -check "${2=0}>=0 && ${3=100%}>=0" -skip ${1=0}
-v - s0="non-mixed" s1="mixed"
-v + -e[^-1] "Blend image$? using seamless mode (Poisson-based), in "${s{$1!=0}}" mode with inner fading $2 and outer fading $3." -v -
-to_a[^0] -r {0,w+32},{0,h+32},1,100%,0,0,0.5,0.5
-if {['$3']!='100%'}
-repeat {$!-1} -l[0,1]
--blend_seamless $1,$2,100% -channels.. 100% -!=.. 0 -distance.. 1
iM={-2,iM} ic={if(${-is_percent\ $3},2*$3*$iM,1+$3)}
-if {$ic<=$iM} -c.. 0,{max(1,$ic)} -n.. 0,1
-else -n.. 0,{max(0,2-$ic/$iM)}
-endif
-*.. -1 -+.. 1
-j[0] [2],0,0,0,0,1,[1] -rm[1,2]
-endl -done
-else
-repeat {$!-1} -l[0,1]
--r[0] 1,1,1,100%,2 avg={^} -rm.
-split_opacity. -!=. 0 -*.. [-1] -erode. 3
-g[0,1] xy,1
-*[-3,-2] [-1]
-if $1
--a[0,1] c --a[2,3] c -norm[-2,-1]
-<[-2,-1] -*[-2,-1]
-endif
-if {$2}
-distance. 0
iM={iM} ic={if(${-is_percent\ $2},2*$2*$iM,1+$2)}
-if {$ic<=$iM} -c. 0,{max(1,$ic)} -n. 0,1
-else -n. 0,{max(0,2-$ic/$iM)}
-endif
-endif
-j[-5] [-3],0,0,0,0,1,[-1]
-j[-4] [-2],0,0,0,0,1,[-1]
-rm[-3--1]
-g[0] x,-1 -g[1] y,-1 -+
-fft[0]
100%,100%,1,1,'cos(2*x*pi/w)+cos(2*y*pi/h)' -*. 2 --. 4
-=. 1 -/[-3,-2] [-1] -rm.
-=.. 0 -=. 0
-ifft[-2,-1] -rm.
--fc. $avg
-+[-2,-1]
-c 0,255
-endl -done
-endif
-z 16,16,{w-17},{h-17} -v +
#@gmic fade_diamond : 0<=_start<=100,0<=_end<=100
#@gmic : Create diamond fading from selected images.
#@gmic : Default values: 'start=80' and 'end=90'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_diamond 80,85
fade_diamond : -skip ${1=70},${2=90}
-e[^-1] "Create ($1%,$2%) diamond-shaped fading from image$?."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
(0,1,0;1,1,1;0,1,0) -_fade $1,$2
-endl -done -v +
#@gmic fade_linear : _angle,0<=_start<=100,0<=_end<=100
#@gmic : Create linear fading from selected images.
#@gmic : Default values: 'angle=45', 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_linear 45,48,52
fade_linear : -skip ${1=45},${2=30},${3=70}
-e[^-1] "Create ($2%,$3%) linear fading from image$?, with angle $1 deg."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
64,64,1,1,"x*cos($1*pi/180) + y*sin($1*pi/180)" -_fade $2,$3
-endl -done -v +
#@gmic fade_radial : 0<=_start<=100,0<=_end<=100
#@gmic : Create radial fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_radial 30,70
fade_radial : -skip ${1=30},${2=70}
-e[^-1] "Create ($1%,$2%) radial fading from image$?."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
100%,100% -=. 1,50%,50% -distance. 1 -_fade $1,$2
-endl -done -v +
#@gmic fade_x : 0<=_start<=100,0<=_end<=100
#@gmic : Create horizontal fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_x 30,70
fade_x : -skip ${1=30},${2=70}
-e[^-1] "Create ($1%,$2%) horizontal fading from image$?."
-v - -repeat {int($!/2)} -l[$>,{$>+1}] (0,1) -_fade $1,$2 -endl -done -v +
#@gmic fade_y : 0<=_start<=100,0<=_end<=100
#@gmic : Create vertical fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_y 30,70
fade_y : -skip ${1=30},${2=70}
-e[^-1] "Create ($1%,$2%) vertical fading from image$?."
-v - -repeat {int($!/2)} -l[$>,{$>+1}] (0;1) -_fade $1,$2 -endl -done -v +
#@gmic fade_z : 0<=_start<=100,0<=_end<=100
#@gmic : Create transversal fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
fade_z : -skip ${1=30},${2=70}
-e[^-1] "Create ($1%,$2%) transversal fading from image$?."
-v - -repeat {int($!/2)} -l[$>,{$>+1}] (0/1) -_fade $1,$2 -endl -done -v +
#@gmic sub_alpha : [base_image],_opacity_gain>=1
#@gmic : Compute the minimal alpha-channel difference (opposite of alpha blending) between the selected images and the specified base image.
#@gmic : The alpha difference A-B is defined as the image having minimal opacity, such that alpha_blend(B,A-B) = A.
#@gmic : Default value: 'opacity_gain=1'.
#@gmic : $ image.jpg -testimage2d {w},{h} --sub_alpha[0] [1] -display_rgba
sub_alpha : -check "${2=1}>=1 && "${"-is_image_arg $1"}
-e[^-1] "Compute minimal alpha-channel difference between image$? and base image $1, with opacity gain $2."
-v - -remove_opacity -repeat $! -pass$1 0 -l[$>,-1]
-to_colormode 0 -r ${-max_whd},100%,0,0,0.5,0.5
-->[0,1] -*[2] 255
--[0,2] [1] -replace[2] 0,1
-i[2] [0] -/[2,3]
-compose_channels[2] max
-*[2] $2 -c[2] 0,1
--replace[2] 0,1 -/[0,3] -+[0,1] -*[1] 255 -a c
-endl -done -v +
#@gmic :: Image sequences and videos
#@gmic animate : filter_name,"param1_start,..,paramN_start","param1_end,..,paramN_end",nb_frames>=0,_output_frames={ 0 | 1 },_output_filename : delay>0
#@gmic : Animate filter from starting parameters to ending parameters or animate selected images
#@gmic : in a display window.
#@gmic : Default value: 'delay=30'.
#@gmic : $ image.jpg -animate flower,"0,3","20,8",9
animate : -skip ${1=30},${2=0},${3=""},${4=10},${5=1},"${6=}"
-if {isval($1)}
-if $2 -e[0--4] "Animate image$?, with a delay of $1 ms, and ping-pong mode."
-else -e[0--4] "Animate image$?, with a delay of $1 ms."
-endif
-if {!$!} -return -endif
-v -
speed=$1
pause=-1
direction=1
frame=0
-w[$frame] ${-fitscreen[]\ {$frame,w},{$frame,h}},1,0,-1,-1,{$frame,b}.{$frame,x}
-do
-w[$frame] -1,-1,1,0,-1,-1,{$frame,b}.{$frame,x}
frame+=$direction
-if $2
-if {$frame==-1} frame=0 direction=1
-elif {$frame==$!} frame={$!-1} direction=-1
-endif
-else frame%=$!
-endif
-wait $speed
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} -w[] {{*,w}*1.5},{{*,h}*1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} -w[] {{*,w}/1.5},{{*,h}/1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} -w[] {0,w},{0,h} -wait -1 -endif
-if {*,o} speed={min(500,max(10,$speed-10*{*,o}))} -wait -1 -endif
-if {*,SPACE}
-if {$pause>=0} direction=$pause pause=-1
-else pause=$direction direction=0 -endif
-wait -1
-endif
-while {{*}" && "!{*,Q}" && "!{*,ESC}} -w 0 -v +
-else
-e[0--3] "Compute animated version of filter '$1', from parameters $2 to $3 with $4 frames."
-if {!($5||narg("$6"))} -return -endif
-v - ($2) ($3) -y[-2,-1] x -a[-2,-1] y -r. 100%,$4,1,1,3 -mv. 0 -rprogress 0
-repeat {$!-1},u
-v + -e[] " > Animate image ["$>"]" -v -
-repeat $4 --l[0,1]
-$1. {0,@{$>*{0,w}}-{($>+1)*{0,w}-1}} -rm[0]
-if {narg("$6")} -o ${-filename\ "$6",$u,$>} -endif
-if {!$5} -rm -endif
-rprogress {100*($>+1)/$4}
-v + -e[] "\r > Animate image ["$u"] : Frame "{$>+1}"/$4    " -v -
-endl -done
-rm[1] -done -rm[0] -v +
-endif
#@gmic apply_camera : _command,_camera_index>=0,_skip_frames>=0,_output_filename
#@gmic : Apply specified command on live camera stream, and display it on display window [0].
#@gmic : Default values: 'command=""', 'camera_index=0' (default camera), 'skip_frames=0' and 'output_filename=""'.
apply_camera : -skip "${1=},${4=}" -check "${2=0}>=0 && ${3=0}>=0"
-e[^-1] "Apply command '$1' on camera stream ""#$2, with $3 frames skip and output filename '$4'." -v -
-l[] i=0 -do
-camera $2,1,$3 $1 -w. -1,-1,"(Camera ""#$2, "{w}x{h}")"
-if {narg("$4")} -o. ${-filename\ "$4",$i} i+=1 -endif
-if {*,S} -o. gmic_camera.png -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} -w[] {{*,w}*1.5},{{*,h}*1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} -w[] {{*,w}/1.5},{{*,h}/1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} -w[] {0,w},{0,h} -wait -1 -endif
-rm.
-while {{*}" && "!{*,ESC}" && "!{*,Q}} -camera $2,0 -endl -v +
#@gmic apply_files : "command","filename_pattern",_output_prefix,_output_extension,_view_window={ 0 | 1 }
#@gmic : Apply specified command on all specified image files, by reading them one by one,
#@gmic : and save result by appending 'output_prefix' to each original filename.
#@gmic : If 'output_extension' is set, the output files are written using the specified extension instead of keeping
#@gmic : the original one.
#@gmic : Default value: 'output_prefix=gmic_', 'output_extension=""' and 'view_window=0'.
apply_files : -skip "${3=gmic_}","${4=}",${5=0}
-v -
files=${"-files \"$2\""} -arg2var _file,$files nb_files=${}
({'$files'}) -if {w>128} -z. 0,127 s_files={t}... -else s_files=$files -endif -rm.
-m "_apply_files : $1"
-v + -e[^-1] "Apply command '$1' on files '"$s_files"' and save result with prefix '$3'.\n" -v -
-repeat $nb_files -l[]
file=${_file{$>+1}}
_file=${-basename\ $file}
-if {narg("$4")} 0 -nm. $_file output_file="$3"{b}."$4" -rm. -else output_file="$3"$_file -endif
-v + -e[] "\r - Image "{1+$>}/$nb_files" ["$_file"] -> ["$output_file"]                    " -v -
$file -_apply_files
-o $output_file
-if $5 -w. ${-fitscreen\ {w},{h},{d}},1,0,-1,-1,$_file -endif
-rm
-onfail -v + -e[] "\n - Error occured on file '"$file"'.\n" -v -
-endl -done -uncommand _apply_files -v +
#@gmic apply_video : _command,_input_filename,_output_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1
#@gmic : Apply specified command on video stream, and display it on display window [0].
#@gmic : Default values: 'command=""', 'input_filename=""', 'output_filename=""', 'first_frame=0', 'last_frame=-1' and 'frame_step=1'.
apply_video : -skip "${1=},${2=},${3=}" -check "isint(${4=0}) && $4>=0 && isint(${5=-1}) && ($5>=0 || $5==-1) && ${6=1}>=1"
-e[^-1] "Apply command '$1' on video stream '$2', with output filename '$3', first frame $4, last frame $5 and frame step $6."
-v - -l[]
frame=$4 i=0 basename=${"-basename \"$2\""}
-do
-i "$2",$frame
-if $!
$1 -w -1,-1,"(Video '"$basename"', "{w}x{h}")"
frame+=$6
-if {$5>=0" && "$frame>$5} frame=$4 -endif
-if {narg("$3")" && "$i>=0} -o. ${-filename\ "$3",$i} i+=1 -endif
-if {*,S} -o. gmic_video.png -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} -w[] {{*,w}*1.5},{{*,h}*1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} -w[] {{*,w}/1.5},{{*,h}/1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} -w[] {0,w},{0,h} -wait -1 -endif
-else frame=$4 i=-1
-endif
-rm
-while {{*}" && "!{*,ESC}" && "!{*,Q}} -i "$2",0,0,0
-endl -v +
#@gmic average_video : input_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@gmic : Compute the average frame of a video file.
#@gmic : If a display window is opened, the frames are displayed in it during processing.
#@gmic : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
average_video : -check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1" -skip "${5=}"
-e[^-1] "Average frames of video file '$1', with first frame $2, last frame $3, frame step $4 and output filename '$5'.\n"
-v - -_average_files[] "\"$1\",$frame",$2,$3,$4,"$5" -v +
#@gmic average_files : "filename_pattern",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_output_filename
#@gmic : Compute the average frame of a file sequence.
#@gmic : If a display window is opened, the frames are displayed in it during processing.
#@gmic : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1' and 'output_filename=(undefined)'.
average_files : -check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1" -skip "${5=}"
-e[^-1] "Average frames of file sequence '$1', with first frame $2, last frame $3, frame step $4 and output filename '$5'.\n"
-v - -arg2var _file,${"-files \"$1\""} -_average_files[] "${_file{$frame+1}}",$2,$3,$4,"$5" -v +
_average_files : -skip "${5=}"
frame=$2 i=0 go_on=1 N=0
-do
-l[] $1 -nm. img -onfail go_on=0 -endl
-if $img
-v + -e[] "\r  > Frame ""#"$frame -v -
frame+=$4 N+=1
-endif
-if {$!>1} -+ -endif
-if {narg("$5")} --/. $N -c. 0,255 -o. ${-filename\ "$5",$i} -rm. i+=1 -endif
-if {*}
--n 0,255 -w. -1,-1,0,"Frame ""#"$frame
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} -w[] {{*,w}*1.5},{{*,h}*1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} -w[] {{*,w}/1.5},{{*,h}/1.5} -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} -w[] {0,w},{0,h} -wait -1 -endif
-rm.
-endif
-while {$go_on" && "($3==-1" || "$frame<=$3)}
-/ $N -c 0,255
#@gmic files2video : "filename_pattern",_output_filename,_fps>0,_codec
#@gmic : Convert several files into a single video file.
#@gmic : Default values: 'output_filename=output.avi', 'fps=25' and 'codec=mp4v'.
files2video : -check "isint(${3=25}) && $3>0" -skip "${2=output.avi}",${4=mp4v}
-v -
files=${"-files \"$1\""} -arg2var _file,$files nb_files=${}
({'$files'}) -if {w>128} -z. 0,127 s_files={t}... -else s_files=$files -endif -rm.
-v + -e[^-1] "Convert image files '"$s_files"' into frames of output video '$2', with $3 fps and $4 codec.\n" -v -
-repeat $nb_files -l[]
file=${_file{$>+1}}
_file=${-basename\ $file}
-v + -e[] "\r - Image "{1+$>}/$nb_files" ["$_file"] -> [$2]                    " -v -
-i $file -o "$2",$3,$4,1
-rm
-onfail -v + -e[] "\n - Error occured on input file '"$file"'.\n" -v -
-endl -done
-o $"$2",0,0,0 -v +
#@gmic median_video : input_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_frame_rows[%]>=1,_is_fast_approximation={ 0 | 1 }
#@gmic : Compute the median frame of a video file, doing it by blocks of rows to save memory usage.
#@gmic : If a display window is opened, the frames are displayed in it during processing.
#@gmic : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1', 'frame_rows=100%' and 'is_fast_approximation=1'.
median_video : -check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1 && ${5=100%}>0 && isval(${6=1})"
-v - s0="fast" s1="precise"
-v + -e[^-1] "Compute median frame of video file '$1', with first frame $2, last frame $3, frame step $4, frame rows $5, using "${s{!$6}}" algorithm." -v -
-l[]
-i[res] "$1",0 -f. 0
-_median_files "\"$1\",$frame",${2-6}
-endl -v +
#@gmic median_files : "filename_pattern",_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1,_frame_rows[%]>=1,_is_fast_approximation={ 0 | 1 }
#@gmic : Compute the median frame of a video file, doing it by blocks of rows to save memory usage.
#@gmic : If a display window is opened, the frames are displayed in it during processing.
#@gmic : Default values: 'first_frame=0', 'last_frame=-1', 'frame_step=1', 'frame_rows=20%' and 'is_fast_approximation=1'.
median_files : -check "isint(${2=0}) && $2>=0 && isint(${3=-1}) && ($3>=0 || $3==-1) && ${4=1}>=1 && ${5=20%}>0 && isval(${6=1})"
-v - s0="fast" s1="precise"
-v + -e[^-1] "Compute median frame of file sequence '$1', with first frame $2, last frame $3, frame step $4, frame rows $5, using "${s{!$6}}" algorithm." -v -
-l[]
-arg2var _file,${"-files \"$1\""}
-i[res] ${_file{$frame+1}} -f. 0
-_median_files "${_file{$frame+1}}",${2-6}
-endl -v +
_median_files :
-if {$3==-1} max_frame="(undefined)" -else max_frame=$3 -endif
h1={h-1} drows={round(${-is_percent\ $5}?$5*h:$5)}
nb_iter={round(h/$drows,1,1)}
-repeat $nb_iter
row0={$drows*$>} row1={0,min(h,$row0+$drows-1)}
-v + -e[] "- Iteration \#"{$>+1}/$nb_iter": Load rows "$row0-$row1/$h1".\n" -v -
frame=$2 go_on=1
-if $6
N=0
-i[hist] {w},$drows,256,{s}
-do
-l[] $1 -nm. img -onfail go_on=0 -endl
-if $img
-v + -e[] "\r    > Frame "$frame"/"$max_frame"." -v -
-if {{*}" && "!$>} -w[img] -1,-1,0,"Frame ""#"$frame -endif
-rows[img] $row0,$row1 -f[img] ":++i(#-2,x,y,i,c)"
-rm[img]
frame+=$4 N+=1
-endif
-while {$go_on" && "($3==-1" || "$frame<=$3)}
-cumulate[hist] z
N2={int($N/2)}
[hist],[hist],1,[hist]
-if {$N%2}
-f. ":go_on = 1; for (z = 0, i(#"$hist",x,y,z,c)<"$N2" && z<256, ++z); z"
-else
-f. ":init(N2p="$N2";N2n=N2p + 1);
go_on = 1;
for (zp = 0, i(#"$hist",x,y,zp,c)<N2p && zp<256, ++zp);
for (zn = zp, i(#"$hist",x,y,zn,c)<N2n && zn<256, ++zn);
0.5*(zn + zp);"
-endif
-rm..
-else
-l[]
-do
-l[] $1 -nm. img -onfail go_on=0 -endl
-if $go_on
-v + -e[] "\r    > Frame "$frame"/"$max_frame"." -v -
-if {{*}" && "!$>} -w. -1,-1,0,"Frame ""#"$frame -endif
-rows. $row0,$row1
frame+=$4
-endif
-while {$go_on" && "($3==-1" || "$frame<=$3)}
-v + -e[] "\r    > Compute median blending of "$!" frames." -v -
-__median_files
-endl
-endif
max_frame={$frame-$4}
-j[res] [-1],0,$row0
-if {*} -w[res] -1,-1,0,"Iteration ""#"$> -endif
-rm.
-done
-v + -e[] "- Done!" -v -
__median_files :
-if {$!<2} -return
-elif {$!==2} -+ -/ 2
-else
-f. ":
stack = vector"{0,2*$!}"();
stacksize = 0;
push(elt0,elt1) = (stack[stacksize++] = elt0; stack[stacksize++] = elt1);
pop() = (_s1 = stack[--stacksize]; _s0 = stack[--stacksize]; [_s0,_s1]);
push(0,"$!" - 1);
whiledo (stacksize>0,
range = pop();
lo = range[0];
hi = range[1];
pivot = i(#int((lo + hi)/2));
whiledo (lo<=hi,
whiledo (i(#lo)<pivot, ++lo);
whiledo (pivot<i(#hi), --hi);
if (lo<=hi, tmp = i(#lo); i(#lo++) = i(#hi); i(#hi--) = tmp);
);
if (range[0]<hi,push(range[0],hi));
if (lo<range[1],push(lo,range[1]));
)"
-if {$!%2} -k[{int($!/2)}]
-else -k[{int($!/2-1)},{$!/2}] -+ -/ 2
-endif
-endif
#@gmic morph : nb_frames>0,_smoothness>=0,_precision>=0
#@gmic : Create morphing sequence between selected images.
#@gmic : Default values: 'smoothness=0.1' and 'precision=5'.
#@gmic : $ image.jpg --rotate 20,1,1,50%,50% -morph 9
morph : -check "$1>=0 && ${2=0.1}>=0 && ${3=5}>=0"
-e[^-1] "Create morphing sequence between image$?, with $1 added frames, smoothness $2 and precision $3.\n"
-if {!$1} -return -endif
-v - -r[^0] [0],3 -repeat {$!-1} -l[$<,{$<+1}]
nm={0,n}
-v + -e[] "\r > Morph image "$>" to image "{$>+1}".    " -v -
--equalize[-2,-1] -n[-2,-1] 0,255
--displacement. [-2],$2,$3 --warp[0] [-1],1,1,1,$1 -a[-$1--1] z -rm..
--displacement... [-2],$2,$3 --warp[1] [-1],1,1,1,$1 -a[-$1--1] z -k[0,1,-3,-1] -mirror. z
(0/1) -r. [-2],[-2],[-2],1,3 -j... [-2],0,0,0,0,1,[-1] -rm[-2,-1]
-mv. 1 -s[1] z -nm[^-1] $nm
-endl -done -v +
#@gmic register_nonrigid : [destination],_smoothness>=0,_precision>0,_nb_scale>=0
#@gmic : Register selected source images with specified destination image, using non-rigid warp.
#@gmic : Default values: 'smoothness=0.2', 'precision=6' and 'nb_scale=0(auto)'.
#@gmic : $ image.jpg --rotate 20,1,1,50%,50% --register_nonrigid[0] [1]
register_nonrigid : -check ${-is_image_arg\ $1}" && ${2=0.2}>=0 && ${3=5}>0 && ${4=0}>=0"
-e[^-1] "Register source image$? with destination image $1, using non-rigid warp with smoothness $1, precision $2 and $3 scale(s)."
-v - -pass$1 0 -equalize. -n. 0,255
-repeat {$!-1}
--equalize[$>] -n. 0,255 --displacement.. [-1],$2,$3,$4 -rm..
-warp[$>] [-1],1,1,1 -rm.
-done -rm. -v +
#@gmic register_rigid : [destination],_smoothness>=0,_boundary={ 0=dirichlet | 1=neumann | 2=periodic }
#@gmic : Register selected source images with specified destination image, using rigid warp (shift).
#@gmic : Default values: 'smoothness=1' and 'boundary=0'.
#@gmic : $ image.jpg --shift 30,20 --register_rigid[0] [1]
register_rigid : -check ${-is_image_arg\ $1}" && ${2=1}>=0 && isint(${3=0}) && $3>=0 && $3<=2"
-e[^-1] "Register source image$? with destination image $1, using rigid warp with smoothness $2."
-v - -pass$1 0 -equalize. -b. $2 -n. 0,255
-repeat {$!-1}
--equalize[$>] -b. $2 -n. 0,255
--phase_correlation. [-2] -rm..
-shift[$>] {^},0,$3 -rm.
-done -rm. -v +
#@gmic transition : [transition_shape],nb_added_frames>=0,100>=shading>=0,_single_frame_only={ -1=disabled | >=0 }
#@gmic : Generate a transition sequence between selected images.
#@gmic : Default values: 'shading=0' and 'single_frame_only=-1'.
#@gmic : $ image.jpg --mirror c 100%,100% -plasma. 1,1,6 -transition[0,1] [2],5
transition : -check ${-is_image_arg\ $1}" && $2>=0 && ${3=0}>=0 && $3<=100" -skip ${4=-1}
-v - frame={round($4)} s0=" and shading $3" s1=", shading $3 and single-frame-only "$frame -v +
-e[^-1] "Create transition sequence between image$? with $2 added frames, transition shape $1"${s{$4>0}}"."
-if {$!<2" || "!$2} -return -endif
-v - -to_colormode 0 -r ${-max_whd},100%,0,0,0.5,0.5
-pass$1 0 -norm. -r. [0],[0],[0],1,3 -n. 0,1 -mv. 0
-repeat {$!-2} -l[0,{$<+1},{$<+2}]
nm0={1,n}
-if $3 -repeat $2 -if {$4<0" || "$>==$frame}
val0={($>+0.5)/$2-$3%}
val1={($>+0.5)/$2+$3%}
--f[0] '(i-$val0)/($val1-$val0)' -c. 0,1
--j[2] [1],0,0,0,0,1,[-1] -rm..
-nm. $nm0\ ""#{1+$>}
-endif -done -else -repeat $2 -if {$4<0" || "$>==$frame}
--ge[0] {($>+0.5)/$2}
--j[2] [1],0,0,0,0,1,[-1] -rm..
-nm. $nm0\ ""#{1+$>}
-endif -done -endif
-mv[2] $!
-endl -done -rm[0] -v +
#@gmic transition3d : _nb_frames>=2,_nb_xtiles>0,_nb_ytiles>0,_axis_x,_axis_y,_axis_z,_is_antialias={ 0 | 1 }
#@gmic : Create 3d transition sequence between selected consecutive images.
#@gmic : 'axis_x', 'axis_y' and 'axis_z' can be set as mathematical expressions, depending on 'x' and 'y'.
#@gmic : Default values: 'nb_frames=10', 'nb_xtiles=nb_ytiles=3', 'axis_x=1', 'axis_y=1', 'axis_z=0' and 'is_antialias=1'.
#@gmic : $ image.jpg --blur 5 -transition3d 9 -display_rgba
transition3d : -check "isint(${1=10}) && $1>=2 && isint(${2=3}) && $2>0 && isint(${3=$2}) && $3>0" -skip ${4=1},${5=1},${6=0},${7=1}
-e[^-1] "Create 3d transition sequence between image$?, with $1 frames, $2x$3 tiles and rotation axis ($4,$5,$6).\n"
-v -
-if {$!<2} -return -endif
-slices 0 -to_rgb -r ${-max_whds},3
off=0 -repeat {$!-1} -l[{$>+$off},{$>+$off+1}]
-v + -e[] "\r > Generate transition from image "$>" to image "{$>+1}".    " -v -
$2,$3,1,1,'$4'
$2,$3,1,1,'$5'
$2,$3,1,1,'$6'
-a[-3--1] z
-permute. zxyc -r. 3,{$2*$3},1,1,-1
-repeat {h} rot$>={@0-2} -shift. 0,-1,0,0 -done
-rm.
--split_tiles[-2,-1] $2,$3 -mv[0,1] $!
N={$2*$3} i=0 y=0
-repeat $3
x=0
-repeat $2
lw={$i,w} lh={$i,h}
-imageplane3d[$i] -imageplane3d[$N] -r3d[$N] ${rot$i},-180 -c3d[$i,$N] -+3d[$i,$N]
x$i=$x y$i=$y x+=$lw i+=1
-done
y+=$lh
-done
-repeat {$1-2}
-repeat $N -r3d[$>] ${rot$>},{180/($1-1)} --+3d[$>] ${x$>},${y$>},0 -done
-+3d[-$N--1] -c3d.
-if $7
-i... {2*{-2,w}},{2*{-2,h}},1,3,-1
-*3d. 2 -j3d... [-1],50%,50%,0,1,2,0,0 -rm.
-to_rgba.. -replace_color.. 0,0,-1,-1,-1,255,0,0,0,0
-r.. [-1],[-1],1,100%,2
-else
-i... {-2,w},{-2,h},1,3,-1 -j3d... [-1],50%,50%,0,1,2,0,0 -rm.
-to_rgba.. -replace_color.. 0,0,-1,-1,-1,255,0,0,0,0
-endif
-done
-rm[0-{$N-1}]
-nm[1--2] {0,n}
off+={$1-2}
-endl -done
-v +
#@gmic video2files : input_filename,_output_filename,_first_frame>=0,_last_frame={ >=0 | -1=last },_frame_step>=1
#@gmic : Split specified input video file into image files, one for each frame.
#@gmic : First and last frames as well as step between frames can be specified.
#@gmic : Default values: 'output_filename=frame.png', 'first_frame=0', 'last_frame=-1' and 'frame_step=1'.
video2files : -check "isint(${3=0}) && $3>=0 && isint(${4=-1}) && ($4>=0 || $4==-1) && isint(${5=1}) && $5>=1" -skip ${2="frame.png"}
-e[^-1] "Split input video file '$1' into image frames '$2', with first frame $3, last frame $4, and frame step $5.\n"
-v -
frame=$3 stopflag=0
-do -l[]
-i "$1",$frame
-if $!
-o ${"-filename \"$2\","$frame} -rm
-v + -e[] "\r  > Frame ""#"$frame -v -
frame+=$5
-else stopflag=1
-endif
-onfail stopflag=1
-endl -while {!$stopflag" && "($frame<=$4" || "$4==-1)}
-v +
#@gmic :: PINK-library operators
_wrbytepnk :
-output_pink3d ${1}.pnk
_xpink :
na={-1,n}
filename=${-file_rand}
x_filename={/$filename}
prefix=pink.
-if {!${-is_windows}}
-x "which "${prefix}${1}" >/dev/null 2>&1"
-if {${}!=0} prefix=""
-x "which "$1" >/dev/null 2>&1"
-if {${}!=0} -v + -error "Executable (pink.)"$1" not found in PATH, status = "${}"!! Returning!!\n" -endif
-endif
-output_pink3d ${filename}.pnk -x ${prefix}${1}" "${filename}".pnk $2 "${filename}"_o.pnk >/dev/null 2>&1"
-else
-output_pink3d ${filename}.pnk -x $1" "${x_filename}".pnk $2 "${x_filename}"_o.pnk"
-endif
status=${}
-file_rm ${x_filename}.pnk
-if {$status!=0" && "['"$1"']!='seuilauto'} -v + -error "Exec status is "${status}"."
-elif ${filename}_o.pnk -i ${filename}_o.pnk -file_rm ${x_filename}_o.pnk -k. -nm. $na
-else -v + -error "Exec error!!"
-endif
_xpinks :
s={s} -if {$s>1} -s. c -endif
-repeat $! -l[$>]  -_xpink $1,"$2" -k. -endl -done
-if {$s>1} -a[-$s--1] c -endif
_xframe :
-line 0%,0%,100%,0% -line 0%,100%,100%,100% -line 0%,0%,0%,100% -line 100%,0%,100%,100%
#@gmic output_pink3d : filename
#@gmic : Save selected images as P5-coded PPM files (PINK extension for 3d volumetric images).
output_pink3d :
-e[^-1] "Output image$? as file '$1' (in 3d pink extension of P5-coded PPM format)."
-v - -if {$!==1} filename0="$1"
-else -repeat $! filename$>=${-filename\ "\"$1\"",$>} -done
-endif
-repeat $! -l[$>]
-if {d==1} -o. ppm:${filename$>}
-else
({'P5\n{w}\ {h}\ {d}\n255\n'})
--channels.. 0 -y. x -a[-2,-1] x
-o. raw:${filename$>},char
-rm.
-endif
-endl -done -v +
#@gmic pink
#@gmic : Pink wrapper name,p1, .. ,pn (requires the PINK library to be installed).
#@gmic : (http://pinkhq.com/)
#@gmic : prepares input, calls external "name input p1 ... pn output" and reads output (/tmp)
#@gmic : $ image.jpg --pink asfr,5 -pink[0] asf,5
#@gmic : $ image.jpg --blur 2 -pink maxima,4
pink : -v -
-if {$#>1} ({"'${2--1}'"}) -replace. {','},{"' '"} p={t} -rm. -else p=" " -endif
-v + -e[^-1] "Call pink package on image$? with cmd: \"$1 [img] "$p" [img]\"." -v -
-repeat $! -l[$>] -_xpinks $1,$p -endl -done -v +
#@gmic pink_grayskel : _connectivity={ 4 | 8 | 6 | 26 }, _lambda=0
#@gmic : (http://pinkhq.com/doxygen/grayskel_8c.html)
#@gmic : Grayscale homotopic skeleton (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'lambda=0'.
#@gmic : $ image.jpg --pink_grayskel , --pink_grayskel[0] ,10 --pink_grayskel[0] ,100 -append_tiles 2
pink_grayskel : -skip ${1=4},${2=0}
-check "${1=4}==4 || $1==8 || $1==6 || $1==26"
-repeat $! -l[$>] -_xpinks "grayskel","null $1 $2" -endl -done
#@gmic pink_heightmaxima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@gmic : (http://pinkhq.com/doxygen/heightmaxima_8c.html)
#@gmic : Heightmaxima filtering (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'height=1'.
#@gmic : $ image.jpg --blur 2 --pink_heightminima ,15 --pink_heightmaxima[0,1] ,15 --[-3,-1] --[-3,-1] -keep[-1,-2]
pink_heightmaxima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=1}
-e[^-1] "Filter by heightmaxima exec with connectivity $1 height $2."
-v - -repeat $! -l[$>]
s={s} -if {$s>1} -s. c -endif
-repeat $! -l[$>] -_xpink "heightmaxima","$1 $2" -k. -endl -done
-if {$s>1} -a[-$s--1] c -endif
-endl -done -v +
#@gmic pink_heightminima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@gmic : (http://pinkhq.com/doxygen/heightminima_8c.html)
#@gmic : Heightminima filtering (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'height=1'.
#@gmic : $ image.jpg --blur 2 --pink_heightminima ,15 --pink_heightmaxima[0,1] ,15 --[-3,-1] --[-3,-1] -keep[-1,-2]
pink_heightminima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=1}
-e[^-1] "Apply filter by heightminima exec with connectivity $1 height $2."
-v - -repeat $! -l[$>]
s={s} -if {$s>1} -s. c -endif
-repeat $! -l[$>] -_xpink "heightminima","$1 $2" -k. -endl -done
-if {$s>1} -a[-$s--1] c -endif
-endl -done -v +
#@gmic pink_htkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@gmic : (http://pinkhq.com/doxygen/htkern_8c.html)
#@gmic : (http://pinkhq.com/doxygen/htkernu_8c.html)
#@gmic : Grayscale ultimate homotopic thinning/thickening without condition (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'type=""'.
#@gmic : $ image.jpg --pink_htkern ,u --pink_htkern[0] , ---[-1,-2] -remove[0]
pink_htkern : -skip ${1=4},${2=""}
-repeat $! -l[$>] -_xpinks htkern$2,"null $1" -endl -done
#@gmic pink_lvkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@gmic : (http://pinkhq.com/doxygen/lvkern_8c.html)
#@gmic : (http://pinkhq.com/doxygen/lvkernu_8c.html)
#@gmic : Grayscale ultimate leveling thinning/thickening without condition (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'type=""'.
#@gmic : $ image.jpg -pink_lvkern ,u
pink_lvkern : -skip ${1=4},${2=""}
-check "${1=4}==4 || $1==8 || $1==6 || $1==26"
-repeat $! -l[$>] -_xpinks lvkern${2},"null $1" -endl -done
#@gmic pink_reg_minima : _connectivity={ 4 | 8 | 6 | 26 }
#@gmic : (http://pinkhq.com/doxygen/minima_8c.html)
#@gmic : Regional minima (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4'.
#@gmic : $ image.jpg --blur 2 -pink_reg_minima ,
pink_reg_minima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26"
-e[^-1] "Compute regional minima exec with connectivity $1."
-v - -repeat $! -l[$>]
s={s} -if {$s>1} -s. c -endif
-repeat $! -l[$>]  -_xpink "minima","$1" -k. -endl -done
-if {$s>1} -a[-$s--1] c -endif
-endl -done -v +
#@gmic pink_skelcurv : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@gmic : (http://pinkhq.com/doxygen/skelcurv_8c.html)
#@gmic : Curvilinear binary skeleton guided by a priority function or image (requires the PINK library to be installed).
#@gmic : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% {w},{h} -fill. 'if(x>w/2,255,0)' tp=${-path_tmp} -output. ${tp}/inhibit.pgm -remove. --pink_skelcurv[0] , --pink_skelcurv[0] ,,${tp}/inhibit.pgm -exec "rm "${tp}"/inhibit.pgm"
#@gmic : $ image.jpg -threshold 50% --pink_skelcurv , --pink_skelcurv.. ,8
pink_skelcurv : -skip ${1=0},${2=4},${3=""}
-e[^-1] "Curvilinear binary skeleton guided by a priority function or image from image$?, prio=$1, connectivity=$2, inhibit=$3."
-repeat $! -l[$>] -_xpinks "skelcurv","$1 $2 $3" -endl -done
#@gmic pink_skelend : _connectivity={ 4 | 8 | 6 | 26 },_n=0
#@gmic : (http://pinkhq.com/doxygen/skelend_8c.html)
#@gmic : Homotopic skeleton of a 2d or 3d binary image with dynamic detection of end points (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'n=0'.
#@gmic : $ image.jpg -threshold 50% --pink_skelend , --pink_skelend.. ,-1
pink_skelend : -skip ${1=4},${2=0}
-repeat $! -l[$>] -_xpinks "skelend","$1 $2" -endl -done
#@gmic pink_skeleton : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@gmic : (http://pinkhq.com/doxygen/skeleton_8c.html)
#@gmic : Ultimate binary skeleton guided by a priority image (requires the PINK library to be installed).
#@gmic : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% --pink_skeleton. ,
pink_skeleton : -skip ${1=0},${2=4},${3=""}
-repeat $! -l[$>] -_xpinks "skeleton","$1 $2 $3" -endl -done
#@gmic pink_skelpar : _algorithm={0..29},_nsteps=_1,_inhibit=""
#@gmic : (http://pinkhq.com/doxygen/skelpar_8c.html)
#@gmic : Parallel binary skeleton (requires the PINK library to be installed).
#@gmic : Default values: 'algorithm=4', 'nsteps=-1' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% --pink_skelpar. 0 --pink_skelpar. 2
pink_skelpar : -skip ${1=4},${2=-1},${3=""}
-repeat $! -l[$>] -_xframe -_xpinks "skelpar","$1 $2 $3" -endl -done
#@gmic pink_wshed : _connectivity={ 4 | 8 | 6 | 26 },_inverse={ 0 | 1 },_height=0
#@gmic : (http://pinkhq.com/doxygen/wshedtopo_8c.html)
#@gmic : Watershed (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4', 'inverse=0' and 'height=0'.
#@gmic : $ image.jpg --pink_wshed ,1,5 -pink_wshed[0] ,,5
pink_wshed : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=0},${3=0}
-e[^-1] "Compute wshedtopo exec with connectivity $1 inversion $2 height $3."
-v - -repeat $! -l[$>]
s={s} -if {$s>1} -s. c -endif
-if {d==1}
-check "${1=4}==4 || $1==8"
-repeat $! -l[$>]
-if {$2!=0} -negative -endif
-f max(min(i,255),0)
-if {$3>=0} -pink heightminima,$1,$3 -endif
-pink wshedtopo,$1
-if {$2!=0} -negative -endif
-endl -done
-else
-check "$1==6 || $1==26"
-repeat $! -l[$>]
-if {$2!=0} -negative -endif
-f max(min(i,255),0)
-if {$3>=0}
-pink heightminima,$1,$3
-endif
-pink wshedtopo,$1
-if {$2!=0} -negative -endif
-endl -done
-endif
-if {$s>1} -a[-$s--1] c -endif
-endl -done -v +
#@gmic :: Convenience functions
#@gmic alert : _title,_message,_label_button1,_label_button2,...
#@gmic : Display an alert box and wait for user's choice.
#@gmic : If a single image is in the selection, it is used as an icon for the alert box.
#@gmic : Default values: 'title=[G'MIC Alert]' and 'message=This is an alert box.'.
alert : -skip "${1=[G"{`39`}"MIC Alert]},${2=This is an alert box.},${3=OK}"
-if {$!==1}
-e[0--3] "Display alert box, with image$?, title '$1', message '$2' and buttons '${3--1}'."
-else
-e[0--3] "Display alert box, with title '$1', message '$2' and buttons '${3--1}'."
-endif
-v -
-if {$!==1} logo= -else logo=[] -endif
--l$logo
-if {$!==1} -to_rgb
-else
64,64 -polygon 3,50%,10%,10%,90%,90%,90%,1,1 -b 3 ->= 50%
--erode. 5 --. [-2] -==. 0
-polygon. 4,47%,43%,53%,43%,53%,66%,47%,66%,1,0 -circle. 50%,76%,2,1,0
--*[0] 255 [-1] 100%,100% -a[-3--1] c --. '3*(y-h/2)'
-*. [-2] -rm.. -*[0] 255 -rv -a c
-drop_shadow 3,3,1 -i[0] 100%,100%,1,3,200 -blend alpha
-endif
-channels -1,2
$=arg
-repeat {$#-2} label=${arg{$>+3}} 0 -t. $label,0,0,16,1,-200 -done
-r[^0] {min(128,max(64,${-max_w[^0]}+12))},{min(48,max(24,${-max_h[^0]}+12))},1,1,0,0,0.5,0.5
-+[^0] 200 -to_rgb[^0]
-mv[0] $!
[0],[0],1,1,'(y-h/2)' -*. -2 -c. -30,30 -+[0--3] [-1] -rm. -c[^-1] 0,255
-repeat {$!-1} -l[$<]
--rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
-rectangle. 1,1,{w-2},{h-2},1,0xFFFFFFFF,0
-line. 2,{h-3},{w-3},{h-3},1,150 -line. {w-3},{h-3},{w-3},2,1,150
-line. 1,1,{w-3},1,1,255 -line. 1,1,1,{h-3},1,255
-rectangle. 4,4,{w-5},{h-5},1,0xAAAAAAAA,0
--shift.. 1,1,0,0,2
-rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
-rectangle. 1,1,{w-2},{h-2},1,0xFFFFFFFF,150
-rectangle. 4,4,{w-5},{h-5},1,0xAAAAAAAA,0
-rectangle... 0,0,100%,100%,1,0xFFFFFFFF,0
-line... 1,{h-2},{w-2},{h-2},1,150 -line... {w-2},{h-2},{w-2},1,1,150
-line... 0,0,{w-2},0,1,255 -line... 0,0,0,{h-2},1,255
-i[0] 100%,100% -=[0] 1,0,0
-a c -endl -done
--l
-channels 0,3 -sh 1,100% --[50%--1] 200 -rm[50%--1] -frame 8,8,0
-if {$!<6} -a[^-1] x -else -append_tiles[^-1] , -endif
0 -t. "$2",0,0,16,1,0,-200,-200,-200 -r. {w+16},{h+8},1,4,0
-a[-2,-1] x,0.5 -rv -a y,0.5
-sh 1,100% -+. 200 -rm.
-rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
-line 0,0,{w-2},0,1,0,255,255,255 -line 0,0,0,{h-2},1,0,255,255,255
-endl
-rm..
--channels. 0
(0,{w-1}) (0;{-2,h-1}) -r[-2,-1] [-3],3 -a[-2,-1] c -round. -rv[-2,-1] -*[-2,-1]
-discard. 0 -r. {h/2},2,1,1,-1
-channels.. 1,3 -rv[-2,-1]
100%,100% -repeat {-3,w} x0={-3,i($>,0)} y0={-3,i($>,1)} -rectangle. $x0,$y0,{$x0+{0,w}-1},{$y0+{0,h}-1},1,{1+$>} -done
-a[-2,-1] c
-repeat 9 -if {!{*$>}} disp=$> -break -endif -done
-if {!narg($disp)} -v + -error[0--4] "Command '-alert': Cannot open display window for alert box." -endif
selected={if($#==3,0,-1)} clicked=-1
-do
--channels. 0,2
-if {$clicked>=0}
x0={-3,i($clicked,0)} y0={-3,i($clicked,1)}
-sh[$clicked] 7,9
-j.. [-1],$x0,$y0 -rm.
-elif {$selected>=0}
x0={-3,i($selected,0)} y0={-3,i($selected,1)}
-sh[$selected] 4,6
-j.. [-1],$x0,$y0 -rm.
-endif
-w$disp. 100%,100%,0,"$1" -rm. -wait
xm={*$disp,x} ym={*$disp,y} bm={{*$disp,b}&1} val={i($xm,$ym,0,3)}
-if {$bm" && "$val} clicked={$val-1}
-elif {$bm" && "!$val" && "$clicked>=0} selected=$clicked clicked=-1
-elif {!$bm" && "$clicked>=0" && "$clicked==$val-1} -break
-endif
-if {*$disp,ARROWRIGHT} selected={($selected+1)%{-2,w}} -wait -1
-elif {*$disp,ARROWLEFT} selected={($selected-1)%{-2,w}+($selected==-1)} -wait -1
-elif {$selected>=0" && "{*$disp,ENTER}} clicked=$selected -break
-endif
-while {{*$disp}" && "!{*$disp,ESC}}
-w$disp 0 -rm -u $clicked
-endl
-v +
#@gmic arg : n>=1,_arg1,...,_argN
#@gmic : Return the n-th argument of the specified argument list.
arg : -check "isint($1) && ($1)>0"
-v - $=arg -u ${arg{1+($1)}} -v +
#@gmic arg2var : variable_name,argument_1,...,argument_N
#@gmic : For each i in [1..N], set 'variable_name$i=argument_i'.
#@gmic : The variable name should be global to make this command useful (i.e. starts by an underscore).
arg2var :
-v - $=arg -u {$#-1} -repeat ${} $1{1+$>}=${arg{2+$>}} -done -v +
#@gmic autocrop_coords : value1,value2,... | auto
#@gmic : Return coordinates (x0,y0,z0,x1,y1,z1) of the autocrop that could be performed on the latest of the selected images.
#@gmic : Default value: 'auto'
autocrop_coords : -skip ${1=auto}
-v -
is_auto={['"$1"']=='auto'}
w={w} h={h} d={d}
value={i(w-1,h-1,d-1)} --=. {1+$value},100%,100%,100% -_autocrop$is_auto. ${1--1} -=. $value,100%,100%,100%
x0={$w-w} y0={$h-h} z0={$d-d} -rm.
--_autocrop$is_auto. ${1--1}
x1={$x0+w-1} y1={$y0+h-1} z1={$z0+d-1} -rm.
-u $x0,$y0,$z0,$x1,$y1,$z1
-v +
_autocrop0 : -autocrop $*
_autocrop1 : -skip $* -autocrop
#@gmic average_color
#@gmic : Return the average color of the latest of the selected images.
average_color :
-v -
res=""
-repeat {s-1} -sh. {1+$>} res=$res,{ia} -rm. -done
-sh. 0 -u {ia}$res -rm.
-v +
#@gmic basename : file_path,_variable_name_for_folder
#@gmic : Return the basename of a file path, and opt. its folder location.
#@gmic : When specified 'variable_name_for_folder' must starts by an underscore
#@gmic : (global variable accessible from calling function).
basename : -skip ${2=unused}
-v -
-l[] ({"'$1'"}) -replace 92,47 -s +,47
-if {i==47} -a y $2={t} -u ""
-elif {$!==1} -u {t} $2=""
-else -a[^-1] y -u {t} $2={-2,t}
-endif
-rm -endl
-v +
#@gmic bin : binary_int1,...
#@gmic : Print specified binary integers into their octal, decimal, hexadecimal and string representations.
bin :
-v - dec=${-bin2dec\ ${^0}} -v +
-e[^-1] "Convert binary integer"${-arg\ 1+($#>1),"",s}" '${^0}' to octal '"${-dec2oct\ $dec}"',
decimal '"$dec"', hexadecimal '"${-dec2hex\ $dec}"' and string '"${-dec2str\ $dec}"'."
#@gmic bin2dec : binary_int1,...
#@gmic : Convert specified binary integers into their decimal representations.
bin2dec :
-v - res=${-_$0\ $1} -repeat {$#-1} res=$res,${-_$0\ ${-arg\ $>+2,${^0}}} -done -u $res -v +
_bin2dec :
({'${-struncase\ $1}'})
is_negative=0
-if {i[0]==45} -z. 1,100% is_negative=1 -endif
-f. "if(i>=48 && i<=49,(i-48)*2^(w-1-x),nan)"
-u {if($is_negative,-1,1)*{is}}
-rm.
compress_gmic :
-v -
-s -,10 N=$!
-ap -_compress_gmic
-s -,10 -i[1--2] (10) -a y
-v +
_compress_gmic :
-if {i==_'#'}
-if {!same([{^}],'#@gmic',6)" || (i[6]!=_' ' && i[6]!=_':')"} -rm. (10) -endif
-else
-l. -s +,32,35 -if {$!>2} -k[0] -endif -a y -endl
-autocrop. 32 -if {!w} -rm. (10) -endif
-endif
compress_gmic_gimp :
-v -
-s -,10 N=$!
-ap -_compress_gmic_gimp
-s -,10 -i[1--2] (10) -a y
-v +
_compress_gmic_gimp :
-if {i==_'#'}
-if {!same([{^}],'#@gimp',6)} -rm. (10) -endif
-else
-l. -s +,32,35 -if {$!>2} -k[0] -endif -a y -endl
-autocrop. 32 -if {!w} -rm. (10) -endif
-endif
#@gmic dec : decimal_int1,...
#@gmic : Print specified decimal integers into their binary, octal, hexadecimal and string representations.
dec :
-e[^-1] "Convert decimal integer"${-arg\ 1+($#>1),"",s}" '${^0}' to binary '"${-dec2bin\ ${^0}}"',"\
" octal '"${-dec2oct\ ${^0}}"', hexadecimal '"${-dec2hex\ ${^0}}"' and string '"${-dec2str\ ${^0}}"'."
#@gmic dec2str : decimal_int1,...
#@gmic : Convert specifial decimal integers into its string representation.
dec2str :
-v - -u {`[${^0}]`} -v +
#@gmic dec2bin : decimal_int1,...
#@gmic : Convert specified decimal integers into their binary representations.
dec2bin :
-v - res=${-_$0\ $1} -repeat {$#-1} res=$res,${-_$0\ ${-arg\ $>+2,${^0}}} -done -u $res -v +
_dec2bin : -check isint($1)
res="" r={abs($1)}
-do res={$r%2}$res r={int($r/2)} -while $r
-u ${-arg\ 1+($1>=0),-,""}$res
#@gmic dec2hex : decimal_int1,...
#@gmic : Convert specified decimal integers into their hexadecimal representations.
dec2hex :
-v - res=${-_$0\ $1} -repeat {$#-1} res=$res,${-_$0\ ${-arg\ $>+2,${^0}}} -done -u $res -v +
_dec2hex : -check isint($1)
res="" r={abs($1)}
-do res=${-_dec2hex_{$r%16}}$res r={int($r/16)} -while $r
-u ${-arg\ 1+($1>=0),-,""}$res
_dec2hex_0 : -u 0
_dec2hex_1 : -u 1
_dec2hex_2 : -u 2
_dec2hex_3 : -u 3
_dec2hex_4 : -u 4
_dec2hex_5 : -u 5
_dec2hex_6 : -u 6
_dec2hex_7 : -u 7
_dec2hex_8 : -u 8
_dec2hex_9 : -u 9
_dec2hex_10 : -u a
_dec2hex_11 : -u b
_dec2hex_12 : -u c
_dec2hex_13 : -u d
_dec2hex_14 : -u e
_dec2hex_15 : -u f
#@gmic dec2oct : decimal_int1,...
#@gmic : Convert specified decimal integers into their octal representations.
dec2oct :
-v - res=${-_$0\ $1} -repeat {$#-1} res=$res,${-_$0\ ${-arg\ $>+2,${^0}}} -done -u $res -v +
_dec2oct : -check isint($1)
res="" r={abs($1)}
-do res={$r%8}$res r={int($r/8)} -while $r
-u ${-arg\ 1+($1>=0),-,""}$res
#@gmic fact : value
#@gmic : Return the factorial of the specified value.
fact : -check isint($1)
-v - res=1 -repeat $1 res*={($>+1)} -done -u $res -v +
#@gmic fibonacci : N>=0
#@gmic : Return the Nth number of the Fibonacci sequence.
fibonacci : -check "$1>=0"
-u {N=$1;if(N<2,N,for(n=N;F0=0;F1=1,n=n-1,F2=F0+F1;F0=F1;F1=F2))}
#@gmic file_mv : filename_src,filename_dest
#@gmic : Rename or move a file from a location $1 to another location $2.
file_mv :
-e[^-1] "Move file '$1' to location '$2'."
-v - -if ${-is_windows} -x "move "$1" "$2 -else -x "mv "$1" "$2 -endif -v +
#@gmic file_rand
#@gmic : Return a random filename for storing temporary data.
file_rand :
-v -
-do filename=${-path_tmp}gmic$_pid{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}{round(u(0,9))}
-while $filename
-u $filename
-v +
#@gmic file_rm : filename
#@gmic : Delete a file.
file_rm :
-e[^-1] "Remove file '$1'."
-v -
-if ${-is_windows}
1 -nm. "$1" dir={f} base={b} ext={x} -rm. com=""
-if {narg($dir)} com="cd \""$dir"\\\" && " -endif
-if {narg($ext)} com=${com}"del \""$base.$ext"\"" -else com=${com}"del \""$base"\"" -endif
-x $com
-else
-x "rm -f \"$1\""
-endif
-v +
#@gmic filename : filename,_number1,_number2,...,_numberN
#@gmic : Return a filename numbered with specified indices.
filename : -skip "${1=default}"
-v -
-if {$#==1} -u "$1"
-else
(${2--1}) -nm. "$1" -u {f}{b}
-repeat {w}
-u ${}_{int(i/100000)%10}{int(i/10000)%10}{int(i/1000)%10}{int(i/100)%10}{int(i/10)%10}{i%10}
-shift. -1
-done
-if {narg({'{x}'})} -u ${}.{x} -endif
-rm.
-endif
-v +
#@gmic files : _mode,path : (+)
#@gmic : Return the list of files and/or subfolders from specified path.
#@gmic : 'path' can be eventually a matching pattern.
#@gmic : 'mode' can be { 0=files only | 1=folders only | 2=files + folders }.
#@gmic : Add '3' to 'mode' to return full paths instead of relative paths.
#@gmic : Default value: 'mode=5'.
#@gmic fitratio_wh : min_width,min_height,ratio_wh
#@gmic : Return a 2d size 'width,height' which is bigger than 'min_width,min_height' and has the specified w/h ratio.
fitratio_wh :
-v - -if {$3*$2>$1} -u {int($3*$2)},$2 -else -u $1,{int($1/$3)} -endif -v +
#@gmic fitscreen : width,height,_depth,_minimal_size[%],_maximal_size[%]
#@gmic : Return the 'ideal' size WxH for a window intended to display an image of specified size on screen.
fitscreen : -check "$1>0 && $2>0 && ${3=1}>0 && ${4=128}>0 && ${5=85%}>0"
-v -
mp=${-is_percent\ $4}
mw={if($mp,int({*,u}*$4),$4)}
mh={if($mp,int({*,v}*$4),$4)}
Mp=${-is_percent\ $5}
Mw={if($Mp,int({*,u}*$5),$5)}
Mh={if($Mp,int({*,v}*$5),$5)}
w={if($3>1,$1+$3,$1)}
h={if($3>1,$2+$3,$2)}
-if {$w<$mw} h={max(1,int($h*$mw/$w))} w=$mw -endif
-if {$h<$mh} w={max(1,int($w*$mh/$h))} h=$mh -endif
-if {$w>$Mw} h={max(1,int($h*$Mw/$w))} w=$Mw -endif
-if {$h>$Mh} w={max(1,int($w*$Mh/$h))} h=$Mh -endif
w={max($w,$mw)}
h={max($h,$mh)}
-u $w,$h
-v +
#@gmic fps
#@gmic : Return the number of time this function is called per second, or -1 if this info is not yet available.
#@gmic : Useful to display the framerate when displaying animations.
fps :
-v -
-if {narg($_fps_fps)}
dt={$|-$_fps_time}
-if {$dt>1} _fps_fps={round($_fps_nbframes/$dt)} _fps_time=$| _fps_nbframes=0 -endif
-u $_fps_fps
_fps_nbframes+=1
-else _fps_nbframes=0 _fps_time=$| _fps_fps=-1 -u -1
-endif
-v +
#@gmic gcd : a,b
#@gmic : Return the GCD (greatest common divisor) between a and b.
gcd : -check "isint($1) && isint($2) && $1*$2!=0"
-v - -_gcd {max(abs($1),abs($2))},{min(abs($1),abs($2))} -v +
_gcd :
r={$1%$2} -if $r -u ${-_gcd\ $2,$r} -else -u $2 -endif
#@gmic hex : hexadecimal_int1,...
#@gmic : Print specified hexadecimal integers into their binary, octal, decimal and string representations.
hex :
-v - dec=${-hex2dec\ ${^0}} -v +
-e[^-1] "Convert hexadecimal integer"${-arg\ 1+($#>1),s,""}" '${^0}' to binary '"${-dec2bin\ $dec}"',
octal '"${-dec2oct\ $dec}"', decimal '"$dec"' and string '"${-dec2str\ $dec}"'."
#@gmic hex2dec : hexadecimal_int1,...
#@gmic : Convert specified hexadecimal integers into their decimal representations.
hex2dec :
-v - res=${-_$0\ $1} -repeat {$#-1} res=$res,${-_$0\ ${-arg\ $>+2,${^0}}} -done -u $res -v +
_hex2dec :
({'${-struncase\ $1}'})
is_negative=0
-if {i[0]==45} -z. 1,100% is_negative=1 -endif
-f. "if(i>=48 && i<=57,i-48,if(i>=97 && i<=102,i-87,nan))*16^(w-1-x)"
-u {if($is_negative,-1,1)*{is}}
-rm.
#@gmic hex2img : "hexadecimal_string"
#@gmic : Insert new image 1xN at the end of the list with values specified by the given hexadecimal-encoded string.
hex2img :
-v - ({'"$1"'}) 1,{w/2}
-f. "*
from_char(x) = x>=48 && x<=57?x - 48:x-87;
off = 2*y;
from_char(i[#-2,off])*16 + from_char(i[#-2,off+1])"
-rm.. -v +
#@gmic hex2str : hexadecimal_string
#@gmic : Convert specified hexadecimal string into a string.
hex2str : -skip ${1=""}
-if {!narg("$1")} -u "" -return -endif
-v - ({'$*'}) -if {w<2} -rm. -v + -u "" -return -endif
-f. 'v=i-if(i>=97,87,48);if(x%2,v,v*16)' -r. 2,{int(w/2)},1,1,-1 -cumulate. x -z. 1,1
-u {t} -rm. -v +
#@gmic img2hex
#@gmic : Return representation of last image as an hexadecimal-encoded string.
#@gmic : Input image must have values that are integers in [0,255].
img2hex :
-v - whds={w},{h},{d},{s} -y. 2,{h}
-f.. "*
to_char(x) = x>=0 && x<=9?48 + x:87 + x;
i(#-1,0,y) = to_char(int(i/16));
i(#-1,1,y) = to_char(i%16);
i"
-u {t} -rm. -r. $whds,-1 -v +
#@gmic img2str
#@gmic : Return the content of the latest of the selected image as a special G'MIC input string.
img2str :
-v -
-u "("
-repeat {s} c=$>
-repeat {d} z=$>
-repeat {h} y=$>
--z. 0,$y,$z,$c,100%,$y,$z,$c
-u ${}{^}
-rm.
-if {$y!=h-1} -u ${}; -endif
-e ${}
-done
-if {$z!=d-1} -u ${}/ -endif
-done
-if {$c!=s-1} -u ${}^ -endif
-done
-u ${}")"
-v +
#@gmic img2text : _line_separator
#@gmic : Return text contained in a multi-line image.
#@gmic : Default value: 'line_separator= '.
img2text : -skip "${1= }"
-v - --l -s y -s -,0 -y x -if {$!>1} -i[1--2] ({'"$1"'}) -endif -a x -u {0,t} -rm -endl -v +
#@gmic img82hex
#@gmic : Convert selected 8bits-valued vectors into their hexadecimal representations (ascii-encoded).
img82hex :
-e[^-1] "Convert 8bits-valued vector$? into hexadecimal representations (ascii-encoded)."
-v - -% 256 -y
-repeat $!
--f[$>] 'v=int(i)&15;v+if(v<10,48,87)'
-f[$>] 'v=int(i)>>4;v+if(v<10,48,87)'
-a[$>,-1] x
-done -v +
#@gmic hex2img8
#@gmic : Convert selected hexadecimal representations (ascii-encoded) into 8bits-valued vectors.
hex2img8 :
-e[^-1] "Convert hexadecimal representation$? (ascii-encoded) into 8bits-valued vectors."
-v - -repeat $!
-s. x,2 -f[-2,-1] 'if(i>=97,i-87,i-48)' -*.. 16 -+[-2,-1]
-mv. 0 -done -v +
#@gmic is_3d
#@gmic : Return 1 if all of the selected image are 3d objects, 0 otherwise.
is_3d :
-v - -u 1 -l -check3d 1 -onfail -u 0 -endl -v +
_is_3d :
-v - -u {"h>6 && int(i[0])==67 && int(i[1])==73 && int(i[2])==109 && int(i[3])==103 && int(i[4])==51 && int(i[5])==100"} -v +
#@gmic is_image_arg : string
#@gmic : Return 1 if specified string looks like '[ind]'.
is_image_arg : -skip "${1=;}"
-v - asc={'"$1"'} -u {arg(1,$asc)==_'['" && "arg(-1,$asc)==_']'" && "min($asc)>=45" && "max($asc)<=122} -v +
#@gmic is_percent : string
#@gmic : Return 1 if specified string ends with a '%', 0 otherwise.
is_percent :
-v - -u {arg(-1,{'"$1"'})==37} -v +
#@gmic is_windows
#@gmic : Return 1 if current computer OS is Windows, 0 otherwise.
is_windows :
-v - -u {narg($OS)==1" && "narg($WINDIR)==1} -v +
#@gmic mad
#@gmic : Return the MAD (Maximum Absolute Deviation) of the last selected image.
#@gmic : The MAD is defined as MAD = med_i|x_i-med_j(x_j)|
mad :
-v - -if $! ---. {ic} -abs. -u {1.4826*ic} -rm. -else -u 0 -endif -v +
#@gmic max_w
#@gmic : Return the maximal width between selected images.
max_w :
-v - -u {arg(1,${-_max_whds\ 4})} -v +
#@gmic max_h
#@gmic : Return the maximal height between selected images.
max_h :
-v - -u {arg(2,${-_max_whds\ 4})} -v +
#@gmic max_d
#@gmic : Return the maximal depth between selected images.
max_d :
-v - -u {arg(3,${-_max_whds\ 4})} -v +
#@gmic max_s
#@gmic : Return the maximal spectrum between selected images.
max_s :
-v - -u {arg(4,${-_max_whds\ 4})} -v +
#@gmic max_wh
#@gmic : Return the maximal wxh size of selected images.
max_wh :
-v - -_max_whds 2 -v +
#@gmic max_whd
#@gmic : Return the maximal wxhxd size of selected images.
max_whd :
-v - -_max_whds 3 -v +
#@gmic max_whds
#@gmic : Return the maximal wxhxdxs size of selected images.
max_whds :
-v - -_max_whds 4 -v +
_max_whds :
w=0 h=0 d=0 s=0
-repeat $!
w={max($w,w)}
h={max($h,h)}
d={max($d,d)}
s={max($s,s)}
-mv. 0 -done
-if {$1>=4} -u $w,$h,$d,$s
-elif {$1==3} -u $w,$h,$d
-elif {$1==2} -u $w,$h
-else -u $w
-endif
#@gmic med
#@gmic : Return the median value of the last selected image.
med :
-v - -u {ic} -v +
#@gmic color_med
#@gmic : Return the median color value of the last selected image.
color_med :
-v - -u "" s="" -repeat {s} --channels. $> -u ${}$s${-med.} s=, -rm. -done -v +
#@gmic min_w
#@gmic : Return the minimal width between selected images.
min_w :
-v - -u {arg(1,${-_min_whds\ 4})} -v +
#@gmic min_h
#@gmic : Return the minimal height between selected images.
min_h :
-v - -u {arg(2,${-_min_whds\ 4})} -v +
#@gmic min_d
#@gmic : Return the minimal depth between selected images.
min_d :
-v - -u {arg(3,${-_min_whds\ 4})} -v +
#@gmic min_s
#@gmic : Return the minimal s size of selected images.
min_s :
-v - -_min_s ${-_min_whds\ 4} -v +
_min_s :
-u $4
#@gmic min_wh
#@gmic : Return the minimal wxh size of selected images.
min_wh :
-v - -_min_whds 2 -v +
#@gmic min_whd
#@gmic : Return the minimal wxhxd size of selected images.
min_whd :
-v - -_min_whds 3 -v +
#@gmic min_whds
#@gmic : Return the minimal wxhxdxs size of selected images.
min_whds :
-v - -_min_whds 4 -v +
_min_whds :
w={w} h={h} d={d} s={s}
-repeat $!
w={min($w,w)}
h={min($h,h)}
d={min($d,d)}
s={min($s,s)}
-mv. 0 -done
-if {$1>=4} -u $w,$h,$d,$s
-elif {$1==3} -u $w,$h,$d
-elif {$1==2} -u $w,$h
-else -u $w
-endif
#@gmic normalize_filename : filename
#@gmic : Return a "normalized" version of the specified filename, without spaces and capital letters.
normalize_filename :
-v - ({'"$1"'}) -f. 'if(i>=65&&i<=90,i+32,if(i==32,95,i))' -u {t} -rm. -v +
#@gmic oct : octal_int1,...
#@gmic : Print specified octal integers into their binary, decimal, hexadecimal and string representations.
oct :
-v - dec=${-oct2dec\ ${^0}} -v +
-e[^-1] "Convert octal integer"${-arg\ 1+($#>1),"",s}" '${^0}' to binary '"${-dec2bin\ $dec}"', decimal '"$dec"',
hexadecimal '"${-dec2hex\ $dec}"' and string '"${-dec2str\ $dec}"'."
#@gmic oct2dec : octal_int1,...
#@gmic : Convert specified octal integers into their decimal representations.
oct2dec :
-v - res=${-_$0\ $1} -repeat {$#-1} res=$res,${-_$0\ ${-arg\ $>+2,${^0}}} -done -u $res -v +
_oct2dec :
({'${-struncase\ $1}'})
is_negative=0
-if {i[0]==45} -z. 1,100% is_negative=1 -endif
-f. "if(i>=48 && i<=55,(i-48)*8^(w-1-x),nan)"
-u {if($is_negative,-1,1)*{is}}
-rm.
#@gmic padint : number,_size>0
#@gmic : Return a integer with 'size' digits (eventually left-padded with '0').
padint : -check "isint($1)" -skip ${2=4}
-v - -u "" -repeat $2 -u ${}{int($1/10^$<)%10} -done -v +
#@gmic path_gimp
#@gmic : Return a path to store GIMP configuration files for one user (whose value is OS-dependent).
path_gimp :
-v -
-if {!narg({'$_path_gimp'})}
-if {narg({'${GIMP2_DIRECTORY}'})} _path_gimp=${GIMP2_DIRECTORY}
-elif {narg({'${USERPROFILE}'})} _path_gimp=${USERPROFILE}
-elif {narg({'${HOME}'})} _path_gimp=${HOME}
-endif
-if ${-is_windows} sep=\\ -else sep=/ -endif
-if $_path_gimp$sep.gimp-2.8${sep}pluginrc _path_gimp=$_path_gimp$sep.gimp-2.8$sep
-elif $_path_gimp$sep.gimp-2.6${sep}pluginrc _path_gimp=$_path_gimp$sep.gimp-2.6$sep
-else _path_gimp=${-path_tmp}
-endif
-endif
-u $_path_gimp
-v +
#@gmic path_tmp
#@gmic : Return a path to store temporary files (whose value is OS-dependent).
path_tmp :
-v -
-if {!narg({'$_path_tmp'})}
-if {narg({'${TMP}'})} _path_tmp=${TMP}
-elif {narg({'${TEMP}'})} _path_tmp=${TEMP}
-elif {narg({'${TMPDIR}'})} _path_tmp=${TMPDIR}
-elif {narg({'${HOME}'})} _path_tmp="/tmp"
-endif
-if ${-is_windows} _path_tmp=$_path_tmp{`92`} -else _path_tmp=$_path_tmp/ -endif
-endif
-u $_path_tmp
-v +
#@gmic region_feature : region_label,feature,_default_value
#@gmic : Return feature for a specified region.
#@gmic : This function requires two images [img,region_label] in the selection.
#@gmic : Argument 'feature' is a string that corresponds to the way the feature would
#@gmic : be asked for the entire image.
#@gmic : Default value: 'default_value=0'.
#@gmic : $ image.jpg --luminance -quantize. 2 -label. 0,1 mean=${"-region_feature[0,1] 10,\"{ia}\""} sum=${"-region_feature[0,1] 10,\"{is}\""}
region_feature : -skip "${3=0}"
-v -
s={-2,s} --channels. 0 -==. $1 -^. -1 --. 1 -r. [-3] -+. [-3]
-l.
-s. -,inf -a y
-if $! -r. 1,{h/$s},1,$s,-1 -u $2 -rm.
-else -u $3
-endif
-endl
-v +
#@gmic reset
#@gmic : Reset global parameters of the interpreter environment.
reset :
-e[^-1] "Reset global parameters of the interpreter environment."
-v -1 -db3d -m3d -md3d -f3d -l3d -sl3d -ss3d -v +
#@gmic RGB
#@gmic : Return a random int-valued RGB color.
RGB :
-v - -u {round(u(255))},{round(u(255))},{round(u(255))} -v +
#@gmic RGBA
#@gmic : Return a random int-valued RGBA color.
RGBA :
-v - -u {round(u(255))},{round(u(255))},{round(u(255))},{round(u(255))} -v +
#@gmic str : string
#@gmic : Print specified string into its binary, octal, decimal and hexadecimal representations.
str : -skip $1
-v - dec={'$*'} -v +
-e[^-1] "Convert string '$*' to binary '"${-dec2bin\ $dec}"', octal '"${-dec2oct\ $dec}"', decimal '"$dec"' and
hexadecimal '"${-dec2hex\ $dec}"'."
#@gmic str2hex : string
#@gmic : Convert specified string into a sequence of hexadecimal values.
str2hex :
-v - ({'"$*"'}) -y. -r. 2,100% -f. 'v=if(x,i%16,int(i/16));if(v<=9,48+v,87+v)' -u {t} -rm. -v +
#@gmic stresc : val1,...,valN
#@gmic : Return escaped string from specified ascii codes.
stresc :
-v - ($*) -c. 32,255 -y. [-1]
-f.. 'if(i==32||i==34||i==36||i==44||i==64||i==92||i==123||i==125,92,-1)' -a[-2,-1] x
-discard. -1 -u {t} -rm. -v +
#@gmic strcat : "string1","string2",...
#@gmic : Return the concatenation of all strings passed as arguments.
strcat :
-v - $=s res="$1" -repeat {$#-1} res=$res${s{$>+2}} -done
-u $res -v +
#@gmic strcmp : "string1","string2",_nb_characters>=0
#@gmic : Return '1' if the two specified strings are equals, '0' otherwise.
#@gmic : If 'nb_characters' is specified, the comparison is done only for the 'nb_characters' first characters.
strcmp : -skip "${1=}","${2=}","${3=}"
-v - -if {isval($3)} -u {$3>0?!norm2(vector$3(0.{'"$1"'},0)-=vector$3(0.{'"$2"'},0)):1}
-else -u {A=vector(0.{'"$1"'});B=vector(0.{'"$2"'});size(A)==size(B)?!norm2(A-=B):0}
-endif -v +
#@gmic strcontains : string1,string2
#@gmic : Return 1 if the first string contains the second one.
strcontains :
-v - -l[] ({'"$1"'}) -s +,{'"$2"'} -u {$!>1} -rm -endl -v +
#@gmic strlen : string1
#@gmic : Return the length of specified string argument.
strlen : -skip "${1=}"
-v - -u {narg({'"$1"'})} -v +
#@gmic strreplace : string,search,replace
#@gmic : Search and replace substrings in an input string.
strreplace : -skip "${3=}"
-v -
-if {narg("$3")}
ls=${-strlen\ "$2"}
lr={${-strlen\ "$3"}-1}
-l[] ({'"$1"'}) -s +,{'"$2"'} -s y,-$ls
-repeat $! -if {[{$>,^}]==['"$2"']} -rows[$>] 0,$lr -f[$>] {'"$3"'} -endif -done
-a y -u {t} -rm -endl
-else
-l[] ({'"$1"'}) -s -,{'"$2"'} -a y -u {t} -rm -endl
-endif
-v +
#@gmic struncase : string
#@gmic : Return a lower-case version of the specified string.
struncase :
-v - ({'"$*"'}) -+. 'if(i>=65&&i<=90,32,0)' -u {t} -rm. -v +
#@gmic strver : _version
#@gmic : Return the specified version number of the G'MIC interpreter, as a string.
#@gmic : Default value: 'version=$_version'.
strver : -check ${1=$_version}>0
-v - ({'$1'}) -r. {2*w-1} -f. 'if(x%2,_'.',i)' -u {t} -rm. -v +
#@gmic tic
#@gmic : Initialize tic-toc timer.
#@gmic : Use it in conjunction with '-toc'.
tic :
-e[^-1] "Initialize timer."
-v - -if {!narg($_ticpos)} _ticpos=0 -endif _tic$_ticpos=$| _ticpos={$_ticpos+1} -v +
#@gmic toc
#@gmic : Display elapsed time of the tic-toc timer since the last call to '-tic'.
#@gmic : This command returns the elapsed time in the status value.
#@gmic : Use it in conjunction with '-tic'.
toc :
-v - _ticpos={$_ticpos-1} -v +
-u {_$|-${_tic$_ticpos}}
-e[^-1] "Elapsed time: "${}" s".
#@gmic std_noise
#@gmic : Return the estimated noise standard deviation of the last selected image.
std_noise :
-v - -if $! --laplacian. --. {ic} -abs. -u {1.4826*ic/sqrt(d==1?20:42)} -rm. -else -u 0 -endif -v +
#@gmic :: Other interactive commands
#@gmic demo : _run_in_parallel={ 0=no | 1=yes | 2=auto }
#@gmic : Show a menu to select and view all G'MIC interactive demos.
demo : -check "isint(${1=2}) && $1>=0 && $1<=2"
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"G\47MIC demo menu"$n" ------------------\n
----\n
---- "${c}"Mouse button"$n" to select a demo.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
-v - -l[]
parallel_mode={1-if($1!=2,$1,$_cpus>=2)}
380,620,1,3 --plasma. 1,1,5 -n. 0,230 -water. 100
(0.1;0.03^0;0.1^0.2;0.1) -r. [-2],3 -*[-2,-1] -c. 0,255
100%,100%,1,3
0 -t. "1- 2048 game\n"\
"2- Blobs editor\n"\
"3- Bouncing balls\n"\
"4- Fire effect\n"\
"5- Fireworks\n"\
"6- Fish-eye effect\n"\
"7- Fourier filtering\n"\
"8- Histogram demo\n"\
"9- Hough transform\n"\
"10- Jawbreaker\n"\
"11- Virtual landscape\n"\
"12- The game of life\n"\
"13- Light effect\n"\
"14- Mandelbrot explorer\n"\
"15- 3d metaballs\n"\
"16- Minesweeper\n"\
"17- Minimal path\n"\
"18- Pacman\n"\
"19- Paint\n"\
"20- Plasma effect\n"\
"21- RGB quantization\n"\
"22- 3d reflection\n"\
"23- 3d rubber object\n"\
"24- Shade bobs\n"\
"25- Spline editor\n"\
"26- Tetris\n"\
"27- Tic-tac-toe\n"\
"28- Image waves\n"\
"29- Fractal whirls\n"\
"30- Color curves\n",0,0,18,1,255,255,255
commands=-x_2048,-x_blobs,-x_bouncing,-x_fire,-x_fireworks,-x_fisheye,-x_fourier,-x_histogram,-x_hough,\
-x_jawbreaker,-x_landscape,-x_life,-x_light,-x_mandelbrot,-x_metaballs3d,-x_minesweeper,-x_minimal_path,\
-x_pacman,-x_paint,-x_plasma,-x_quantize_rgb,-x_reflection3d,-x_rubber3d,-x_shadebobs,\
-x_spline,-x_tetris,-x_tictactoe,-x_waves,-x_whirl,-_demo_color_curves
nb_demos={narg($commands)}
y0=59
-j.. [-1],20,$y0,0,0 -rm.
-rectangle. 0,16,100%,44,1,120,120,32
0 -t. "G\'MIC "${-strver}" demos",2,2,28,1,1,1,1
-if {narg($_prerelease)} 0 -t. "Pre-release :\n ""#"$_prerelease,30,2,13,1,1,1,1 -a[-2,-1] x -endif
-b. 0.5 -n. 0,1
(32;255^255;255^0;0) -r. [-2],[-2],1,3,3 -*[-2,-1] -round. 1,-1 --!=. 0 -channels. 1
-j... [-2],20,16,0,0,1,[-1] -rm[-2,-1] --channels. 1 -dilate. 5
(80;255;80^0;255;0^0;0;0) (10;255;10^0;100;0^0;0;0)
-r[-2,-1] [-3],18,1,3,3 -polygon[-2,-1] 3,1,1,1,16,10,8,1,255,255,255 --mirror[-2,-1] x
-max[-4,-2] -max[-2,-1]
-ball[] 64,200,100,64 -n. 0,230 -s. c,-3 -rgb2hsv.. -*. 0.5 -a[-2,-1] c
-repeat 6
-sh. 0 -f. {$>*360/6} -rm. --s. c,-3 -hsv2rgb.. -a[-2,-1] c
({'CImg3d'}) (5,5) 3,5 (1,0;1,4) -r. 2,5,1,1,3 -round. 4,5 -y[-5--1] -a[-5--1] y
-rv[-2,-1] -sprites3d.. [-1],1 -rm. -rv[-2,-1]
-done -rm. -+3d[-6--1]
cfx={0} cfy={0} cfz={0} nfx={g} nfy={g} nfz={g} alpha=0 time0={$|-4} selected=-1 -f3d 400
-w[0] -1,-1,0,0,50%,50%,"[G'MIC] Demo menu"
-do
t={1.5*$|}
1,30,1,1,'(1-$alpha)*cos($cfx*y+$t)+$alpha*cos($nfx*y+$t)'
1,30,1,1,'(1-$alpha)*sin($cfy*y+$t)+$alpha*sin($nfy*y+$t)'
1,30,1,1,'(1-$alpha)*sin($cfz*y+$t)+$alpha*sin($nfz*y+$t)'
-a[-3--1] x -s. y,5 -a[-5--1] x -y.
-j[6] [-1],0,8 -rm. -*3d[6] {0,w/2-30},{0,h/2-30},300 -+3d[6] 0,0,200
-*[0] 0.85 -+[0] [1] -j3d[0] [6],50%,50%,0,1,0,0,0 -j[0] [2],0,0,0,0,1,[3],255
y={{*,y}*{0,h}/{*,h}}
-if {$y>=0} y={max(0,min({$nb_demos-1},int(($y-$y0)/18)))} -j[0] [{if($selected>=0,5,4)}],0,{$y0+18*$y},0,0,0.2 -endif
-w[0] -wait 20
-if {{*,CTRLLEFT}&&{*,D}} -w[0] 150%,150% -elif {{*,CTRLLEFT}&&{*,C}} -w[0] 100%,100% -endif
-if {({*,b}&1)&&$selected<0} selected=$y
-elif {!{*,b}}
-if {$selected>=0&&$y==$selected}
-m "com : -v 0 "${-arg\ {1+$y},$commands} -parallel $parallel_mode,"-l[] -com -v -1 -rm -endl" -uncommand com
-endif
selected=-1
-endif
-if {$|-$time0>5} alpha+=0.03 -endif
-if {$alpha>1} alpha-=1 cfx=$nfx cfy=$nfy cfz=$nfz nfx={g} nfy={g} nfz={g} time0={$|-u*3} -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -endl -v 0 -e[] ""
_demo_color_curves :
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Color curves"$n" ----------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" on a curve creates a new control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" on a control point deletes it.\n
---- "${c}"Left mouse button"$n" on the main image window shows the initial image until button is released.\n
---- "${c}"Right mouse button"$n" on the main image window adds a keypoint to all curves from picked color.\n
---- Key '"${c}"R"$n"' on a curve resets it.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' close the current window.\n
----\n
------------------------------------------------------------------------------------------------"
-v - -testimage2d 512 -x_color_curves rgb -v +
#@gmic x_2048
#@gmic : Launch the 2048 game.
x_2048 :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"2048"$n" -----------------------------------------------\n
----\n
---- Join the numbers and get to the "${g}"2048"$n" title!\n
----\n
---- Use your "${c}"arrow keys"$n" to move the tiles. When two tiles\n
---- with the same number touch, they merge into one!\n
---- This command is a port of the '"${c}"2048"$n"' game originally\n
---- designed by "${c}"Gabriele Cirulli"$n", and available at:\n
---- "${r}"http://gabrielecirulli.github.io/2048/"$n"\n
----\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
-v - -l[]
score=0 -f3d 50 -m3d 0
-m "_x_2048_setrandom : --==[0] 0 -f. 'if(i,4*y+x,-1)' -discard. -1
off={i[round(u(h-1))]} -rm. x={$off&3} y={$off>>2} n={if(u<0.75,1,2)}
-=[0] $n,$x,$y [{2+$n}] -c3d.
-repeat 6 -j3d[1] [-1],{78+$x*121},{190+$y*121},{10*$<},{(1+$>)/6} -w[1] -wait 20 -done
-rm."
-m "_x_2048_object3d : --f[0] 'if(i,i*16+4*y+x,-1)' -discard. -1
N={h} -repeat {h} v={-{1+$>},@$>} --+3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} -done
-+3d[-$N--1] -rm.."
-i[0] 4,4
b0=204,192,179 b1=238,228,218 b2=237,224,200 b3=242,177,121
b4=245,149,99 b5=246,124,95 b6=246,94,59 b7=237,207,114
c0=119,110,101 c1=249,246,242 s0=" "
520,630,1,3 -fc. 250,248,239
-t. "2048",20,10,86,1,$c0
-t. "Join the numbers and get to the 2048 title!",20,90,20,1,$c0
-rectangle. 422,20,501,75,1,187,173,160 -t. "SCORE",439,25,15,1,238,228,218
-repeat 12
107,107,1,3 -fc. ${b{min($>,7)}} --fc. ${c{$>>2}}
s1={2^$>} 0 -t. ${s{$>>0}},0,0,52,1,1
-r. [-2],[-2],1,1,0,0,0.5,0.5 -dilate_circ. 3 -b. 0.5
-j... [-2],0,0,0,0,1,[-1],1 -rm[-2,-1]
-done
-frame_round[2--1] 10,5,1,0.5,187,173,160 -frame[2--1] 7,7,187,173,160 -to_rgb[2--1]
-r[2] 400%,400%,1,3,0,2 -j[1] [2],18,130
-sprite3d[3--1]
-w[1] 100%,100%,0,"[G"{`39`}"MIC] 2048" insert_new=1
-repeat 2 -_x_2048_setrandom -done
-do
-if $insert_new
-_x_2048_object3d -*3d. 121 -j[1] [2],18,130 -j3d[1] [-1],78,190 -rm.
80,25,1,3 -fc. $c1 0 -t. $score,0,0,25,1,1,1,1 -r. [-2],0,0,0.5,0.8
-rectangle[1] 422,45,501,69,1,187,173,160 -j[1] [-2],422,45,0,0,1,[-1] -rm[-2,-1]
-w[1] insert_new=0
-endif
--+[0] 1 -f. 'j(-1)==i||j(1)==i||j(0,-1)==i||j(1,0)==i||i==1'
-if {0,iM==11}
-alert "Game Over","\nCongratulations! You got the 2048 title!\n\n   Your score: "$score,"OK"
-break
-elif {!iM}
-alert "Game Over","\nBad luck! You lost the game!\n\n   Your score: "$score,"OK"
-break
-endif
-rm.
-wait
is_shift=0 -uncommand shift2048,ishift2048,vshift2048
-if {*,ARROWLEFT}
-m "shift2048:" -m "ishift2048:" -m "vshift2048:"
is_shift=1
-elif {*,ARROWRIGHT}
-m "shift2048: -rotate 180" -m "ishift2048: -rotate 180"
-m "vshift2048: -s3d -l[2] -r 3,{h/3},1,1,-1 -s x --[0,1] 3 -*[0,1] -1 -a x -y -endl -a y"
is_shift=1
-elif {*,ARROWUP}
-m "shift2048: -rotate -90" -m "ishift2048: -rotate 90"
-m "vshift2048: -s3d -l[2] -r 3,{h/3},1,1,-1 -s x -rv[0,1] --[0] 3 -*[0] -1  -a x -y -endl -a y"
is_shift=1
-elif {*,ARROWDOWN}
-m "shift2048: -rotate 90" -m "ishift2048: -rotate -90"
-m "vshift2048: -s3d -l[2] -r 3,{h/3},1,1,-1 -s x -rv[0,1] --[1] 3 -*[1] -1  -a x -y -endl -a y"
is_shift=1
-endif
-if $is_shift
-wait -1
-shift2048[0]
-repeat 2
-_x_2048_object3d
--s[0] y -discard[-4--1] 0 -y[-4--1] x -r[-4--1] 4,1,1,1,0,0 -a[-4--1] y
--==[0,-1] insert_new={$insert_new||!im} -rm.
--f[0,-1] 'if(i,x,-1)' -discard[-2,-1] -1 -rv[-2,-1] --[-2,-1] -rv[0,-2] -rm..
-if {(im||iM)&&!{*,k}}
-/. 5 -z. 0,2 -y.
-repeat 5
-j.. [-1],0,8,0,0,-1
-j[1] [2],18,130 --vshift2048.. -*3d. 121 -j3d[1] [-1],78,190 -rm.
-w[1] -wait 20
-done
-endif
-rm[-2,-1]
-if {!$>} dscore=0
[0] --f[0] 'if(i,i*16+4*y+x,-1)' -discard. -1
-repeat {h}
x={i[$>]&3} y={(i[$>]>>2)&3} n={i[$>]>>4}
-if {$x>0" && "{0,i($x-1,$y)}==$n}
-=[0] 0,$x,$y -=[0] {$n+1},{$x-1},$y -=.. 0,$x,$y insert_new=1 dscore+={2^($n+1)}
-else -=. -1,0,$>
-endif
-done
score+=$dscore
-if {iM<0} -rm[-2,-1]
-else
-discard. -1
-rv[0,-2] -_x_2048_object3d -rv[0,-3] -vshift2048. -*3d. 121
-j[1] [2],18,130 -j3d[1] [-1],78,190 -rm[-3,-1]
N={h} -repeat {h} v={-{1+$>},@$>} --+3d[{2+($v>>4)}] {$v&3},{($v>>2)&3} -done
-+3d[-$N--1] -rm..
0 -t. +$dscore,0,0,33,1,1 100%,100%,1,3 -fc. $c0
-repeat 6
--vshift2048... -*3d. 121 --j3d[1] [-1],78,190
-j. [-3],430,{80-$>},0,0,{min(1,$</6)},[-4]
-w. -rm[-2,-1] --3d... {1/6},0,0 -wait 20
-done
-rm[-3--1]
-endif
-endif
-done
-ishift2048[0]
-if $insert_new -_x_2048_setrandom -endif
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -endl -uncommand _x_2048_setrandom,_x_2048_object3d -v +
#@gmic x_blobs
#@gmic : Launch the blobs editor.
x_blobs :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Blobs editor"$n" --------------------------\n
----\n
---- "${c}"Mouse"$n" to insert/move/delete blobs.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
-v -
-l[] (0;0^0;128^0;255) -r. 450,450,1,3,3 -flower. 30,8,0,0,50%,50%,1 -water. 20
-w {w},{h},0,0,"[G"{`39`}"MIC] Blobs editor"
moving=-1
-do
x={{*,x}*{0,w}/{*,w}}
y={{*,y}*{0,h}/{*,h}}
b={*,b} nearest=-1
fps=${-fps}
-if {$!>1}
{0,w},{0,h},1,2
-repeat {1,h}
r={{1,@2}*(1+{1,@3}*cos({1,@4}+{1,@5}*$|*1000))}
-ellipse. {1,@0,1},$r,$r,0,1,{1,@6-7}
d={sqrt(($x-{1,@0})^2+($y-{1,@1})^2)}
-if {$d<$r} nearest=$> -endif
-shift[1] 0,-1,0,0,2 -done
-b. 15
--norm. -->=. 50 -<=.. 40 -*[-3,-1]
--*[0,-1] -rm.. -rv[-2,-1] -*. 1.6 -c. 0,255 -+[-2,-1]
-if {$fps>0} -text_outline. $fps" fps",5,{h-29},24,2,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-rm.
-else
--text_outline[0] "G\47MIC Blobs Editor",75,100,35,3,1,200,128,255
-text_outline. "* Left mouse button : Create and move blobs.\n\n\
* Right mouse button : Remove blob.\n\n\
* Middle mouse button : Remove all blobs.\n\n\
* Key 'ESC' or 'Q' : Quit.\n\n\
* Colors and sizes of appearing blobs are\n   chosen randomly",\
50,180,18,1,1,255
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-rm.
-endif
-wait 20
-if {$x<0||$y<0} -continue -endif
-if {$b&1}
-if {$nearest>=0" || "$moving>=0}
-if {$moving<0} moving=$nearest -endif
-=[1] $x,0,$moving -=[1] $y,1,$moving
-else
($x,$y,{u(20,50)},{u(-0.3,0.3)},{u(0,pi/2)},{u(0,0.009)},{u(64,255)},{u(64,255)}) -a[^0] y
moving={h-1}
-endif
-elif {$b&2}
-if {$nearest>=0} -l[1] -s y -rm[$nearest] -a y -endl nearest=-1 -endif
-elif {$b&4}
-k[0]
-else
moving=-1
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -endl -v +
#@gmic x_bouncing
#@gmic : Launch the bouncing balls demo.
x_bouncing :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Bouncing balls"$n" ------------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
-v - -l[]
520,320,1,3 -plasma 1,1,9 -n 0,220
N=12
-repeat $N
-ball[] {round(u(32,80))},${-RGB}
t$>={u(200)} x$>={0,u(10,w-10)} h$>={u(150,300)} vx$>={if(u<0.5,1,-1)*u(1,8)}
-done
-mv[0] $! -w. -1,-1,0,"[G"{`39`}"MIC] Bouncing balls"
(0;0.7;1) -r. {-2,w},70,1,1,3
-do
[$N]
-repeat $N
bw={$>,w} bh={$>,h}
y={${h$>}*abs(cos(${t$>}*pi/60))-$bh/2}
dt=1
-if {$y<0} d={-$y} y=0 bh-=$d bw+=$d dt={max(0.2,1-($d/$bh)^2)} -else dt=1 -endif
-if {${x$>}+$bw/2>w}
d={${x$>}+$bw/2-w} bw-=$d bh+={0.5*$d}
-if {${x$>}+$bw/4>w} vx$>={-${vx$>}} -endif
-endif
-if {${x$>}-$bw/2<0}
d={$bw/2-${x$>}} bw-=$d bh+={0.5*$d}
-if {${x$>}-$bw/4<0} vx$>={-${vx$>}} -endif
-endif
--r[$>] $bw,$bh,1,4,3 -s. c,-3
-j... [-2],{max(0,min({$N,w-$bw},${x$>}-$bw/2))},{{$N,h}-{h}-$y-70},0,0,1,[-1],255 -rm[-2,-1]
t$>+=$dt
x$>+={$dt*${vx$>}}
-done
--rows. {h-2*70},{h-1-70} -mirror. y -*. [{$N+1}]
-j.. [-1],0,{-2,h-71},0,0,0.5 -rm.
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,{h-29},24,2,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-rm. -wait 20
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w 0 -rm -endl -v +
#@gmic x_color_curves : _colorspace={ rgb | cmy | cmyk | hsi | hsl | hsv | lab | lch | ycbcr | last }
#@gmic : Apply color curves on selected RGB[A] images, using an interactive window.
#@gmic : Set 'colorspace' to 'last' to apply last defined color curves without opening interactive windows.
#@gmic : Default value: 'colorspace=rgb'.
x_color_curves : -skip ${1=rgb}
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[^-1] "Apply color curves of image$?, in the '$1' colorspace."
-if {['"$1"']=='last'} -v -
-if {!narg($_xcc_colorbase)} -v + -return -endif
-__x_color_curves[] $_xcc_colorbase
-else
-e[] "\n
------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" on a curve creates a new control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" on a control point deletes it.\n
---- "${c}"Left mouse button"$n" on the main image window shows the initial image until button is released.\n
---- "${c}"Right mouse button"$n" on the main image window adds a keypoint to all curves from picked color.\n
---- Key '"${c}"R"$n"' on a curve resets it.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' close the current window.\n
----\n
------------------------------------------------------------------------------------------------"
-v -
-__x_color_curves[] $1 _xcc_colorbase=$1
-endif
-repeat $! -l[$>]
-if {['"$1"']!='last'}
--r[0] ${-fitscreen[]\ {0,w},{0,h},1,128,70%},1,100%,3
--l. -xcc_goto -s c -histogram 256,0,255 -xcc_info -endl
__C0= __C1= __C2= __C3= __C4=
-if {narg($__xcc_C0)} __C0=$__xcc_C0 -endif
-if {narg($__xcc_C1)} __C1=$__xcc_C1 -endif
-if {narg($__xcc_C2)} __C2=$__xcc_C2 -endif
-if {narg($__xcc_C3)} __C3=$__xcc_C3 -endif
-if {narg($__xcc_C4)} __C4=$__xcc_C4 -endif
x={1,({*,u}-560-w)/2} y={1,({*,v}-h)/2}
-if {$!==5}
-parallel "-w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" -x_select_function1d... __C0,"$_color0"",\
"-w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" -x_select_function1d.. __C1,"$_color1"",\
"-w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" -x_select_function1d. __C2,"$_color2"",\
"-w. 100%,100%,0,0,"{$x+560}","$y" -_x_color_curves[-4]"
-elif {$!==6}
-parallel "-w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" -x_select_function1d[-4] __C0,"$_color0"",\
"-w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" -x_select_function1d... __C1,"$_color1"",\
"-w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" -x_select_function1d.. __C2,"$_color2"",\
"-w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" -x_select_function1d. __C3,"$_color3"",\
"-w. 100%,100%,0,0,"{$x+560}","$y" -_x_color_curves[-5]"
-elif {$!==7}
-parallel "-w[] 256,256,0,0,"$x","$y",\"Curve: "$_title0"\" -x_select_function1d[-5] __C0,"$_color0"",\
"-w[] 256,256,0,0,"{$x+280}","$y",\"Curve: "$_title1"\" -x_select_function1d[-4] __C1,"$_color1"",\
"-w[] 256,256,0,0,"$x","{$y+300}",\"Curve: "$_title2"\" -x_select_function1d... __C2,"$_color2"",\
"-w[] 256,256,0,0,"{$x+280}","{$y+300}",\"Curve: "$_title3"\" -x_select_function1d.. __C3,"$_color3"",\
"-w[] 256,256,0,0,"{$x+280}","{$y+600}",\"Curve: "$_title4"\" -x_select_function1d. __C4,"$_color4"",\
"-w. 100%,100%,0,0,"{$x+560}","$y" -_x_color_curves[-6]"
-endif
-k[0]
-endif
-xcc_goto
-repeat {s} -function1d[] 1,${__xcc_C$>} -*. {255%} -r. 256,1,1,1,5 -c. 0,255 -sh[0] $> -map. [-2] -rm[-2,-1] -done
-xcc_backto
-endl -done
-uncommand xcc_goto,xcc_backto,xcc_info -v +
_x_color_curves :
title={0,b} -if {narg({'{0,x}'})} title=$title.{0,x} -endif ({'$title'}) -discard. {'~'} title={t} -rm.
--drgba. -w. 100%,100%,0,"[G"{`39`}"MIC] Image: "$title -rm.
-xcc_goto. [-1]
oC0= oC1= oC2= oC3= oC4= viewmode=0
-do
-wait 100 need_refresh=0
oviewmode=$viewmode is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}} x={*,x} y={*,y}
-if {*,r} need_refresh=1
-elif {$is_ctrl" && "{*,-D}} -w[] {{*,w}*125%},{{*,h}*125%} need_refresh=1
-elif {$is_ctrl" && "{*,-C}} -w[] {{*,w}*80%},{{*,h}*80%} need_refresh=1
-elif {$is_ctrl" && "{*,-R}} -w[] {w},{h} need_refresh=1
-elif {{*,b}&1} viewmode={x={*,x};if(x<w/3,1,if(x<2*w/3,2,3))}
-elif {{*,b}&2" && "$x>=0" && "$y>=0}
xc={$x*w/{*,w}} yc={$y*h/{*,h}} --z[0] $xc,$yc,$xc,$yc
-repeat {s} (${__C$>},{i[$>]/255%},{i[$>]/255%}) -r. 2,{w/2},1,1,-1 -sort. +,y __C$>={^} -rm. -done
-rm. -wait -1
-else viewmode=0
-endif
need_refresh={$need_refresh||$oviewmode!=$viewmode}
-repeat {s} -if {['_${oC$>}']!=['_${__C$>}']}
-function1d[] 1,${__C$>} -*. {255%} -r. 256,1,1,1,5 -c. 0,255
--channels[0] $> -map. [-2] -j[1] [-1],0,0,0,$> -rm[-2,-1]
need_refresh=1 oC$>=${__C$>}
-endif -done
-if $need_refresh
-if {$viewmode==0}
--xcc_backto[1]
-elif {$viewmode%2}
w2={0,int(w/2)} b={$viewmode==1} --z[{!$b}] 0,{$w2-1} --z[$b] $w2,100%
-xcc_backto.. -xcc_backto. -a[-2,-1] x -line. 50%,0,50%,100%,1,0
-else
--xcc_backto[0]
-endif
-if {s>3} -drgba. -endif -w. -rm. refresh=0
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,SPACE}" && "!{*,ENTER}}
-w 0
-repeat 4 -if {narg(${__C$>})} __xcc_C$>=${__C$>} __C$>=-1 -endif -done
__x_color_curves :
-if {['"$1"']=='rgb'}
_color0="255,180,180" _color1="180,255,180" _color2="180,180,255" _color3="220,220,220" _title0=Red _title1=Green _title2=Blue _title3=Alpha
-m "xcc_goto:" -m "xcc_backto:"
-m "xcc_info: (0,255;0,0;0,0) (0,0;0,255;0,0) (0,0;0,0;0,255) -r[-3--1] 256,3,1,1,3 "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-elif {['"$1"']=='cmy'}
_color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Alpha
-m "xcc_goto: -s c,-3 -rgb2cmy[0] -a c" -m "xcc_backto: -s c,-3 -cmy2rgb[0] -a c"
-m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) -r[-3--1] 256,3,1,1,3 "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-elif {['"$1"']=='cmyk'}
_color0="180,255,255" _color1="255,180,255" _color2="255,255,100" _color3="180,180,180" _color4="220,220,220" _title0=Cyan _title1=Magenta _title2=Yellow _title3=Key _title4=Alpha
-m "xcc_goto: -s c,-3 -rgb2cmyk[0] -a c" -m "xcc_backto: -s c,-4 -cmyk2rgb[0] -a c"
-m "xcc_info: (255,0;255,255;255,255) (255,255;255,0;255,255) (255,255;255,255;255,0) (255,0) -r[-4--1] 256,3,1,1,3 "\
"-a[0,-4] y -a[1,-3] y -a[2,-2] y -a[3,-1] y"
-elif {['"$1"']=='hsi'}
_color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Intensity _title3=Alpha
-m "xcc_goto: -s c,-3 -rgb2hsi8[0] -a c" -m "xcc_backto: -s c,-3 -hsi82rgb[0] -a c"
-m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) -hsi82rgb[-3--1] -permute[-3--1] xcyz "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-elif {['"$1"']=='hsl'}
_color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Lightness _title3=Alpha
-m "xcc_goto: -s c,-3 -rgb2hsl8[0] -a c" -m "xcc_backto: -s c,-3 -hsl82rgb[0] -a c"
-m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) -hsl82rgb[-3--1] -permute[-3--1] xcyz "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-elif {['"$1"']=='hsv'}
_color0="255,220,220" _color1="220,220,220" _color2="180,180,180" _color3="220,220,220" _title0=Hue _title1=Saturation _title2=Value _title3=Alpha
-m "xcc_goto: -s c,-3 -rgb2hsv8[0] -a c" -m "xcc_backto: -s c,-3 -hsv82rgb[0] -a c"
-m "xcc_info: 256,1,1,3,if(!c,x,255) 256,1,1,3,if(!c,0,if(c==1,x,128)) 256,1,1,3,if(!c,0,if(c==1,0,x)) -hsv82rgb[-3--1] -permute[-3--1] xcyz "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-elif {['"$1"']=='lab'}
_color0="180,180,180" _color1="220,180,220" _color2="220,220,180" _color3="220,220,220" _title0=Lightness _title1=Chroma-A _title2=Chroma-B _title3=Alpha
-m "xcc_goto: -s c,-3 -srgb2rgb[0] -apo[0] -rgb2lab8,0,4 -a c" -m "xcc_backto: -s c,-3 -apo[0] -lab82rgb,0,4 -rgb2srgb[0] -a c"
-m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,240,if(c==1,x,128)) 256,1,1,3,if(!c,240,if(c==1,128,x)) -lab82rgb[-3--1] -permute[-3--1] xcyz "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-elif {['"$1"']=='lch'}
_color0="180,180,180" _color1="220,180,220" _color2="255,220,220" _color3="220,220,220" _title0=Lightness _title1=Chroma _title2=Hue _title3=Alpha
-m "xcc_goto: -s c,-3 -srgb2rgb[0] -apo -rgb2lch8[0],0,4 -a c" -m "xcc_backto: -s c,-3 -apo -lch82rgb[0],0,4 -rgb2srgb[0] -a c"
-m "xcc_info: 256,1,1,3,if(!c,x,0) 256,1,1,3,if(!c,255,if(c==1,x,128)) 256,1,1,3,if(!c,220,if(c==1,128,x)) -lch82rgb[-3--1] -permute[-3--1] xcyz "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-elif {['"$1"']=='ycbcr'}
_color0="180,180,180" _color1="220,220,255" _color2="255,220,220" _color3="220,220,220" _title0=Luma _title1=Blue\ chroma _title2=Red\ chroma _title3=Alpha
-m "xcc_goto: -s c,-3 -rgb2ycbcr[0] -a c" -m "xcc_backto: -s c,-3 -ycbcr2rgb[0] -a c"
-m "xcc_info: 256,1,1,3,if(!c,x,128) 256,1,1,3,if(!c,128,if(c==1,x,128)) 256,1,1,3,if(!c,128,if(c==1,128,x)) -ycbcr2rgb[-3--1] -permute[-3--1] xcyz "\
"-a[0,-3] y -a[1,-2] y -a[2,-1] y"
-else -v + -error[0--3] "Command 'x_color_curves': Unknown specified color space '$1'."
-endif
#@gmic x_colorize : _is_lineart={ 0 | 1 },_max_resolution={ 0 | >=128 },_multichannels_output={ 0 | 1 },_[palette1],_[palette2]
#@gmic : Colorized selected B&W images, using an interactive window.
#@gmic : When >0, argument 'max_resolution' defines the maximal image resolution used in the interactive window.
#@gmic : Default values: 'is_lineart=1', 'max_resolution=1024' and 'multichannels_output=0'.
x_colorize : -skip ${1=0},${3=0},${4=0},${5=0} -check "${2=1024}==0 || $2>=128"
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - s0="image" s1="lineart" s2="multichannel" s3="merged" -v +
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[^-1] "Colorize selected B&W "${s{!$1}}"$? interactively, with maximum resolution $2 and "${s{2+!$3}}" output."
-e[] "\n
--------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" creates a new colored control point (or moves an existing one).\n
---- "${c}"Right mouse button"$n" or key '"${c}"X"$n"' over a control point deletes it.\n
---- "${c}"Right mouse button"$n" or key '"${c}"P"$n"' anywhere else picks a color from the image.\n
---- "${c}"Mouse wheel"$n", or keys '"${c}"CTRL+arrows UP/DOWN"$n"' zoom view in/out.\n
---- '"${c}"CTRL+mouse wheel"$n"', '"${c}"SHIFT+mouse wheel"$n"' or "${c}"arrow keys"$n" move image in zoomed view.\n
---- Key '"${c}"SPACE"$n"' updates the extrapolated color field.\n
---- Key '"${c}"TAB"$n"' toggles between markers view modes.\n
---- Key '"${c}"BACKSPACE"$n"' deletes the last control point added.\n
---- Key '"${c}"PAGE UP"$n"' increases image contrast.\n
---- Key '"${c}"PAGE DOWN"$n"' decreases image contrast.\n
---- Key '"${c}"R"$n"' toggles color replace mode.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$c"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
--------------------------------------------------------------------------------------"
-v -
is_palette1=${"-is_image_arg[] $4"}
-if $is_palette1 -pass$4 1 ({'{b}'}) -discard. {'~'} palette_title1={t} -rm. -endif
is_palette2=${"-is_image_arg[] $5"}
-if $is_palette2 -pass$5 1 ({'{b}'}) -discard. {'~'} palette_title2={t} -rm. -endif
__color=255,255,255
-if {$is_palette1" && "$is_palette2}
-repeat {$!-2} -l[$>,-2,-1]
-parallel "-_x_colorize[0] ${1--1}","-w[] 400,320,0,Palette -x_select_color[] __color,255,255,255",\
"-w[] 400,400,0,\""$palette_title1"\" -x_select_palette[1] __color",\
"-w[] 400,400,0,\""$palette_title2"\" -x_select_palette[2] __color"
-endl -done
-rm[-2,-1]
-elif $is_palette1
-repeat {$!-1} -l[$>,-1]
-parallel "-_x_colorize[0] ${1--1}","-w[] 400,320,0,Palette -x_select_color[] __color,255,255,255",\
"-w[] 400,400,0,\""$palette_title1"\" -x_select_palette[1] __color"
-endl -done
-rm.
-else
-repeat $! -l[$>]
-parallel "-_x_colorize[0] ${1--1}","-w[] 400,320,0,Palette -x_select_color[] __color,255,255,255"
-endl -done
-endif
-v +
_x_colorize :
name={n} title={b} -if {narg({x})} title=$title.{x} -endif
w={w} h={h}
-if $1
-if {s==4} -sh. 3 -if {abs(im-iM)>64} --*. -1 -rm.. -+. 255 -else -rm. -sh. 0 -endif
-else -sh. 0
-endif
-n 0,255
-else
-if {s==1} -sh. 0
-else --luminance.
-endif
-endif
-nm. img
fdim=${-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
selection=-1 view_markers=2 contrast=9 xpan=-1 ypan=-1 replace_color= current_replace_color=
-if {narg($_gimp_control_points)>=6}  ($_gimp_control_points) -r. {w/6},6,1,1,-1
-else 0
-endif
-nm. points
-if {$2>0} -if {$w>$h} --r2dx[img] {min($2,$w)},2 -else --r2dy[img] {min($2,$h)},2 -endif -else [img] -endif
-__x_colorize. $1
pw={potential,w} ph={potential,h}
-do
-if {narg($replace_color)" && "{*,x}<0" && "{*,y}<0} -wait 200 -else -wait -endif
x={*,x} y={*,y} b={*,b} o={*,-o}
is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
is_shift={{*,SHIFTLEFT}" || "{*,SHIFTRIGHT}}
is_mouseout={$x<0" || "$y<0}
x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1
-if {*,r}
nww={*,d} nwh={*,e} m={min($nww,$nwh)}
cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
x0={$cx-$dx/2} x1={$cx+$dx/2}
y0={$cy-$dy/2} y1={$cy+$dy/2}
ww=$nww wh=$nwh
-elif {$is_ctrl" && "{*,-D}}
nww={min({*,u},$ww*1.25)} nwh={min({*,v},$wh*1.25)} m={min($nww,$nwh)}
-if {$m==$nww} ww=$m wh={$h*$m/$w} -else ww={$w*$m/$h} wh=$m -endif
-elif {$is_ctrl" && "{*,-C}}
nww={$ww/1.25} nwh={$wh/1.25}
-if {min($nww,$nwh)>=64} ww=$nww wh=$nwh -endif
-elif {$is_ctrl" && "{*,R}}
fdim=${-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
x0=0 y0=0 x1={$w-1} y1={$h-1}
-elif {($is_shift" && "$o<0)" || "{*,ARROWLEFT}}
dx={($x1-$x0)/6} x0-=$dx x1-=$dx
-elif {($is_shift" && "$o>0)" || "{*,ARROWRIGHT}}
dx={($x1-$x0)/6} x0+=$dx x1+=$dx
-elif {($is_ctrl" && "$o>0)" || "({*,ARROWUP}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0-=$dy y1-=$dy
-elif {($is_ctrl" && "$o<0)" || "({*,ARROWDOWN}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0+=$dy y1+=$dy
-elif {$o>0" || "($is_ctrl" && "{*,ARROWUP})}
-if {$x1-$x0>16" && "$y1-$y0>16}
cx={if($x>=0" && "!{*,ARROWUP},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWUP},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
-endif
-elif {$o<0" || "($is_ctrl" && "{*,ARROWDOWN})}
zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
-if {$zfactor<1.3}
cx={if($x>=0" && "!{*,ARROWDOWN},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWDOWN},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
-else
dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
-endif
-elif {$b&4" && "!$is_mouseout}
-if {$panx<0" && "$pany<0} panx=$x pany=$y
-else dx={round($panx-$x)} dy={round($pany-$y)} x0+=$dx y0+=$dy x1+=$dx y1+=$dy
-endif
-else panx=-1 pany=-1
-endif
-if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} -rm[baseview] -endif
N={points,w}
-if {narg($baseview)" && "($b&3" || "{*,X}" || "{*,P})" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
-if {$selection==-1" && "$N}
($x;$y) -r. $N,2 --. [points] -*. {max($ww,$wh)/max($x1-$x0,$y1-$y0)} -sqr. -s. y -+[-2,-1]
dmin={im} selection={if($dmin>25,-1,xm)} -rm.
-endif
-if {narg($replace_color)}
replace_color= -wait -1
-elif {$selection>=0}
-if {$b&1" && "$view_markers}
--columns[points] $selection ox={i[0]} oy={i[1]} -=. $x -=. $y,0,1 -j[points] [-1],$selection -rm.
-rm[view]
-elif {($b&2" || "{*,X})" && "$view_markers}
-if {$N>1} --z[points] {$selection+1},100% -j[points] [-1],$selection -rm. -r[points] {$N-1},100%,1,1,0
-else -rm[points] -i[points] 0 -endif
-wait -1 -rm[view]
-endif
-elif {$b&1}
($x;$y;0) ($__color) -y. y -+. 1 -a[-2,-1] y -a[points,-1] x selection=$N -if {!$view_markers} view_markers=2 -endif -rm[view]
-elif {$b&2" || "{*,P}}
__color={colors,I($x*$pw/$w,$y*$ph/$h)}
-endif
-else selection=-1
-if {{*,-SPACE}" && "narg($colors)} replace_color= -rm[colors]
-elif {*,-TAB} view_markers={($view_markers-1)%3} -rm[view] -wait -1
-elif {!$is_ctrl" && "{*,-R}}
-if {narg($replace_color)} replace_color= -else replace_color=$__color -endif
-rm[baseview] -wait -1
-elif {*,PAGEDOWN} contrast={max(0,$contrast-1)} -rm[view] -wait -1
-elif {*,PAGEUP} contrast={min(9,$contrast+1)} -rm[view] -wait -1
-elif {{*,BACKSPACE}" && "$N} -if {$N>1} -z[points] 0,{$N-2} -else i=$points -rm[points] -i[$i] 0 -nm[$i] points -endif -rm[view] -wait -1
-endif
-endif
w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
-if {$x0<-$w2} x1-={$x0+$w2} x0=-$w2 -endif
-if {$y0<-$h2} y1-={$y0+$h2} y0=-$h2 -endif
-if {$x1>=$w+$w2} x0+={$w-1+$w2-$x1} x1={$w-1+$w2} -endif
-if {$y1>=$h+$h2} y0+={$h-1+$h2-$y1} y1={$h-1+$h2} -endif
-if {!narg($colors)}
N={points,w}
-if {narg($view)} -text_outline[view] "Processing...",5,5,20,2 -w[view] -endif
-if $N
[points]
-sh. 0,0,0,0 -*. {$pw/$w} -rm.
-sh. 1,1,0,0 -*. {$ph/$h} -rm.
-pointcloud. -1,$pw,$ph
--compose_channels. max -!=. 0 -distance. 1 -*. 0.02 -+. 1 -^. -1 -+. [potential]
-if {!$1} -dilate.. 3 -endif
-watershed.. [-1] -rm. --. 1
-else [potential],[potential],1,3,255
-endif
-nm. colors
-if {narg($baseview)} -rm[baseview] -endif
-endif
-if {!narg($replace_color)" && "narg($points_replaced)}
-rm[points,colors,view] -nm[colors_replaced] colors -nm[points_replaced] points current_replace_color=
-elif {narg($replace_color)" && "['$__color']!=['$current_replace_color']}
-if {narg($colors_replaced)} -rm[colors_replaced,points_replaced] -endif
current_replace_color=$__color
-if {points,w}
--replace_color[colors] 0,0,$replace_color,$current_replace_color
--rows[points] 3,5 -permute. xzcy --. 1
-replace_color. 0,0,$replace_color,$current_replace_color
-+. 1 -permute. xcyz --j[points] [-1],0,3 -rm..
-else 0 0
-endif
-nm.. colors_replaced
-nm. points_replaced
-if {narg($baseview)} -rm[baseview] -endif
-endif
-if {!narg($baseview)}
nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
--z[img] $x0,$y0,$x1,$y1
-r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
-if {narg($replace_color)" && "{points,w}} icolors=$colors_replaced -else icolors=$colors -endif
--z[$icolors] $nx0,$ny0,$nx1,$ny1
-r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
-if $1 -*.. -1 -+.. 255 -channels.. -3,0 -blend. [-2],alpha -rm..
-else -rgb2ycbcr. -j. [-2],0,0,0,0 -rm.. -ycbcr2rgb.
-endif
-nm. baseview
-if {narg($view)} -rm[view] -endif
-endif
-if {!narg($view)}
[baseview] -r. 100%,100%,1,3
-if {$contrast<9} -/. {10-$contrast} -+. {128*(1-1/(10-$contrast))} -endif
-if $view_markers
-if {$view_markers==2} rad1=5 rad2=3 -else rad1=3 rad2=2 -endif
-if {narg($replace_color)" && "{points,w}} ipoints=$points_replaced -else ipoints=$points -endif
-repeat {$ipoints,w}
--columns[$ipoints] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} col={i[3]-1},{i[4]-1},{i[5]-1} -rm.
-circle. $x,$y,$rad1,1,0 -circle. $x,$y,$rad2,1,$col
-done
-endif
-if {narg($replace_color)}
-text_outline. "Replace      by",5,5,20,2
-rectangle. 80,8,111,25,1,0 -rectangle. 82,10,109,23,1,$replace_color
-rectangle. 150,8,181,25,1,0 -rectangle. 152,10,179,23,1,$current_replace_color
-endif
-nm. view
-w[view] $ww,$wh,0,$title
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}
-if {narg($view)} -text_outline[view] "Processing fullres...",5,5,20,2 -w[view] -endif
-k[0,img,points]
N={points,w} status=
-if $N
status={points,^}
[img] -__x_colorize. $1
-pointcloud[points] -1,$w,$h
--compose_channels[points] max -!=. 0 -distance. 1 -*. 0.02 -+. 1 -^. -1 -+[potential,-1]
-if {!$1} zfact={{img,max(w,h)}/{potential,max(w,h)}} -dilate[points] {int(3*$zfact)} -endif
-watershed[points] [potential] --[points] 1 -nm[points] colors
-else [img],[img],1,3,255 -nm. colors
-endif
-if $3
-k[0,colors] -a c
-else
-k[0,img,colors]
-if $1 --*[img] -1 -+. 255 -channels. -3,0 -blend[colors,-1] alpha -rm[0,img]
-else -rgb2ycbcr[colors] -j[colors] [img],0,0,0,0 -rm[0,img] -ycbcr2rgb[colors]
-endif
-endif
-a c -nm $name
__color=-1
-u $status
-w 0
__x_colorize :
-if $1
-b. 0.05% -n. 0,1 --b. 0.5% -^.. 10 -n.. 0,1 -n. 0.3,1 -min[-2,-1]
-else
-gradient_norm. -n. 0,255 -normalize_local. 3,3 -*. -1 -n. 0,255
-b. 0.05% -n. 0,1 -sqr. --b. 0.5% -n[-2,-1] 0,1 -min[-2,-1]
-endif
-nm. potential
#@gmic x_fire
#@gmic : Launch the fire effect demo.
x_fire : -skip "${1=G\47MIC}"
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Fire effect"$n" ------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
-v -
-i[0] 100,32 -w[0] 450,200,0,"[G"{`39`}"MIC] Fire effect"
-i[1] (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) -r[1] 256,1,1,3,3
-i[2] (0,0,0;0,0,0;1,1,1;0,1,0) -*[2] 0.21
-text3d "$1",33,3,1
-mv. 3 -c3d[3] -n3d[3] -*3d[3] 320 -col3d[3] 255,205,130 -db3d 0 -f3d 300
100,100 -rand. 0,255 -ellipse. 50%,50%,5,5,0,1,300 -b. 10
-sharpen. 1000 -shrink_xy. 1 -n. 0,255 -to_rgb. -light3d [-1] -rm.
angle=0
-do
-correlate[0] [2]
{0,w},1 -rand. 128,256 -j[0] [-1],0,{{0,h}-1} -rm.
--r[0] 400,200,1,1,3 -map. [1]
--r3d[3] 0,1,0,$angle -j3d.. [-1],50%,50%,0,1,5,0,0
-*3d. 0.25,0.16,1 -j3d[0] [-1],50%,50%,0,1,3,0,0
-rm.
angle+=3
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,{h-22},16,1,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-rm. -wait 40
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm[0-3] -w 0
-v +
#@gmic x_fireworks
#@gmic : Launch the fireworks demo.
x_fireworks :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Fireworks"$n" --------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------"
-v - -l[]
(16;64^64;32^128;32) -r 320,160,1,3,3
[-1]
-w. {1.5*w},{1.5*h},0,"[G"{`39`}"MIC] Fireworks"
time=0
-do
time-=1
-if {$!==2\ ||\ $time<0}
-i[0] ({u(w)},\
{h},\
{u(-3,3)},\
{u(2)-5},\
{30+u(20)},\
1.5,\
255,255,255)
time={u(20)}
-endif
-*. 0.99
-j. [-2],0,0,0,0,0.2
i=0
-repeat {$!-2}
to_be_removed=0
radius={if({$i,@4}>0,{$i,@5}/3,{$i,@5}*(1+2*({$i,@4}+2)/120))}
-ellipse. {$i,@0},{$i,@1},{$i,@5},{max(0.5,$radius)},{atan2({$i,@3},{$i,@2})*180/pi},0.6,{$i,@6-8}
({$i,@2},{$i,@3},0,0.09,-1,0,0,0,0) -+[$i,-1]
-if {{$i,@0}<0\ ||\ {$i,@0}>=w\ ||\ {$i,@1}>=h\ ||\ $radius<0} to_be_removed=1 -endif
-if {{$i,@4}<0\ &&\ {$i,@4}>=-1}
color={min(255,80+u(200))},{min(255,80+u(200))},{min(255,80+u(200))}
radius={u(10)}
N={5+u(10)}
-repeat $N
angle={$>*2*pi/$N}
-i... ({$i,@0,1},{2*cos($angle)+{$i,@2}/1.5},{2*sin($angle)+{$i,@3}/1.5},-2,$radius,$color)
-done
to_be_removed=1
-endif
-if $to_be_removed -rm[$i] -else i+=1 -endif
-done
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",3,{h-20},14,1,0.2 -endif
-w. -wait 20
-if {{*,CTRLLEFT}&&{*,D}} -w[] {3*w},{3*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {1.5*w},{1.5*h} -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -endl -v +
#@gmic x_fisheye
#@gmic : Launch the fish-eye effect demo.
x_fisheye :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Fish-eye effect"$n" --------------------\n
----\n
---- "${c}"Mouse pointer"$n" moves fish-eye center.\n
---- "${c}"Mouse buttons"$n" set fish-eye size.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
-v -
-if {$!>0} -a x -n 0,255 -r2dy 220 -else
120,90,1,3 -rand. 0,255 -plasma. 0.3,3 -n 0,255
-t "  G\47MIC\nFISH-EYE\n EFFECT",20,13,23,1,255 -scale3x -b 5 -sharpen 1000
-f i+150-3*abs(y-h/2) -c. 0,255 -frame_fuzzy. 15,10,15,1.5,0 -to_rgb.
-endif
-torus3d 20,6 -col3d. {u(30,255)},{u(30,255)},{u(30,255)} --r3d. 1,0,0,90
-col3d. {u(30,255)},{u(30,255)},{u(30,255)} -+3d. 15 -+3d[-2,-1] -*3d. 4 -db3d 0 -c3d.
R=30
-w.. {1.25*{-2,w}},{1.25*{-2,h}},0,"[G"{`39`}"MIC] Fish-eye effect"
-do
-wait 40
-if {{*,b}==1} R={min(80,$R+8)} -endif
-if {{*,b}==2} R={max(3,$R-8)} -endif
--j3d.. [-1],{50+30*cos($|*2.5)}%,{50+30*sin($|*1.6)}%,{80+230*sin($|*2.6)},0.7,3,0,0 -r3d.. 1,0.2,0.6,3
-if {{*,x}>=0}
-fisheye. {{*,x}*100/{*,w}},{{*,y}*100/{*,h}},$R
-endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {3*w},{3*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {1.5*w},{1.5*h} -endif
-rm.
-if {{*}==0" || "{*,ESC}" || "{*,Q}} -rm[-2,-1] -w 0 -v + -return -endif
-while 1
#@gmic x_fourier
#@gmic : Launch the fourier filtering demo.
x_fourier :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Fourier-filtering"$n" ----------------------------------------\n
----\n
---- "${c}"Mouse buttons"$n" on the right image to set min/max frequencies.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------------"
-v -
-if {!$!} -testimage2d 256 -endif
-repeat $! -l[$>]
need_update=1
freqmin=0
freqmax=100
-if {w>3*{*,u}/5} -r2dx. {3*{*,u}/10} -endif
-if {h>3*{*,v}/5} -r2dy. {3*{*,v}/5} -endif
--fft. -nm.. real -nm. imag
--sqr[real,imag] -+[-2,-1] -sqrt. -+. 1 -log.
-n. 0,255 -shift. {round(w/2)},{round(h/2)},0,0,2 -to_colormode. {-2,s}
-nm. logmag
--r2dy. 128 -frame. 1,1,0 -nm. thumb
-w[0,-2] -1,-1,0,"[G"{`39`}"MIC] Fourier filtering"
-l
-if {!narg($first_time)}
-parallel 0,"-alert[thumb] \"[G"{`39`}"MIC Fourier filtering]\",\
\"The G\47MIC Fourier filtering demo illustrates the effect\n\
of bandpass frequency filtering on an image. Use your mouse\n\
buttons to select low and high bounds for the frequencies\n\
displayed on the Fourier representation of the image\n\
(right image).\",\
\"OK\""
first_time=0
-endif
-do
-if $need_update
-i[mask] [logmag],[logmag]
r={sqrt(w^2+h^2)*$freqmax/200} -ellipse[mask] 50%,50%,$r,$r,0,1,1
r={max(0,sqrt(w^2+h^2)*$freqmin/200-1)} -if $r -ellipse[mask] 50%,50%,$r,$r,0,1,0 -endif
--*[logmag] [mask] -+. [mask] -/. 2 -n. 0,255
-shift[mask] -{mask,round(w/2)},-{mask,round(h/2)},0,0,2
--*[real,imag] [mask]
-rm[mask]
-ifft[-2,-1] -rm. -n. 0,255
-rv[-2,-1]
-if {*} -r[-2,-1] {{*,w}/2},{*,h} -endif
-t. "Freq. Min/Max = "{int($freqmin)}"% / "{int($freqmax)}"%",5,5,13,1,255
-w[-2,-1] -rm[-2,-1]
need_update=0
-endif
-wait
-if {{*,b}" && "{*,x}>={*,w}/2}
r={200*sqrt(({*,x}-3*{*,w}/4)^2+({*,y}-{*,h}/2)^2)/\
sqrt(({*,w}/2)^2+{*,h}^2)}
-if {{*,b}&1} freqmax=$r
-else freqmin={max(0,$r-3)}
-endif
-if {$freqmin>=$freqmax} freqmin=$freqmax -endif
need_update=1
-endif
-if {*,r} need_update=1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} -w[] {{*,w}*1.5},{{*,h}*1.5} need_update=1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} -w[] {{*,w}/1.5},{{*,h}/1.5} need_update=1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} -w[] {2*{0,w}},{0,h} need_update=1 -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w 0
-endl
-rm[^0]
-endl -done -rm -v +
#@gmic x_histogram
#@gmic : Launch the histogram demo.
x_histogram :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Histogram demo"$n" -------------------------------\n
----\n
---- "${c}"Mouse"$n" to set parameters.\n
---- "${c}"Right button"$n" or key '"${c}"SPACE"$n"' to reset.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
-v -
-if {!$!} -testimage2d 300,300 -else -k[0] -to_rgb -r2dy 300,2 -if {w>800} -r 800,100%,1,3,2 -endif -n 0,255 -endif
--frame. 1,1,0
300,{h},1,3,220
-t. "Gamma :",5,0,16,1,0
-t. "Contrast :",5,50,16,1,0
-t. "Brightness :",5,100,16,1,0
-t. "Smoothness :",5,150,16,1,0
-t. "Sharpness :",5,200,16,1,0
-t. "Clusters :",5,250,16,1,0
-a[-2,-1] x
{w},200,1,3,255
-grid. 10%,10%,0,0,0.3,0xCCCCCCCC,0
-rectangle. 0,0,100%,100%,1,0xFFFFFFFF,0
-axes. 0,255,1,0,13,1,0
-frame[-2,-1] 5,5,220
-a[-2,-1] y
clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1
-do
[0]
ia={ia}
-if $gamma -/. 255 -^. {1/$gamma} -*. 255 -endif
--. $ia -*. $contrast -+. $brightness -+. $ia
-b. $smoothness
-sharpen. $sharpness
-c. 0,255
--j.. [-1],6,6
sx={{0,w}+12}
-_x_histogram. {$gamma*100/4} -j.. [-1],$sx,25 -rm.
-_x_histogram. {$contrast*100/4} -j.. [-1],$sx,75 -rm.
-_x_histogram. {($brightness+128)*100/256} -j.. [-1],$sx,125 -rm.
-_x_histogram. {$smoothness*100/10} -j.. [-1],$sx,175 -rm.
-_x_histogram. {$sharpness*100/2000} -j.. [-1],$sx,225 -rm.
-_x_histogram. {$clusters*100/256} -j.. [-1],$sx,275 -rm.
--s.. c -histogram[-3--1] $clusters,0,255 -/[-3--1] {3*{0,wh}/$clusters} -rm[-5]
--z[-4] 5,317,{{-4,w}-5},{{-4,h}-6}
-graph. [-4],3,0,1,0,0.2,255,0,0
-graph. [-3],3,0,1,0,0.2,0,255,0
-graph. [-2],3,0,1,0,0.2,0,0,255
-rm[-4--2]
-j.. [-1],5,317 -rm.
-w. {w},{h},0,"[G"{`39`}"MIC] Histogram demo" -rm.
-wait
-if {{*,b}&1\ &&\ {*,x}>={0,w}-10}
-if {{*,y}>=25\ &&\ {*,y}<=42}
gamma={max(0,min(4,({*,x}-$sx)*4/280))}
-elif {{*,y}>=75\ &&\ {*,y}<=92}
contrast={max(0,min(4,({*,x}-$sx)*4/280))}
-elif {{*,y}>=125\ &&\ {*,y}<=142}
brightness={max(-128,min(128,({*,x}-$sx)*256/280-128))}
-elif {{*,y}>=175\ &&\ {*,y}<=192}
smoothness={max(0,min(10,({*,x}-$sx)*10/280))}
-elif {{*,y}>=225\ &&\ {*,y}<=242}
sharpness={max(0,min(2000,({*,x}-$sx)*2000/280))}
-elif {{*,y}>=275\ &&\ {*,y}<=292}
clusters={max(2,min(256,({*,x}-$sx)*256/280))}
-endif
-endif
-if {{*,b}&2\ ||\ {*,SPACE}} clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1 -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w 0 -rm -v +
_x_histogram :
val={max(0,min(100,$1))}
280,2,1,3,255 -line. 0,0,$val%,0,1,0,255,0 -line. 0,1,$val%,1,1,240,255,62 -r. 100%,16,1,3,3
0 -t. {round($val)}%,0,0,14,1,1 --*. -255 -+. 255 -r. 100%,100%,1,3
-j... [-1],{(280-w)/2},{(16-h)/2},0,0,1,[-2] -rm[-2,-1]
-r. {w+2},{h+2},1,3,0,0,0.5,0.5
#@gmic x_hough
#@gmic : Launch the hough transform demo.
x_hough :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Hough-transform"$n" -----------------------------------------\n
----\n
---- "${c}"Mouse buttons"$n" on the vote image to draw corresponding line.\n
---- "${c}"Mouse buttons"$n" on the image to vote for all lines crossing.\n
---- the clicked point.\n
---- Key '"${c}"SPACE"$n"' to reset the hough window.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------------"
-v -
-if {!$!} -testimage2d 400 -endif
-n 0,255
-repeat $! -l[$>]
-r. ${-fitscreen\ {w},{h}},1,100%,3
-if {!narg($first_time)}
-parallel 0,"--l[0] -r2dy 128 -frame 1,1,0 \
-alert \"[G"{`39`}"MIC Hough Transform]\",\
\"The G\47MIC Hough transform demo illustrates the application\n\
of the Hough transform to detect lines in an image. Use your\n\
mouse buttons to explore the transform image and see how\n\
lines in images are represented by points in the transform.\",\
\"OK\" \
-rm -endl"
first_time=0
-endif
rhomax={sqrt(w^2+h^2)/2}
--b. 1.5 -hough. 512,400 -b. 0.5 -+. 1 -log. -n. 0,255
-w.. -1,-1,0,"[G"{`39`}"MIC] Image" -w1. -1,-1,0,"[G"{`39`}"MIC] Hough transform"
-do
-wait
-if {*,b}
x0={{*,x}-{*,w}/2}
y0={{*,y}-{*,h}/2}
rho0={sqrt(($x0)^2+($y0)^2)}
theta0={atan2($y0,$x0)}
(0,{2*pi}) ($theta0,{$theta0-2*pi})
-r[-2,-1] {-3,w},1,1,1,3
-cos. -*. $rho0 --<. 0 -abs..
-*. {pi} -+[-3,-1] -%.. {2*pi}
-*.. {0.5*{-3,w}/pi} -*. {{-3,h}/$rhomax}
-a[-2,-1] y
-repeat {w} -point.. {i($>,0)},{i($>,1)},0,0.3,255 -done
-rm. -w1.
-elif {{*1,x}>=0" && "{*1,b}}
theta={{*1,x}*2*pi/{*1,w}}
rho={{*1,y}*$rhomax/{*1,h}}
x={{-2,w}/2+$rho*cos($theta)}
y={{-2,h}/2+$rho*sin($theta)}
x0={$x+1000*sin($theta)}
y0={$y-1000*cos($theta)}
x1={$x-1000*sin($theta)}
y1={$y+1000*cos($theta)}
[-2]
-line. $x0,$y0,$x1,$y1,1,0x0F0F0F0F,255
-line. {$x0+1},$y0,$x1,$y1,1,0x0F0F0F0F,255
-line. $x0,{$y0+1},$x1,$y1,1,0x0F0F0F0F,255
-line. $x0,$y0,$x1,$y1,1,0xF0F0F0F0,0
-line. {$x0+1},$y0,$x1,$y1,1,0xF0F0F0F0,0
-line. $x0,{$y0+1},$x1,$y1,1,0xF0F0F0F0,0
-w. -rm.
-elif {{*,SPACE}" || "{*1,SPACE}}
-rm. --b. 1.5 -hough. 512,400 -b. 0.5 -+. 1 -log. -n. 0,255
-w1. -1,-1,0,"Hough Transform"
-elif {*,r} -w..
-elif {*1,r} -w1.
-endif
-while {{*}" && "{*1}" && "!{*,ESC}" && "!{*,Q}" && "!{*1,ESC}" && "!{*1,Q}}
-w 0 -w1 0
-rm. -endl
-if {!{*}" || "!{*1}} -break -endif
-done -rm -v +
#@gmic x_jawbreaker : 0<_width<20,0<_height<20,0<_balls<=8
#@gmic : Launch the Jawbreaker game.
x_jawbreaker : -check "${1=12}>0 && $1<20 && ${2=13}>0 && $2<20 && ${3=5}>0 && $3<=8"
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Jawbreaker"$n" --------------------------------------------\n
----\n
---- The goal of the game is to "${c}"remove the maximum number of\n
---- balls on the board"$n", simply by clicking on them. But a\n
---- colored ball can disappear only if it is grouped with at\n
---- least one ball of the same color. The score is higher if\n
---- you destroy larger sets of connected colored balls.\n
----\n
---- "${c}"Left mouse button"$n" to select/destroy balls on board.\n
---- Key '"${c}"BACKSPACE"$n"' or '"${c}"SPACE"$n"' to undo the last move.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
-v -
-i[board] $1,$2 -rand[board] 1,$3 -round[board] 1
-i[undo] [-1]
-i[balls] 32,32,1,4 -_x_jawbreaker_ball. -autocrop. 0 -expand_xy. 1,0 -*. 1.5 -c. 0,255 -r. {{board,w}*w},{{board,h}*h},1,1,0,2 -/. 255
-i[back] {w},{h},1,3 -l.
-rand 0,255 -blur_xy 6,20 -equalize 100,0,255 -blur_xy 2,4
-sh 0 -sh.. 1 -sh... 2 -/... 4 -/.. 8 -/. 2 -rm[-3--1]
-endl
-i[visu] [back]
score=0
undoscore=0
render_board=1
shapescorey=0
shapescore=0
-do
-if $render_board
--abs[board] --. 1 -*. {360/$3} -->=[board] 0 -*. 0.9 --!=[board] 0
-r[-3--1] [balls] [balls] -*[-2,-1] -a[-3--1] c -hsv2rgb.
--compose_channels. + ->. 0 -dilate. 3
-j[visu] [back] -j[visu] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
-if {!$shapescorey} -w[visu] {back,w},{back,h},0,"[G"{`39`}"MIC] Jawbreaker (score : "$score")" -endif
render_board=0
-endif
-if $shapescorey
--t[visu] "+"$shapescore,{*,x},{{*,y}-64+$shapescorey},32,{($shapescorey-1)/31},255
shapescorey={max(0,$shapescorey-1)}
-w. {back,w},{back,h},0,"[G"{`39`}"MIC] Jawbreaker (score : "$score")" -rm. -wait 25
-else -wait -endif
--f[board] "if(i,j(-1)==i || j(1)==i || j(0,1)==i || j(0,-1)==i,0)"
-if {!is} -rm. -break -endif -rm.
-if {*,r} render_board=1
-elif {*,S} -o[visu] gmic_jawbreaker.png
-elif {{*,BACKSPACE}" || "{*,SPACE}}
-abs[undo] -j[board] [undo]
score=$undoscore
render_board=1
-elif {{*,x}">=0 && "{*,b}}
-wait -1
x={"int("{*,x}"*"{board,w}"/"{*,w}")"}
y={"int("{*,y}"*"{board,h}"/"{*,h}")"}
-if {{board,i($x,$y)}>0}
-abs[board] -flood[board] $x,$y,0,0,0,1,-{board,i($x,$y)}
-->=[board] 0 --. 1
shapescore={(is+1)^2} shapescorey={if($shapescore,32,0)} -rm.
-elif {board,i($x,$y)}
--flood[board] $x,$y,0,0,0,1,-1 -==. -1
-if {is>1}
-j[undo] [board]
undoscore=$score
-flood[board] $x,$y,0,0,0,1,0
-repeat {board,w}
--columns[board] $> -mirror. y
h={board,h} -l. -s -,0 -a y -if $! -r 1,$h,1,1,0 -mirror y -else -i 1,$h -endif -endl
-j[board] [-1],$> -rm.
-done
-rows[board] -1,100% -f[board] "if(y==0,if(i(x,h-1),x,w),i)" -sort[board] +,x -rows[board] 1,100%
score+={int((is-1)^2)}
-endif
-rm.
-else -abs[board]
-endif
render_board=1
-endif
-while {{*}" && "!{*,Q}" && "!{*,ESC}}
-if {{*}" && "!{*,ESC}}
-w[] {visu,w},{visu,h},0,"[G"{`39`}"MIC] Jawbreaker (final score : "$score")"
-i[gameover] 260,85 -t. "Game Over!",3,0,53,1,1 -t. "Score : "$score,23,53,32,1,1
--dilate. 5 -nm. "mgameover" -*.. 255 -r.. 100%,100%,1,3
-repeat 25
--r[gameover,mgameover] {400-12*($>+1)}%,{400-12*($>+1)}%
--j[visu] [-2],{({visu,w}-w)/2},{({visu,h}-h)/2},0,0,{$>/25},[-1]
-w. -rm[-3--1] -wait 25
-done
-do
-wait -if {*,r} -w[] {*,w},{*,h} -wait -1 -endif
-while {{*}" && "!{*,Q}" && "!{*,ESC}" && "!{*,b}}
-rm[gameover,mgameover]
-endif
-rm[board,undo,balls,back,visu]
-w 0 -v +
_x_jawbreaker_ball :
mwh={min(w,h)}
-sh 3 -f. 0 -rm.
-ellipse {0.5*$mwh},{0.5*$mwh},{0.5*$mwh-4},{0.5*$mwh-4},0,1,240,240,240,1
-sh 0,2 -*. '($mwh+y-x)/(2*w)' -rm.
-ellipse {$mwh*0.7},{$mwh*0.3},{min(30,$mwh*$mwh/512)},{min(30,$mwh*$mwh/512)},0,{min($mwh/64,1)},255,255,255,1
-sh 0,2 -b. {0.02*$mwh} -rm.
-sh 3 -*.. [-1] -dilate. 3 -rm.
-sh 0,2 -+. 'if(i&&(!j(-1)||!j(1)||!j(0,-1)||!j(0,1)),240/6,0)' -rm.
#@gmic x_landscape
#@gmic : Launch the virtual landscape demo.
x_landscape :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Virtual landscape"$n" -------------------------------------\n
----\n
---- Enjoy the view!\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
-v - -l[]
W=150 H=350
900,900 -plasma. 1,1,6 -b. 0.07% -n. 0,255 -nm. map
--g. -*. 0.5 -+[-2,-1] -n. 0,1 -^. 2 -n. -150,330
-equalize[map] 256 -n[map] -400,160 -c[map] 0,100%
(0,102,51;149,175,124;102,42,0;255,255,255) -permute. yzcx -srgb2rgb. -r. 256,1,1,3,3 -rgb2srgb. --n[map] 0,255 -map. [-2] -rm..
-+. [-2] -rm.. -c. 0,255 -nm. colors
$W,$H,1,1,'x' -y. x -nm. x
$W,$H,1,1,'1+x+y*w' -y. x -nm. offsets
$W,$H,1,1,'0.5*y' -nm. gmap Mgmap={iM}
$W,$H,1,3 -fc. 60,80,135 -nm. ccolors
$W,$H,1,1,'(y/$H)^2' -nm. mcolors
$W,400,1,1,'b=h-1-$Mgmap;if(y>=b,256+(y-b)*255/(h-1-b),y*255/b)' -round.
(96^16^128) (0^200^255) -a[-2,-1] x -r. 256,1,1,3,3
(0^32^0) (0^64^128) -a[-2,-1] x -r. 256,1,1,3,3
-a[-2,-1] x -map.. [-1] -rm.
-nm. background
-quadrangle3d[] -0.45,0,0,0.45,0,0,0.55,1,0,-0.55,1,0 -*3d. {$W/2},{$H/2} -nm. viewrange3d
(64^16^0) -r. $W -nm. groundcolor
-w[] 520,400,0,"[G"{`39`}"MIC] Virtual landscape"
-do
t={$|*0.03}
xm={map,w/2+(w-$H/2)/2*cos(3.1*$t)}
ym={map,h/2+(h-$H/2)/2*sin(2.8*$t)}
u={map,(w-$H/2)*cos(2.5*$t)}
v={map,(h-$H/2)*sin(9.7*$t)}
a={atan2($v,$u)*180/pi}
--r3d[viewrange3d] 0,0,1,$a -y. x
({$xm+i[8]},{$xm+i[11]};{$xm+i[17]},{$xm+i[14]}^{$ym+i[9]},{$ym+i[12]};{$ym+i[18]},{$ym+i[15]}) -rm..
-r. $W,$H,1,2,3 --warp[map,colors] [-1],0,1,0 -rm...
-nm.. lmap -nm. lcolors
--!=[lmap] 0 -nm. ground
-+[lmap] [gmap]
-j[lcolors] [ccolors],0,0,0,0,1,[mcolors]
-j[lcolors] [groundcolor]
--round[lmap] -f. '>m=abs(j(0,-1));i>m?i:-m' -nm. y0
--shift. 0,1 -abs. -+. 1 -nm. y1
-*[y0,y1] [ground] -rm[ground]
-r[lcolors,y0,y1] {$W*$H},1,1,100%,-1
-->[y0] 0 -*. [offsets] -discard. 0
-if {h}
--. 1 --warp[x] [-1],0,0,0 -nm. lx
-warp[lcolors,y0,y1] [-2],0,0,0 -rm..
N={h} ({'CImg3d'},{2*$N},$N)
--a[lx] [y0],x -rm[y0] --a[lx] [y1],x -rm[lx,y1] -a[-2,-1] y -z. 0,2
1,$N,1,1,2 --f. y --+. $N -a[-3--1] x
-mv[lcolors] $! -permute. cyzx
1,$N,1,1,1
-y[-5--1] y -a[-5--1] y -*3d. -1,-1
--j3d[background] [-1],{background,w-1},{background,h},0,1,1,0,0,0 -rm[-3,-2]
-else
-rm[-5--1] [background]
-endif
-r. {*,w},{*,h},1,3
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,5,24,2,0.2 -endif
-w. -1,-1,0 -rm.
-if {{*,CTRLLEFT}&&{*,D}} -w[] 720,600 -elif {{*,CTRLLEFT}&&{*,C}} -w[] 520,400 -endif
-wait 20
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -endl -v +
#@gmic x_life
#@gmic : Launch the game of life.
x_life :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"The game of life"$n" --------------------------------------\n
----\n
---- The goal is to create the "${c}"biggest possible biological\n
---- system"$n". You start with a stock of cells which you can\n
---- spread over the board. For each new cells created\n
---- simultaneously and spontaneously by your system, you\n
---- gain more new cells to scatter.\n
----\n
---- "${c}"Left mouse button"$n" to scatter cells in stock.\n
---- "${c}"Right mouse button"$n" to reset game.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
-v -
-i[0] 90,90,1,1,0
-i[1] [0] -f[1] 0
-i[2] 400,400,1,3
-i[3] 1
iteration=0
score=0
bestscore=0
stock=500
-w[0] 400,400,0,"[G"{`39`}"MIC] The game of life"
-cursor[0] 0
-do
(1,1,1;1,0,1;1,1,1) --correlate[0] [-1],0 -rm..
--ir. 2,2 -&. [0] -ir.. 3,3 -|[-2,-1]
-rv[0,-1]
-if {{*,x}>0" && "{*,b}==1" && "$stock>0}
nb={u*7}
-repeat $nb
x={{*,x}/{*,w}*{0,w}+u(-4,4)}
y={{*,y}/{*,h}*{0,h}+u(-3,3)}
-=[0] 1,$x,$y
-=[1] $iteration,$x,$y
-point[2] {$x*{2,w}/{0,w}},{$y*{2,h}/{0,h}},0,0.8,255
-done
stock={round(max(0,$stock-$nb))}
-endif
--. [0] -*. -1
stock-={2*(min(0,int(is/16*$score/150)))}
-+[1] [0]
-min. 0 -+. 1 -*[1,-1]
-if {{*,b}==2}
-f[0-2] 0 iteration=0 score=0 bestscore=0 stock=500 -rm[3] -i[3] 1
-endif
-if {{3,w}==1}
-rm[3] -i[3] {u(3,12)},1,1,3,u(100,255)
-r[3] {u(100,300)}%,1,1,3,4
-point[3] 0,0,0,1,0
-r[3] {u(100,600)}%,1,1,3,5 -c[3] 0,255
-endif
--r[1] {2,w},{2,h} -&. 7 -b. {1+$score*0.05}
-n. 0,{3,w} -map. [3] -*. 0.1 -+[2,-1] -/[2] 1.1
[2] -if {{*,x}>0}
opac={0.7*min(1,$stock/500)} r={min(500,$stock)*cos($iteration)/100}
-ellipse. {*,x},{*,y},{15+$r},{15+$r},0,$opac,0,196,0
-ellipse. {*,x},{*,y},{10+$r},{10+$r},0,$opac,32,64,16
-ellipse. {*,x},{*,y},{5+$r},{5+$r},0,$opac,255,230,0
-endif
-t. "Living cells : "$score"\n"\
"Stock : "$stock"\n"\
"Score : "$bestscore,5,3,22,0.7,255
-w. {*,w},{*,h}
-if {*,S} -o. gmic_life.png -endif
-rm.
-if {!($iteration%10)} score={0,is} bestscore={max($score,$bestscore)} -endif
-wait 60
iteration+=1
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm[0-3] -w 0 -v +
#@gmic x_light
#@gmic : Launch the light effect demo.
x_light :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Light effect"$n" ------------------------\n
----\n
---- Move light position with "${c}"mouse"$n".\n
---- "${c}"Mouse buttons"$n" fade light in/out.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
-v -
0 -t. "    G\47MIC\nLight effect",0,0,80,1,255 -expand_xy. 15,0 -b. 3
[-1] -n.. 0,1 -r.. 100%,100%,1,3
-sh.. 0 -*. 120 -rm.
-sh.. 1 -*. 70 -rm.
-sh.. 0,50%,0,2 -*. 120 -rm.
25%,25%,1,1 -rand. -20,20 -smooth. 10,0,1,1,4 -r. [-2],3 -b. 3 -n. -100,100
-+[-2,-1] -g. xy -a[-2,-1] c -n. -150,150
-w[] {1.5*{-2,w}},{1.5*{-2,h}},0,"[G"{`39`}"MIC] Light effect"
-cursor[0] 0
light=70
640,640 -gaussian. $light -n. 0,255
t=0
-do
-if {{*,x}>=0}
X={round((w-{*,x})/2)}
Y={round((h-{*,y})/2)}
-else
X={round((w-{-2,w}*(1+cos(2*$t)))/2)}
Y={round((h-{-2,h}*(1+sin(2.5*$t)))/2)}
t+=0.02
-endif
-if {{*,b}&1} light={min(200,$light+10)} -gaussian. $light -n. 0,255 -endif
-if {{*,b}&2} light={max(10,$light-10)} -gaussian. $light -n. 0,255 -endif
--z. $X,$Y,{$X+{-2,w}-1},{$Y+{-2,h}-1}
-warp. [-3],1,0,1
-r. 100%,100%,1,3 -+. [-4] -c. 0,255
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,5,16,1,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {3*w},{3*h}
-elif {{*,CTRLLEFT}&&{*,C}} -w[] {1.5*w},{1.5*h} -endif
-rm. -if {{*,x}>=0" && "!{*,b}} -wait -else -wait 20 -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w[] 0 -rm[-3--1] -v +
#@gmic x_mandelbrot : _julia={ 0 | 1 },_c0r,_c0i
#@gmic : Launch Mandelbrot/Julia explorer.
x_mandelbrot : -skip ${1=0},${2=0.317},${3=0.03}
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Mandelbrot/Julia explorer"$n" -----------------\n
----\n
---- Select zooming region with "${c}"mouse"$n".\n
---- "${c}"Click once"$n" to reset zoom factor.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
---- Key '"${c}"C"$n"' to print current fractal coordinates.\n
----\n
--------------------------------------------------"
-v -
-rm -w 512,512,0 -_x_mandelbrot_coords $1 -_x_mandelbrot_palette
-do
siz={min({*,w},{*,h})}
$siz,$siz -mandelbrot. {0,^},256,$1,{if($1,$2,0)},{if($1,$3,0)} -map. [1]
-if $1 -w. $siz,$siz,0,"[G"{`39`}"MIC] Julia set c=("{0,@0-1}")-("{0,@2-3}"), c0=($2,$3)"
-else -w. $siz,$siz,0,"[G"{`39`}"MIC] Mandelbrot set c=("{0,@0-1}")-("{0,@2-3}")" -endif
w={w} h={h} -round. -select. 2
-if {i[0]>0}
M={max(i[3]-i[0],i[4]-i[1])}
-if {$M<5} -_x_mandelbrot_coords $1 -rm[1] -_x_mandelbrot_palette -mv. 1
-else ({{0,@0}+{@0}*({0,@2}-{0,@0})/$w};\
{{0,@1}+{@1}*({0,@3}-{0,@1})/$h};\
{{0,@0}+({@0}+$M)*({0,@2}-{0,@0})/$w};\
{{0,@1}+({@1}+$M)*({0,@3}-{0,@1})/$h})
-endif
-rm[0] -mv. 0
-endif
-rm.
-if {{*,C}}
-if $1 -v + -e[0--4] "Julia set, at c = ("{0,@0-1}")-("{0,@2-3}"), with c0 = ($2,$3)." -v -
-else -v + -e[0--4] "Mandelbrot set, at c = ("{0,@0-1}")-("{0,@2-3}")." -v -
-endif
-endif
-if {!{*}" || "{*,ESC}" || "{*,Q}} -rm -w 0 -v + -return -endif
-wait -1
-while 1
_x_mandelbrot_coords :
-if $1 (-2;-2;2;2) -else (-2.1;-1.5;1.2;1.5) -endif
_x_mandelbrot_palette :
6,1,1,3 -rand. 20,255 -r. 32,1,1,3,3 -r. 1024,1,1,3,0,2 -=. 0,0,0,0,0 -=. 0,0,0,0,1 -=. 0,0,0,0,2
#@gmic x_metaballs3d
#@gmic : Launch the 3d metaballs demo.
x_metaballs3d :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"3d metaballs"$n" ---------------------------------------\n
----\n
---- "${c}"Mouse button"$n" or '"${c}"SPACE"$n"' key to toggle rendering mode.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------------"
-v - -l[]
100,100 -noise. 100,1 -plasma. 1,0,10 -r. 512,320,1,3 -n. 0,1 -b. 4,0 -n. 0,255
-mix_channels. (0.7,0,0;0,0.9,0;0,0,1.2) -c. 0,255 -l3d
0
24,24,24,1,'X=x-w/2;Y=y-h/2;Z=z-d/2;exp(-(X*X+Y*Y+Z*Z)/100)'
72,72,72 M=8 mode=3
s0=Dots s1=Wireframe s2=Flat s3=Flat-shaded s4=Gouraud-shaded s5=Phong-shaded
-repeat $M fx$>={2*g} fy$>={2*g} fz$>={2*g} -done
-w[0] -1,-1,0,"[G"{`39`}"MIC] 3d metaballs"
-do
-repeat $M
x$>={w/2+0.5*(w-{2,w}-4)*cos(${fx$>}*$|)}
y$>={h/2+0.5*(h-{2,h}-4)*sin(${fy$>}*$|)}
z$>={d/2+0.5*(d-{2,d}-4)*sin(${fz$>}*$|)}
-done
-f[3] 0 -repeat $M -j[3] [2],{${x$>}-{2,w/2}},{${y$>}-{2,h/2}},{${z$>}-{2,d/2}},0,-1 -done
--r[3] 28,28,28,1,2 -isosurface3d. 0.4 --3d. 12,12,12 -*3d. 13 -rv3d.
-r3d. 1,2,1,{100*$|}
N={i[7]} (255,255,150;200,96,164;50,150,230) -r. 3,$N,1,1,3 -y. -j.. [-1],0,{{-2,h}-4*$N}
-if {!$mode} -circles3d.. 4 -endif
-if {!{1,w}}
0 -t. ${s$mode},5,5,23,0.5,255,255,255 -b. 0.7 -n. 0,255
--dilate. 3 --j[0] [-2],5,3,0,0,1,[-1],255 -mv. 1 -rm[2,-2,-1]
-endif
--j3d[1] [-2],50%,50%,0,1,{if(!$mode,3,$mode)},0,0,300,0,0,-500,0.1,1.5
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,{h-22},16,2,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-rm[-3--1] -wait 20
-if {{*,b}||{*,SPACE}} mode={($mode+if({*,b}&2,-1,1))%6} -wait -1 -rm[1] -i[1] 0 -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -endl -v +
#@gmic x_minesweeper : 8<=_width=<20,8<=_height<=20
#@gmic : Launch the Minesweeper game.
x_minesweeper : -check "${1=20}>=8 && $1<=30 && ${2=$1}>=8 && $2<=30"
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Minesweeper"$n" -------------------------------------------\n
----\n
---- The goal is to "${c}"clear the minefield"$n" without detonating a\n
---- mine.\n
----\n
---- "${c}"Left mouse button"$n" to try clearing one square.\n
---- "${c}"Right mouse button"$n" to flag or unflag a square.\n
---- "${c}"Middle mouse button"$n" to reset mine field.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------\n"
-v -
$1,$2 -noise. 30,2 nb_mines={is} (1,1,1;1,0,1;1,1,1) --convolve.. [-1],0 -rm.. -+. 1 -==.. 0 -*[-2,-1] -nm. field
-do x={round(u(w-1))} y={round(u(h-1))} -while {i($x,$y)!=1}
--f[field] 11 -=. 12,$x,$y -nm. board
24,24,1,3,200 -fc. 255,180,130
-ellipse. 12,12,4,4 -line. 6,12,18,12 -line. 12,6,12,18 -line. 13,10,14,10,1,255 -line. 13,11,14,11,1,255
-z. 1,1,{w-2},{h-2} -frame. 1,1,0
--fc. 230,250,255
--t. "1",10,5,13,1,0,196,0 --t.. "2",9,5,13,1,0,128,0 --t... "3",9,5,13,1,0,0,255
--t[-4] "4",9,5,13,1,255,0,0 --t[-5] "5",9,5,13,1,200,0,0 --t[-6] "6",9,5,13,1,150,0,0
--t[-7] "7",9,5,13,1,128,0,0 --t[-8] "8",9,5,13,1,64,0,0
--f. 'if(x<=1||y<=1||x>=w-2||y>=h-2,if(x<y,128,255),160+2*(y+x))'
--polygon. 4,13,15,11,15,6,18,17,18,1,0 -line. 12,15,12,6,1,255,0,0 -polygon. 3,12,6,6,9,12,12,1,220,0,0
-rv[-2,-1]
[-1] 100%,100%,1,3 -line. 6,14,10,18,1,0,200,0 -line. 10,18,16,6,1,0,200,0 -dilate. 2
--channels. 1 -n. 0,0.7 -dilate. 3 -j... [-2],0,0,0,0,1,[-1] -rm[-2,-1]
-a[-13--1] x -nm. sprites
(0,23;0,23^0,0;23,23) -r. 24,24,1,2,3 -r. {board,w*24},{board,h*24},1,2,0,2 -nm. offsets
[-1],[-1],1,3,255 -frame. 1,1,0 -frame. 23,23,255
0 -t. "Number of mines : "$nb_mines,0,0,18,1,100,200,255 -negative. -j.. [-1],{({-2,w}-w)/2},{{-2,h}-h-2} -rm.
-nm. canvas
failed=0 succeeded=0 nb_flags=0 started=0
-do
--*[board] 24 -r. [offsets],[offsets] -channels. 0,1 -+. [offsets] --warp[sprites] [-1],0,0 -rm..
-j[canvas] [-1],24,24 -rm.
-wait -1
-if $failed
0 -t. "Game\nOver!",3,3,38,1,255 -r. 100%,100%,1,4 -sh. 3 -dilate. 5 -/. 2 -rm.
-drop_shadow. 5,5,1 -blend[canvas,-1] alpha
0 -t. "Boom! You failed!",0,0,18,1,100,255,255 -r. {canvas,w},100%,1,3,0,0,0.5,0.5 -negative. -j[canvas] [-1],0,3 -rm.
-do -w[canvas] {w},{h} -wait -while {{*}" && "!{*,ESC}" && "!{*,Q}}
-elif $succeeded
0 -t. "Success!",3,3,38,1,255 -r. 100%,100%,1,4 -sh. 3 -dilate. 5 -/. 2 -rm.
-drop_shadow. 5,5,1 -blend[canvas,-1] alpha
0 -t. "Congratulations! ("{round($|-$tic)}" s)",0,0,18,1,255,100,255 -r. {canvas,w},100%,1,3,0,0,0.5,0.5
-negative. -j[canvas] [-1],0,3 -rm.
-do -w[canvas] {w},{h} -wait -while {{*}" && "!{*,ESC}" && "!{*,Q}}
-else
--==[board] 10 nb_flags={is} -rm.
-do
-if {!$started} tic=$| -endif
0 -t. "Elapsed time : "{round($|-$tic)}" s / Flags : "$nb_flags,0,0,18,1,255,200,0 -r. {canvas,w},100%,1,3,0,0,0.5,0.5
-negative. -j[canvas] [-1],0,3 -rm.
-wait 50
x={int(({*,x}-24)/24)} y={int(({*,y}-24)/24)} b={*,b}
-w[canvas] {w},{h},0,"[G"{`39`}"MIC] Minesweeper"
-while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!$b}
-endif
-if {$x>=0\ &&\ $y>=0\ &&\ $x<{board,w}\ &&\ $y<{board,h}}
-if {$b&1}
started=1 val={field,i($x,$y)}
-if {$val==0} --==[field] 0 -j[board] [field],0,0,0,0,1,[-1] -rm. failed=1
-elif {$val==1} --flood[field] $x,$y,0,0,1,1,-1 -==. -1 -dilate. 3 -j[board] [field],0,0,0,0,1,[-1] -rm.
-else -=[board] $val,$x,$y
-endif
-elif {n={board,i($x,$y)};$b&2" && "n>=10" && "n<=11}
-=[board] {if({board,i($x,$y)}==11,10,11)},$x,$y
-elif {$b&4} -f[board] 10
-endif
-endif
-if {$nb_mines==$nb_flags\ &&\ {board,iM}!=11} succeeded=1 -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w 0 -v +
#@gmic x_minimal_path
#@gmic : Launch the minimal path demo.
x_minimal_path :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Minimal path"$n" ------------------------------------------\n
----\n
---- "${c}"Click on two points"$n" to compute and display the minimal\n
---- path between those points. The ending point is then\n
---- chosen as the next starting point for another path.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
-v -
-if {!$!} -testimage2d 400 -endif
-n 0,200 -round 1
-repeat $! -l[$>]
-w[0] -1,-1,0,"[G"{`39`}"MIC] Select starting point P0"
-if {!narg($first_time)}
-parallel 0,"--l[0] -r2dy 128 -frame 1,1,0 \
-alert \"[G"{`39`}"MIC Minimal path]\",\
\"The G\47MIC minimal path demo illustrates how minimal paths\n\
can be computed in images to detect and track edge points.\n\
Use your mouse to select desired starting and ending points,\n\
and see what is the minimal path computed between these points.\",\
\"OK\" \
-rm -endl"
first_time=0
-endif
--gradient_norm -b. 1 -f. exp(-i/10)
-to_rgb[0] --select[0] 0 P0={^}
-ellipse[0] {@0,1},3,3,0,1,255,0,255
-ellipse[0] {@0,1},3,3,0,1,0xFFFFFFFF,255,255,255
-rm.
-if {min($P0)>=0}
p=1
-do
-w[0] -1,-1,0,"[G"{`39`}"MIC] Select ending point P"$p
--select[0] 0
-if {{*,S}}
-rm.
--text_outline[0] "Saving snapshot...",5,5,13,1,1,255,255,255 -w. -rm.
-o[0] gmic_minimal_path.png
-wait -1
-else
P1={^}
-ellipse[0] {@0,1},3,3,0,1,255,0,255
-ellipse[0] {@0,1},3,3,0,1,0xFFFFFFFF,255,255,255
-rm.
-if {min($P1)>=0}
--text_outline[0] "Processing...",5,5,13,1,1,255,255,255 -w. -rm.
--minimal_path[1] $P0,$P1,1
-pointcloud. 0 -*. 255 -r. 100%,100%,1,[0],0,0,0,0,0,0.5 -r. [0],0 -|[0,-1]
P0=$P1 p+=1
-endif
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-endif
-rm[1] -w 0
-endl -done -v +
#@gmic x_pacman
#@gmic : Launch pacman game.
x_pacman :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Pacman"$n" -----------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the "${g}"pacman"$n" game.\n
----\n
---- Move the pacman to eat all pacdots on the different levels.\n
---- Eating a pacgum makes pacman invincible for "${c}"10 seconds"$n",\n
---- which mean pacman can eat ghosts during this time.\n
---- Eating a ghost earns "${c}"100 pts"$n".\n
---- Eating a cherry earns "${c}"10 pts"$n".\n
---- Eating a strawberry earns "${c}"100 pts"$n".\n
---- Eating an orange earns "${c}"1000 pts"$n".\n
---- Eating a banana earns "${c}"5000 pts"$n".\n
----\n
---- "${c}"Arrow keys"$n" to control pacman.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
-v - -l[]
-m "_pacman_ghost_base_gfx : 31,19 -circle. 15,15,15,1,1 31,12,1,1,'y<4+8*abs(cos(x*0.3+0.25*pi*$""1))' -a[-2,-1] y"
-repeat 4
-_pacman_ghost_standard_gfx 255,0,0,$> -nm. ghost0_$>
-_pacman_ghost_standard_gfx 0,255,222,$> -nm. ghost1_$>
-_pacman_ghost_standard_gfx 255,184,222,$> -nm. ghost2_$>
-_pacman_ghost_standard_gfx 255,184,71,$> -nm. ghost3_$>
-_pacman_ghost_afraid_gfx $> -nm. ghosta_$>
-_pacman_ghost_base_gfx $> -r. 16,16,1,1,2 -nm. ghostm_$>
-_pacman_ghost_standard_gfx 0,0,0,$> -nm. ghostd_$>
-_pacman_pacman_gfx $> -nm.. pacman_$> -nm. pacmanm_$>
-done
--channels[ghostd_0] 0 -!=. 0 -nm. ghostdm
-_pacman_cherry_gfx -nm. fruit0 -_pacman_strawberry_gfx -nm. fruit1
-_pacman_orange_gfx -nm. fruit2 -_pacman_banana_gfx -nm. fruit3
20,2,1,3,200 -nm. gate
score0="10" score1="100" score2="1000" score3="5000" score4="Argh!"
-repeat 5
0 -t. ${score$>},0,0,13,1,255,255,255 -autocrop. 0 -expand_xy. 1,0 --dilate. 3
-nm. scorem$> -nm.. score$>
-done
time4=255,255,255 time3=255,255,32 time2=255,128,32 time1=255,32,32
-repeat 11 0 -t. $<" s",0,0,23,1,${time{min(4,round(($<+1)/2))}} -nm. time$< -done
0 -t. "Get Ready!",0,0,32,1,255 -autocrop. 0 -expand_xy. 4,0 --dilate. 8 -r.. 100%,100%,1,3
-nm.. get_ready -nm. get_readym
0 -t. "Game\nOver!",0,0,53,1,255 -autocrop. 0 -expand_xy. 4,0 --dilate. 8 -r.. 100%,100%,1,3
-nm.. game_over -nm. game_overm
score=0 level=-1 lives=3 is_quit=0
-do
-if {$level<0}
_rlevel=33 _glevel=33 _blevel=255
-_pacman_map_level{((-$level-1)%6)+1} mw={w} mh={h} mw2={int(w/2)} mh2={int(h/2)}
-if {$level<-6} -replace. 3,2 -endif
-nm. map0 -i[map] [-1]
--shift[map] -1,0 --shift[map] 0,-1 --shift[map] 1,0 --shift[map] 0,1 -a[-4--1] z -!=. 1 -nm. can_go
--==[map] 1 100%,100% -=. 1,$mw2,$mh2 -distance. 1,[-2],3 -rm..
-f. 'if(i==2,0,if(i==8,1,if(i==1,2,if(i==4,3,i))))' -nm. path
--==[map] 2 pacdots={is} -rm.
level={-$level}
-endif
-f[map] 'if(i>=4,0,i)' --==[map] 1 -expand_xy. 1,0 -r. 1600%,1600% -erode. 9 -b. 2
-g. xy -abs[-2,-1] -+[-2,-1] ->=. 80% -b. 2 -n. 0,1 -shrink_xy. 16
--*. $_glevel --*.. $_blevel -*... $_rlevel -a[-3--1] c
16,16,1,1,'x' ---[map] 1 -max. 0 -*. 16 -r. 1600%,1600%
16,16,1,1,'y' -r[-3,-1] [-2],0,2 -+[-2,-1] -a[-2,-1] c
16,16,1,3 -_pacman_pacdots_gfx -_pacman_pacgum_gfx -a[-3--1] y
-warp. [-2],0,0 -rm.. -|[-2,-1] -r. 100%,{h+24},1,3,0,0,0,1
-t. "Lives :",10,0,24,1,255 -t. "Score :",{w-140},0,24,1,255
-if $lives --r[pacman_2] 12,12,1,4,2 -r. {100*$lives}%,100%,1,4,0,2 -j.. [-1],90,7 -rm. -endif
-nm. visu
-w[visu] -1,-1,0,"[G"{`39`}"MIC] Pacman" -cursor[0] 0
0 -t. "Level "$level,0,0,53,1,1 -autocrop. 0 -expand_xy. 4,0 (0,255^0,255^0,0) --map.. [-1] -rm.. -dilate.. 8
-nm. level_N -nm.. levelm_N
-repeat 4 xg$>={16*$mw2} yg$>={16*$mh2+4*$>} dg$>=3 mg$>=0 -done
xp={16*10} yp={16*21} dp=-1 pacgum_timer=-1 fruit_timer=$| dying_pacman=0 is_get_ready=1
xscore=0 yscore=0 nscore=0 oscore=0
-do
t={int(6*$|)%4} left={if($pacgum_timer>=0,10-$|+$pacgum_timer,-1)}
[visu]
-repeat 4
mg=${mg$>} xg=${xg$>} yg={${yg$>}+24}
-if {$mg==0} -j. [ghost$>_$t],$xg,$yg,0,0,1,[ghostm_$t]
-elif {$mg==1} t2={if($left>7,$t,if($left>3,int(12*$|)%4,int(24*$|)%4))} -j. [ghosta_$t2],$xg,$yg,0,0,1,[ghostm_$t]
-elif {$mg==2} -j. [ghostd_$t],$xg,$yg,0,0,0.8,[ghostdm]
-else -j. [ghost$>_$t],$xg,$yg,0,0,{$mg-2},[ghostm_$t] -j. [ghostd_$t],$xg,$yg,0,0,1,[ghostdm]
-endif
-done
-if $dying_pacman
-_pacman_pacman_gfx {$dying_pacman/2} -rotate[-2,-1] {90*(abs($dp)-1)} -j... [-2],$xp,{24+$yp},0,0,1,[-1],255 -rm[-2,-1]
dying_pacman+=1
-if {$dying_pacman>64}
-if {$lives!=1} -rm. -break -endif
-j. [game_over],{(w-{game_over,w})/2},{12+(h-{game_over,h})/2},0,0,{min(1,($dying_pacman-64)/50)},[game_overm],255
-rectangle. 90,7,101,18,1,0
-endif
-else
--rotate[pacman_$t,pacmanm_$t] {90*(abs($dp)-1)} -j... [-2],$xp,{24+$yp},0,0,1,[-1],255 -rm[-2,-1]
-if {$left>=0" && "($left>=5" || "$t<=2)} -j. [time{round($left)}],{(w-{time0,w})/2-10},1 -endif
-endif
-t. $score,{w-65},3,22,1,255
-if {$is_get_ready}
-j. [level_N],{(w-{level_N,w})/2},{12+(h-1.5*{level_N,h})/2},0,0,1,[levelm_N]
-if {int($|*4)%2} -j. [get_ready],{(w-{get_ready,w})/2},{24+(h+{get_ready,h})/2},0,0,1,[get_readym],255 -endif
-endif
-if {$oscore>0} -j. [score$nscore],$xscore,$yscore,0,0,$oscore,[scorem$nscore],255 oscore-=0.04 yscore-=1 -endif
-j. [gate],158,223,0,0,0.6
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-rm.
-repeat 4
xg=${xg$>} yg=${yg$>} dg=${dg$>} mg=${mg$>}
-if {max(abs($xg-$xp),abs($yg-$yp))<=8}
-if {$mg==0" && "!$dying_pacman} dying_pacman=1
xscore=$xp yscore={$yp+12} oscore=1 nscore=4
-elif {$mg==1} mg=2 mg$>=$mg score+=100
xscore=$xp yscore={$yp+12} oscore=1 nscore=1
-endif
-endif
-if {$mg>=2" && "($xg>>4)==$mw2" && "($yg>>4)==$mh2}
mg+=0.01
-if {$mg>=3} mg=0 xg&=-2 yg&=-2 -endif
mg$>=$mg
-endif
-if {!($xg&15)" && "!($yg&15)}
({u},{u},{u},{u};0,1,2,3)
-if {$mg<2}
-=. {u(0.6,1)},{if($mg==0,dX0=$xp-$xg;dY0=$yp-$yg;if(abs(dX0)>abs(dY0),if(dX0>0,0,2),if(dY0>0,1,3)),\
dX1=$xp-$xg;dY1=$yp-$yg;if(abs(dX1)<abs(dY1),if(dX1>0,2,0),if(dY1>0,3,1)))}
-=. 0,{($dg+2)%4}
-if $is_get_ready -=. 0.8,{path,i({$xg>>4},{$yg>>4})} -endif
-else -=. 1,{path,i({$xg>>4},{$yg>>4})}
-endif
-sort. -,x -repeat 4 d={i($>,1)} -if {can_go,i({$xg>>4},{$yg>>4},$d)} dg=$d -break -endif -done -rm.
dg$>=$d
-endif
u={D=${dg$>};(D==0)-(D==2)}
v={D=${dg$>};(D==1)-(D==3)}
xg$>={($xg+$u*(1+($mg==0)))%(16*$mw)}
yg$>={($yg+$v*(1+($mg==0)))%(16*$mh)}
-done
-wait 22
-if {!$dying_pacman}
d={if({*,ARROWRIGHT},1,if({*,ARROWDOWN},2,if({*,ARROWLEFT},3,if({*,ARROWUP},4,$dp))))}
-if {!($xp&15)" && "!($yp&15)}
i={map,i({$xp>>4},{$yp>>4})}
-if {$i==2} score+=10 pacdots-=1
-elif {$i==3} pacgum_timer=$| -repeat 4 -if {!${mg$>}} mg$>=1 dg$>={(${dg$>}+2)%4} -endif -done
-elif {$i>=4} score+={${score{$i-4}}} xscore=$xp yscore={$yp+12} oscore=1 nscore={$i-4}
-endif
-=[map] 0,{$xp>>4},{$yp>>4}
16,16,1,3 -j[visu] [-1],$xp,{24+$yp} -rm.
d={if({can_go,i({$xp>>4},{$yp>>4},{abs($d)-1})},$d,$dp)}
d={if({can_go,i({$xp>>4},{$yp>>4},{abs($d)-1})},$d,-abs($dp))}
dp=$d
-else dp={if(abs($d-$dp)==2,$d,$dp)}
-endif
is_get_ready={if($dp>0,0,$is_get_ready)}
u={($dp==1)-($dp==3)}
v={($dp==2)-($dp==4)}
xp={($xp+2*$u)%(16*$mw)}
yp={($yp+2*$v)%(16*$mh)}
-if {$pacgum_timer>=0" && "$|>$pacgum_timer+10}
-repeat 4 xg$>&=-2 yg$>&=-2 mg$>={if(${mg$>}==1,0,${mg$>})} -done
pacgum_timer=-1
-endif
-if {!$is_get_ready" && "($|-$fruit_timer)>=10}
x={round(u(0,{map0,w}))}
y={round(u(0,{map0,h}))}
-if {!{map,i($x,$y)}" && "{map0,i($x,$y)}==2}
n={min(3,int(abs(g*1.7)))} -=[map] {4+$n},$x,$y -j[visu] [fruit$n],{16*$x},{16*$y+24} fruit_timer=$|
-endif
-endif
-endif
-if {!{*}" || "{*,Q}" || "{*,ESC}} is_quit=1 -endif
-while {!$is_quit" && "$pacdots}
-if $is_quit -break
-elif $pacdots
lives-=1
-else
level={-$level-1} -wait[0] -1
-rm[map0,map,can_go,path]
-endif
-rm[visu,level_N,levelm_N]
-while $lives
-rm -w 0 -endl -v +
_pacman_ghost_standard_gfx :
-_pacman_ghost_base_gfx $4 (0,$1^0,$2^0,$3) -map.. [-1] -rm.
-ellipse. 10,11,3,4,0,1,255 -ellipse. 20,11,3,4,0,1,255
-r. 16,16,1,3,2 -point. 5,{7-($4>=2)},0,1,1 -point. 10,{7-($4>=2)},0,1,1
_pacman_ghost_afraid_gfx :
-_pacman_ghost_base_gfx $1
-if {$1<2} col=255,255,255 (0,0^0,0^0,208) -else col=255,0,0 (0,248^0,248^0,248) -endif
-map.. [-1] -rm. -r. 16,16,1,3,2
-line. 4,4,6,6,1,$col,255 -line. 4,6,6,4,1,$col,255
-line. 9,4,11,6,1,$col,255 -line. 9,6,11,4,1,$col,255
-f. 'if(y>=9&&y<=10&&x>=2&&x<=13&&((int((x+1)/2)+y)%2),arg(c+1,$col),i)'
_pacman_pacman_gfx :
32,32,1,1,'X=x-15;Y=y-15;A=atan2(Y,X);R=sqrt(X^2+Y^2);R<15.5&&abs(A)>0.8*0.33*$1'
(0,255^0,255^0,0^0,255) -map.. [-1] -rm. -r. 16,16,1,4,2 -s. c,-3
_pacman_pacdots_gfx :
(255^184^151) -r. 4,4,1,3 -r. 16,16,1,3,0,0,0.5,0.5
_pacman_pacgum_gfx :
16,16,1,3 -circle. 7,7,7,1,255,128,64
_pacman_cherry_gfx :
(12,12,1,1,0,0,-10,-2,1,-8,-4,1,-6,-2,1,0,1,-7,0,1,-3,0,1,-3,-4,2,-3,0,1,-3,-6,2,0,1,-4,-5,2,0,-4,2,-2,\
0,2,3,-2,2,0,-6,2,0,-2,2,3,2,0,-6,2,-2,-3,2,0,2,3,-4,2,-6,-2,2,3,-3,2,-7,-4,2,-2,0)
-decompress_rle. (0,0,255,255^0,173,0,255^0,0,0,255) -map.. [-1] -rm. -r2dy. 14 -r. 16,16,1,3,0,0,0.5,0.5
_pacman_strawberry_gfx :
(11,12,1,1,0,0,-5,0,3,-7,-3,1,3,-3,1,-3,-2,2,-5,1,-2,2,0,-4,2,-3,1,-2,2,3,-2,2,3,-5,2,3,-6,2,3,\
2,3,-13,2,3,-2,2,0,2,3,-2,2,3,-4,2,-2,-9,2,-3,-2,2,3,-2,2,3,-6,-5,2,-8,0,2,-5,0)
-decompress_rle. (0,0,255,255^0,173,0,255^0,0,0,255) -map.. [-1] -rm. -r2dy. 14 -r. 16,16,1,3,0,0,0.5,0.5
_pacman_orange_gfx :
(12,13,1,1,0,0,-5,0,1,0,-2,1,-8,-6,1,-6,0,1,3,-3,1,-4,-3,2,1,-4,2,-3,-10,2,0,-60,2,0,-10,2,-2,-10,2,-4,-6,2,-3,0)
-decompress_rle. (0,0,255,255^0,173,173,255^0,0,0,255) -map.. [-1] -rm. -r2dy. 14 -r. 16,16,1,3,0,0,0.5,0.5
_pacman_banana_gfx :
(9,12,1,1,0,0,-7,0,1,-7,-2,1,-7,-3,1,-5,0,1,0,-2,1,-5,0,1,0,-2,1,-4,0,1,0,-3,1,-4,0,1,0,-3,\
1,-3,0,1,0,1,2,1,-3,0,1,0,1,2,-2,1,-2,0,1,0,1,2,-2,1,-2,-6,1,-3,-4,1,-5,0)
-decompress_rle. (0,255,255^0,173,255^0,0,255) -map.. [-1] -rm. -r2dy. 14 -r. 16,16,1,3,0,0,0.5,0.5
_pacman_map_level1 :
(11,28,1,1,0,0,-12,1,-5,2,1,-4,2,1,3,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-10,2,-3,1,2,1,2,-3,1,2,1,-2,0,1,2,1,2,-3,1,2,-4,1,\
2,1,2,-3,1,2,1,-3,0,2,1,-5,2,-4,1,2,-3,1,0,-3,1,-2,0,1,2,-3,1,0,-3,1,-2,0,1,2,-9,0,1,2,-3,1,0,-2,1,-3,0,1,2,1,-3,0,1,-4,\
0,1,2,1,0,1,0,1,-2,-3,1,2,1,0,1,0,-3,1,-3,0,2,-2,0,1,-4,-3,1,2,-5,1,0,1,-2,0,1,-5,2,-2,0,1,-2,0,1,2,-3,1,2,-6,1,2,-3,1,2,\
-4,1,-9,2,0,1,2,-3,1,2,-3,1,2,-2,1,2,-3,1,2,1,-3,2,-2,1,3,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-10,2,-11,1)
-decompress_rle. --mirror. x -z. 1,100% -a[-2,-1] x
_rlevel=33 _glevel=33 _blevel=255
_pacman_map_level2 :
(11,28,1,1,0,0,-12,1,-10,2,1,3,1,2,-3,1,2,-4,1,2,1,2,-3,1,2,1,-2,2,1,2,1,-5,2,1,2,-2,1,2,-3,1,2,1,2,1,2,-2,1,2,-3,1,2,1,2,1,\
2,-2,1,-5,2,1,-3,2,-4,1,2,-5,1,0,1,-2,0,1,2,-5,1,0,1,-2,0,1,2,-5,1,0,1,-2,0,1,-3,2,1,-4,-3,1,0,1,2,1,0,-2,1,-5,0,1,2,1,0,1,\
-2,-5,1,2,-2,0,1,-2,-5,1,2,1,0,-3,1,-4,0,1,2,1,-4,-3,1,-3,2,-3,1,0,1,-2,0,1,2,1,-3,2,-2,0,1,-2,0,1,2,-3,1,2,1,0,-4,1,2,-3,1,\
2,1,0,-2,1,-7,2,1,-2,0,1,2,-3,1,2,1,2,-4,1,2,1,-3,2,1,-4,2,1,3,1,2,-5,1,2,-2,1,2,1,2,-5,1,2,-2,1,-9,2,-12,1)
-decompress_rle. --mirror. x -z. 1,100% -a[-2,-1] x
_rlevel=200 _glevel=33 _blevel=33
_pacman_map_level3 :
(11,28,1,1,0,0,-11,1,-6,0,1,-4,2,-5,1,0,1,2,-8,1,0,1,2,-4,1,3,-8,2,-2,1,2,-5,1,2,1,2,-2,1,2,-5,1,2,1,2,-2,1,2,1,-5,2,1,2,-2,1,2,\
1,2,-3,1,0,1,2,-2,1,-5,2,1,0,1,-2,2,-5,1,2,1,0,-4,1,-5,2,1,-4,0,1,2,-3,1,2,1,0,-2,1,0,1,2,-3,1,2,1,0,1,-2,0,1,-3,2,1,2,-2,0,1,\
-2,-3,1,2,1,2,1,0,-3,1,-2,0,1,2,1,2,1,-6,0,1,2,1,2,-2,1,0,-2,1,-2,0,1,2,1,2,-2,1,0,-2,1,-2,0,1,-6,2,-5,1,2,-4,1,2,-2,1,-3,-3,2,\
1,-3,2,0,-3,1,2,1,2,1,2,-4,1,3,-2,2,1,-5,2,-2,1,2,-3,1,2,-3,1,2,-2,1,2,-3,1,2,-3,1,2,-2,1,-10,2,-11,1)
-decompress_rle. --mirror. x -z. 1,100% -a[-2,-1] x
_rlevel=33 _glevel=200 _blevel=255
_pacman_map_level4 :
(11,28,1,1,0,0,-9,1,-2,0,1,-7,2,1,-2,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,-3,2,3,-3,2,-4,1,2,-2,1,2,-2,1,-4,2,1,2,\
-2,1,2,-2,1,2,-2,1,2,1,-7,2,-2,1,2,1,2,-2,1,2,-2,1,-4,2,1,2,-2,1,2,-2,1,2,-2,1,2,1,-7,2,-2,1,2,-3,1,-10,0,1,-5,-2,1,0,-3,1,-5,0,1,\
-10,0,1,-2,-3,1,-5,-6,1,-8,0,1,2,-9,0,1,2,-2,1,2,-2,1,2,-2,1,2,1,2,-2,1,2,-2,1,2,-2,1,2,1,-10,2,1,2,-2,1,2,-2,1,2,-3,0,1,2,-2,1,2,\
-2,1,2,0,-3,1,-3,2,3,-4,2,1,0,1,2,-2,1,2,-2,1,2,-2,1,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,-7,2,1,-2,-9,1,-2,0)
-decompress_rle. --mirror. x -z. 1,100% -a[-2,-1] x
_rlevel=200 _glevel=200 _blevel=33
_pacman_map_level5 :
(11,28,1,1,0,0,-12,1,-7,2,1,-2,2,1,3,-5,1,2,1,2,-2,1,2,-5,1,2,1,2,-2,1,2,1,-7,2,-2,1,-3,2,1,2,-3,1,2,-4,1,2,1,2,1,0,1,2,-4,1,2,1,2,\
-3,1,2,1,-4,0,1,-6,2,1,2,1,0,-3,1,0,-4,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-3,1,0,1,0,-2,1,0,1,2,-3,1,0,1,0,1,-2,0,1,2,-4,0,1,0,1,-2,\
0,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-3,1,0,-3,1,0,-2,1,-5,2,1,-3,2,-4,1,2,1,2,1,2,-6,1,2,1,2,1,2,-4,1,3,-2,2,1,-5,2,0,1,2,-3,1,2,-3,\
1,2,-2,1,-5,2,1,-3,2,-2,1,2,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-5,2,1,-4,2,-11,1)
-decompress_rle. --mirror. x -z. 1,100% -a[-2,-1] x
_rlevel=200 _glevel=255 _blevel=33
_pacman_map_level6 :
(11,28,1,1,0,0,-12,1,-10,2,1,2,-2,1,2,-7,1,3,-9,2,-5,1,2,-6,1,-10,2,1,2,-4,1,0,-5,1,2,1,-8,0,1,2,1,0,-3,1,0,-3,1,0,2,1,0,1,-6,2,1,2,\
-2,0,1,2,-2,1,0,-3,1,2,1,-2,0,2,1,-4,0,1,2,1,0,1,2,-2,-2,1,0,1,2,1,0,1,2,1,0,1,-2,0,1,2,1,0,1,2,1,0,1,-2,0,1,2,1,0,1,2,-2,-4,1,2,\
1,-2,0,2,1,-4,0,1,2,-2,0,1,2,-2,1,0,-2,1,0,2,1,0,1,-6,2,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-4,1,0,-3,1,0,1,-10,2,-5,1,2,-6,1,3,-9,\
2,1,2,-2,1,2,-7,1,-10,2,-11,1)
-decompress_rle. --mirror. x -z. 1,100% -a[-2,-1] x
_rlevel=255 _glevel=130 _blevel=233
#@gmic x_paint
#@gmic : Launch the interactive painter.
x_paint :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Interactive painter"$n" -----------------------\n
----\n
---- Use "${c}"mouse"$n" to select color and brush.\n
---- "${c}"Left button"$n" draws a colored stroke.\n
---- "${c}"Right button"$n" fills a colored region.\n
---- "${c}"Arrow keys"$n" or '"${c}"SPACE"$n"' and '"${c}"BACKSPACE"$n"' to swap\n
---- between available images.\n
---- Key '"${c}"S"$n"' to save snapshot of the current view.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------"
-v - -to_rgb
-if {!$!} -i[0] 512,512,1,3,255 -nm[0] "[New image]" -else -k[0] -endif
1
-parallel "-_x_paint[]","-w[] 400,320,0,Palette -x_select_color[] __color,0,0,0" -k[0]
-v +
_x_paint :
-pass[-2,-1] 1 ({'{-2,n}'}) -discard. {'~'} -nm... {t} -rm.
__color={0,if(ia<128,vector3(255),vector3(0))}
brushsize=1
brushopacity=0
brushangle=90
brushthickness=1
image=0
refresh_image=1
refresh_brush=1
ox1=-1
oy1=-1
-do
-if $refresh_brush
-rm. (32,64;64,32) -r. 16,16,1,3,1 -r. {8*48},{4*48},1,3,0,2
-repeat 4,y -repeat 8
-ellipse. {48*$>+24},{48*$y+24},{2*$>+1},{(2*$>+1)*$brushthickness},$brushangle,{1-$y/4},255
-done -done
-rectangle. {$brushsize*48},{$brushopacity*48},\
{$brushsize*48+47},{$brushopacity*48+47},\
1,0xFFFFFFFF,255,128,128
{w},16,1,3 -line. 0,50%,100%,50%,1,0x55555555,128,64,128
bx={$brushangle*w/180}
-rectangle. {$bx-16},20%,{$bx+16},80%,1,128
-line. {$bx-16},20%,{$bx+16},20%,1,255 -line. {$bx+16},20%,{$bx+16},80%,1,255
-line. {$bx-16},80%,{$bx+16},80%,1,64 -line. {$bx-16},20%,{$bx-16},80%,1,64
-a[-2,-1] y
16,{h-16},1,3 -line. 50%,0,50%,100%,1,0x55555555,128,64,128
by={$brushthickness*(h-16)}
-rectangle. 20%,{$by-16},80%,{$by+16},1,128
-line. 20%,{$by-16},80%,{$by-16},1,255 -line. 80%,{$by-16},80%,{$by+16},1,255
-line. 20%,{$by-16},20%,{$by+16},1,64 -line. 20%,{$by+16},80%,{$by+16},1,64
-a[-2,-1] x
-w3. {w},{h},0,"Brush"
refresh_brush=0
-endif
-if $refresh_image
-w1[$image] {$image,w},{$image,h},0,"Image "#$image" : "{$image,b}.{$image,x}
refresh_image=0
-endif
x1={*1,x} y1={*1,y}
x2={*2,x} y2={*2,y}
x3={*3,x} y3={*3,y}
-if {$x1>=0}
-if {{*1,b}&1}
ox1={if($ox1<0,$x1,$ox1)}
oy1={if($oy1<0,$y1,$oy1)}
delta={max(abs($x1-$ox1),abs($y1-$oy1))}
r1={2*$brushsize+1}
r2={$r1*$brushthickness}
dx={2*($x1-$ox1)/max(1,$delta)}
dy={2*($y1-$oy1)/max(1,$delta)}
o={1-($brushopacity/4)^0.04}
-repeat {max(1,($delta+1)/2)}
-ellipse[$image] {$ox1+$>*$dx},{$oy1+$>*$dy},$r1,$r2,$brushangle,$o,$__color
-done
ox1=$x1 oy1=$y1
refresh_image=1
-else
ox1=-1 oy1=-1
-if {{*1,b}&2}
-flood[$image] $x1,$y1,0,10,0,1,$__color
refresh_image=1
-endif
-endif
-endif
-if {{*1,ARROWRIGHT}" || "{*2,ARROWRIGHT}" || "{*3,ARROWRIGHT}" || "\
{*1,ARROWUP}" || "{*2,ARROWUP}" || "{*3,ARROWUP}" || "\
{*1,SPACE}" || "{*2,SPACE}" || "{*3,SPACE}}
image={($image+1)%($!-2)} refresh_image=1
-elif {{*1,ARROWLEFT}" || "{*2,ARROWLEFT}" || "{*3,ARROWLEFT}" || "\
{*1,ARROWDOWN}" || "{*2,ARROWDOWN}" || "{*3,ARROWDOWN}" || "\
{*1,BACKSPACE}" || "{*2,BACKSPACE}" || "{*3,BACKSPACE}}
image={($image-1)%($!-2)} refresh_image=1
-endif
-if {*1,S} -o[$image] gmic_paint.png -endif
-if {{*3,b}" && "$x3>=0}
-if {$x3<384" && "$y3>=192} brushangle={$x3*180/(w-16)}
-elif {$x3>=384" && "$y3<192} brushthickness={$y3/(h-16)}
-elif {$x3<384" && "$y3<192} brushsize={int($x3*8/(w-16))} brushopacity={int($y3*4/(h-16))}
-endif
refresh_brush=1
-endif
-wait
-while {{*1}" && "!{*1,Q}" && "!{*1,ESC}}
__color=-1 -w1[] 0 -w2[] 0 -w3[] 0 -rm[-2,-1]
#@gmic x_plasma
#@gmic : Launch the plasma effect demo.
x_plasma :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Plasma effect"$n" ----------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
-v - -l[]
N=8
-repeat $N
320,200,1,3 -rand. 0,255 -plasma. 1,0,7 -n. 0,255
amp={u(-40,40)} freq={round(u(2,6))} dir$>={if(u<0.5,-1,1)*round(u(1,2))}
100%,100%,1,1,'$amp*cos(y*2*pi*$freq/h)'
-done
{w+2},100%,1,1,'x' 100%,100%,1,1,'Y=(y-80+15*cos(x/30)+10*sin(x/22));if(Y<0||Y>=50,-1,Y)' -a[-2,-1] c
0 -t. "** Welcome to G\47MIC, a powerful image processing framework **",0,0,50,1,255
-b. 0.5 -n. 0,255
M={w}
-w[] {1.5*{0,w}},{1.5*{0,h}},0,"[G"{`39`}"MIC] Plasma effect"
t=0 tt={-1.5*{0,w}}
-do
tic=$|
a={int($t)} a2={2*$a} a21={$a2+1}
b={($a+1)%$N} b2={2*$b} b21={$b2+1}
--warp[$a2] [$a21],1,0,2
--warp[$b2] [$b21],1,0,2
-j.. [-1],0,0,0,0,{$t-$a} -rm.
-shift[$a21] 0,${dir$a},0,0,2
-shift[$b21] 0,${dir$b},0,0,2
-if {int($t+0.005)>int($t)} dir$a={if(u<0.5,-1,1)*round(u(1,3))} -endif
t={($t+max(0.005,($|-$tic)))%$N}
--z.. $tt,{$tt+w-1+2}
-warp. [-4],0,0,0
-r. 100%,100%,1,3
--*. -1 -+. 255
-j... [-1],0,0,0,0,1,[-2],255 -rm.
-j.. [-1],-2,-2,0,0,1,[-1],255 -rm.
tt+={max(2,($|-$tic)*250)}
-if {$tt>=$M} tt={-1.5*{0,w}} -endif
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,5,16,1,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {3*w},{3*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {1.5*w},{1.5*h} -endif
-rm. -wait 20
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm[{-2*$N-2}--1] -w[] 0 -endl -v +
#@gmic x_quantize_rgb : _nbcolors>=2
#@gmic : Launch the RGB color quantization demo.
x_quantize_rgb : -check "isint(${1=16}) && $1>1"
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"RGB Quantization"$n" --------------------------------------\n
----\n
---- This demo shows how RGB colors can be quantified using\n
---- the "${c}"k-means algorithm"$n".\n
----\n
---- "${c}"Left mouse button"$n" on 3d view rotates the color cube.\n
---- "${c}"Right mouse button"$n" on 3d view toggles colors/clusters mode.\n
---- "${c}"Left mouse button"$n" on image toggles dithering mode,\n
---- "${c}"Left mouse button"$n" on colormap adds a random color.\n
---- "${c}"Right mouse button"$n" on colormap removes a color.\n
---- Key '"${c}"R"$n"' init colormap with random values.\n
---- Key '"${c}"U"$n"' init colormap with uniform sampling.\n
---- Key '"${c}"M"$n"' init colormap with median-cut algorithm.\n
---- Key '"${c}"SPACE"$n"' does a single iteration of k-means and pauses.\n
---- Key '"${c}"ENTER"$n"' runs k-means algorithm.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------------------"
-v -
-if {!$!} -testimage2d 300 -endif
-k[0] -to_rgb -if {h>300} -r2dy 300 -round 1 -endif -nm. img
--r {w*h},1,1,3,-1 -r. {min(w,8192)},1,1,3 -nm. colors
$1,1,1,3 -rand. 0,255 -round. 1 -nm. centroids
-_x_quantize_rgb_3d (1,0,0,0;0,1,0,0;0,0,1,0) -nm. pose3d
-_x_quantize_rgb_text "Colors",clustering0
-_x_quantize_rgb_text "Clusters",clustering1
-_x_quantize_rgb_text "Dithering: off",dithering0
-_x_quantize_rgb_text "Dithering: on",dithering1
-if {img,h<300} --r2dy[img] 300,1 -else [img] -endif
{w+315},365,1,3,255 -rm..
-rectangle. 4,4,305,305,1,0xFFFFFFFF,0
-rectangle. 309,4,{w-5},305,1,0xFFFFFFFF,0
-rectangle. 4,309,{w-5},360,1,0xFFFFFFFF,0
[-1],[-1]
-rectangle. 310,5,{w-6},305,1,1
-rectangle. 5,310,{w-6},360,1,2
300,300,1,1,'(y<<11)+(x<<2)+3' -j.. [-1],5,5 -rm.
-a[-2,-1] c -nm. visu
dithering=0 clustering=0 pause=1 s0=off s1=on
-repeat 1e10
-if {!narg($visu_3d)}
---[centroids] 2 --+[centroids] 2 -a[-2,-1] x -permute. cxyz -y. --. 128
-j[obj3d] [-1],0,8 -rm.
[obj3d]
-if $clustering
-if {{colors,iM}<256} --index[colors] [centroids] -*. 256 -+[colors,-1] -endif
--channels[colors] 0 ->>. 8 -map. 2 -permute. cxyz -y. -j.. [-1],0,{{-2,h}-$_N-h} -rm.
-endif
-pose3d. {pose3d,^} 300,300,1,3 -j3d. [-2],50%,50%,100,1,2,0,0,300 -rm..
-j. [clustering$clustering],2,0,0,0,1,[mclustering$clustering],255
-nm. visu_3d -j[visu] [visu_3d],5,5
-endif
-if {!narg($visu_img)}
--index[img] [centroids],{0.7*$dithering},1 -if {h<300} -r2dy. 300,1 -endif
-j. [dithering$dithering],2,0,0,0,1,[mdithering$dithering],255
-nm. visu_img -j[visu] [visu_img],310,5
-endif
-if {!narg($visu_centroids)}
--luminance[centroids] -a. [centroids],y -sort. +,x -rows. 1 -r. {visu,w-10},50,1,3
0 -t. "Colors: "{centroids,w},2,0,16,1,255,255,255 --dilate. 3 -j... [-2],2,2,0,0,1,[-1],255
-rm[-2,-1] -nm. visu_centroids -j[visu] [visu_centroids],5,310
-endif
-l[visu]
-w -1,-1,0,"[G"{`39`}"MIC] RGB quantization"
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-endl
x={int({*,x}*{visu,w}/{*,w})}
y={int({*,y}*{visu,h}/{*,h})}
b={*,b}
i={visu,i($x,$y,0,3)}
-if {$b&1" && "$i==1}
dithering={!$dithering} -rm[visu_img] -wait -1
-elif {$b&1" && "$i==2}
(${-RGB}) -y. c -a[centroids,-1] x  -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -&[colors] 255 pause=1 -wait 100
-elif {$b&2" && "$i==2" && "{centroids,w}>2}
-r[centroids] {centroids,w-1} -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -&[colors] 255 pause=1 -wait 100
-elif {$b&2" && "$i>=3}
clustering={!$clustering} -rm[visu_3d] -wait -1
-elif {*,M}
--&[colors] 255 -colormap. {centroids,w},0,0 -rm[centroids] -nm. centroids
-_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -&[colors] 255 pause=1 -wait -1
-elif {*,R}
-rand[centroids] 0,255 -round[centroids] 1
-_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -&[colors] 255 pause=1 -wait -1
-elif {*,U}
-uniform_distribution {centroids,w},3 -*. 255 -rm[centroids] -nm. centroids
-_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -&[colors] 255 pause=1 -wait -1
-elif {*,ENTER}
pause=0
-elif {$b&1" && "$i>=3}
coords={visu,i($x,$y,0,3)-3} u1={(($coords>>2)&511)-150} v1={($coords>>11)-150}
-if {!narg($u0)} u0=$u1 v0=$v1 -endif
-if {$u0!=$u1" && "$v0!=$v1}
n0={sqrt(($u0)^2+($v0)^2)}
nu0={if($n0>135,$u0*135/$n0,$u0)} nv0={if($n0>135,$v0*135/$n0,$v0)} nw0={sqrt(max(0,18225-($nu0)^2-($nv0)^2))}
n1={sqrt(($u1)^2+($v1)^2)}
nu1={if($n1>135,$u1*135/$n1,$u1)} nv1={if($n1>135,$v1*135/$n1,$v1)} nw1={sqrt(max(0,18225-($nu1)^2-($nv1)^2))}
u={$nv0*$nw1-$nw0*$nv1} v={$nw0*$nu1-$nu0*$nw1} w={$nv0*$nu1-$nu0*$nv1} n={sqrt(($u)^2+($v)^2+($w)^2)}
-rotation3d[] $u,$v,$w,{asin($n/18225)*180/pi} -mv[pose3d] $! -**[-2,-1] -nm. pose3d
u0=$u1 v0=$v1 -rm[visu_3d]
-endif
-elif {!($b&1)} u0=
-endif
-if {!$pause" || "{*,SPACE}}
pause={*,SPACE}
-&[colors] 255 --index[colors] [centroids] -*. 256 -+[colors,-1]
-repeat {colors,s}
-sh[colors] $> --histogram. {centroids,w*256},0,{centroids,w*256-1} -rm..
-i.. 256,1,1,1,'x' -r.. {w},1,1,1,0,2 -*.. [-1] -r[-2,-1] {centroids,w},1,1,1,2 -max. 0.01 -/[-2,-1]
-done -a[-{colors,s}--1] c
-rm[centroids] -nm. centroids
-->>[colors] 8 -channels. 0 -histogram. {centroids,w},0,{centroids,w-1}
cmax={xM}
-repeat {w} -if {!i($>)} -point[centroids] $>,0,0,1,{centroids,I($cmax)} -point[centroids] $>,0,0,-0.001,${-RGB} -endif -done
-rm. -c[centroids] 0,255
-if $visu_3d -rm[visu_3d] -endif
-if $visu_img -rm[visu_img] -endif
-if $visu_centroids -rm[visu_centroids] -endif
-wait 20
-else -if $visu_img -wait -endif
-endif
-if {!{*}" || "{*,Q}" || "{*,ESC}} -break -endif
-done
-rm -w 0 -v +
_x_quantize_rgb_3d :
-if $obj3d -rm[obj3d] -endif
--distribution3d[centroids] -circles3d. 5 -col3d. 255
-colorcube3d -p3d. 1
--&[colors] 255 -distribution3d. -o3d. 0.8 -+3d[-3--1]
--3d. 128,128,128 -nm. obj3d _N={i[7]}
_x_quantize_rgb_text :
0 -t. "$1",0,0,16,1,255 -r. {w+2},15,1,1,0,0,0.5,0.5 --dilate. 3 -to_rgb..
-nm.. $2 -nm. m$2
#@gmic x_reflection3d
#@gmic : Launch the 3d reflection demo.
x_reflection3d :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"3d reflection"$n" ----------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
-v -
128,256,1,3 -rand. 0,255 -plasma. 1,100 -blur_xy. 30,2
-sh. 0 -n. 0,90 -rm. -sh. 1 -n. 0,60 -rm. -sh. 2 -n. 0,180 -rm.
--mirror. x [-2,-1] -a[-4--1] x
--luminance. -mirror. x -b. 2 -n. 0,255
-torus3d 30,10 -col3d. 255,200,0
-spherical3d 47,34,"80+20*abs(cos(2*theta))" -s3d. -rm.. -i.. 3,{h},1,1,150,220,255,200,255,255 -y.. -a[-6--1] y
-spherical3d 47,34,"100*abs(1+0.6*cos(3*phi)*sin(4*theta))"
-r3d[-2,-1] 0,1,0,90 -db3d 0
xb=0 xl=0 anim=0
-w[] 400,400,0,"[G"{`39`}"MIC] 3d reflection"
-do
tic=$|
--rows. 8,{8+3*i[6]-1} --j... [-1],0,8,0,0,{if($anim<250,0,0.5-0.5*cos(($anim-250)/100))} -rm..
--z[-6] $xb,0,{$xb+255},255 -j3d. [-2],75%,50%,0,1,3,0,0
--z[-6] $xl,0,{$xl+255},255
xf={min(30,$anim-70)+20*cos(1.8*$|)}
yf={50+20*sin(2.7*$|)}
-j3d. [-6],{20+$xf}%,$yf%,0,1,4,0,0
-l3d [-1] -rm. --j3d. [-2],75%,50%,0,1,5,0,0 -j.. [-1],0,0,0,0,0.6 -rm[-3,-1]
-j3d. [-4],$xf%,$yf%,0,1,4,0,0
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,{h-19},13,1,0.2 -endif
-w. -rm.
-if {{*,CTRLLEFT}&&{*,D}} -w[] 800,800 -elif {{*,CTRLLEFT}&&{*,C}} -w[] 400,400 -endif
xb={($xb+6)&255}
xl={($xl-6)&255}
anim+=1
-r3d[-2,-1] {sin(0.5*$|)},{cos($|)},1,{($|-$tic)*33}
-r3d... -1,0.3,0.8,{($|-$tic)*100}
-wait 20
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm[-5--1] -w[] 0 -v +
#@gmic x_rubber3d
#@gmic : Launch the 3d rubber object demo.
x_rubber3d :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"3d rubber object"$n" -------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------"
-v - -rm
-sphere3d 150,0 -torus3d 70,15 -cylinder3d 20,40
-col3d... 200,200,200,0.3 -col3d.. 128,200,76 -col3d. 200,128,76
-c3d[-3--1] -r3d. 1,0,0,70 -+3d[-3--1] -+3d. 10,-8,20 -*3d. 1.5
400,400,64,3
{w},{h},1,3,'if(c==0,x,if(c==1,y,y*{1,d}/h))'
{w},{h},1,3
-w[] {w},{h},0,"[G"{`39`}"MIC] 3d rubber object"
frame=0
-do
fps=${-fps}
{w},{h},1,3 -fc. 16,32,32 -j3d. [0],50%,50%,0,1,3,0,0 -j[1] [-1],0,0,$frame -rm.
-r3d[0] 0.1,1,0.6,{3*cos($|*1.25)} -r3d[0] 1,0.2,0.6,-1
--warp[1] [2],0,0 -*[3] 0.8 -*. 0.2 -+[3] [-1] -rm.
-if {$fps>0} -text_outline. $fps" fps",5,{h-29},24,2,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2*w},{2*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {w},{h} -endif
-wait[0] 20
-sh[2] 2 --. 1 -&. {{1,d}-1} -rm.
frame={($frame-1)%{1,d}}
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -v +
#@gmic x_segment : _max_resolution={ 0 | >=128 }
#@gmic : Segment foreground from background in selected opaque RGB images, interactively.
#@gmic : Return RGBA images with binary alpha-channels.
#@gmic : Default value: 'max_resolution=1024'.
x_segment : -check "${1=1024}==0 || $1>=128"
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[^-1] "Extract foreground from background in image$? interactively, with maximum resolution $1."
-e[] "\n
----------------------------------------------------------------------------------------------------\n
----\n
---- "${c}"Left mouse button"$n" or key '"${c}"F"$n"' create a new foreground control point (or move an existing one).\n
---- "${c}"Right mouse button"$n" or key '"${c}"B"$n"' create a new background control point (or move an existing one).\n
---- "${c}"Mouse wheel"$n", or keys '"${c}"CTRL+arrows UP/DOWN"$n"' zoom view in/out.\n
---- '"${c}"CTRL+mouse wheel"$n"', '"${c}"SHIFT+mouse wheel"$n"' or "${c}"arrow keys"$n" move image in zoomed view.\n
---- Key '"${c}"SPACE"$n"' updates the extraction mask.\n
---- Key '"${c}"TAB"$n"' toggles background view modes.\n
---- Key '"${c}"M"$n"' toggles marker view modes.\n
---- Key '"${c}"BACKSPACE"$n"' deletes the last control point added.\n
---- Key '"${c}"PAGE UP"$n"' increases background opacity.\n
---- Key '"${c}"PAGE DOWN"$n"' decreases background opacity.\n
---- Keys '"${c}"CTRL+D"$n"' increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' decrease window size.\n
---- Keys '"${c}"CTRL+R"$n"' reset window size.\n
---- Keys '"${c}"ESC"$n"', '"${c}"Q"$n"' or '"${c}"ENTER"$n"' exit the interactive window.\n
----\n
----------------------------------------------------------------------------------------------------"
-v - -repeat $! -l[$>]
name={0,n} title={0,b} -if {narg({0,x})} title=$title.{0,x} -endif
w={w} h={h} fdim=${-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)} x0=0 y0=0 x1={w-1} y1={h-1}
selection=-1 marker_mode=2 xpan=-1 ypan=-1 bg_mode=0 opacity=64
-to_rgb -nm img
-if {narg($_gimp_control_points)>=4}  ($_gimp_control_points) -r. {w/4},4,1,1,-1
-else 0
-endif
-nm. points
-if {$1>0} -if {$w>$h} --r2dx[img] {min($1,$w)},2 -else --r2dy[img] {min($1,$h)},2 -endif -else [img] -endif
-_x_segment.
pw={potential,w} ph={potential,h}
-do
-wait
x={*,x} y={*,y} b={*,b} o={*,-o}
is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
is_shift={{*,SHIFTLEFT}" || "{*,SHIFTRIGHT}}
is_mouseout={$x<0" || "$y<0}
x={$x0+$x*($x1-$x0+1)/$ww} y={$y0+$y*($y1-$y0+1)/$wh}
oww=$ww owh=$wh ox0=$x0 oy0=$y0 ox1=$x1 oy1=$y1
-if {*,r}
nww={*,d} nwh={*,e} m={min($nww,$nwh)}
cx={($x0+$x1)/2} cy={($y0+$y1)/2} dx={$nww*($x1-$x0+1)/$ww} dy={$nwh*($y1-$y0+1)/$wh}
x0={$cx-$dx/2} x1={$cx+$dx/2}
y0={$cy-$dy/2} y1={$cy+$dy/2}
ww=$nww wh=$nwh
-elif {$is_ctrl" && "{*,-D}}
nww={min({*,u},$ww*1.25)} nwh={min({*,v},$wh*1.25)} m={min($nww,$nwh)}
-if {$m==$nww} ww=$m wh={$h*$m/$w} -else ww={$w*$m/$h} wh=$m -endif
-elif {$is_ctrl" && "{*,-C}}
nww={$ww/1.25} nwh={$wh/1.25}
-if {min($nww,$nwh)>=64} ww=$nww wh=$nwh -endif
-elif {$is_ctrl" && "{*,-R}}
fdim=${-fitscreen[]\ $w,$h} ww={arg(1,$fdim)} wh={arg(2,$fdim)}
x0=0 y0=0 x1={$w-1} y1={$h-1}
-elif {($is_shift" && "$o<0)" || "{*,ARROWLEFT}}
dx={($x1-$x0)/6} x0-=$dx x1-=$dx
-elif {($is_shift" && "$o>0)" || "{*,ARROWRIGHT}}
dx={($x1-$x0)/6} x0+=$dx x1=+$dx
-elif {($is_ctrl" && "$o>0)" || "({*,ARROWUP}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0-=$dy y1-=$dy
-elif {($is_ctrl" && "$o<0)" || "({*,ARROWDOWN}" && "!$is_ctrl)}
dy={($y1-$y0)/6} y0+=$dy y1+=$dy
-elif {$o>0" || "($is_ctrl" && "{*,ARROWUP})}
-if {$x1-$x0>16" && "$y1-$y0>16}
cx={if($x>=0" && "!{*,ARROWUP},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWUP},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)*0.75} y0={$cy+($y0-$cy)*0.75}
x1={$cx+($x1-$cx)*0.75} y1={$cy+($y1-$cy)*0.75}
-endif
-elif {$o<0" || "($is_ctrl" && "{*,ARROWDOWN})}
zfactor={max(($x1-$x0+1)/$w,($y1-$y0+1)/$h)}
-if {$zfactor<1.3}
cx={if($x>=0" && "!{*,ARROWDOWN},$x,($x0+$x1)/2)}
cy={if($y>=0" && "!{*,ARROWDOWN},$y,($y0+$y1)/2)}
x0={$cx+($x0-$cx)/0.75} y0={$cy+($y0-$cy)/0.75}
x1={$cx+($x1-$cx)/0.75} y1={$cy+($y1-$cy)/0.75}
dx={$zfactor^2*($w-$x0-$x1)/2} dy={$zfactor^2*($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
-else
dx={($w-$x0-$x1)/2} dy={($h-$y0-$y1)/2}
x0+=$dx x1+=$dx y0+=$dy y1+=$dy
-endif
-elif {$b&4" && "!$is_mouseout}
-if {$panx<0" && "$pany<0} panx=$x pany=$y
-else dx={round($panx-$x)} dy={round($pany-$y)} x0+=$dx y0+=$dy x1+=$dx y1+=$dy
-endif
-else panx=-1 pany=-1
-endif
-if {$ww!=$oww" || "$wh!=$owh" || "$ox0!=$x0" || "$oy0!=$y0" || "$ox1!=$x1" || "$oy1!=$y1} -rm[baseview] -endif
N={points,w}
is_left_button={$b&1" || "{*,F}} is_right_button={$b&2" || "{*,B}} is_button={$is_left_button" || "$is_right_button}
-if {narg($baseview)" && "$is_button" && "$x>=0" && "$y>=0" && "$x<$w" && "$y<$h}
-if {$selection==-1" && "$N}
($x;$y) -r. $N,2 --. [points] -*. {max($ww,$wh)/max($x1-$x0,$y1-$y0)} -sqr. -s. y -+[-2,-1]
dmin={im} selection={if($dmin>25,-1,xm)} -rm.
-endif
-if {$selection>=0}
-if $marker_mode
--columns[points] $selection ox={i[0]} oy={i[1]}
-=. $x -=. $y,0,1 -=. {1+$is_left_button},0,3
-j[points] [-1],$selection -rm. -rm[view]
-endif
-else
($x;$y;0;{1+$is_left_button}) -a[points,-1] x selection=$N -if {!$marker_mode} marker_mode=2 -endif -rm[view]
-endif
-else selection=-1
-if {{*,SPACE}" && "narg($labels)} -rm[labels]
-elif {{*,TAB}" && "narg($baseview)} bg_mode={($bg_mode+1)%6} -rm[baseview] -wait -1
-elif {{*,M}" && "narg($view)} marker_mode={($marker_mode-1)%3} -rm[view] -wait -1
-elif {{*,PAGEDOWN}" && "narg($baseview)} opacity={max(0,$opacity-32)} -rm[baseview] -wait -1
-elif {{*,PAGEUP}" && "narg($baseview)} opacity={min(255,$opacity+32)} -rm[baseview] -wait -1
-elif {{*,BACKSPACE}" && "$N} -if {$N>1} -z[points] 0,{$N-2} -else i=$points -rm[points] -i[$i] 0 -nm[$i] points -endif -rm[view] -wait -1
-endif
-endif
w2={round(($x1-$x0)/2)} h2={round(($y1-$y0)/2)}
-if {$x0<-$w2} x1-={$x0+$w2} x0=-$w2 -endif
-if {$y0<-$h2} y1-={$y0+$h2} y0=-$h2 -endif
-if {$x1>=$w+$w2} x0+={$w-1+$w2-$x1} x1={$w-1+$w2} -endif
-if {$y1>=$h+$h2} y0+={$h-1+$h2-$y1} y1={$h-1+$h2} -endif
-if {!narg($labels)}
N={points,w}
-if {narg($view)} -text_outline[view] "Processing...",5,5,20,2 -w[view] -endif
-if $N
[points]
-sh. 0,0,0,0 -*. {$pw/$w} -rm.
-sh. 1,1,0,0 -*. {$ph/$h} -rm.
-pointcloud. -1,$pw,$ph -dilate. 3
-watershed. [potential] --. 1
-else [potential],[potential],1,1,1
-endif
-nm. labels
-if {narg($baseview)} -rm[baseview] -endif
-endif
-if {!narg($baseview)}
nx0={$x0*$pw/$w} ny0={$y0*$ph/$h}
nx1={$x1*$pw/$w} ny1={$y1*$ph/$h}
--z[img] $x0,$y0,$x1,$y1
-r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,1)}
--z[labels] $nx0,$ny0,$nx1,$ny1
-r. $ww,$wh,1,100%,{if($ww<w" && "$wh<h,2,3)}
-if {$bg_mode>=3} -*. -1 -+. 1 -endif
-*. {255-$opacity} -+. $opacity -a[-2,-1] c
-if {$bg_mode%3>=1} -i.. 100%,100%,1,3,{(($bg_mode-1)%3)*255} -blend[-2,-1] alpha
-else -drgba.
-endif
-nm. baseview
-if {narg($view)} -rm[view] -endif
-endif
-if {!narg($view)}
[baseview] -r. 100%,100%,1,3
-if $marker_mode
-if {$marker_mode==2} rad1=5 rad2=3 opa=1 -else rad1=3 rad2=2 opa=0.8 -endif
col0=255,0,0 col1=0,255,0
-repeat {points,w}
--columns[points] $> x={(i[0]-$x0)*$ww/(1+$x1-$x0)} y={(i[1]-$y0)*$wh/(1+$y1-$y0)} l={i[3]-1} -rm.
-circle. $x,$y,$rad1,1,0 -circle. $x,$y,$rad2,$opa,${col$l}
-done
-endif
-nm. view
-w[view] $ww,$wh,0,$title
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}" && "!{*,ENTER}}
-if {narg($view)} -text_outline[view] "Processing fullres...",5,5,20,2 -w[view] -endif
-k[img,points]
N={points,w} status=
-if $N
status={points,^}
[img] -_x_segment. -pointcloud[points] -1,$w,$h
zfact={{img,max(w,h)}/{potential,max(w,h)}} -dilate[points] {int(3*$zfact)}
-watershed[points] [potential] --[points] 1 -k[img,points]
-*. 255
-else -k[img] [img],[img],1,1,255
-endif
-a c -nm $name
-endl -done
-u $status
-w 0 -v +
_x_segment :
-b. 0.2% -gradient_norm. -f. '1/(1+i^2)'
-nm. potential
#@gmic x_select_color : _variable_name
#@gmic : Display a RGB or RGBA color selector.
#@gmic : Argument 'variable_name' specifies the variable that contains the selected color values (as R,G,B,[A]) at any time.
#@gmic : Its value specifies the initial selected color. Assigning '-1' to it forces the interactive window to close.
#@gmic : Default value: 'variable_name=xsc_variable'.
x_select_color : -skip ${1=xsc_variable}
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -rm
n={narg($$1)} -if {!$n} $1=0,0,0 -endif
rgba_mode={$n>=4} R={arg(1,$$1)} G={arg(2,$$1)} B={arg(3,$$1)} A={if($rgba_mode,arg(4,$$1),255)}
-v + -e[^-1] "Open "${-arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget, with variable '$1' and starting color "($$1)"." -v -
-if {!{*}} -w[] {400+24*$rgba_mode},400,0,"Select a color" -endif
update_view=1 is_sv=0 is_h=0 is_a=0 colordb=0 is_thread_variable={arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'}
-m "add_preset : -if {!narg($_xsc_preset$""1)} _xsc_preset$""1=$""2,$""3,$""4 -endif"
-add_preset 0,0,0,0,0 -add_preset 1,255,255,255 -add_preset 2,255,0,0 -add_preset 3,0,255,0 -add_preset 4,0,0,255 -add_preset 5,255,255,0
-add_preset 6,255,0,255 -add_preset 7,0,255,255 -add_preset 8,50,50,50 -add_preset 9,100,100,100 -add_preset 10,150,150,150 -add_preset 11,200,200,200
-uncommand add_preset
-if {!narg($_xsc_preset)} _xsc_preset=11 -endif
($R^$G^$B) -c. 0,255 -rgb2hsv. H={i[0]} S={i[1]} V={i[2]} -rm.
-do
w={*,d} h={*,e} x={*,x} y={*,y} b={*,b}
-if {!$!}
$w,$h,1,3,200
-if $rgba_mode x1={w-89} y1={h-57} x2={w-80} -else x1={w-49} y1={h-57} x2={w-40} -endif
x0=8 y0=8 x3={$x2+31} x4={w-40} x5={$x4+31} x6={max($x0+232+32*$rgba_mode,w-152)} y6={$y1+7}
-rectangle {$x0-1},{$y0-1},{$x1+1},{$y1+1},1,0xFFFFFFFF,232 -line {$x0-1},{$y0-1},{$x1+1},{$y0-1},1,128 -line {$x0-1},{$y0-1},{$x0-1},{$y1+1},1,128
(1;0) (0,1) -r[-2,-1] {$x1-$x0+1},{$y1-$y0+1},1,1,3 -i... 100%,100%,1,1,$H -a[-3--1] c -hsv2rgb. -j.. [-1],$x0,$y0 -rm.
-rectangle {$x2-1},{$y0-1},{$x3+1},{$y1+1},1,0xFFFFFFFF,232 -line {$x2-1},{$y0-1},{$x3+1},{$y0-1},1,128 -line {$x2-1},{$y0-1},{$x2-1},{$y1+1},1,128
(359;0^1;1^1;1) -r. {$x3-$x2+1},{$y1-$y0+1},1,3,3 -hsv2rgb. -j.. [-1],$x2,$y0 -rm.
-if $rgba_mode
-rectangle {$x4-1},{$y0-1},{$x5+1},{$y1+1},1,0xFFFFFFFF,232 -line {$x4-1},{$y0-1},{$x5+1},{$y0-1},1,128 -line {$x4-1},{$y0-1},{$x4-1},{$y1+1},1,128
(1;0) -r. {$x5-$x4+1},{$y1-$y0+1},1,4,3 -*. 255 -drgba. -j.. [-1],$x4,$y0 -rm.
-endif
-t. "Current",$x0,{$y1+12},14,1,0
-if {narg($_xsc_old)}
-t. "Old",$x0,{$y1+34},14,1,0
($_xsc_old) -y. c -r. 48,16 -drgba. -r. {w+2},{h+2},1,3,0,0,0.5,0.5 -j.. [-1],{$x0+55},{$y1+32} -rm.
-endif
-repeat 12
(${_xsc_preset$>}) --. 255 -r. 4,1,1,1,0 -+. 255
-y. c -r. 18,18 -drgba. -frame. 1,1,{255*($>==$_xsc_preset)}
-j.. [-1],{$x6+($>%6)*25},{$y6+($>>=6)*25} -rm.
-done
update_view=1
-endif
-if $update_view
[-1]
cx={$x0+$V*($x1-$x0)} cy={$y0+(1-$S)*($y1-$y0)}
-if {$cx>$x0} -line. {$cx-1},$y0,{$cx-1},$y1,1,200 -endif
-if {$cx<$x1} -line. {$cx+1},$y0,{$cx+1},$y1,1,200 -endif
-if {$cy>$y0} -line. $x0,{$cy-1},$x1,{$cy-1},1,200 -endif
-if {$cy<$y1} -line. $x0,{$cy+1},$x1,{$cy+1},1,200 -endif
-line. $x0,$cy,$x1,$cy,1,0 -line. $cx,$y0,$cx,$y1,1,0
cy={$y0+(359-$H)*($y1-$y0)/359}
-if {$cy>$y0} -line. $x2,{$cy-1},$x3,{$cy-1},1,200 -endif
-if {$cy<$y1} -line. $x2,{$cy+1},$x3,{$cy+1},1,200 -endif
-line. $x2,$cy,$x3,$cy,1,0
-if $rgba_mode
cy={$y0+(255-$A)*($y1-$y0)/255}
-if {$cy>$y0} -line. $x4,{$cy-1},$x5,{$cy-1},1,200 -endif
-if {$cy<$y1} -line. $x4,{$cy+1},$x5,{$cy+1},1,200 -endif
-line. $x4,$cy,$x5,$cy,1,0
-endif
($H^$S^$V^$A) -sh. 0,2 -hsv2rgb. -rm. -round. R={i[0]} G={i[1]} B={i[2]}
-r. 48,16 -drgba. -r. {w+2},{h+2},1,3,0,0,0.5,0.5 -j.. [-1],{$x0+55},{$y1+10} -rm.
-t. "HSV ("{round($H)}","{round($S*255)}","{round($V*255)}")",{$x0+115},{$y1+24},14,1,0
-if $rgba_mode -t. "RGBA ("$R","$G","$B","{round($A)}")",{$x0+115},{$y1+8},14,1,0
-else -t. "RGB ("$R","$G","$B")",{$x0+115},{$y1+8},14,1,0
-endif
({'${-dec2hex\ {$R*65536+$G*256+$B}}'}) --. {'0'} -r. 6,1,1,1,0,0,1,0 -+. {'0'}
-f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
-t.. "HTML ""#"{t},{$x0+115},{$y1+40},14,1,0 -rm.
-w. 100%,100%,0 -rm.
-if $rgba_mode $1=$R,$G,$B,$A -else $1=$R,$G,$B -endif
update_view=0
-endif
-if $is_thread_variable -wait 50 -else -wait -endif
ww={*,w} wh={*,h}
is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
-if {*,r} ww={*,d} wh={*,e}
-elif {$is_ctrl" && "{*,-D}} ww={1.25*$ww} wh={1.25*$wh}
-elif {$is_ctrl" && "{*,-C}} ww={0.8*$ww} wh={0.8*$wh}
-elif {$is_ctrl" && "{*,R}} ww={400+24*$rgba_mode} wh=400
-endif
ww={max(200,$ww)} wh={max(200,$wh)}
-if {$ww!={*,w}" || "$wh!={*,h}} -w[] $ww,$wh -rm -endif
-if {$b&1" && "$x>=0" && "$y>=0}
-if {!$is_h" && "!$is_a" && "($is_sv" || "($x>=$x0" && "$x<=$x1" && "$y>=$y0" && "$y<=$y1))}
S={max(0,min(1,1-($y-$y0)/($y1-$y0)))} V={max(0,min(1,($x-$x0)/($x1-$x0)))}
update_view=1 colordb=0 is_sv=1 -k[0]
-elif {!$is_sv" && "!$is_a" && "($is_h" || "($x>=$x2" && "$x<=$x3" && "$y>=$y0" && "$y<=$y1))}
H={max(0,min(359,359-($y-$y0)*359/($y1-$y0)))}
colordb=0 is_h=1 -rm
-elif {!$is_sv" && "!$is_h" && "($is_a" || "($x>=$x4" && "$x<=$x5" && "$y>=$y0" && "$y<=$y1))}
A={round(max(0,min(255,255-($y-$y0)*255/($y1-$y0))))}
colordb=0 is_a=1 update_view=1 -k[0]
-elif {!$is_sv" && "!$is_h" && "!$is_a" && "{narg($_xsc_old)}" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+32" && "$y<=$y1+47}
($_xsc_old) -y. c -sh. 0,2 -rgb2hsv. -rm. H={i[0]} S={i[1]} V={i[2]} A={i[3]}
colordb=0 -rm
-elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x6" && "$x<=$x5" && "$y>=$y6" && "$y<=$y6+50" && "($x-$x6)%25<=20" && "($y-$y6)%25<=20}
p={int(($x-$x6)/25)+6*int(($y-$y6)/25)} (${_xsc_preset$p}) --. 255 -r. 4,1,1,1,0 -+. 255 -y. c -sh. 0,2 -rgb2hsv. -rm.
H={i[0]} S={i[1]} V={i[2]} A={i[3]}
colordb=0 -rm
-elif {!$is_sv" && "!$is_h" && "!$is_a" && "$x>=$x0+55" && "$x<=$x0+102" && "$y>=$y1+10" && "$y<=$y1+27}
_xsc_old=$R,$G,$B,$A colordb={($colordb+1)%2}
-if {!$colordb} _xsc_preset$_xsc_preset=$R,$G,$B,$A _xsc_preset={($_xsc_preset-1)%12} -endif
-rm -wait -1
-else colordb=0
-endif
-elif {!$b} is_sv=0 is_h=0 is_a=0
-endif
-if {*,ARROWUP} colordb=0 S={min(1,$S+1/256)} update_view=1 -k[0] -wait -1
-elif {*,ARROWDOWN} colordb=0 S={max(0,$S-1/256)} update_view=1 -k[0] -wait -1
-elif {*,ARROWRIGHT} colordb=0 V={min(1,$V+1/256)} update_view=1 -k[0] -wait -1
-elif {*,ARROWLEFT} colordb=0 V={max(0,$V-1/256)} update_view=1 -k[0] -wait -1
-elif {*,PAGEUP} colordb=0 H={min(359,$H+1)} -rm -wait -1
-elif {*,PAGEDOWN} colordb=0 H={max(0,$H-1)} -rm -wait -1
-endif
-if {['$$1']=='-1'} -break -endif
-if {(($rgba_mode" && "['$$1']!='$R,$G,$B,$A')" || "(!$rgba_mode" && "['$$1']!='$R,$G,$B'))" && "$x<0" && "$y<0" && "!$is_sv" && "!$is_h" && "!$is_a}
($$1) -y. c --. 255 -r. 1,1,1,4,0 -+. 255 -sh. 0,2 -rgb2hsv. -rm.
H={i[0]} S={i[1]} V={i[2]} A={i[3]} -rm
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0
-if $rgba_mode -u $R,$G,$B,$A -else -u $R,$G,$B -endif
_xsc_old=${}
-v +
#@gmic x_select_function1d : _variable_name,_background_curve_R,_background_curve_G,_background_curve_B
#@gmic : Open an interactive window, where the user can defined its own 1d function.
#@gmic : If an image is selected, it is used to display additional information :
#@gmic :   - The first row defines the values of a background curve displayed on the window (e.g. an histogram).
#@gmic :   - The 2nd, 3rd and 4th rows define the R,G,B color components displayed beside the X and Y axes.
#@gmic : Argument 'variable_name' specifies the variable that contains the selected function keypoints at any time.
#@gmic : Assigning '-1' to it forces the interactive window to close.
#@gmic : Default values: 'variable_name=xsf_variable', 'background_curve_R=220', 'background_curve_G=background_curve_B=background_curve_T'.
x_select_function1d : -skip ${1=xsf_variable},${2=220},${3=$2},${4=$2}
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-e[^-1] "Open 1d function widget, with variable name '$1'."
-v -
-if $! -k[0] -endif
is_additional_data=$!
-if {!{*}} -w[] 400,400,0,"Create a 1d function" -endif
reset_w={*,w} reset_h={*,h}
-if {!narg($$1)} $1=0,0,100,100 -endif
-i[points] ($$1) -y. x -r. 2,{w/2},1,1,-1
is_thread_variable={arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} selected=-1 X=-1 Y=-1
-do
-if {!narg($baseview)}
{{*,d}-48},{{*,e}-48},1,3,255
-if $is_additional_data
100%,100% --rows[0] 0 -graph.. [-1],3,0,0,0,1,1 -rm. -c. 0,1
--fc.. ${2-4} -j... [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-endif
-grid. {(w-1)/8},{(h-1)/8},0,0,0.2,0xCCCCCCCC,0
-line. 0,100%,100%,0,0.2,0
-frame. 24,24,200
-rectangle. 23,23,{w-24},{h-24},1,0xFFFFFFFF,232 -line. 23,23,23,{h-24},1,128 -line. 23,23,{w-24},23,1,128
-if {$is_additional_data" && "{0,h}>1}
-if {{0,h}>2} --rows[0] 1,3 -else --rows[0] 1 -r. 100%,3 -endif
-r. {-2,w-48},3,1,1,3 -permute. xzcy -r. 100%,8 -frame. 1,1,0
-j.. [-1],23,{-2,h-19} -rotate. -90 -j.. [-1],{-2,w-19},23 -rm.
-endif
-nm. baseview
-l -rm[view] -onfail -endl
-endif
-if {!narg($view)}
--z[baseview] 24,24,{baseview,w-25},{baseview,h-25} -r. 200%,200%
-function1d[] 1,{points,^}
-l. -c 0,100 -transpose
-i[0] ({'CImg3d'},{h},{h-1})
-i.. 1,100%,1,1,y 1,100% -a[-3--1] x
1,{h-1},1,1,2 --f. y --+. 1 -a[-3--1] x
4,100%,1,1,1 -y -a y -col3d 0
-endl
-*3d. {-2,(w-1)/100},{-2,(1-h)/100}
-j3d.. [-1],0,100%,0,1,1,0,0 -rm.
-repeat {points,h}
x={points,i(0,$>)} y={100-{points,i(1,$>)}}
-circle. $x%,$y%,6,1,0xFFFFFFFF,0
-done
-if {$selected>=0}
x={points,i(0,$selected)} y={100-{points,i(1,$selected)}}
-circle. $x%,$y%,3,1,0
-endif
-r. 50%,50%,1,3,2
--j[baseview] [-1],24,24 -rm..
-if {$X>=0" && "$Y>=0} -t. "X: "{min(255,round(255*$X/100))}" Y: "{min(255,round(255*$Y/100))},24,6,12,1 -endif
-nm. view
-w[view]
-endif
-if $is_thread_variable -wait 50 -else -wait -endif
x={*,x} y={*,y} b={*,b} is_ctrl={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
X={($x-24)*100/({*,w}-49)} Y={100-($y-24)*100/({*,h}-49)}
oww={*,w} owh={*,h} ww=$oww wh=$owh
-if {*,r} ww={*,d} wh={*,e}
-elif {$is_ctrl" && "{*,-D}} ww={view,w*125%} wh={view,h*125%}
-elif {$is_ctrl" && "{*,-C}} ww={view,w*75%} wh={view,h*75%}
-elif {$is_ctrl" && "{*,R}} ww=$reset_w wh=$reset_h
-elif {!$is_ctrl" && "{*,R}} -rm[points] -i[points] (0,0;100,100) $1={points,^} -rm[view]
-elif {$b&3}
is_inside={$X>=0" && "$Y>=0" && "$X<=100" && "$Y<=100}
-if {$selected<0} --f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*{*,w}%' -z. 0,0 selected={if(im>8,-1,ym)} -rm. -endif
-if {$x>=0" && "$b&1" && "$selected>=0}
-if {{*,SHIFTLEFT}||{*,SHIFTRIGHT}} X={points,i(0,$selected)} -endif
-if {{*,CTRLLEFT}||{*,CTRLRIGHT}} Y={points,i(1,$selected)} -endif
-if {points,$selected>0" && "$selected<h-1}
-=[points] {points,max(min($X,i(0,$selected+1)-0.5),i(0,$selected-1)+0.5)},0,$selected
-endif
-=[points] {min(100,max(0,$Y))},1,$selected $1={points,^} -rm[view]
-elif {$b&1" && "$is_inside}
($X,$Y) -a[points,-1] y -sort[points] +,y
--f[points] 'sqrt((i-$X)^2+(j(1)-$Y)^2)*{*,w}%' -z. 0,0 selected={if(im>8,-1,ym)} $1={points,^} -rm[view,-1]
-elif {$b&2" && "$selected>0" && "$selected<{points,h-1}" && "$is_inside}
-l[points] -s y -rm[$selected] -a y -endl -wait -1 selected=-1 $1={points,^} -rm[view]
-endif
-elif {!($b&1)} selected=-1
-endif
ww={min(90%*{*,u},max(200,$ww))}
wh={min(90%*{*,v},max(200,$wh))}
-if {$oww!=$ww" || "$owh!=$wh} -w[] $ww,$wh -rm[baseview,view] -endif
-if {['$$1']=='-1'} -break -endif
-if {['$$1']!=['{points,^}']} -rm[points] -i[points] ($$1) -y. x -r. 2,{w/2},1,1,-1 -l -rm[view] -onfail -endl -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w[] 0 -u {points,^}
-if $is_additional_data -rm[^0] -else -rm -endif
-v +
#@gmic x_select_palette : _variable_name,_number_of_columns= { 0=auto | >0 }
#@gmic : Open a RGB or RGBA color selector widget from a palette.
#@gmic : The palette is given as a selected image.
#@gmic : Argument 'variable_name' specifies the variable that contains the selected color values (ad R,G,B,[A]) at any time.
#@gmic : Assigning '-1' to it forces the interactive window to close.
#@gmic : Default values: 'variable_name=xsp_variable' and 'number_of_columns=2'.
x_select_palette : -skip ${1=xsp_variable},${2=0}
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-if {!$!} -error[0--3] "Command '-x_select_palette': Missing specified palette image." -endif
-v - -k[0] --r {w*h*d},1,1,{s},-1 -to_color. rgba_mode={s==4} -to_rgba. -nm. palette -v +
-e[^-1] "Open "${-arg\ 1+$rgba_mode,RGB,RGBA}" color selector widget for palette$?, with variable name '$1'."
-v -
-if {w>1024} -v + -error[0--3] "Command 'x_select_color': Too much colors ("{w}") in selected palette." -endif
-if {!{*}} -w[] 400,400,0,0,-1,-1,"Palette: "{0,b} -endif
selected=-1 oselected=-1
-do
ww={*,w} wh={*,h}
R={palette,round(i($selected,0,0,0))} G={palette,round(i($selected,0,0,1))}
B={palette,round(i($selected,0,0,2))} A={palette,round(i($selected,0,0,3))}
-if {$selected>=0" && "$oselected!=$selected}
-if $rgba_mode $1=$R,$G,$B,$A -else $1=$R,$G,$B -endif
-endif
-if {['$$1']=='-1'} -break -endif
-if {!narg($baseview)} -l[palette]
{w},1,1,1,x -+. 1
-s. x -append_tiles[^0] $2
M={w} N={h} 100%,100%,1,1,1
--r. {$ww-17},100%,1,1,4
-r.. 100%,{$wh-57},1,1,4
-r[-2,-1] [-1],[-2] -|[-2,-1]
-line. 100%,0,100%,100%,1,1
-line. 0,100%,100%,100%,1,1
--. 1 -*. -1
-r.. [-1],[-1],1,1,1 --.. 1
--map.. [0],0 -drgba.
-rv[-2,-1] -*[-2,-1]
--!=.. -1 -dilate. 3
-mv... $! -+. 1 -a[-3--1] c
-nm. baseview
-endl
-if {narg($view)} -rm[view] -endif
-endif
-if {!narg($view)}
$ww,$wh,1,3,200
-if {$selected<0} -sh[baseview] 0,2
-else
--channels[baseview] 0,2 --channels[baseview] 4,4
-!=. {$selected+1} -rectangle. 0,0,100%,100%,1,0xFFFFFFFF,1
--dilate. 5 --[-2,-1] -*. -1 --dilate. 5 -*.. 255
-r.. 100%,100%,1,3 -j... [-2],0,0,0,0,1,[-1] -rm[-2,-1]
-if $rgba_mode -t.. "RGBA ("$R","$G","$B","$A")",8,{$wh-45},14,1,0
-else -t.. "RGB ("$R","$G","$B")",8,{$wh-45},14,1,0
-endif
($R^$G^$B) -rgb2hsv. H={round(i[0])} S={round(i[1]*255)} V={round(i[2]*255)} -rm.
-t.. "HSV ("$H","$S","$V")",8,{$wh-31},14,1,0
({'${-dec2hex\ {$R*65536+$G*256+$B}}'}) --. {'0'} -r. 6,1,1,1,0,0,1,0 -+. {'0'}
-f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
-t... "HTML ""#"{t},8,{$wh-17},14,1,0 -rm.
-endif
-sh[baseview] 3 -j... [-2],8,8,0,0,1,[-1] -rm[-2,-1]
-nm. view -w[view]
-endif
-if {arg(1,{'$1'})==_'_'" && "arg(2,{'$1'})==_'_'} -wait 50 -else -wait -endif
is_ctrl={{*,CTRLLEFT}||{*,CTRLRIGHT}}
-if {*,r} ww={*,d} wh={*,e}
-elif {$is_ctrl" && "{*,-D}} ww={1.25*$ww} wh={1.25*$wh}
-elif {$is_ctrl" && "{*,-C}} ww={0.8*$ww} wh={0.8*$wh}
-elif {$is_ctrl" && "{*,R}} ww=400 wh=400
-endif
ww={max(200,$ww)} wh={max(200,$wh)}
-if {($ww!={*,w}" || "$wh!={*,h})" && "narg($baseview)} -w[] $ww,$wh -rm[baseview] -endif
oselected=$selected
-if {narg($baseview)}
x={*,x} y={*,y} b={*,b}
-if {$b&1" && "$x>=0" && "$y>=0}
-if {baseview,i($x-8,$y-8,0,4)} selected={baseview,i($x-8,$y-8,0,4)-1} -else selected=-1 -endif
-rm[view] -wait -1
-elif {{*,ARROWUP}" && "$selected>=$M} selected-=$M -rm[view] -wait -1
-elif {{*,ARROWDOWN}" && "$selected<{0,w-$M}} selected+=$M -rm[view] -wait -1
-elif {{*,ARROWRIGHT}" && "$selected<{0,w-1}} selected+=1 -rm[view] -wait -1
-elif {{*,ARROWLEFT}" && "$selected>0} selected-=1 -rm[view] -wait -1
-endif
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w 0 -k[0]
-if {$selected>=0} -if $rgba_mode -u $R,$G,$B,$A -else -u $R,$G,$B -endif -else -u -1 -endif
-v +
#@gmic x_shadebobs
#@gmic : Launch the shade bobs demo.
x_shadebobs :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Shade bobs"$n" -------------------------------\n
----\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-------------------------------------------------"
-v - -rm t=100 -w 512,512,0,"[G"{`39`}"MIC] Shade bobs"
-do
t+=0.015
-if {$t>4*pi" || "{*,b}}
rx={u(-1,1)} ry={u(-1,1)} rz={u(-1,1)} rt={u(-1,1)} rcx={u(-0.6*0.6)} t=0
N={20+round(u(80))} R={(2+round(u(40)))*min({*,w},{*,h})/300}
-if $obj3d -rm[colormap,img,obj3d] -endif
{4+round(u(12))},1,1,3 -noise[0] 255,2 -r[0] 256,1,1,3,3 -*[0] 255 -shift[0] 1 -nm. colormap
(67.5;73.5;109.5;103.5;51.5;100.5;{2*$N};$N) 3,{2*$N},1,1,0
1,$N,1,1,5 2,$N,1,1,'y+x*$N' -a[-2--1] x -z. 0,5
4,$N,1,1,1 -y[-3--1] -a[-4--1] y -nm. obj3d
{*,w},{*,h} -nm. img
-wait -1
-endif
r={$ry+$rx*cos(6*$rz*$t)+(1-$rx)*sin(6*$rt*$t)}
(0;{30*$ry*($N-1)}) ($t;{2*pi*($N-1)/$N+$t}) -r[-2,-1] 1,$N,1,1,3
-+.. {360*sin($rz*$t)} -*.. {pi/180}
--sin[-2,-1] -cos[-4,-3] -*[-4,-2] $r -*[-3,-1] $rcx -+[-4,-3] -+[-2,-1]
-*.. {{*,w}/2} -*. {{*,h}/2} -a[-2,-1] x
--+. $R --.. $R -a[-2,-1] y -z. 0,2 -y. -j[obj3d] [-1],0,8 -rm.
-j3d[img] [obj3d],50%,50%,0,-1,2,0,0
-&[img] 255 --map[img] [colormap] -w. -rm. -wait 20
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -v +
#@gmic x_spline
#@gmic : Launch spline curve editor.
x_spline :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Spline curve editor"$n" --------------------------\n
----\n
---- "${c}"Mouse"$n" to insert/move/delete points.\n
---- Key '"${c}"R"$n"' to reset the curve.\n
---- Key '"${c}"SPACE"$n"' to shows/hide spline curve.\n
---- Key '"${c}"P"$n"' to shows/hide control points.\n
---- Key '"${c}"ENTER"$n"' to shows/hide control polygon.\n
---- Key '"${c}"T"$n"' to shows/hide point tangents.\n
---- Key '"${c}"I"$n"' to shows/hide point indices.\n
---- Key '"${c}"C"$n"' to shows/hide point coordinates.\n
---- Keys '"${c}"+"$n"' and '"${c}"-"$n"' to increase/decrease roundness.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
-----------------------------------------------------"
-v -
-if $! -a x -n 0,255 -to_rgb -else (0;0^0;128^0;0) -r. 512,512,1,3,3 -nm. "[G"{`39`}"MIC] Spline Editor" -endif
-w[0] {0,w},{0,h},0,0,-1,-1,{n} -r[0] {*,w},{*,h},1,3,1
-i[1] 1
roundness=0.5
visuflags=23
nearest=-1
active=-1
-do
-if {{1,whds}==1}
-rm[1] roundness=0.5 nearest=-1 active=-1
-i[1] ({0.2*w},{0.2*h};\
{0.2*w},{0.8*h};\
{0.8*w},{0.8*h};\
{0.8*w},{0.2*h})
-endif
[1] ({{*,w}/{0,w}},{{*,h}/{0,h}}) -*[-2,-1]
--shift[2] 0,-1,0,0,2 --shift[2] 0,1,0,0,2 --[-2,-1] -*. $roundness
--s. x -sqr[-2,-1] -+[-2,-1] -sqrt. -r. 2 --/[-2,-1] -rm..
--r[0] {*,w},{*,h},1,3
-if {$visuflags&4} -polygon. {2,h},{2,^},0.3,128,200,255 -endif
-repeat {1,h}
-line. {2,@0-3},0.3,255,255,0
-if {$visuflags&1} -spline. {2,@0-1},{3,@0-1},{2,@2-3},{3,@2-3},32,1,255 -endif
-if {$visuflags&8} -line. {{2,@0}-{4,@0}*20},{{2,@1}-{4,@1}*20},{{2,@0}+{4,@0}*20},{{2,@1}+{4,@1}*20},1,0,255,0 -endif
-if {$visuflags&16} -t. $>,{{2,@0}-3},{{2,@1}-18},13,1,255,255,0 -endif
-if {$visuflags&32} -t. "("{round({1,@0})}","{round({1,@1})}")",{{2,@0}-16},{{2,@1}+10},13,1,100,200,255 -endif
-shift[1-4] 0,-1,0,0,2
-done
-if {$visuflags"&2"} -repeat {1,h}
-ellipse. {2,@0-1},4,4,0,1,0,0,0 -ellipse. {2,@0-1},2,2,0,1,255,100,155 -shift[2] 0,1,0,0,2
-done -endif
-w. -rm[3,4,-1] -wait
-if {*,SPACE} visuflags+={if($visuflags&1,-1,1)} -wait -1 -endif
-if {*,P} visuflags+={if($visuflags&2,-2,2)} -wait -1 -endif
-if {*,ENTER} visuflags+={if($visuflags&4,-4,4)} -wait -1 -endif
-if {*,T} visuflags+={if($visuflags&8,-8,8)} -wait -1 -endif
-if {*,I} visuflags+={if($visuflags&16,-16,16)} -wait -1 -endif
-if {{*,C}" && "!{*,CTRLLEFT}" && "!{*,CTRLRIGHT}} visuflags+={if($visuflags&32,-32,32)} -wait -1 -endif
-if {{*,PADADD}" && "$roundness<1} roundness*=1.1 -wait -1 -endif
-if {{*,PADSUB}" && "$roundness>0.1} roundness*=0.9 -wait -1 -endif
-if {{*,R}" && "!{*,CTRLLEFT}" && "!{*,CTRLRIGHT}} -rm. -i[1] 1 -wait -1 -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,D}} -w[] {{*,w}*1.5},{{*,h}*1.5} -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,C}} -w[] {{*,w}/1.5},{{*,h}/1.5} -endif
-if {({*,CTRLLEFT}" || "{*,CTRLRIGHT})" && "{*,R}} -w[] {0,w},{0,h} -endif
-if {*,r} -w[] -endif
-if {{*,b}==0} active=-1
-elif {{*,x}>=0" && "{*,b}" && "$active==-1}
[2] ({*,x},{*,y}) --[-2,-1] -sqr. -s. x -+[-2,-1]
nearest={ym}
-if {im<64} active=$nearest -endif
-rm.
-endif
-rm[2]
-if {{*,b}&1" && "{*,x}>=0" && "$active!=-1}
-=[1] {{*,x}*{0,w}/{*,w}},0,$active
-=[1] {{*,y}*{0,h}/{*,h}},1,$active
-elif {{*,b}&2" && "{*,x}>=0" && "{1,h}>3}
-l[1] -s y -rm[$nearest] -a y -endl -wait -1
-elif {{*,b}&1" && "{*,x}>=0}
xy=({{*,x}*{0,w}/{*,w}},{{*,y}*{0,h}/{*,h}})
--shift[1] 0,-1,0,0,2 -+. [1] -/. 2
$xy --[-2,-1] -sqr. -s. x -+[-2,-1]
ns={ym} -rm.
-l[1] -s y -i[{$ns+1}] $xy -a y -endl
active={$ns+1}
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
--shift[1] 0,-1,0,0,2 --shift[1] 0,1,0,0,2 --[-2,-1] -*. $roundness
[0],[0],1,1,2 -rm[0]
-repeat {1,h} -spline. {0,@0-1},{1,@0-1},{0,@2-3},{1,@2-3},128,1,1 -shift[0] 0,-1,0,0,2 -shift[1] 0,-1,0,0,2 -done
-flood. 0,0,0,0,0,1,0
-rm[0,1] -w 0 -v +
#@gmic x_tetris
#@gmic : Launch tetris game.
x_tetris :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Tetris"$n" --------------------------------------------\n
----\n
---- This is a G\47MIC implementation of the "${g}"Tetris"$n" game.\n
----\n
---- "${c}"Arrow keys"$n" to move/rotate the triominos.\n
---- Key '"${c}"SPACE"$n"' to make the current triomino falling.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
----------------------------------------------------------"
-v - -rm
-i[m0] 4,1,1,1,1,1,1,1
-i[m4] 3,2,1,1,1,0,0,1,1,1
-i[m8] 3,2,1,1,0,0,1,1,1,1
-i[m12] 2,2,1,1,1,1,1,1
-i[m16] 3,2,1,1,0,1,1,1,1,0
-i[m20] 3,2,1,1,0,1,0,1,1,1
-i[m24] 3,2,1,1,1,1,0,0,1,1
-if {u<0.25}
-i[m28] 2,1,1,1,1,1
-i[m32] 2,2,1,1,1,1,0,1
-i[m36] 3,1,1,1,1,1,1
-i[m40] 1,1,1,1,1
-i[m44] 3,2,1,1,1,1,1,1,0,1
-i[m48] 3,3,1,1,1,1,1,1,0,1,1,1,1
-endif
-repeat $! i={4*$>} -l[m$i] -repeat 3 --rotate[0] {90*($>+1)} -nm. m{$i+$>+1} -done -endl -done
N=$!
-i[colors] 3,$N,1,1,'u(16,224)' -r. 3,400% -i[mask] (0,-1,0;1,0,-1;0,1,0) -*. 120
-repeat $N
--r[m$>] 500%,500%,1,3 --correlate. [mask],0 -r. 200%,200%,1,1,3 -r.. [-1] -*[-2,-1] -c. 30%,100%
--r[m$>] [-1],[-1],1,3 --replace_color. 0,0,1,1,1,{colors,@{3*$>}-{3*$>+2}} -rv[-3,-1] -+[-3,-1] -c.. 0,255
-channels. 0 -*. 255 -a[-2,-1] c -nm. s$>
-done
-rm[colors,mask]
fact={{s0,w}/{m0,w}}
W=12 H=20
-i[board] $W,$H -i[curr_board] [board]
-i[render] {$fact*$W},{$fact*$H},1,3 -i[curr_render] [render] --channels. 0 -nm. curr_render_mask
--rows[render] 0,50% -plasma. 1,2 -noise. 20 -blur_y. 40%,1 --mirror. y -a[-2,-1] y -r. [render]
-n. 0,64 -blur_x. 1 100%,100% -noise. 0.5,2 -b. 1 -*. 300 -+[-2,-1] -c. 0,255 -nm. background
time=$| score=0 fall_mode=0 gameover=0 n=-1 nn={round(u(0,$N-1))}
-do
-wait {if($fall_mode,-1,-20)}
-if $gameover
--j[background] [curr_render],0,0,0,0,0.7,[curr_render_mask],255
-text_outline. "Game\nOver!",22,30%,32,2,1,255 -w. -rm.
-continue
-endif
-if {$n<0}
-l[board] -s y i=-1 -repeat $! -if {$<,im} i=$<,$i -endif -done
0 -rm[$i] -a y score+={2^(narg($i)-1)-1} -r $W,$H,1,1,0,0,0,1 -nm board -endl
-if {narg($i)>1} -l[render] -s y,$H 0 -rm[$i] -a y -r {$fact*$W},{$fact*$H},1,3,0,0,0,1 -nm render -endl -endif
n=$nn nn={round(u(0,$N-1))} x={$W/2} y=0 do_render=1 fall_mode=0
-endif
-if $do_render
-rm[curr_board,curr_render,curr_render_mask]
-i[curr_board] [board] -j[curr_board] [m$n],{$x-int({m$n,w}/2)},$y,0,0,1,[m$n]
-i[curr_render] [render] -sh[s$n] 3 -j[curr_render] [s$n],{$fact*($x-int({m$n,w}/2))},{$fact*$y},0,0,1,[-1],255 -rm.
--*[curr_board] 255 -r. [curr_render],[curr_render] -nm. curr_render_mask
0 -t. "Score : "$score"    Next :",4,0,32,1,164 -r. 40%,40%,1,3,2 --!=. 0 -*. 255
-j[curr_render] [-2],0,0,0,0,1,[-1],255 -j[curr_render_mask] [-1],0,0,0,0,1,[-1],255 -rm[-2,-1]
--*[m$nn] 196 -r. 300%,300%,1,3 -j[curr_render,curr_render_mask] [-1],{{curr_render,w}-w-4},3,0,0,1,[-1],196 -rm.
do_render=0
-endif
--shift[background] 0,{round(-13*$|*1.04^$score)},0,0,2
-j. [curr_render],0,0,0,0,1,[curr_render_mask],255
-w. {2.25*w},{2.25*h},0,"[G"{`39`}"MIC] Tetris" -rm. -cursor[0] 0
-if {*,SPACE} fall_mode=1 -endif
-if {{*,ARROWUP}" || "{*,ARROWLEFT}" || "{*,ARROWRIGHT}}
an={if({*,ARROWUP},n=$n+1;if(n%4,n,n-4),$n)}
nx={w2=int({m$an,w}/2);max(w2,min($x-{*,ARROWLEFT}+{*,ARROWRIGHT},$W-({m$an,w}%2)-w2))}
--j[board] [m$an],{$nx-int({m$an,w}/2)},$y,0,0,-1,[m$an]
-if {{iM}==1} x=$nx n=$an -endif
-rm.
do_render=1
-endif
-if {{*,ARROWDOWN}" || "$|-$time>0.9^int($score/2)" || "$fall_mode}
y+=1
--j[board] [m$n],{$x-int({m$n,w}/2)},$y,0,0,-1,[m$n]
-if {{iM}>1" || "$y+{m$n,h}>$H}
-if {$y<=1} gameover=1 -endif
-j[board] [curr_board] -j[render] [curr_render] n=-1
-endif
-rm.
time=$| do_render=1
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -v +
#@gmic x_tictactoe
#@gmic : Launch tic-tac-toe game.
x_tictactoe :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Tic-Tac-Toe game"$n" -----------------\n
----\n
---- Use "${c}"mouse"$n" to select positions of the\n
---- symbols. Close window to exit game.\n
----\n
-----------------------------------------"
-v -
message=0
counter=0
player=0
state=0
tmp3=0
tmp2=0
tmp1=0
-_x_tictactoe2
-w. -1,-1,0," "
-do
-if $player message="Tic-Tac-Toe (O to play)"
-else message="Tic-Tac-Toe (X to play)"
-endif
-do
-w[] {w},{h},0,"[G"{`39`}"MIC] "$message -wait
-if {!{*}" || "{*,ESC}" || "{*,Q}} -w[] 0 -rm -v + -return -endif
-if {{*,b}&1" && "{*,x}>20" && "{*,y}>20" && "{*,x}<400" && "{*,y}<400}
tmp3={int(({*,x}-15)/130)}
tmp2={int(({*,y}-15)/130)}
tmp1={4^($tmp2*3+$tmp3)}
-if {int($state/$tmp1)%4} tmp1=-1 -endif
-else tmp1=-1 -endif
-while {$tmp1<0}
-_x_tictactoe{$player%2}
-j... [-2],{"130*"$tmp3" + 15+u(-5,5)"},\
{"130*"$tmp2" + 15+u(-5,5)"},0,0,1,[-1]
-rm[-2--1]
-w.
state+={(1+$player)*$tmp1}
(21,1344,86016,4161,16644,66576,65793,4368;\
0,0,0,0,1,2,0,0;\
0,1,2,0,0,0,0,0;\
3,3,3,4,4,4,5,6)
-repeat {w}
tmp1={@$>}
-if {($state&$tmp1)==$tmp1||($state&(2*$tmp1))==2*$tmp1}
-_x_tictactoe{i($>,3)}
-j[-4] [-2],{130*{-3,i($>,1)}+u(-5,5)},\
{130*{-3,i($>,2)}+u(-5,5)},0,0,1,[-1] -rm[-2--1]
-if {($state&$tmp1)==$tmp1} -w.. -1,-1,0,"Tic-Tac-Toe (X won!)"
-else -w.. -1,-1,0,"Tic-Tac-Toe (O won!)"
-endif
-do -wait
-if {*} -w[] {*,w},{*,h} -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w[] 0 -v + -return
-endif
-done
-rm.
player={($player+1)%2}
counter+=1
-while {$counter<9}
-w[] -1,-1,0,0,"Tic-Tac-Toe (Tied game!)"
-do -wait
-if {*} -w[] {*,w},{*,h} -endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-w[] 0 -rm -v +
_x_tictactoe :
-spread. 4 -b. 6 -sharpen. 0.8 -n. 0,1
__x_tictactoe :
--f. 1-i --n.. $2,255 --n... $3,255 -n[-4] $1,255 -a[-4,-2,-1] c
_x_tictactoe0 :
128,128,1,1,1 -line. 15%,15%,85%,85%,1,0 -line. 15%,85%,85%,15%,1,0 -erode. 12 -_x_tictactoe -deform. 4 -__x_tictactoe 40,40,160
_x_tictactoe1 :
128,128,1,1,1 -ellipse. 50%,50%,22%,22%,0,1,0 -ellipse. 50%,50%,15%,15%,0,1,1 -_x_tictactoe -deform. 4 -__x_tictactoe 160,40,160
_x_tictactoe2 :
391,391,1,1,"!(x%130) || !(y%130)" -r. 421,421,1,1,0,0,0.5,0.5 -dilate. 3 -_x_tictactoe -f. 1-i
100%,100% -noise. 10 -b. 8,0 -sharpen. 1.5 -n. 220,255 -*[-2,-1] -to_rgb.
_x_tictactoe3 :
421,130,1,1,1 -line. 10%,60%,90%,60%,1,0 -erode. 6 -_x_tictactoe -rotate. {u(-6,6)},1,1,50%,50% -__x_tictactoe 180,10,10
_x_tictactoe4 :
-_x_tictactoe3 -transpose[-2--1]
_x_tictactoe5 :
421,421,1,1,1 -line. 10%,10%,90%,90%,1,0 -erode. 6 -_x_tictactoe -__x_tictactoe 180,10,10
_x_tictactoe6 :
421,421,1,1,1 -line. 10%,90%,90%,10%,1,0 -erode. 6 -_x_tictactoe -__x_tictactoe 180,10,10
#@gmic x_waves
#@gmic : Launch the image waves demo.
x_waves :
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Image waves"$n" --------------------------\n
----\n
---- "${c}"Left mouse button"$n" to drop balls.\n
---- "${c}"Right mouse button"$n" to rotate view.\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"CTRL+F"$n"' to switch fullscreen mode.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
---------------------------------------------"
-v -
-if {!$!} -l[]
200,200 x={-1.06-u*0.1} y={-0.26-u*0.1}
-mandelbrot $x,$y,{$x+0.1},{$y+0.1},256
16,1,1,3,u -r. 256,1,1,3,3 -shift. 1
-map[0] [-1] -rm. -r2dx 100
--mirror y --mirror x -+ -n 0,255
-endl -else -k[0] -r[0] 100,100,1,3,2 -endif
-i[0] (20;80;0^20;80;0^20;80;0) -r[0] 400,300,1,3,3 -water[0] 100,2
-w[0] {0,1.25*w},{0,1.25*h},0,"[G"{`39`}"MIC] Image waves"
w={w} -elevation3d. 0 -rv3d.
-sh. 8,{7+3*i[6]},0,0 -r. 3,{h/3},1,1,-1
(0,1,0;1,0,1;0,1,0) -/. 2
-ball[] 20,200,255,128,1,0.7,3.5
0 $w,$w [-1]
-l3d {$w/2},-200,-1000 -sl3d 0.4 -ss3d 0.8 -f3d 500 time0=$|
-do
--convolve. [3],1 --. [-3] -rm... -b. 0.8 --. {ia}
-r. 1,{$w*$w},1,1,-1 -j[2] [-1],2,0 -r. $w,$w,1,1,-1
[1]
-if {5,h} --l[5] -rows 0,2
nb={w}
-i[0] ({'CImg3d'}) -i[1] ($nb,$nb) -transpose[2]
(1,0;1,{$nb-1}) -r. 2,$nb,1,1,3 -round.
1,{4*$nb},1,1,1 -y -a y
-endl [4] -sprites3d.. [-1],1 -rm. -+3d[-2,-1] -endif
--3d. {$w/2},{$w/2} -*3d. {0,0.9*max(w,h)/$w}
-r3d. 0,0,1,{if({*,b}&2,-{*,x}*360/{*,w},$|*30)} -r3d. 1,0,0,-120
--j3d[0] [-1],50%,65%,30,1,3,0,0
fps=${-fps} -if {$fps>0} -text_outline. $fps" fps",5,{h-22},16,2,0.2 -endif
-w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {2.25*w},{2.25*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {1.25*w},{1.25*h}
-elif {{*,CTRLLEFT}&&{*,F}}
-if {!narg($is_fs)} is_fs={*,w},{*,h} fw={min({*,u}*h/w,{*,v}*w/h)} -w[] $fw,{$fw*h/w},0,1
-else -w[] $is_fs,0,0 is_fs=""
-endif
-endif
-rm[-2,-1] -wait 20
-if {{*,b}&1||($|-$time0)>1} ({u*$w};{u*$w};70;0) -a[5,-1] x time0={$|-u} -endif
-if {5,h} -l[5,-1]
-sh[0] 2,2,0,0 -sh[0] 3,3,0,0 --.. [-1] -+. 0.2 -rm[-2,-1]
-s[0] x -repeat {$!-1} coords={$<,@0-1} -if {{$<,@2}<i($coords)} -=. {80+{i($coords)}},$coords -rm[$<] -endif -done
-if {$!==1} -i[0] 0 -else -a[0--2] x -endif
-endl
-endif
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm -w 0 -v +
#@gmic x_whirl : _opacity>=0
#@gmic : Launch the fractal whirls demo.
#@gmic : Default values: 'opacity=0.2'.
x_whirl : -check ${1=0.2}>=0
-if {!{*,u}} -error[0--3] "Command '-$0': No display available." -return -endif
-v - -use_vt100 g=$_gmic_g c=$_gmic_c n=$_gmic_n r=$_gmic_r -v +
-e[] "\n
------ "${g}"Fractal whirls"$n" ----------------------------\n
----\n
---- Keys '"${c}"CTRL+D"$n"' to increase window size.\n
---- Keys '"${c}"CTRL+C"$n"' to reset window size.\n
---- Keys '"${c}"ESC"$n"' or '"${c}"Q"$n"' to exit.\n
----\n
--------------------------------------------------"
-v -
5,5,1,3 256,256,1,3 [-1] -w. 384,384,0,"[G"{`39`}"MIC] Fractal whirls"
tangle=0 tzoom=0 xc={(w-{-3,w})/2} yc={(h-{-3,h})/2}
-do
-rand... 0,255 -j.. [-3],$xc,$yc,0,0
-rotate.. {8*sin($tangle)},0,0,{w/2+u(-2,2)},{h/2},{1.03+0.02*sin($tzoom)}
tangle+=0.001 tzoom+=0.02
-j. [-2],0,0,0,0,$1 -w.
-if {{*,CTRLLEFT}&&{*,D}} -w[] {3*w},{3*h} -elif {{*,CTRLLEFT}&&{*,C}} -w[] {1.5*w},{1.5*h} -endif
-wait 20
-while {{*}" && "!{*,ESC}" && "!{*,Q}}
-rm[-3,-2] -w[] 0 -v +
__help_end :
gimp_filter_sources : -skip ${1=0}
({'{/$_path_user}'})
({'http://gmic.eu/gimp_update$_version.gmic'},1)
file_hotchocolate=${_path_rc}hotchocolate.gmic
-if $file_hotchocolate
-i raw:$file_hotchocolate,uchar
-if {i!=32" && "i!=10}
-if {!$1} (10) -o. raw:{/$file_hotchocolate},uchar -rm. -endif
-else
is_too_old={"Y = date(0); M = date(1); D = date(2); date_current = Y*365 + M*31 + D;
Y = date(0,"$file_hotchocolate"); M = date(1,"$file_hotchocolate"); D = date(2,"$file_hotchocolate"); date_file = Y*365 + M*31 + D;
delta = date_current - date_file;
(i==32 && delta>10) || (i==10 && delta>45)"}
-if $is_too_old
({'"\#@gimp <span color=\"red\">&#x2764; <b>One-click chocolate !</b></span> : _none_, gimp_friends"\n\
"\#@gimp : note = note{\"Want to send a <b>free hot chocolate</b> to the <b>hard-working</b> developers who provide G\47MIC <b>for free</b> ?\\n"\n\
"\#@gimp : Just follow the link below (or copy/paste into your browser) and click <b>on the sponsored link</b> that is shown. It\47s as simple as that and"\n\
"\#@gimp : we\47ll drink to you :)\"}"\n\
"\#@gimp : link = link{\"Send a free hot chocolate to the G\47MIC developers\",\"http://gmic.eu/freechocolate.shtml\"}"\n\
"\#@gimp : link = link{\"http://gmic.eu/freechocolate.shtml\"}"\n\
"\#@gimp : sep = separator()"\n\
"\#@gimp : note = note{\"If you\47d like to send <b>more</b> than a single hot chocolate for our efforts, please visit the following page where you can contribute"\n\
"\#@gimp : extra to help keep us motivated (via <b>Paypal</b>):\"}"\n\
"\#@gimp : link = link{\"Offer even more hot chocolate to the G\47MIC developers\",\"http://gmic.eu/morechocolate.shtml\"}"\n\
"\#@gimp : link = link{\"http://gmic.eu/morechocolate.shtml\"}"\n\
"\#@gimp : sep = separator()"\n\
"\#@gimp : note = note{\"<small><b>Note:</b> This filter won\47t appear anymore after you re-run the plug-in. So, don\47t miss the occasion!</small>\"}"\n\
"\#@gimp : sep = separator(), note = note(\"<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/30/2015</i>.</small>\")"\n\
'})
-o. raw:$file_hotchocolate,uchar -rm.
-endif
-endif
-rm.
-else
(32) -o. raw:$file_hotchocolate,uchar -rm.
-endif
({'{/$file_hotchocolate}'})
-l[] -i cimgz:${_path_rc}gimp_filter_sources -onfail -endl
gimp_parallel_overlap :
-apo "$1",$3,{if($2,2^($2-1),0)}
gimp_preview :
-frame 1,1,0,0,0,255 -montage B
gimp_layer_name :
-u ${"-_gimp_merge_layers[0] name,[unnamed]"}
gimp_layer_mode :
-u ${"-_gimp_merge_layers[0] mode,alpha"}
gimp_layer_opacity :
-u ${"-_gimp_merge_layers[0] opacity,100"}
gimp_layer_pos :
-u ${"-_gimp_merge_layers[0] pos,0,0"}
gimp_set_layer_pos :
-repeat $! -l[$>]
name=${-gimp_layer_name} mode=${-gimp_layer_mode} opacity=${-gimp_layer_opacity}
-nm "name("$name"),mode("$mode"),opacity("$opacity"),pos("{round($1)},{round($2)}")"
-endl -done
gimp_set_layer_mode :
-repeat $! -l[$>]
name=${-gimp_layer_name} opacity=${-gimp_layer_opacity} pos=${-gimp_layer_pos}
-nm "name("$name"),mode($1),opacity("$opacity"),pos("$pos")"
-endl -done
gimp_set_layer_opacity :
-repeat $! -l[$>]
name=${-gimp_layer_name} mode=${-gimp_layer_mode} pos=${-gimp_layer_pos}
-nm "name("$name"),mode("$mode"),opacity($1),pos("$pos")"
-endl -done
gimp_merge_layers :
mode0=${"-_gimp_merge_layers. mode,alpha"}
opacity0=${"-_gimp_merge_layers. opacity,100"}
pos0=${"-_gimp_merge_layers. pos,0,0"}
-if {$opacity0<100" || "['$pos0']!='0,0'} 100%,100%,1,4 -endif
wh0={w},{h}
wh=${-max_wh} -r. $wh,1,100%,0
-repeat {$!-1} -l[-2,-1] -rv
mode=${"-_gimp_merge_layers[1] mode,alpha"}
opacity=${"-_gimp_merge_layers[1] opacity,100"}
pos=${"-_gimp_merge_layers[1] pos,0,0"}
-to_a[1] -r[1] $wh,1,100%,0
-shift[1] ${-u\ $pos},0,0
-to_colormode[0,1] 0
-blend $mode,{max(0,min(1,$opacity/100))}
-endl -done
-r $wh0,1,100%,0
_gimp_merge_layers :
res="" ({'{0,n}'})
-l.
str="$1(" l={size(['$str'])}
-s +,{'$str'}
-if {$!>1} -repeat $!
-if {$>!=$!-1" && "same([{$>,^}],['$str'],$l)}
-l[{$>+1}] -s +,{')'} -if {$!>1} res={0,t} -endif -a y -endl
-endif
-if {narg({'$res'})} -break -endif
-done -endif -rm
-endl
-if {narg({'$res'})} -u $res -else -u "${2--1}" -endif
_before :
0 -t. "Before",1,-1,13,1,1 -r. {w+4},{h+4},1,1,0,0,0.5,0.5
_after :
0 -t. "After",1,-1,13,1,1 -r. {w+4},{h+4},1,1,0,0,0.5,0.5
gimp_split_preview : -skip ${3=0},${4=0}
-m "_gsp : m={max(w,h,256)} -if {$m==256} -rr2d $m,$m,0,1 -endif"
-if $3
-m "gsp : w={w} h={h} s={s} -l -apply_timeout \"$1\",$3 -onfail -gimp_timeout_preview -endl -if {!$!} $w,$h,1,4 -drgba -to_colormode $s -endif -k[0] -if {s>4} -channels 0,3 -endif"
-else
-m "gsp : w={w} h={h} s={s} $1 -if {!$!} $w,$h,1,4 -drgba -to_colormode $s -endif -k[0] -if {s>4} -channels 0,3 -endif"
-endif
-repeat $! -l[$>]
-if {$2==0} -gsp. -mv. 0 -continue -endif
-if {!($2%2)}
-if $4 -r. 200%,100%,100%,100%,0,2 -endif
-s. x,2
-if {$2==2}
-gsp. -to_colormode[-2,-1] 0
-_gsp.. -_gsp.
-_before -_after
-elif {$2==4}
-gsp.. -to_colormode[-2,-1] 0
-_gsp.. -_gsp.
-_after -_before
-else
-rm. --gsp. -to_colormode[-2,-1] 0
-_gsp.. -_gsp.
-_before -_after
-endif
-if $4
hw={-4,int(w/2)} -z[-4] 0,{$hw-1}
-if {$2==6} -z... 0,{$hw-1} -else -z... $hw,100% -endif
-endif
-line... 0,0,0,{-3,h},1,0,0,0,255 -a[-4,-3] x
-else
-if $4 -r. 100%,200%,100%,100%,0,2 -endif
-s. y,2
-if {$2==1}
-gsp. -to_colormode[-2,-1] {max({-2,s},s)}
-_gsp.. -_gsp.
-_before -_after
-elif {$2==3}
-gsp.. -to_colormode[-2,-1] {max({-2,s},s)}
-_gsp.. -_gsp.
-_after -_before
-else
-rm. --gsp. -to_colormode[-2,-1] 0
-_gsp.. -_gsp.
-_before -_after
-endif
-if $4
hh={-4,int(h/2)} -rows[-4] 0,{$hh-1}
-if {$2==5} -rows... 0,{$hh-1} -else -rows... $hh,100% -endif
-endif
-line... 0,0,{-3,w},0,1,0,0,0,255 -a[-4,-3] y
-endif
--dilate[-2,-1] 5 -*[-4,-3] 255 -to_colormode[-4,-3] {-5,s}
-j[-5] [-4],1,1,0,0,0.8,[-2] -j[-5] [-3],{{-5,w}-w-1},{{-5,h}-h-1},0,0,0.8,[-1]
-rm[-4--1]
-endl -done
-uncommand gsp -uncommand _gsp
gimp_print_preview : -skip "${1=},${3=}" -check "${2=32}>=0 && ${4=20}>=0 && ${5=20}>=0"
-if {!$!" || "w<128" || "h<128} -rm 420,300,1,4,0 -endif
-k[0] -drgba
(1;1^1;0.5^0;0.5) (1.5,0,1.5;0,0,0;1.5,0,1.5) -r[-2,-1] [-3],3 -* -c 0,255
-l[]
0 -t. "$1",0,0,$2,1,255 -r. 100%,140%,1,1,0
-i[0] 100%,100%,1,3 -fc[0] 255,200,128 -a c
-onfail -rm
-endl
-l[]
({'"$3"'}) --f. '>if(i>32||j(-1)<$5,j(-1)+1,0)' -==. 0 -*. 256 -max[-2,-1] -s -,256
-s y,-{round(1.3*$5)}
-repeat $! -l[$>] 0 -t. {0,t},0,0,$4,1,255 -rm[0] -endl -done
-a y -i[0] 100%,100%,1,3,255 -a c
-onfail -rm
-endl
-a[^0] y,0.5
-if {$!>1}
-if {w>{0,w}} -r2dx. {0,w-8} -endif
-if {h>{0,h}} -r2dy. {0,h-8} -endif
-r[1] [0],[0],1,4,0,0,0.5,0.5 -blend alpha
-endif
gimp_no_preview : -skip "$*"
-gimp_print_preview "",0,"No preview\n  available",32
gimp_timeout_preview :
-gimp_print_preview "",0,"Preview timeout",32
gimp_warning_preview :
-gimp_print_preview "Preview warning:",32,"$*",22,30
gimp_error_preview :
-gimp_print_preview "Preview error:",32,"$*",15,40
gimp_check_version :
-if {$_version<$1}
-gimp_error_preview "This filter requires at least version *"${"-strver $1"}"* of the G'MIC framework.\n\n"\
"http://gmic.eu/gimp.shtml"
-u 0
-else -u 1
-endif
gimp_autocrop_layers :
-repeat $! -l[$>]
nm=${-gimp_layer_name}
mode=${-gimp_layer_mode}
opacity=${-gimp_layer_opacity}
coords=${-autocrop_coords\ auto}
-z $coords
-nm mode($mode),opacity($opacity),pos({arg(1,$coords)},{arg(2,$coords)}),name($nm)
-endl -done
gimp_logo_version3 : -skip "${1=Plug-in for GIMP}"
-rm s="G\47MIC"
-repeat {narg({'$s'})}
0 -t. {`arg(1+$>,{'$s'})`},0,0,53,1,1 -frame. 3,0,0
-r. 500%,500%,1,1,3 -b. 3% ->=. 50%
-distance. 1 -<=. 10
[-1]x3 -whirls[-4--2] ,
r$>={u(0.4,1)} g$>={u(0.2,1)} b$>={u(0.6,1)}
-*[-4] ${r$>} -*... ${g$>} -*.. ${b$>}
-a[-4--2] c -n.. 0,255 -*. 255 -a[-2,-1] c
-done
-a[-5--1] x
-r. 100%,120%,1,4,0,0,0.5,1
-ball 64,{255*$r3},{255*$g3},{255*$b3} -j.. [-1],450,5 -rm.
-sh. 100% -dilate. 7 -rm. -autocrop.
-drop_shadow. 10,10,1%,0.5
0 -t. "$1",0,0,53,1,255 -frame. 4,4,0 [-1]x3 -dilate. 7 -a[-4--1] c
-a[-2,-1] y,0.5
-r2dy. 50%
-i.. 120%,120%,1,3,255 -plasma.. 1,1 -s.. c
-n[-4] 150,255 -n... 180,255 -n.. 200,255 -a[-4--2] c
-blend alpha
-frame 0,1,0,0,0 -frame 0,5,255,255,255
gimp_logo_version2 : -skip "${1=Plug-in for GIMP}"
-if $! -k[0] -endif
-to_rgb 0 -t. "G\47MIC",0,0,53,1,1 -label.
6,1,1,3 -rand. 150,255 -point. 0 -map.. [-1] -rm.
-expand_xy. 10,0 -b. 2 -r. 200%,200%,1,3,6 -sqr. -c. 0,60% -n. 0,255
-warp_perspective. 0.5,0,1,50,50,0 -shift. 0,-10
100%,100% -noise. 0.8,2 -*. 180 --blur_linear. 20,0,45,0 -*. 20 -max[-3--1]
-sh. 2 (0;128) -r. [-2],3 -+[-2,-1] -min. 255 -rm.
0 -t. "$1",0,0,13,1,1 --dilate. 3 -*.. 255 -r.. 100%,100%,1,3
-j... [-2],{({-3,w}-w)/2},75%,0,0,1,[-1] -rm[-2,-1]
-frame. 1,1,128 -mv. 0
-if {$!>1} -*[^0] 0.45 -repeat {$!-1} -j. [0],{(w-{0,w})/2},{(h-{0,h})/2} -mv. 1 -done -rm[0] -endif
gimp_logo_version1 : -skip "${1=Plug-in for GIMP}"
-if $! ratio={w/h} -else ratio=1 -endif
-rm 118,44,1,1 -t "G\47MIC",3,-6,53,1,255 -r 100%,100%,10,1 -r 100%,100%,20,1,0,0,0.5,0.5,0.5 -b 1.5
-isosurface3d 50%
-col3d {u(150,255)},{u(150,255)},{u(150,255)}
-sphere3d 8 -col3d. {u(150,255)},{u(150,255)},{u(150,255)} -+3d. 72,-6 -+3d -c3d. -rv3d
-db3d 0 -sl3d 0.2 -ss3d 1.3 -r3d. 1,0,0,30 -f3d 120 -*3d. 1.5
230,120,1,3 -j3d. [-2],50%,30%,0,1,4 -rm..
0 -t. "$1",0,0,13,1,255,255,255 -j.. [-1],{({-2,w}-w)/2},75% -rm.
-to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -drop_shadow 6,6,2
-i.. ${-fitratio_wh\ 230,120,$ratio},1,3
-rand.. 0,255 -sh.. 0 -/. 2 -rm.
-blur_radial.. 20 -sharpen.. 300
-r. [-2],[-2],1,4,0,0,0.5,0.5 -blend alpha
gimp_logo : -skip "${1=Plug-in for GIMP\n    [ "${-strver}" ]}"
-gimp_logo_version{round(u(0.5,3.49))} "$1"
gimp_logo_en :
-if {narg($_prerelease)}
-gimp_logo_version{round(u(0.5,3.49))} "       Plug-in for GIMP\n"[" "${-strver}" pre-release ""#"$_prerelease]
-else
-gimp_logo_version{round(u(0.5,3.49))} "Plug-in for GIMP\n    "[" "${-strver}" "]
-endif
gimp_logo_fr :
-if {narg($_prerelease)}
-gimp_logo_version{round(u(0.5,3.49))} "     Greffon pour GIMP\n"[" "${-strver}" pre-release ""#"$_prerelease]
-else
-gimp_logo_version{round(u(0.5,3.49))} "Greffon pour GIMP\n    "[" "${-strver}" "]
-endif
gimp_download_all_data :
-l[] -input_clut foo -rm -onfail -rm -endl
_filenames_grain=${-_gimp_emulate_grain}
_url_grain=http://gmic.eu/data_film_presets
_prefix_grain=grain_
_filenames_lightleak=${-_gimp_light_leaks}
_url_lightleak=http://gmic.eu/data_lightleaks
_prefix_lightleak=
_filenames_logo=gmicky_large_deevad,gmicky_small_deevad,gmicky_large_mahvin,gmicky_small_mahvin,gmicky_wilber_large,gmicky_wilber_small,roddy_large,roddy_small
_url_logo=http://gmic.eu/img
_prefix_logo=
_n=0
_N={narg($_filenames_grain,$_filenames_lightleak,$_filename_logo)}
-progress 0
-_gimp_download_all_data[] grain,$1
-_gimp_download_all_data[] lightleak,$1
-_gimp_download_all_data[] logo,$1
-progress 100
_gimp_download_all_data :
-repeat {narg(${_filenames_$1})}
filename=${-arg\ 1+$>,${_filenames_$1}}.cimgz
-v + -e[] "Download "$filename -v -
-if {$2" || "!isfile(${_path_rc}${_prefix_$1}$filename)} -l[] ${_url_$1}/$filename -o ${_path_rc}${_prefix_$1}$filename -rm -onfail -endl -endif
-progress {100*$_n/$_N}
_n+=1
-done
gimp_friends : -skip $*
-if $! ratio={w/h} -else ratio=1 -endif
-rm -_heart80x73 -scale3x -r 150%,150%,1,1,0,0,0.5,0.5
--*. 70 --*.. 110 --*... 255 -*[-4] 255 -a c
-blur_radial 4 -sharpen 300
-i.. ${-fitratio_wh\ {w},{h},$ratio},1,3
-rand.. 0,255 -sh.. 1,2 -/. 2 -rm.
-blur_radial.. 20 -sharpen.. 50
-r. [-2],[-2],1,4,0,0,0.5,0.5 -blend alpha
113,67,1,1,0 -t. "Greetings to\n  all G\47MIC\n  friends!",2,-2,23,1,1
--dilate. 3 -*.. 255 -to_rgb.. -j... [-2],{({-3,w}-{-2,w})/2},{({-3,h}-{-2,h})/2.2},0,0,1,[-1]
-rm[-2,-1]
_heart80x73 :
40,73,1,1,0 -ellipse 22,22,20,20,0,1,1 -polygon 3,7,37,42,72,42,27,1,1 --mirror x -a x
gimp_logo_ca :
-if {narg($_prerelease)}
-gimp_logo_version{round(u(0.5,3.49))} "         per al GIMP\n"[" "${-strver}" pre-release ""#"$_prerelease]
-else
-gimp_logo_version{round(u(0.5,3.49))} "per al GIMP\n  "[" "${-strver}" "]
-endif
gimp_gmicky :
-rm
-if {$1==0} -gmicky_deevad -nm "name(Gmicky)"
-elif {$1==1} -gmicky_mahvin -nm "name(Gmicky)"
-elif {$1==2} -gmicky_wilber -nm "name(Gmicky & Wilber)"
-else -roddy -nm "name(Roddy)"
-endif
gimp_gmicky_preview :
w={w} h={h} -rm
-if {$1==0}
filename=${_path_rc}gmicky_small_deevad.cimgz
url=http://gmic.eu/img/gmicky_small_deevad.cimgz
-elif {$1==1}
filename=${_path_rc}gmicky_small_mahvin.cimgz
url=http://gmic.eu/img/gmicky_small_mahvin.cimgz
-elif {$1==2}
filename=${_path_rc}gmicky_wilber_small.cimgz
url=http://gmic.eu/img/gmicky_wilber_small.cimgz
-else
filename=${_path_rc}roddy_small.cimgz
url=http://gmic.eu/img/roddy_small.cimgz
-endif
-if $filename $filename -else $url -o $filename -endif
-r2dy $h
gimp_search_filters : -skip "${1=}"
-l[]
date_current={date(2)+31*(date(1)+12*date(0))}
file_filters=${_path_rc}gimp_filters
date_filters={date(2,$file_filters)+31*(date(1,$file_filters)+12*date(0,$file_filters))}
-if {$date_filters<0" || "$date_current-$date_filters>0}
-l[] -i raw:http://gmic.eu/gimp_filters.txt,uchar -o raw:$file_filters,uchar -onfail -endl -rm
-endif
-l[] -i raw:$file_filters,uchar -onfail 0 -endl
({'" $1"'}) -+. 'if(i>=65&&i<=90,32,0)' -autocrop. 32 term={t} -rm.
--l
-+ 'if(i>=65&&i<=90,32,0)' -s -,10
-if $2 -replace_seq {``{'"(in "{`39`}'}},1e10
-else -replace_seq {``{'"(command "{`39`}'}},1e10
-endif
-replace_seq {``{'"* "'}},1e10
-if {narg("$1")}
-if {!$3}
-if $2 -replace_seq {``{'" (command "{`39`}'}},0
-else -replace_seq {``{'" (in "{`39`}'}},0
-endif
-ap "-f '>if(y>1&&!i[y-1],0,i)'"
-endif
-replace_seq {``{'$term'}},-1e5
-else -f -(iM<=255)
-endif
-a x -r 100%,1,1,1,2 -lt 0
-endl
-s[0] -,10 -a[^-1] x
-rv -a y -discard x,0
-if {!w} -rm ({'"\n** no match found!\n"'})
-else
-rows 1,100%
-s x
-autocrop 0 -autocrop 32 N=$!
-i[^0] (10)
-i[0] ({'"** "$N" match"${"-if {"$N"!=1} -u es -else -u \"\" -endif"}" found:\n\n"'})
-y -f 'if(y==0&&i>=97&&i<=122,i-32,i)'
-i[^0,-1] ({'"- "'}) -y -a y
-endif
-replace_str. "&","&amp;"
-u "{\"$1\"}{$2}{$3}{"{t}"}"
-rm
-endl
-if {narg("$1")} -gimp_print_preview "Search filters",,"whose names contain:\n\n      $1"
-else -gimp_print_preview "Search filters",,"(all filters)"
-endif
gimp_survey : -skip $"*"
-rm -i http://gmic.eu/gmic_survey.png
gimp_survey_preview :
-if $-1
lockname=${-path_tmp}.gmic_survey.lock
-if $lockname -gimp_print_preview "Your answers have been sent.",20,"Thank you!",16
-else
-str2hex $"*",$_version
-l
-m "http://gmic.eu/gmic_survey.cgi?"${}
-gmic_survey_check
1 -o. raw:$lockname,char -rm.
-gimp_print_preview "Your answers have been sent.",20,"Thank you!",16
-onfail
-gimp_print_preview "Sending error:",32,"Sorry, but something went wrong! Your answers have not been sent. Maybe a problem with the Internet connection?",15,40
-endl
-endif
-endif
survey :
-e[^-1] "Generate image of the survey results."
-v - -l[]
-i raw:http://gmic.eu/gmic_survey.raw,uchar -s -,10
-repeat {$!-1} -l[{$<-1},$<] -if {ia=={-2,ia}" && "im=={-2,im}" && "iM=={-2,iM}} -rm. -endif -endl -done
-m "__survey : -_survey $""1"
N=0 -repeat $! -l[$>]
({'${-hex2str\ {t}}'})
--replace. {'" "'},{'~'} -z. 0,32 -z.. 34,100%
-if {{@100%}==_'0'" || "{@100%}==_'1'}
-v + -e[] "["{1+$N}"] "{-2,t} -v -
-__survey {t} N+=1
-endif
-rm 0
-endl -done
-uncommand ___survey
-rm
_back={u(240,255)},{u(240,255)},{u(240,255)}
-_survey_choice[] 0,"1. Who am I?","N.C.","A photographer","A painter","An illustrator","A graphic designer","A lover of image filters","An image processing expert","An open-source enthusiast","A scientist","Someone else",420
-_survey_bool[] 1,"I do graphics/image processing for a living."
-r[-2,-1] ${-max_w[-2,-1]},100%,1,3,0,1 -a[-2,-1] y
-_survey_choice[] 2,"2. How did I hear about G'MIC?","N.C.","A friend showed me","From a search engine","From a discussion forum","From a blog entry","From an online magazine","From a physical magazine",420
-_survey_choice[] 3,"3. How often am I using G'MIC?","N.C.","Several times a day","Almost everyday","Few times a week","Rarely","Never","I've just discovered G'MIC today",420
-_survey_choice[] 4,"4. My preferred G'MIC interface:","N.C.","the CLI tool 'gmic'","the plug-in for GIMP","the plug-in for Krita","the web interface G'MICol","ZArt","I don't know about other interfaces",420
0 -t. "5. I follow the news about the G'MIC project on:",0,0,32,1,127,0,0,255 -frame. 8,16,0,0,0,0
-i.. 100%,100%,1,3 -fc.. $_back -blend[-2,-1] alpha
-_survey_bool[] 5,"The G'MIC website.",256
-_survey_bool[] 6,"The Google+ page.",256
-_survey_bool[] 7,"The GimpChat forum.",256
-_survey_bool[] 8,"The Flickr user group.",256
-_survey_bool[] 9,"The mailing list.",256
-_survey_bool[] 10,"I don't follow G'MIC news.",256
-r[-7--1] ${-max_w[-7--1]},100%,1,3,0,1 -a[-7--1] y
-_survey_choice[] 11,"6. How do I rate the frequency\n    of G'MIC releases?","N.C.","Too fast","Just fine","Too slow",500
-_survey_bool[] 12,"A rolling release would be nice for G'MIC."
-r[-2,-1] ${-max_w[-2,-1]},100%,1,3,0,1 -a[-2,-1] y
-_survey_choice[] 13,"7. How do I judge the number of\n   available filters?","N.C.","Too many filters.\n   A pertinent subset should be kept","Fine. The more is the best","Just fine","Not enough useful filters","Not enough. I want more!",500
-_survey_bool[] 14,"I use the \"Faves\" feature of the plug-in"
-r[-2,-1] ${-max_w[-2,-1]},100%,1,3,0,1 -a[-2,-1] y
-_survey_choice[] 15,"8. How do I judge the amount and\n   quality of available documentation?","N.C.","Documentation in too many different places.","Enough but too much technical documentation","Enough but not technical enough documentation","Just fine","I miss technical documentation","I miss non-technical documentation",500
-_survey_bool[] 16,"It's hard to get support and/or feedback from the developers"
-r[-2,-1] ${-max_w[-2,-1]},100%,1,3,0,1 -a[-2,-1] y
-r[0-3] ${-max_w[0-3]},100%,1,3,0,1
-r[4-7] ${-max_w[4-7]},100%,1,3,0,1
-frame 1,1,0 -drop_shadow 5,5,4
-a[4-7] y -a[0-3] y -a x,1
-i.. 100%,100%,1,3,255 -blend[-2,-1] alpha
-i http://gmic.eu/img/logo4.jpg -r2dy. 160 -j.. [-1],60,8 -rm.
-t. "Results of the survey",200,170,24,1,0
-t. "("$N" participants)",540,180,16,1,0,128,0
-r2dx 1280 -round
out=${-path_tmp}gmic_survey.png -o $out
-l[] GMIC_LOGIN=${-gmic_ftp\ 0} -onfail GMIC_LOGIN="" -endl
-l[] GMIC_PASSWD=${-gmic_ftp\ 1} -onfail GMIC_PASSWD="" -endl
-if {narg($GMIC_LOGIN)}
-x "lftp ftp://"$GMIC_LOGIN":"$GMIC_PASSWD"@ftp.gmic.eu -e \"put -O /www/gmic/ \\\""$out"\\\"; quit\" >/dev/null"
-endif
-endl -v +
_survey :
$=arg
-repeat $#
-if {narg(${_answers$>})} _answers$>=${_answers$>},${arg{1+$>}}
-else _answers$>=${arg{1+$>}}
-endif
-done
_survey_bool : -skip ${3=0}
(${_answers$1}) -histogram. 2,0,1 -normalize_sum. val0={round(i[0]*100)} val1={100-$val0} -rm.
0 -t. "$2",0,0,20,1,0,0,0,255
RGB1={u(60,90)},{u(60,90)},{u(60,90)} ($RGB1) -*. 2 -c. 0,255 RGB2={^} -rm.
128,1,1,3 -fc. $RGB1 -line. 0,0,$val1%,0,1,$RGB2
0 -t. $val1%,0,0,16,1,1
-r.. 100%,{h+8},1,3 -r. [-2],[-2],1,1,0,0,0.5,0.5
--fc.. 255,255,255 -j... [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-frame. 1,1,0,0,0,255 -drop_shadow. 3,3,2
-if $3 -r[0] {max($3,w)},100%,1,4,0,1 -endif
-frame 8,2,0,0,0,0 -a x,0.5
-i.. 100%,100%,1,3 -fc.. $_back -blend alpha
_survey_choice :
$=arg
(${_answers$1}) -histogram. {$#-3},0,{$#-4} -normalize_sum.
--l.
i=1 -repeat {w} -if {i[$>]}
RGB$>={u(150)},{u(150)},{u(150)}
val={round(i[$>]*100)}
0 -t. $i." "${arg{3+$>}}"   ",0,0,20,1,${RGB$>},255
0 -t. [$val%],0,0,20,1,${RGB$>},255
-r[-2,-1] 100%,${-max_h[-2,-1]},1,4,0,0,0,0.5
-mv[-2,-1] -3
i+=1
-endif -done
-rm.
-r[0--1:2] ${-max_w[0--1:2]},100%,1,4,0,1
-r[1--1:2] ${-max_w[1--1:2]},100%,1,4,0,1
-append_tiles 2
-if $-1 -r {max($-1,w)},100%,1,4,0 -endif
-endl
-l..
parg1=50,255,255,254
parg2=50,255,255,0
i=1 -repeat {w} -if {i[$>]}
val={round(i[$>]*100)}
parg1=$parg1,$i,{i[$>]},${RGB$>}
-if {$val>10} parg2=$parg2,"\n\n"$val%,{i[$>]},0,0,0
-else parg2=$parg2," ",{i[$>]},0,0,0 -endif
i+=1
-endif -done
512,512,1,3,255 -piechart. $parg1
512,512,1,3 -piechart. $parg2
-max[-2,-1]
-to_rgba. -replace_color. 0,0,255,255,255,255,255,255,255,0
-drop_shadow. 10,10,2
-r2dy. 180
-rm[0]
-endl
-to_rgba. -i.. 0 -t.. "$2",0,0,32,1,128,0,0,255
-r.. 100%,{-2,h+16},1,4,0
-a[-2,-1] y
-frame 16,8,0,0,0,0
-rv -a x,0.5
-i[0] 100%,100%,1,3 -fc[0] $_back -blend alpha
Annular_Steiner_Chain_Round_Tile_en:
-Annular_Steiner_Chain_Round_Tile $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24
gimp_array_fade :
-if {$7&1} -mirror x -endif -if {$7>1} -mirror y -endif
-array_fade $1,$2,$5,$6,$8
-shift -$3%,-$4%,0,0,2
gimp_array_fade_preview :
-gimp_array_fade $1,$2,$3,$4,$5,$6,$7,0
gimp_array_mirror : -skip ${7=0}
-if {$5==1} -mirror x
-elif {$5==2} -mirror y
-elif {$5==3} -rotate 90
-elif {$5==4} -rotate 180
-elif {$5==5} -rotate 270
-endif
-if $7
-if {$4==0} -columns 0,{100-$7}%
-elif {$4==1} -rows 0,{100-$7}%
-elif {$4==2} -z 0,0,{100-$7}%,{100-$7}%
-elif {$4==3} -z {$7/2}%,{$7/2}%,{100-$7/2}%,{100-$7/2}%
-endif
-endif
-shift -$2%,-$3%,0,0,2
-array_mirror $1,$4,$6
gimp_array_mirror_preview :
-gimp_array_mirror $1,$2,$3,$4,$5,0,$7
gimp_array_color :
-repeat $! -l.
$1,$2,1,3 -rand. 0,255 -to_colormode. {-2,s} -r. [-2] -*. $3 -*.. {1-$3} -+[-2,-1]
-endl -mv. 0 -done
gimp_array :
-shift -$3%,-$4%,0,0,2
-if {$5&1} -mirror x -endif -if {$5>1} -mirror y -endif
-array $1,$2,$6
gimp_array_preview :
-gimp_array $1,$2,$3,$4,$5,0
gimp_asciiart : -skip ${10=},${11=},${12=}
-repeat $! -l[$>] -to_rgb
-apply_gamma {10^$7} -b $8% -n 0,255
-if {$1==0} dict="$2"
-elif {$1==1} dict=" 01"
-elif {$1==2} dict=" 0123456789"
-elif {$1==3} dict=" abcdefghijklmnopqrstuvwxyz"
-elif {$1==4} dict=" ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-elif {$1==5} dict=" !\042#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\133\\\135^_\140abcdefghijklmnopqrstuvwxyz\173|\174~"
-elif {$1==6} dict=" \16\17\20\21"
-elif {$1==7} dict=" \200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231"
-endif
-if {$6==1} -negative -endif
-if $-3 --img2ascii $dict,$3,$4%,$5,"$-2"/"$-1"
-else --img2ascii $dict,$3,$4%,$5
-endif
wh=${}
-if {$6==0} -k. -n 0,255
-elif {$6==1} -k. -negative -n 0,255
-elif {$6==2||$6==3}
-r[0] $wh,1,100%,1
-if {$9>=7} -luminance[0] -endif
-if {$9%7} -quantize[0] {arg($9%7,2,3,4,8,12,16)-1},1,0 -endif
-r[0] [1],[1],1,100% -*[0] [1]
-if {$6==2} -rm[1]
-else -*[1] 255 -a c
-endif
-endif
-endl -done
gimp_asciiart_preview :
-repeat $! -l[$>]
w={w} h={h}
-gimp_asciiart $1,"$2",${3-9},0,foo,foo
-r $w,$h,1,100%,0,0,0.5,0.5
-endl -done
gimp_chessboard :
-to_rgba -chessboard ${1-14}
gimp_chessboard_preview :
-gimp_split_preview "-gimp_chessboard $*",$-1
samj_Scintillements_Colores_en :
-samj_Scintillements_Colores $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
-if {$18>0} -deform[-1] $18 -endif
Cercles_Concentriques_A_en:
-Cercles_Concentriques_A $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47
gimp_dices :
-repeat 6 {2*$2},{2*$2} -_dice$> -done
-if {$3%2} -negative[-6--1] -endif
-frame_round[-6--1] 10,10,0,0,128,128,128,0
-r2dy[-6--1] $2 -a[-6--1] x
-repeat {$!-1} -l[$>,-1]
--luminance[0] -rv[1,2] -r[0,1] {100*$1/$2}%,{100*$1/$2}%,1,100%,2 -quantize[1] 6,0
-*.. $2 -channels.. 0,1 -r.. {$2*100}%,{$2*100}%
$2,$2,1,2,'if(c,y,x)' -r. [-3],[-3],1,2,0,2 -+[-3,-1] --warp. [-2],0,0 -rm...
-if {$3<2} -rm[0] -mv. 0
-else -r[0] [2],[2],1,100% -rv[0,-1] -blend[0,-1] multiply
-endif
-endl -done -rm.
_dice0 : -ellipse. 50%,50%,5.2%,5.2%,0,1,255
_dice1 : -ellipse. 25%,25%,5.2%,5.2%,0,1,255 -ellipse. 75%,75%,5.2%,5.2%,0,1,255
_dice2 : -_dice1 -_dice0
_dice3 : -_dice1 -ellipse. 25%,75%,5.2%,5.2%,0,1,255 -ellipse. 75%,25%,5.2%,5.2%,0,1,255
_dice4 : -_dice3 -_dice0
_dice5 : -_dice3 -ellipse. 25%,50%,5.2%,5.2%,0,1,255 -ellipse. 75%,50%,5.2%,5.2%,0,1,255
gimp_extract_objects :
-if $6 min_area=$6% -else min_area=6 -endif
-repeat $! -l[$<] -to_rgba
nm=${-gimp_layer_name}
w={w} h={h}
x={$1%*(w-1)}
y={$2%*(h-1)}
color={I($x,$y)}
-if {$8==0}
--replace_color $4,0,$color,0,0,0,0 -autocrop_components. $5%,$min_area,$7,2
-repeat {w}
--z[0] {1,i($>,0)},{1,i($>,1)},{1,i($>,3)},{1,i($>,4)}
-nm. pos({1,i($>,0)},{1,i($>,1)}),name($nm" "[$>])
-done -rm[0,1]
-elif {$8==1}
-replace_color $4,0,$color,0,0,0,0
--autocrop_components[0] $5%,$min_area,$7,2
-autocrop_components[0] $5%,$min_area,$7,1
-repeat {w} -nm[$>] pos({i($>,0)},{i($>,1)}),name($nm" "[$>]) -done -rm.
-endif
$w,$h,1,4 -fc. $color -nm. name($nm" [background]")
-endl -done
gimp_extract_objects_preview :
-if {$3" && "$!}
nm={0,n} -nm[0] "[G'MIC] Select background point" --select[0] 0
x0={i[0]*100/{-2,w}} y0={i[1]*100/{-2,h}} -rm.
-nm[0] $nm
-else
x0=$1 y0=$2
-endif
-if $6 min_area=$6% -else min_area=5 -endif
-repeat $! -l[$>] -to_rgba
x={$x0%*(w-1)}
y={$y0%*(h-1)}
color={I($x,$y)}
--replace_color $4,0,$color,0,0,0,0
-autocrop_components. $5%,$min_area,$7,2
-repeat {w}
xycoords={1,i($>,0)},{1,i($>,1)},{1,i($>,3)},{1,i($>,4)}
-rectangle[0] $xycoords,0.3,0,0,255,255
-rectangle[0] $xycoords,1,0xFFFFFFFF,0,0,0,255
-done
-drgba[0]
-text_outline[0] {w}" objects",2,2,13,2,0.3,255,255,255,255
-k[0]
-if $9
-line 0,$y0%,100%,$y0%,0.5,0xF0F0F0F0,255 -line 0,$y0%,100%,$y0%,0.5,0x0F0F0F0F,0
-line $x0%,0,$x0%,100%,0.5,0xF0F0F0F0,255 -line $x0%,0,$x0%,100%,0.5,0x0F0F0F0F,0
-endif
-circle $x,$y,3,1,0,255,0 -circle $x,$y,3,1,0xFFFFFFFF,0
-endl -done
-u "{"$x0"}{"$y0"}{0}{$4}{$5}{$6}{$7}{$8}{$9}"
gimp_imagegrid :
-imagegrid $1,$2
gimp_imagegrid_hexagonal :
-repeat $! -l[$>]
-if $3 -r 200%,200%,1,100% -endif
-imagegrid_hexagonal $1,$2
-if $3 -r 50%,50%,1,100%,2 -endif
-endl -done
gimp_imagegrid_triangular :
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-imagegrid_triangular ${1-3},{$7/255},${4-6}
-endl -a c -endl -done
gimp_make_seamless :
-repeat $! -l[$>]
-if $1 --b {20.5-$1/50}% --[0] [1] -fc. ${-average_color.} -+ -endif
-endl -done
-periodize_poisson -c 0,255
gimp_make_seamless_preview :
u={arg($3,2,1,2,3,4)} v={arg($3,1,2,2,3,4)}
-gimp_split_preview "-if {!$2} -gimp_make_seamless $* -endif -if $3 -array "$u","$v" -endif",$-1
gimp_frame_seamless :
-repeat $! -l[$>]
-if $5 --b {20.5-$1/50}% --[0] [1] -fc. ${-average_color.} -+ -endif
-endl -done
-frame_seamless ${1-4} -c 0,255
gimp_frame_seamless_preview :
u={arg($7,2,1,2,3,4)} v={arg($7,1,2,2,3,4)}
-gimp_split_preview "-if {!$6} -gimp_frame_seamless $* -endif -if $7 -array "$u","$v" -endif",$-1
gimp_ministeck :
-repeat $! -l[$>]
-if {w>h} -r2dx {min($2,w)} -else -r2dy {min($2,h)} -endif
-split_opacity -l[0]
--colormap. $1 -index.. [-1]
[0],[0],1,1 -rand[2] 0,1 -dilate[2] $4 -+[0,2]
-r[0] $3""00%,$3""00%
--g[0] xy,1 -!=[-2,-1] 0 --f[0] 'i(x+1,y+1)-i(x,y)' -!=[-3--1] 0 -|[-3--1]
-z[0,-1] 0,0,{w-2},{h-2}
-if $7 [-1] -endif
--shift. 1,1 -*.. -1 -+[-2,-1] -b. {$6*$3/5} -n. -$5,$5
-map[0] [1] -rm[1] -+[0,-1]
-if $7 -==[1] 0 -* -endif
-endl -r. [0],[0],1,100% -a c
-endl -done
-c 0,255
gimp_ministeck_preview :
-repeat $! -l[$>]
w={w} h={h}
-gimp_ministeck $*
-r $w,$h,1,100%,0,0,0.5,0.5
-endl -done
gimp_montage : -skip "${2=A}"
-if {!$!} -return -endif
code0=X code1="$2" code2=H code3=V code4=A code5=B
-if {$3==1&&$4<0.5} -r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 -endif
-to_rgba -if $14 -rv -endif -if {$13%$!} -mv[{$13%$!}--1] 0 -endif
-if {$11||$12} -repeat $! -rotate[$>] {$11+u(-$12,$12)},1,0 -done -endif
-montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},$15,\
"-if {$""7%2} -mirror x -endif -if {$""8%2} -mirror y -endif "\
"-rotate {90*$""6} "\
"-if {$5||$6} "\
"-r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 "\
"-frame $6,$6,${7-10} "\
"-r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
"-else -r $""4,$""5,1,100%,2 -endif "
-if $15 -gimp_autocrop_layers -endif
-nm pos(0,0),name(Montage)
gimp_montage_preview : -skip "${2=A}"
-if {!$!} -return -endif
w={w} h={h}
-if {$3==1&&$4<0.5} -r {max(10,$4*200)}%,{max(10,$4*200)}%,1,100%,2 -endif
-drgba
code0=X code1="$2" code2=H code3=V code4=A code5=B
-to_rgba -if $14 -rv -endif -if {$13%$!} -mv[{$13%$!}--1] 0 -endif
-if {$11||$12} -repeat $! -rotate[$>] {$11+u(-$12,$12)},1,0 -done -endif
-montage ${code$1},{if($3==0,$4,2+max(0,$4-0.5))},0,\
"-if {$""7%2} -mirror x -endif -if {$""8%2} -mirror y -endif "\
"-rotate {90*$""6} "\
"-if {$5||$6} "\
"  -r {max(1,$""4-2*($5+$6))},{max(1,$""5-2*($5+$6))},1,100%,2 fs={min(53,max(w,h)/3)} "\
"  -frame $6,$6,${7-10} "\
"  -r {w+2*$5},{h+2*$5},1,100%,0,0,0.5,0.5 "\
"  0 -t. \#$""1,0,0,$fs,1,255 -expand_xy. 3,0 [-1]x3 -a[-4--2] c -dilate. {3+2*$fs/20} -a.. [-1],c -j[0] [1],{5+$5+$6},{$5+$6},0,0,1,[2],255 -k[0] "\
"-else "\
"  -r $""4,$""5,1,100%,2 fs={min(53,max(w,h)/3)} "\
"  0 -t. \#$""1,0,0,$fs,1,255 -expand_xy. 3,0 [-1]x3 -a[-4--2] c -dilate. {3+2*$fs/20} -a.. [-1],c -j[0] [1],5,0,0,0,1,[2],255 -k[0] "\
"-endif "
nw={w} nh={h}
-resize_ratio2d $w,{$h-16},2,2
-drgba
-i[0] 100%,15,1,3,240 -t[0] "Estimated size : "{round(100*$nw/$w)}%" x "{round(100*$nh/$h)}%,2,0,16 -r[0] 100%,16,1,3,0
-a y
gimp_puzzle :
-repeat $! -l[$<]
w={w} h={h} -to_rgb
-puzzle $w,$h,$1,$2,$3,$4,$5
--b. $6%,0 -g. xy -+[-2,-1] -n. -$7,$7 -+[0,-1]
--b. $8%,0 -n. 0,1 -*. -1 -+. 1 -n. {(255-$9)/255},1 -*[0,-1] -c 0,255
-if {$10!=100||$11||$12||$13||$14||$15||$16}
---. 1 -label_fg. 0
--area_fg. 0,0 -<. 50% -|... [-1] -==. 0 -*[-2,-1]
-distance.. 0 -*.. -1 -watershed. [-2] -rm.. -label. 0,0
-repeat {iM+1}
--==[1] $>
coords=${-autocrop_coords.\ 0}
--z[0] $coords -z.. $coords -rv[-2,-1] -*.. [-1] -*. 255 -a[-2,-1] c
x$>={arg(1,$coords)+round(w/2)} y$>={arg(2,$coords)+round(h/2)}
-done
-rm[0,1]
-if $14 -sort_list +,u -endif
-if $16
-repeat $! -l[$<]
-r2dy {max(0.1,$10+$11*u(-1,1))}% -rotate {$12+$13*u(-1,1)}
-if $15 -expand_xy 1,0 -endif
cx={round(w/2)} cy={round(h/2)}
-sh 100% -if $15 -dilate. 3 -endif
-i[0] $w,$h,1,4
-j[0] [-2],{${x$<}-$cx},{${y$<}-$cy},0,0,1,[-1],255 -rm[-2,-1]
-endl -done
-else
-i[0] $w,$h,1,{s}
-repeat {$!-1}
-r2dy. {max(0.1,$10+$11*u(-1,1))}% -rotate. {$12+$13*u(-1,1)}
-if $15 -expand_xy. 1,0 -endif
cx={round(w/2)} cy={round(h/2)}
-sh. 100% -if $15 -dilate. 3 -endif
-j[0] [-2],{${x$<}-$cx},{${y$<}-$cy},0,0,1,[-1],255 -rm[-2,-1]
-done
-endif
-else -rm.
-endif
-endl -done
gimp_puzzle_preview :
-gimp_puzzle ${1-15},0
gimp_taquin :
-to_a -repeat $! -l[$>] -srand $11 -taquin $1,$2,$3,$4,$5%,$6,${7-10} -endl -done
gimp_rotate_tileable :
-if $3 -array_mirror 1,{$3-1},1 -endif
-rotate_tileable $1,{if($3==0,$2,$2/2)}
gimp_rotate_tileable_preview :
-l -gimp_rotate_tileable $*
-onfail -gimp_warning_preview "Invalid image size" -endl
gimp_isolate_tiles :
-repeat $! -l[$>] -to_rgba
-if $5 sx={round(min(w,h)*max($1,$2)/100)} sy=$sx -else sx={round(w*$1/100)} sy={round(h*$2/100)} -endif
-if $6 bx={max($3,$4)} by=$bx -else bx=$3 by=$4 -endif
-s x,-$sx
-repeat $! -l[$>] -s y,-$sy -r 100%,{100+$by}%,1,100%,0,0,0.5,0.5 -a y -endl -done
-r {100+$bx}%,100%,1,100%,0,0,0.5,0.5 -a x
-endl -done
_gimp_normalize_tiles :
-repeat $! -l. -split_tiles $1,$2 -n $3,$4 -append_tiles $1,$2 -endl -mv. 0 -done
gimp_normalize_tiles :
-ac "-_gimp_normalize_tiles ${1-4}",$-1
gimp_parameterize_tiles :
-if $3
-quadratize_tiles $1,$2
-else
-linearize_tiles $1,$2
-endif
-c 0,255
gimp_shift_tiles :
-to_rgba -shift_tiles $1,$2,$3
-if {$4<1} -repeat $! -s. c -*. $4 -a[-4--1] c -mv. 0 -done -endif
gimp_rotate_tiles :
-to_rgba -rotate_tiles $3,$1,$2 -drop_shadow $4%,$5%,$6%
samj_Angoisse_en :
-samj_Angoisse $1,$2,$3,$4,$5,$6,$7,$8,$9
gcd_aurora : -skip ${1=6},${2=1},${3=0}
-repeat $! -l[$>]
-to_rgb --deriche $1%,2,y -deriche[-1] $2%,0,x
-c[-1] 0,255 -n[-1] 0,255
-if $3 -blend average -else -k[-1] -endif
-endl -done
gimp_crayongraffiti2 :
-repeat $! -l[$>] -split_opacity -l[0]
--blur $3 -hardsketchbw[-1] $1,$2,$4,$5,$6 -to_rgb
-negative[-1] -blur_xy[-2] $7,$7 -reverse
-if {$8==0} -compose_lightness
-elif {$8==1} -compose_value
-elif {$8==2} -gimp_compose_colordoping 1,1 -endif
-endl -a c -endl -done
gimp_crayongraffiti2_preview :
-gimp_split_preview "-gimp_crayongraffiti2 ${1--2}",$-1
gimp_blockism:
XSize={int($1/100*w)}
-if {$XSize==0} XSize=1 -endif
Ratio=$2
Variance={int($3*$XSize)}
Randomness=-1,1
Repeats={int($4/100*max(w,h))}
Opacity=$5
FlipTol=$6
ReverseFlip=$7
LAB=1-$8
YSize={int($Ratio*$XSize)}
MaxXSize={int($XSize+$Variance)}
MaxYSize={int($MaxXSize*$Ratio)}
-to_rgb[0]
-if {$LAB}
-rgb2lab[0]
-split[0] c
-endif
-repeat $!
#Take copy of the last image in the stack for grey value checking
[-1]
-repeat $Repeats
X={int(u(-1,w))}
Y={int(u(-1,h))}
-if {$ReverseFlip==0}
-if {i($X,$Y,0,0)>$FlipTol}
BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-if {i($X,$Y,0,0)<=$FlipTol}
BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-endif
-if {$ReverseFlip==1}
-if {i($X,$Y,0,0)<$FlipTol}
BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-if {i($X,$Y,0,0)>=$FlipTol}
BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
-endif
-endif
x0={int($X-$BW/2)}
y0={int($Y-$BH/2)}
x1={int($x0+$BW)}
y1={int($y0+$BH)}
-rectangle[-2] $x0,$y0,$x1,$y1,$Opacity,{i($X,$Y,0,0)},{i($X,$Y,0,1)},{i($X,$Y,0,2)},{i($X,$Y,0,3)}
-done
-remove[-1]
-mv[-1] 0
-done
-if {$LAB}
-append[-3,-2,-1] c
-lab2rgb[-1]
-endif
gimp_blockism_preview :
-gimp_split_preview "-gimp_blockism $1,$2,$3,{$4*10},$5,$6,$7,$8",$-1
gimp_bokeh :
_shape=$2
-srand $3
-repeat $! -l[$<] nm=${-gimp_layer_name} pos=${-gimp_layer_pos}
100%,100%,1,3
(${4-13};${14-23}) -if {$1>2} -r. 100%,$1,1,1,3 -endif
-repeat $1
--rows. $> -_gimp_bokeh... {^} -rm.
-done
-rm. -nm. name($nm),opacity(100),mode(screen),pos($pos)
-rv
-if {0$_output_mode==0} -gimp_merge_layers
-elif {0$_output_mode<2} -rm.
-endif
-endl -done
_gimp_bokeh0 : -shape_star $1,3
_gimp_bokeh1 : $1,$1,1,1,1
_gimp_bokeh2 : -shape_diamond $1
_gimp_bokeh3 : -shape_polygon $1,5,45
_gimp_bokeh4 : -shape_polygon $1,6,45
_gimp_bokeh5 : -shape_polygon $1,8,45
_gimp_bokeh6 : -shape_polygon $1,10,45
_gimp_bokeh7 : -shape_star $1,5
_gimp_bokeh8 : -shape_circle $1
gimp_bokeh_preview :
-gimp_split_preview "_output_mode=0 -gimp_bokeh $*",$-1,0,1
_gimp_bokeh :
radius1={r=max(w,h)*$2%;r+1-(r%2)}
radius2={r=$radius1-($radius1*$3%);r+1-(r%2)}
-random3d $1 -*3d. {-2,w},{-2,h},0
-_gimp_bokeh$_shape $radius1
-if {$radius2>=1} -_gimp_bokeh$_shape $radius2 -r. [-2],0,0,0.5,0.5 -*. {max(0,min(1,1-$4))} --[-2,-1] -endif
sigma={-3,$5%*w}
-r. {w+5*$sigma},{h+5*$sigma},1,1,0,0,0.5,0.5
-b. $sigma,0 -n. 0,255
-sprites3d[1] [2],1 -rm[2]
-l.
-s3d -r.. 3,{-2,h/3},1,1,-1 -s.. x
d={$10*255}
-rand[-4] {$6-$d},{$6+$d}
-rand... {$7-$d},{$7+$d}
-rand.. {$8-$d},{$8+$d}
-a[-4--2] x -c.. 0,255 -y -a y
-endl
-j3d[0] [1],0,0,0,{$9/255},1,0,0 -rm[1]
gimp_brushify :
-_gimp_brushify $*
s0=0--3 s1=1--2 s2=0--2
-l[${s{$1==0?0:$1==1?1:2}},-1] -brushify[^-1] [-1],$3,{$5%},$6,$9,$10,$11,$12%,$13,$14,$15,$16,$17,$18 -rm. -endl
_gimp_brushify :
N={0.9*$4}
-if {$1==0} --autocrop. -i.. 100%,100%,1,3,1 -blend[-2,-1] alpha -rr2d. $N,$N,0,3
-elif {$1==1} --autocrop[0] -i.. 100%,100%,1,3,1 -blend[-2,-1] alpha -rr2d. $N,$N,0,3
-elif {$1==2} $4,$4 -rectangle. 10%,10%,90%,90%,1,1
-elif {$1==3} -shape_diamond. $N
-elif {$1==4} -shape_polygon $N,5
-elif {$1==5} -shape_polygon $N,6
-elif {$1==6} -shape_polygon $N,8
-elif {$1==7} -shape_circle. $N
-elif {$1==8} $4,$4 -gaussian. 30%,30%,0
-elif {$1==9} -shape_star $N
-elif {$1==10} -shape_heart $N
-endif
-norm. -r. 100%,{max(0.01,100*$2)}%,1,1,2 -r. $4,$4,1,1,0,0,0.5,0.5
-spread. $7 -b. $8% -n. 0,1
gimp_brushify_preview :
-if {$1<2" && "$!<2}
-gimp_error_preview "When a custom brush (bottom or top layer) is specified, at least two layers are required for this filter to work.In this case, don't forget to set the 'Input layers' option!"
-return
-endif
-gimp_brushify $*
-if $19
-_gimp_brushify $*
-if {$1==0} -rm.. -elif {$1==1} -rm[0] -endif
-rr2d. {0,w/5},{0,h/5},0,2 -n. 0,255
-frame. 3,3,0 -frame. 1,1,255 -frame. 1,1,0
-to_rgb. -text_outline. "Brush",4,2,13,2,1,255,255,0 -to_a.
-j[^-1] [-1],2,2 -rm.
-else
-if {$1==0} -rm. -elif {$1==1} -rm[0] -endif
-endif
gimp_cartoon_preview :
-gimp_split_preview "-cartoon $*",$-1
samj_en_chalkitup :
-samj_chalkitup $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13
samj_en_chalkitup_preview :
-gimp_split_preview "-samj_en_chalkitup ${1--2}",$-1
gimp_circle_abstraction :
-repeat $! -l[$>]
-b $4%
--colormap $1 -index[0] [1],0,0
[0],[0],1,4,0
-repeat $1
-rprogress {$>*100/$1}
--==[0] $>
-skeleton3d. 2,2,0,1,0
-if {@7}
-s3d. -l[-6--1]
-r[2] 3,{2,h/3},1,1,-1
1,{2,h/2*$2%},1,1,1 -r. 1,{2,h/2},1,1,4 -r. 3,200% -*[2,-1] -y
-endl
-a[-6--1] y -col3d. {1,I($>)}
[0],[0],1,4,0
-j3d. [-2],0,0,0,1,{1+$5},0,0
-sh. 3 -col3d... 255 -j3d. [-3],0,0,0,$3,{1+$5},0,0 -rm.
-rm..
-blend[2,-1] alpha
-endif
-done
-k[2]
-if $6 --channels 3 -<. 1 -inpaint[0] [1],0,1 -rm. -channels. 0,2 -endif
-if $7 -n 0,255 -endif
-rprogress 100
-endl -done
gimp_circle_abstraction_preview :
-gimp_split_preview "-gimp_circle_abstraction $*",$-1
gimp_cpencil :
-repeat $! -l[$>] -split_opacity -l[0]
--pencilbw $1,$2 -blur_xy[-1] 0.4,0.4
-quantize[-2] $3 -normalize 0,255 -to_rgb
-blur_xy[-2] $4,$4
-if {$5==0} -gimp_compose_colordoping $6,0
-elif {$5==1} -gimp_compose_darken $6,1
-elif {$5==2} -gimp_compose_hardlight $6,0
-elif {$5==3} -gimp_compose_grainmerge $6,0
-elif {$5==4} -gimp_compose_lightness $6,1
-elif {$5==5} -gimp_compose_multiply $6,0
-elif {$5==6} -gimp_compose_softlight $6,0
-elif {$5==7} -gimp_compose_value $6,1 -endif
-endl -a c -endl -done
gimp_cpencil_preview :
-gimp_split_preview "-gimp_cpencil ${1--2}",$-1
gimp_ColorAbstractionPaint :
-to_rgb
pAbstraction=$1
EllipseRatio=$2
ValueOpacity=$3
UseHue=$4
MultiplyOpacity=$5
UseSaturation=$6
GrainMergeOpacity=$7
NCA=$8
CubeIt=$9
KuwaIt=$10
Soften=$11
SoftenAll=$12
DoNotCompose=$13
ReverseOrder0=1
ReverseOrder1=1
ReverseOrder2=1
eSmoothness=1
eOpacity=0.8
eOutline=1
eDensity={1.5*$eSmoothness/10}
pDetailsScale={$pAbstraction/2}
pColor=1.5
pSmoothness={10*$pAbstraction}
eSmoothness={10+($pAbstraction-1)*(1-10)/(10-1)}
ePrimaryRadius={0,($pAbstraction/5)*($pAbstraction/5)*sqrt(h)}
eSecondaryRadius={$EllipseRatio/100*$ePrimaryRadius}
cAbstraction={2+($pAbstraction-1)*(10-2)/(10-1)}
CubeSize={4+($pAbstraction-1)*(10-4)/(10-1)}
--gimp_ellipsionism[0] $ePrimaryRadius,$eSecondaryRadius,$eSmoothness,$eOpacity,1,$eDensity,0
-if {$SoftenAll==1" && "$Soften>0} -blur[-1] $Soften,0 -endif
--gimp_painting[0] $pAbstraction,$pDetailsScale,$pColor,$pSmoothness,1,0
-if {$KuwaIt==1} -gimp_kuwahara[-1] 2,$pAbstraction,0,0 -endif
-if {$Soften>0} -blur[-1] $Soften,0 -endif
--gimp_color_abstraction[0] $cAbstraction,45,0.35,0
-if {$NCA==1} -negative[-1] -endif
-if {$CubeIt==1} -cubism[-1] 600,$CubeSize,40,0.7,0 -endif
-if {$Soften>0} -blur[-1] $Soften,0 -endif
-if {$DoNotCompose==0}
#Compose Original and Ellipsionism with value
-blend[0,1] value,$ValueOpacity,$ReverseOrder0
#Compose Original+Ellipsionism with painting
-if {$MultiplyOpacity<0}
ReverseOrder1=0
MultiplyOpacity={-1*$MultiplyOpacity}
-endif
-if {$UseHue==0}
-blend[0,1] multiply,$MultiplyOpacity,$ReverseOrder1
-elif {$UseHue==1}
-blend[0,1] hue,$MultiplyOpacity,$ReverseOrder1
-endif
#Compose Original+Ellipsionism+Painting with Color abstraction
-if {$GrainMergeOpacity<0}
ReverseOrder2=0
GrainMergeOpacity={-1*$GrainMergeOpacity}
-endif
-if {$UseSaturation==0}
-blend[0,1] grainmerge,$GrainMergeOpacity,$ReverseOrder2
-elif {$UseSaturation==1}
-blend[0,1] saturation,$GrainMergeOpacity,$ReverseOrder2
-endif
-keep[0]
-endif
-if {$DoNotCompose==1} -remove[0] -endif
gimp_ColorAbstractionPaint_Preview :
-gimp_split_preview "-gimp_ColorAbstractionPaint ${1--2}",$-1
gimp_cubism :
-repeat $1 -cubism ${2--1} -done
gimp_cubism_preview :
-gimp_split_preview "-gimp_cubism $*",$-1
gimp_cutout :
-repeat $! -l[$>] -split_opacity -l[0]
-median {10-$3}
-quantize $1
--area. 0,1 med=${-med} -rm.
-inpaint_holes {$med*$2%},0,1
-if $4 -n 0,255 -endif
-endl -a c -endl -done
gimp_cutout_preview :
-gimp_split_preview "-gimp_cutout $*",$-1
gimp_dreamsmooth :
-m "MergeChoise : $""=_mode" -MergeChoise "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
-to_rgb
Iterations=$1
Eqa=$2
MergingOption=$3
Opacity=$4
ReverseOrder=$5
Smoothness=$6
Threads=$7
Overlap=$8
-repeat $! -l[$>]
-repeat $Iterations
#Calculate width and height
IWidth={0,round(w/($<+1))}
IHeight={0,round(h/($<+1))}
#Resize previously processed image. Not done on first repeat loop since there is no such image yet.
-if {$>!=0}
-r[-1] $IWidth,$IHeight,1,3,5,1
-endif
#Resize and make a copy
--r[0] $IWidth,$IHeight,1,3,5,1
#Smoothing
-gimp_anisotropic_smoothing[-1] {430/$Iterations*($<+1)},0.4,0.5,0.6,2,0.8,30,2,0,0,1,0,$Threads,$Overlap,0
-gimp_anisotropic_smoothing[-1] {600/$Iterations*($<+1)},0.4,1,0.6,4,0.8,15,5,0,1,1,0,$Threads,$Overlap,0
#Combine images if not first round
-if {$>!=0}
-if {$3!=42}
-blend[-1,-2] ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
-endif
-if {$3==42}
-blend_edges[-1,-2] $Opacity,$Smoothness,$ReverseOrder
-endif
-if {$Eqa}
-equalize[-1] 256
-endif
-endif
-done
-keep[-1]
-endl -done
gimp_dreamsmooth_preview :
-gimp_split_preview "-gimp_dreamsmooth ${1--2}",$-1
gimp_ellipsionism :
-ellipsionism ${^0}
gimp_ellipsionism_preview :
-gimp_split_preview "-gimp_ellipsionism $*",$-1
gimp_feltpen :
-repeat $! -l[$>] --gimp_hardsketchbw ${1-5},0,0 -blend hardlight -erode_oct $6 -endl -done
gimp_feltpen_preview :
-gimp_split_preview "-gimp_feltpen $*",$-1
gtutor_fpaint :
-repeat $!
-local[$>]
hasalpha={s>3}
-if {$hasalpha}
-split_opacity[-1]
-reverse[-2,-1]
-endif
lh={h}
--blur[-1] {$1/1.25}%
-if $4
--luminance[-1]
-rgb2hsl[-2]
-split[-2] c
-rm[-4,-2]
-quantize[-2,-1] {round(5+15*(1-$1))},1,1
-gradient_norm[-2,-1]
-normalize[-2,-1] 0,255
-add[-2,-1]
-else
-quantize[-1] {round(5+15*(1-$1))},1,1
-gradient_norm[-1]
-normalize[-1] 0,255
-endif
-threshold[-1] {80-60*$2}%
-dilate_circ[-1] 8
-thinning[-1]
-dilate_circ[-1] 3
--diffusiontensors[-1] 0.1,0.85,0.3,{4+8*$1}
-if {$2<1}
[-1]
-resize2dy[-3,-1] {$lh*(0.25+0.75*$2)},5
-repeat 2
-smooth[-3] [-1],{400*(1-$2)}
-done
-rm[-1]
-resize[-2] [-3],[-3],[-2],[-2],5,0
-endif
-eigen[-1]
-split[-2] c
-fill_color[-3] {1-0.15*$3}
-fill_color[-2] {0.15*$3}
-append[-3,-2] c
-eigen2tensor[-2,-1]
98%,98%,1,1 -noise[-1] {20-10*$3},2
-resize[-1] [-2],[-2],[-1],[-1],0,0,0.5,0.5,0.5,0.5
-to_rgb[-1]
-mul[-1] [-4]
--ac[-4] "-mul 0.6","hsl_s"
-ac[-1]  "-mul 0.85","hsl_l"
-repeat 2
-smooth[-2,-1] [-3],{100*(6-5*$2)}
-done
--luminance[-2]
-normalize[-1] 0,0.7
--normalize[-5] 0,1
-add[-2,-1]
-normalize[-1] 0,1
-blend[-3,-2] add
-gradient[-1]
-append[-2,-1] c
100%,100%,1,2
-if $6
-fill_color[-1] {cos(2*((180+$5)%360)*pi/360)},{sin(2*((180+$5)%360)*pi/360)}
--mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-normalize[-1] 0,1
-to_rgb[-1]
-mul[-1] [-7]
-negative[-1]
-normalize[-1] 0,255
-blend[-4,-1] multiply,$6
-endif
-if $7
-fill_color[-1] {cos(2*$5*pi/360)},{sin(2*$5*pi/360)}
--mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-normalize[-1] 0,1
-to_rgb[-1]
-mul[-1] [-7]
-normalize[-1] 0,255
-blend[-4,-1] screen,$7
-endif
-if $8
-fill_color[-1] {cos(2*$5*pi/360)},{sin(2*$5*pi/360)}
--mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-to_rgb[-1]
-normalize[-1] 0,255
-blend[-4,-1] screen,$8
-endif
-rm[-1,-2,-4,-5,-6]
-ac[-1] "-apply_curve 1,0,32,127,180,255,255","hsl_s"
-apply_gamma[-1] 1.4
-if {$hasalpha}
-reverse[-2,-1]
-append[-2,-1] c
-endif
-endlocal
-done
gtutor_fpaint_preview :
-gimp_split_preview "-gtutor_fpaint ${^0}",$-1
gimp_graphic_boost4 :
-repeat $! -l[$>] -split_opacity -l[0]
-gimp_unsharp 1,$1,30,3,0,$2,0.40,1,0,0,0
-if {$3==1} -break -endif
--gimp_pencilbw $4,$5,0,0,0
-if {$6==1} -keep[-1] -break -endif
-if {$7==1} -gimp_anisotropic_smoothing[1] 60,$8,$9,$10,1.1,0.8,30,2,0,1,1,0 -endif
-if {$11==1} -keep[-1] -break -endif
-if {$12==1}  -reverse -endif
-if {$13==0} -gimp_compose_hardlight $14,0
-elif {$13==1} -gimp_compose_grainmerge $14,0
-elif {$13==2} -gimp_compose_multiply $14,0
-elif {$13==3} -gimp_compose_colorburn $14,0
-elif {$13==4} -gimp_compose_overlay $14,0
-elif {$13==5} -gimp_compose_value $14,1
-elif {$13==6} -gimp_compose_darken $14,0
-elif {$13==7} -gimp_compose_lightness $14,1
-elif {$13==8} -gimp_compose_luminance $14,1
-elif {$13==9} -gimp_compose_colordoping $14,0
-elif {$13==10} -gimp_compose_comix_color $14,0,$15
-elif {$13==11} -gimp_compose_graphicolor $14,0,$15
-elif {$13==12} -gimp_compose_graphixcolor $14,0
-elif {$13==13} -gimp_compose_vividedges $14,0.50,0,$15
-elif {$13==14} -gimp_compose_darkedges $14,0.50,0,$15
-elif {$13==15} -gimp_compose_vividscreen $14,0,$15
-elif {$13==16} -gimp_compose_darkscreen $14,0,$15
-elif {$13==17} -gimp_compose_interpolation $14,0 -endif
-if {$16==1} -gimp_anisotropic_smoothing 60,$17,$18,$19,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
gimp_graphic_novelfxl :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0} -gimp_normalize_local $2,$3,$4,$5,1,3,0 -endif
-if {$6==0} --gimp_pencilbw $7,$8,0,0,0 -endif
-if {$9==1} -keep[-1] -break -endif
-if {$10==1} -gimp_anisotropic_smoothing[-1] 60,$11,$12,$13,1.1,0.8,30,2,0,1,1,0 -endif
-if {$14==1} -keep[-1] -break -endif
-if {$15==1} -reverse -endif
-if {$16==0} -gimp_compose_overlay $17,0
-elif {$16==1} -gimp_compose_multiply $17,0
-elif {$16==2} -gimp_compose_softlight $17,0
-elif {$16==3} -gimp_compose_colorburn $17,0
-elif {$16==4} -gimp_compose_darken $17,0
-elif {$16==5} -gimp_compose_stamp $17,0
-elif {$16==6} -gimp_compose_hardlight $17,0
-elif {$16==7} -gimp_compose_value $17,1
-elif {$16==8} -gimp_compose_grainmerge $17,0
-elif {$16==9} -gimp_compose_freeze $17,0
-elif {$16==10} -gimp_compose_lightness $17,1
-elif {$16==11} -gimp_compose_luminance $17,1
-elif {$16==12} -gimp_compose_colordoping $17,0
-elif {$16==13} -gimp_compose_comix_color $17,0,$18
-elif {$16==14} -gimp_compose_graphicolor $17,0,$18
-elif {$16==15} -gimp_compose_graphixcolor $17,0
-elif {$16==16} -gimp_compose_vividedges $17,0.50,0,$18
-elif {$16==17} -gimp_compose_darkedges $17,0.50,0,$18
-elif {$16==18} -gimp_compose_vividscreen $17,0,$18
-elif {$16==19} -gimp_compose_darkscreen $17,0,$18
-elif {$16==20} -gimp_compose_interpolation $17,0 -endif
-if {$19==1} -gimp_anisotropic_smoothing 60,$20,$21,$22,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
gimp_poster_hope :
-repeat $! -l[$>] -split_opacity -l[0]
-apply_gamma {10^$1} -poster_hope $2
-endl -a c -endl -done
gimp_poster_hope_preview :
-gimp_split_preview "-gimp_poster_hope $*",$-1
gimp_kuwahara :
-ac "-repeat $1 -kuwahara $2 -done",$3,$4
gimp_kuwahara_preview :
-gimp_split_preview "-gimp_kuwahara $*",$-1
gimp_lylejk_painting :
-repeat $! -l[$>]
nm={0,n}
--l -repeat $1 -b 0.75 -unsharp 0.75,10.49 -c 0,255 -mv. 0 -done -endl
-smooth. 300,0.26,1,0,7
[-1] -rv[-3--1]
-blend[-2,-1] lighten,0.5
-blend[-2,-1] grainmerge,1
-gimp_kuwahara. $2,$3,0,0
-texturize_canvas. $4,4
-nm $nm
-endl -done
gimp_lylejk_painting_preview :
-gimp_split_preview "-gimp_lylejk_painting $*",$-1
gimp_Squiggly :
SpreadNoiseAmount=$1
SEgThrshld=$2
SegSmooth=$3
GNSmooth=$4
GNLin=$5
InvertLuminance=$6
EnhanceColors=$7
ToggleOrg=$8
Chroma=$9
ToneTr=$10
ToneGm=$11
OrgMergeCh=$12
OrgOpacity=$13
OrgReverseorder=$14
-if {$ToggleOrg==1}
OrgMergeCh=30
OrgReverseorder=1
-endif
-to_rgb
--gimp_spread[0] $SpreadNoiseAmount,$SpreadNoiseAmount,0,0
-gimp_segment_watershed[1] $SEgThrshld,$SegSmooth,0,0
--gimp_gradient_norm[1] $GNSmooth,$GNLin,0,100,0,0
--blend[2,1] multiply
-if {$InvertLuminance==1}
#Convert to LAB
-rgb2lab[-1]
#Split channels
-split[-1] c
-negative[-3]
-append[-3--1] c
-lab2rgb[-1]
-endif
-if {$EnhanceColors==1}
#Increase chroma
-gimp_mix_ycbcr[3] 1,0,0,$Chroma,0,0,$Chroma,0,0,0,2,0
#Tonemap original
-gimp_map_tones[0] $ToneTr,$ToneGm,0.1,30,0,0
#-gimp_apply_curve[0] 0,30,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
#Compose Squigglies to original
-gimp_blend[0,3] $OrgMergeCh,0,$OrgOpacity,$OrgReverseorder
-keep[0]
-endif
-keep[-1]
gimp_Squiggly_Preview :
-gimp_split_preview "-gimp_Squiggly ${1--2}",$-1
gimp_MorphoPaint :
-to_rgb[0]
--gimp_morpho[0] $1,$2,0,2,0,$3,0
--gimp_apply_curve[1] $4,50,$5,200,$6,-1,128,-1,128,-1,128,255,1,3,0,0,0
-gimp_spread[1] $7,$7,0,0
-gimp_gaussian_blur[2] $8,0,0,1,0,0,0
-gimp_segment_watershed[1] $9,$10,0,0
--gimp_painting[0] $11,$12,1.5,$13,1,0
-remove[0]
-reverse[0,2]
-reverse[1,2]
-if $14
-if {$19==0} MorphoStrength={0} -elif {$19==1} MorphoStrength={$20} -endif
-mul[2] {$MorphoStrength/3}
-if {$15==0} StrokeStrength={0} -elif {$15==1} StrokeStrength={$16} -endif
-mul[0] {$StrokeStrength/3}
-if {$17==0} SegmentStrength={0} -elif {$17==1} SegmentStrength={$18} -endif
-mul[1] {$SegmentStrength/3}
-add[1] [2]
-add[1] [0]
-if $21 -normalize[1] 0,255 -endif
-remove[0,2]
-endif
gimp_MorphoPaint_preview :
-gimp_split_preview "-gimp_MorphoPaint ${1--2}",$-1
gimp_painting : -skip ${4=0},${5=0}
-repeat $! -l[$>]
-to_colormode {max(3,s)} -split_opacity -rv
-repeat $1 -gimp_normalize_local. 10,6,5,20,1,11 -done
-gimp_anisotropic_smoothing. {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
-gimp_mix_lab. 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
-if $5 -gimp_segment_watershed. 10,1,0 -endif
-smooth. $4,0,1,1,1
-rv -a c
-endl -done
gimp_painting_preview :
-gimp_split_preview "-gimp_painting $*",$-1
samj_Barbouillage_Paint_Daub_en :
-samj_Barbouillage_Paint_Daub $1,$2,$3,$4,$5,$6,$7,$8,$9
gimp_pen_drawing :
-drawing $1
gimp_pen_drawing_preview :
-gimp_split_preview "-gimp_pen_drawing $*",$-1
gimp_tk_photoillustration :
-repeat $! -l[$>]
-if {$26==1} scdo=50 scup=200 -endif
-if {$26==2} scdo=25 scup=400 -endif
-if {$26!=0} -r $scdo%,$scdo% -else -endif
-if {$21==0} [^] --negative[1]  [0] --negative[0]
-gimp_gaussian_blur[2] {{{100-$18}/5}+0.5},0,0,1,0,0,0  -gimp_compose_dodge[1,2] 1
-if {$23==1} -gimp_gaussian_blur[1] {{{100-$18}/10}+0.5},0,0,1,0,0,0 -endif
-gimp_gaussian_blur[3] {{{{{100-$18}/5}+1}*10}+10},0,0,1,0,0,0
-gimp_compose_dodge[2,3] 1
-if {$23==1} -gimp_gaussian_blur[2] {{{{100-$18}/10}+0.5}*3},0,0,1,0,0,0 -endif
-reverse[1,2] -gimp_compose_multiply[1,2] {1-{$19/10}}
-tk_gimp_channel_processing[1] {{1-$20}+0.1},1,0,0,0,0,100,256,0,0,0,2,7,0
-elif {$21==1} --gimp_laplacian $19,{99.99-$18},$18,1,1,0
-elif {$21==2} --gimp_gradient_norm $19,0.5,{99.99-$18},$18,1,0
-elif {$21==3} --gimp_highpass {-{$18-100.3}},{{10-$19}*0.7},0,1,0
-elif {$21==4} --gimp_pencilbw {100-$18},{$19*20},0,0,0
-elif {$21==5}
--gimp_hardsketchbw {300+{{$18-50}*15}},{$19*10},$19,1,{50-{$18/2}},0,0,0
-elif {$21==6} --gimp_thin_edges $19,{{$18/5}-10},0,0
-elif {$21==7} --gimp_edges {$19/3.5},{95-$18},0,0
--gimp_mix_hsv[0] 1,0,0,1,-1,0,1,0,0,0,2,0
-tk_gimp_channel_processing[2] 1,1,0,{$19/10},4,{{$18-50}*2},100,256,0,0,0,2,7,0
-reverse[1,2] -gimp_compose_multiply[1,2] {0.5+{$20/2}}
-elif {$21==8} --channels 2
-if {$19<=5}   -gimp_unsharp[1]  1,{2-{{$19*0.3}+0.5}},20,{5-$19},0.00,1.00,0.5,1,0,7,0
-else -gimp_gaussian_blur[1] {$19-5},0,0,1,0,0,0  -endif
-endif
-if {$1!=3}
-tk_gimp_channel_processing[0] 1,1,$12,0,0,0,100,256,0,0,1,{abs($12/10)},7,0
-tk_gimp_channel_processing[0] 1,1,$13,0,0,0,100,256,0,0,3,{abs($12/10)},7,0      -endif
-if {$24==0}
-if {$1==0} -gimp_map_tones[0] {$2/2.5},{1-{$2/2.5}},$2,{2+{$2*80}},3,0
-elif {$1==1} -gimp_map_tones[0] {$2/10},0.5,{10-{$2*2}},300,3,0
-elif {$1==2} -gimp_map_tones_fast[0] {$2*2},{$2/2.5},3,0
-elif {$1==3}
-gimp_normalize_local[0] {$2*2},{1+{$2*25.2}},{$2*16},{$2*16},0,3,0
-elif {$1==4} -gimp_unsharp[0] 0,{{w+h}/100},0,$2,0,1,1,1,0,7,0
-elif {$1==5} --negative[0]
-if {$21!=9} -reverse[1,2] -endif
-gimp_gaussian_blur[1] {{{w+h}/5}-{$2*{{w+h}/12.5}}},0,0,1,0,0,0
-to_gray[1] -reverse[0,1] -gimp_compose_softlight[0,1] {$2/2.5}
-elif {$1==6} -gimp_tk_dri[0] {$2/2.5},{$2/5},{$2/2.5},{$2*2},{$2/2.5},1,1,0
-endif
-else
--to_rgba[0] --channels[0] 0 -if {$21!=9} -move[1] 4 -endif
-negative[2]
-tk_gimp_channel_processing[2] 1,1,2,0,0,0,100,256,0,0,0,2,7,0
-gimp_gaussian_blur[2] {{w+h}/500},0,0,1,0,0,0
-to_gray[2]
-if {$1==0} -gimp_map_tones[1] {$2/2.5},{1-{$2/2.5}},$2,{2+{$2*80}},3,0
-elif {$1==1} -gimp_map_tones[1] {$2/10},0.5,{10-{$2*2}},300,3,0
-elif {$1==2} -gimp_map_tones_fast[1] {$2*2},{$2/2.5},3,0
-elif {$1==3}   -gimp_normalize_local[1]  {$2*2},{1+{$2*25.2}},{$2*16},{$2*16},0,3,0
-elif {$1==4} -gimp_unsharp[1] 0,100,0,$2,0,1,1,1,0,7,0
-elif {$1==5} -negative[1] -gimp_gaussian_blur[1]  {{{w+h}/5}-{$2*{{w+h}/12.5}}},0,0,1,0,0,0
-to_gray[1] -to_rgba[1]
-elif {$1==6} -gimp_tk_dri[1] {$2/2.5},{$2/5},{$2/2.5},{$2*2},{$2/2.5},1,1,0    -to_rgba[1]
-endif
-split[1] c
-if {$21!=9} -reverse[4,5] -compose_multiply[4,5] -append[-5,-4,-3,-2] c
-else -reverse[3,4] -compose_multiply[3,4] -append[-4,-3,-2,-1] c -endif
-if {$1!=3} -compose_rgba[0,1] -else -reverse[0,1]
-gimp_compose_softlight[0,1] {$2/2.5} -endif
-endif
-tk_gimp_channel_processing[0] 1,$11,$10,0,0,0,100,256,0,0,0,2,7,0
-tk_gimp_channel_processing[0] 1,$14,0,0,0,0,100,256,0,0,2,{abs($14*2.5)},7,0
-if {$1==3}
-tk_gimp_channel_processing[0] 1,1,$12,0,0,0,100,256,0,0,1,{abs($12/10)},7,0
-tk_gimp_channel_processing[0] 1,1,$13,0,0,0,100,256,0,0,3,{abs($12/10)},7,0
-endif
-if {$3==0} -gimp_anisotropic_smoothing[0]  {$5*100},{$4*2},$4,$5,$5,0.80,30.00,2.0,0,1,1,0,1,0
-elif {$3==1} -gimp_bilateral[0] {100-{$4*100}},{$5*25},1,0,0
-elif {$3==2} -gimp_gaussian_blur[0] {$5*10},0,0,1,8,0,0
-elif {$3==3} -gimp_segment_watershed[0] {$4*5},{$5/2},0,0
-elif {$3==4} -gimp_morpho[0] 3,{$5*2+2},0,2,0,1,0
-elif {$3==5} -gimp_selective_smoothing[0] {$5*4},{$4*2},10,10,0,1,0
-elif {$3==6} -gimp_haar_smoothing[0] {10-{$4*10}},{round($5*5,1)},0,0,1,0
-elif {$3==7} -to_rgb[0] -gimp_kuwahara[0] {6-{$4*5}},{1+{$5*2.9}},0,0
-endif
-gimp_mix_lab[0] 1,0,0,$17,$15,0,$17,$16,0,0,2,0
-if {$25==0}
-gimp_unsharp[0] 1,$6,20,$7,0.00,1.00,0.5,1,0,7,0
-else
--to_rgba[0] --gimp_edges[0] $6,{30-{$7*5}},1,0 -if {$21!=9} -move[1] 4 -endif
-gimp_unsharp[1] 1,$6,20,$7,0.00,1.00,0.5,1,0,7,0
-gimp_gaussian_blur[2] {{w+h}/500},0,0,1,0,0,0
-to_gray[2]
-split[1] c
-if {$21!=9} -reverse[4,5] -compose_multiply[4,5] -append[-5,-4,-3,-2] c
-else -reverse[3,4] -compose_multiply[3,4] -append[-4,-3,-2,-1] c -endif
-compose_rgba[0,1]
-endif
-if {$22==0}
-if {$21==3}  -reverse -gimp_compose_overlay $20
-elif {$21==8} -reverse -gimp_compose_hardlight $20
-elif {$21!=9} -reverse -gimp_compose_multiply $20
-endif -endif
-if {$8==1}
-gimp_glow[0] $9,0,0
-elif {$8==2} --gimp_highpass[0] {$9*3},2,1,0,0
-if {{$22==1}&&{$21!=9}} -reverse[1,2] -endif
-reverse[0,1] -gimp_compose_overlay[0,1] {$9/40}
-elif {$8==3} [0] [0]
-if {{$22==1}&&{$21!=9}} -reverse[1,3] -endif
-gimp_compose_screen[1,2] 1  -gimp_gaussian_blur[1] {$9*3},0,0,1,0,0,0
-reverse[0,1] -gimp_compose_softlight[0,1] {$9/20}
-elif {$8==4}
-gimp_anisotropic_smoothing[0] 0,1.5,0.3,{$9/4},1.10,0.80,30.00,2.0,0,1,1,0,1,0
-elif {$8==5}
--gimp_mix_hsv[0] 1,0,0,1,-1,0,1,0,0,0,2,0
-if {{$22==1}&&{$21!=9}} -reverse[1,2] -endif
-tk_gimp_channel_processing[1] 1,1,0,0,4,0,{100-{$9*2.5}},256,0,1,0,2,0,0
-gimp_gaussian_blur[1] $9,0,0,1,0,0,0
-tk_gimp_channel_processing[1] 1,1,0,0,4,0,{50-{$9*2}},256,0,1,0,2,0,0
-tk_gimp_replace_color[1] 1,0,0,0,0,255,0,0,0,0
-gimp_gaussian_blur[1] {$9*2},0,0,1,0,0,0
-reverse[0,1] -gimp_compose_softlight[0,1] {0.25+{$9/150}}
-elif {$8==6}
-gimp_anisotropic_smoothing[0]  60,0.16,{{$9/50}+0.6},{{$9/9}+0.6},2.35,0.8,30,2,0,1,1,0,1
-endif
-if {$26!=0} -r $scup%,$scup% -endif
-endl -done
gimp_tk_photoillustration_preview :
-gimp_split_preview "-gimp_tk_photoillustration ${1--2}",$-1
samj_Plasmic :
Flou=$1
Puissance=$2
Edge_threshold=$3
Couper_Cut=$4
Dilate_Contours=$5
Valeur_Plasma=$6
Deformation=$7
Degradation_Spread=$8
Largeur_Origine={w}
Hauteur_Origine={h}
-if {$Flou>0} -blur[-1] $Flou -endif
-if {$Valeur_Plasma>0}
$Largeur_Origine,$Hauteur_Origine,1,3
-plasma[-1] $Valeur_Plasma,$Valeur_Plasma
-n[-1] 0,255
-rv[-1,-2]
-else
--Je_passe_l_hiver_en_Floride[0]
-endif
-to_rgb[-1,-2]
-pow[-1] $Puissance
-c[-1] 0,255
-gimp_segment_watershed[-1] $2,1,0,2,0
-gimp_gradient_norm[-1] 0,0.5,0,100,0,0
-c[-1] $Couper_Cut,255
-n[-1] 0,255
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Dilate_Contours>1} -dilate_circ[-1,-2] $Dilate_Contours -endif
-if {$Degradation_Spread>1} -spread[-1,-2] $Degradation_Spread -endif
-blend[-2,-1] darken,1,0
gimp_delaunay :
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb
--b $3
-gradient_norm. ->=. {(100-$2)/5}
-if $9 -rectangle. 0,0,100%,100%,1,0xFFFFFFFF,1 -endif
-remove_pixels. {100-max(0.1,$1/4)}%
-delaunay3d.
-l. -s3d -rm[4] -i[4] 1,100%,1,1,y -r[4] 3,100% -y -a y -endl
-if $10 -r[0] 200%,200% -*3d[1] 2 -endif
-if {$4==0} -f[0] 0
-elif {$4==1} -f[0] 255
-elif {$4==2} -f[0] 0 -l[1] -s3d -rand.. 0,255 -a y -endl -j3d[0] [1],0,0,0,1,2,1,0,0
-elif {$4==3} [0],[0],1,1,-1 -j3d. [-2],0,0,0,1,2,1,0,0 -blend[0,-1] shapeaverage
-endif
-col3d[1] $5,$6,$7 -j3d[0] [1],0,0,0,{$8/255},1,1,0,0 -rm[1]
-if $10 -r 50%,50%,1,100%,2 -endif
-endl -a c -endl -done
gimp_delaunay_preview :
-gimp_split_preview "-gimp_delaunay $*",$-1
gimp_polygonize :
-polygonize $1,$2,{$3^2},$4,$5
-if $9 -repeat $! -l[$>]
--norm -g. xy,1 -!=[-2,-1] 0 -|[-2,-1] -r. 100%,100%,1,4
-replace_color. 0,0,1,1,1,1,$6,$7,$8,$9
-blend alpha
-endl -done -endif
gimp_polygonize_preview :
-gimp_split_preview "-gimp_polygonize $*",$-1
gimp_pdithered :
--apply_gamma[-1] $1 -- 128 -* $2 -+ 128 -+ $3 -blur[-1] $4 -c[-1] 0,255 -ditheredbw[-1]
-quantize[-2] $5 -to_rgb -blur_xy[-2] $6,$6
-if {$7==0} -gimp_compose_colordoping $8,0
-elif {$7==1} -gimp_compose_darken $8,0
-elif {$7==2} -gimp_compose_softlight $8,0
-elif {$7==3} -gimp_compose_grainmerge $8,0
-elif {$7==4} -gimp_compose_multiply $8,1
-elif {$7==5} -gimp_compose_value $8,1 -endif
gimp_pdithered_preview :
-gimp_split_preview "-gimp_pdithered ${1--2}",$-1
gimp_poster_edges :
-if $1 -bilateral 10,$1 -endif
-poster_edges ${2-7}
gimp_poster_edges_preview :
-gimp_split_preview "-gimp_poster_edges $*",$-1
gimp_rodilius :
-ac "-rodilius ${1-5,7} -repeat $6 -smooth 10,0,1,1,1,0.8,45 -sharpen 30 -done -c 0,255",$8,$9
gimp_rodilius_preview :
-gimp_split_preview "-gimp_rodilius $*",$-1
gimp_shapeism :
-repeat $! -l[$>]
-to_rgb
--gradient_norm -b. $13% -^. $12 -quantize. $6,0,0
100%,100%,1,2
-repeat $6
--channels[2] 100% -->[1] $> -!=.. 0 -|[-2,-1] -a[2,-1] c
size={if($6<=1,$7,$7+($8-$7)*$>/($6-1))}
-if {$size<1} -break -endif
-if $5 {2*$size},{2*$size} -_gimp_shapeism$1. ${2-4} -r2dy. $size
-else $size,$size -_gimp_shapeism$1. ${2-4}
-endif
--!=. 0 -expand_xy[-2,-1] 1,0 -n[-2,-1] 0,1
-if {$10<1} -dilate. 3 -endif
[-1] -a[-3--1] c
-rprogress "-pack_sprites[-2,-1] 1,100,$9,$10,$11",{$>*100/$6},{($>+1)*100/$6}
-channels. 0,1
-done
-rprogress 97
-rm[1]
-channels. 0 --!=. 0 -blend[0,-1] shapeaverage0 -*[1] 255 -a c
-i[0] 100%,100%,1,4 -fc[0] $14,$15,$16,$17
-blend alpha
-rprogress 100
-endl -done
gimp_shapeism_preview :
-gimp_print_preview ""
50%,50% -_gimp_shapeism$1. ${2-4} -frame. 1,1,0 ->=. 50% -n. 0,255 -r. 100%,100%,1,4
-r. [0],0,0,0.5,0.5 -|
_gimp_shapeism0 :
-f 255 -skip $*
_gimp_shapeism1 :
-polygon 3,50%,0,0,100%,100%,100%,1,1 -skip $*
_gimp_shapeism2 :
-shape_circle {w} -rm.. -skip $*
_gimp_shapeism3 :
-shape_diamond {w} -rm.. -skip $*
_gimp_shapeism4 :
-star3d 3,1 -*3d. {0,min(w,h)/2} -j3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*
_gimp_shapeism5 :
-star3d 4,1 -*3d. {0,min(w,h)/2} -j3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*
_gimp_shapeism6 :
-star3d 5 -*3d. {0,min(w,h)/2} -j3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*
_gimp_shapeism7 :
-star3d $1,$2 -*3d. {0,min(w,h)/2} -r3d. 0,0,1,$3 -j3d[0] [-1],50%,50%,0,1,2,0 -k[0]
gimp_smooth_abstract :
-repeat $! -l[$>] -split_opacity -l[0]
-srgb2rgb
mM={im},{iM} --b $4 -n. $mM -gradient_norm. -le. {50-$5}
-inpaint_diffusion[0] [1],$1%,$2,$3 -rm.
-nm 0,255 -rgb2srgb
-endl -a c -endl -done
gimp_smooth_abstract_preview :
-gimp_split_preview "-gimp_smooth_abstract $*",$-1
gimp_vector_painting :
-repeat $! -l[$>]
--luminance -b. {10-$1}%,1,1
-f. "dmax = -1; nmax = 0;
for (n = 0, ++n<=8,
p = arg(n,-1,0,1,-1,1,-1,0,1);
q = arg(n,-1,-1,-1,0,0,1,1,1);
d = (j(p,q,0,0,0,1) - i)^2;
if (d>dmax,dmax = d; nmax = n,nmax)
)"
-blend shapeaverage
-endl -done
gimp_vector_painting_preview :
-gimp_split_preview "-gimp_vector_painting $*",$-1
gimp_watercolor :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$7==0} --gimp_gradient_norm $5,0.5,{99.99-$4},$4,1,0
-elif {$7==1} --gimp_edges {$5/3.5},{95-$4},0,0
-elif {$7==2} --gimp_edges {$5/3.5},{95-$4},0,0
--gimp_mix_hsv[0] 1,0,0,1,-1,0,1,0,0,0,2,0
-tk_gimp_channel_processing[2] 1,1,0,{$5/10},4,{{$4-50}*2},100,256,0,0,0,2,7,0
-reverse[1,2] -gimp_compose_multiply[1,2] {0.5+{$6/2}}
-endif -gimp_frame_round[1] 5,$8,15,0,255,255,255,255,0,0.1,3
-gimp_anisotropic_smoothing[0]
60,0.16,{{20/50}+0.6},{{20/9}+0.6},2.35,0.8,30,2,0,1,1,0,1
[0] --negative[0] -move[1] 4
-gimp_gaussian_blur[2] {{w+h}/100},0,0,1,0,0,0
-gimp_compose_dodge[1,2] 1
-gimp_mix_lab[0] 1,0,0,$1,0,0,$1,0,0,0,2,0
-reverse[0,1]
-gimp_compose_colorburn[0,1] $2
--luminance[0] -reverse[1,2]
-tk_gimp_channel_processing[1] 1,1,0,0,4,{$3*5},100,256,0,0,0,2,0,0
-gimp_gaussian_blur[1] $3,0,0,1,0,0,0
-tk_gimp_channel_processing[1] 1,1,0,0,4,0,99,256,0,1,0,2,0,0
-tk_gimp_replace_color[1] 1,0,255,255,255,255,0,0,0,0
-gimp_spread[1] {$3*2},{$3*2},0,0
-gimp_gaussian_blur[1] {{w+h}/1000},0,0,1,0,0,0
-reverse[0,1] -gimp_compose_multiply[0,1] 1
-split[0] c
-if {$9==0} --negative[0] --negative[1] --negative[2]
-elif {$9==1} --fill_color[0] 255,255,255 --fill_color[0] 255,255,255
--fill_color[0] 255,255,255
-elif {$9==2} --fill_color[0] 255,255,255 --fill_color[0] 255,255,255
--fill_color[0] 255,255,255
-elif {$9==3} --gimp_edges[0] {$10/5},{$13*5},1,0
--gimp_edges[1] {$14/5},{$17*5},1,0 --gimp_edges[2] {$18/5},{$21*5},1,0
-elif {$9==4} --negative[0] --negative[1] --negative[2] -endif
-tk_gimp_channel_processing[0] 1,{{$11/5}+1},{$11/50},0,0,0,100,256,0,0,0,2,0,0
-if {$9!=2}
-gimp_gaussian_blur[0] $10,0,0,1,0,0,0
-else -cubism[0] 300,{$13*5},{$13*36},1,{$10/50} -endif
-if {$9==0}
-tk_gimp_channel_processing[-3] 1,{{$11/5}+1},{$11/50},0,0,0,100,256,0,0,0,2,0,0
-cubism[-3] 300,{$13*5},{$13*36},1,{$10/50} -endif
-if {$9==4}
-tk_gimp_channel_processing[-3] 1,{{$11/5}+1},{$11/50},0,0,0,100,256,0,0,0,2,0,0
-gimp_painting[-3] $13,1.5,2 -endif
-gimp_frame_fuzzy[-3] {$12*5},{$12*5},{$13*20},{$10/2},0,0,0,255
-tk_gimp_channel_processing[1] 1,{{$15/5}+1},{$15/50},0,0,0,100,256,0,0,0,2,0,0
-if {$9!=2}
-gimp_gaussian_blur[1] $14,0,0,1,0,0,0
-else -cubism[1] 300,{$17*5},{$17*36},1,{$14/50} -endif
-if {$9==0}
-tk_gimp_channel_processing[-2] 1,{{$15/5}+1},{$15/50},0,0,0,100,256,0,0,0,2,0,0
-cubism[-2] 300,{$17*5},{$17*36},1,{$14/50} -endif
-if {$9==4}
-tk_gimp_channel_processing[-2] 1,{{$15/5}+1},{$15/50},0,0,0,100,256,0,0,0,2,0,0
-gimp_painting[-2] $17,1.5,2 -endif
-gimp_frame_fuzzy[-2] {$16*5},{$16*5},{$17*20},{$14/2},0,0,0,255
-tk_gimp_channel_processing[2] 1,{{$19/5}+1},{$19/50},0,0,0,100,256,0,0,0,2,0,0
-if {$9!=2}
-gimp_gaussian_blur[2] $18,0,0,1,0,0,0
-else -cubism[2] 300,{$21*5},{$21*36},1,{$18/50} -endif
-if {$9==0}
-tk_gimp_channel_processing[-1] 1,{{$19/5}+1},{$19/50},0,0,0,100,256,0,0,0,2,0,0
-cubism[-1] 300,{$21*5},{$21*36},1,{$18/50} -endif
-if {$9==4}
-tk_gimp_channel_processing[-1] 1,{{$19/5}+1},{$19/50},0,0,0,100,256,0,0,0,2,0,0
-gimp_painting[-1] $21,1.5,2  -endif
-gimp_frame_fuzzy[-1] {$20*5},{$20*5},{$21*20},{$18/2},0,0,0,255
-to_gray[-1] -to_gray[-2] -to_gray[-3] -to_rgba[0] -to_rgba[1] -to_rgba[2]
-split[0] c -reverse[3,-3] -compose_multiply[3,-3] -append[0,1,2,3] c
-split[1] c -reverse[4,-2] -compose_multiply[4,-2] -append[1,2,3,4] c
-split[2] c -reverse[5,-1] -compose_multiply[5,-1] -append[2,3,4,5] c
-if {$22==0} --fill_color[0] 255,255,255 -else --fill_color[0] 0 -endif
-reverse[0,-1]  -compose_rgba[0,-1]
-if {$22==0} --fill_color[1] 255,255,255 -else --fill_color[1] 0 -endif
-reverse[1,-1] -compose_rgba[1,-1]
-if {$22==0} --fill_color[2] 255,255,255 -else --fill_color[2] 0 -endif
-reverse[2,-1] -compose_rgba[2,-1]
-to_gray[0] -to_gray[1] -to_gray[2] -append[0,1,2] c
-if {$23==1} -gimp_paper 0,0 -endif
-if {$24==1} -negative[0] -endif
-gimp_mix_lab 1,$25,0,1,0,0,1,0,0,0,2,0
-reverse[0,1] -gimp_compose_multiply[0,1] $6
-endl -a c -endl -done
gimp_watercolor_preview :
-gimp_split_preview "-gimp_watercolor ${1--2}",$-1
gimp_draw_whirl_preview :
-gimp_split_preview "-draw_whirl $*",$-1
gimp_stencilbw :
-stencilbw $1,$2
-if {$3||$4} -repeat $! -l[$>] -split_opacity
-/[0] 255 -i[0] 100%,100%,1,1,$4 -i[0] 100%,100%,1,1,$3 -a[0-2] c -hsv2rgb[0]
-a c -endl -done -endif
gimp_stencilbw_preview :
-gimp_split_preview "-gimp_stencilbw $*",$-1
gimp_blackandwhite :
-repeat $!
-l. -split_opacity -rv -to_rgb. -s. c
-*... $1 -b... $2%
-*.. $3 -b.. $4%
-*. $5 -b. $6%
-+[-3--1] -/. {$1+$3+$5} -c. 0,255
-apply_gamma. {10^$7}
--. 128 -*. $8 -+. 128 -+. $9 -c. 0,255
-if {$12||$13||$14}
100%,100% [-1]x2
-noise... 100,$17 -b... $16% -n... -$12,$12
-noise.. 100,$17 -b.. $16% -n.. -$13,$13
-noise. 100,$17 -b. $16% -n. -$14,$14
--tones[-4] 3 -b[-3--1] $15%
-*[-6,-3] -*[-4,-2] -*[-2,-1]
-+[-4--1] -c. 0,255
-endif
-if {$10||$11}
-/. 255
-i.. 100%,100%,1,1,$11
-i... 100%,100%,1,1,$10
-a[-3--1] c -hsv2rgb.
-endif
-rv -a c -endl -mv. 0 -done
-if $18 -normalize_local $18,$19,$20,2%,1,0,255 -endif
-if $22 -n 0,255 -endif
-if $21 -to_pseudogray $21,1 -endif
gimp_blackandwhite_preview :
-gimp_split_preview "-gimp_blackandwhite $*",$-1
gimp_charcoal :
-repeat $! -l[$>] -split_opacity -l[0]
-compose_channels max
w={w} h={h}
-if $5 -r. 150%,150%,1,1,6 -endif
-if $4 -equalize. -n. 0,255 -endif
-sharpen {$1*3} -cut 0,255
-if $6 --ir $7,$8 -endif
-ir[0] $2,$3
-if {!$15} -==[0] 0 -endif
-|
--*[0] $10 --*[0] $11 -*[0] $9
-a[-3--1] c -replace_color 0,0,0,0,0,$12,$13,$14
-r $w,$h,1,100%,2
-endl -a c -endl -done
gimp_charcoal_preview :
-gimp_split_preview "-gimp_charcoal $*",$-1
gimp_colorize_comics :
-if {$!<2} -return -endif
-if {$1<2} selection=0,1 -else selection=0,1,2 -endif
-l[$selection]
-if {$1==0}
-elif {$1==1} -rv
-elif {$1==2} -rm[1]
-elif {$1==3} -rm[2] -rv
-endif
--to_rgba[0] -split_opacity. -+.. 1 -!=. 0 -*[-2,-1]
--norm[1] -n. 0,1 --histogram. 2,0,1
-if {i(0)>i(1)} -*.. -1 -+.. 1 -endif -rm.
-b. $4% -watershed.. [-1] -rm.
--. 1
-if {$2==0} -rm[0] -rv -blend[0,1] multiply ind=-1
-elif {$2==1} -rm[0] -rv ind=0
-elif {$2==2} -rm[0] ind=1
-elif {$2==3} -rv[1,2] ind=1
-elif {$2==4} -rv[0,1] ind=2
-endif
-if {$3&&$ind>=0} -l[$ind]
--mix_channels (65536,256,1)
-if {$3==10} -do
iM={1,iM}
-if {$iM>=0}
--==[1] $iM area={is} -replace[1] $iM,-1
--r. 100%,100%,1,3 -*. [0]
-rv[-2,-1] -*. 255 -a[-2,-1] c -nm. $area
-endif
-while {$iM>=0} -else
-label.
-if {$3<10} -%. {$3+1} -endif
-repeat {iM+1} --==[1] $< area={is} --r. 100%,100%,1,[0] -*. [0] -rv[-2,-1] -*. 255 -a[-2,-1] c -nm. $area -done
-endif
-rm[0,1]
-sort_list +,n
-endl -endif
-endl
gimp_colorize_comics_preview :
-gimp_colorize_comics $1,0,$3,$4
gimp_colorize_interactive :
N=$! nm={n}
resolution={arg(1+$3,512,1024,2048,0)}
-nm "[G"{`39`}"MIC] Colorize"
-if {$8==-1" || "$7!=w" || "$8!=h} _gimp_control_points= -else _gimp_control_points=${9--1} -endif
-l[] 0 -nm. "$4" ext={x} -rm -if {same(['$ext'],'gpl',-1,0)} -input_gpl "$4" -endif -onfail -rm -endl
-l[] 0 -nm. "$5" ext={x} -rm -if {same(['$ext'],'gpl',-1,0)} -input_gpl "$5" -endif -onfail -rm -endl
-if {$!==$N+2}
-repeat {$!-2} status=${-x_colorize[$>]\ $1,$resolution,$2,[-2],[-1]} -done
-rm[-2,-1]
-elif {$!==$N+1}
-repeat {$!-1} status=${-x_colorize[$>]\ $1,$resolution,$2,[-1]} -done
-rm.
-else
-repeat $! status=${-x_colorize[$>]\ $1,$resolution,$2} -done
-endif
-if {$2==1} -repeat $! -l[$<]
-channels {s-3},{s-1}
-endl -done
-elif {$2>=2} -repeat $! -l[$<]
--channels {s-3},{s-1} -channels.. 0,{0,s-4}
-endl -done
-if {$2>=3} -split_colors[1] 0,256,8 -endif
-endif
-nm $nm
-u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{0\}\{{w},{h}\}\{$status\}
gimp_colorize_interactive_preview :
-if $6
-gimp_print_preview "No preview\n  available",,"(Control points cleared)"
-u \{$1\}\{$2\}\{$3\}\{"$4"\}\{"$5"\}\{0\}\{{w},{h}\}\{-1\}
-else -gimp_no_preview ,
-endif
gimp_recolorize :
-repeat {int($!/2)}
-if $3 s=$>,{$>+1} -else s={2*$>},{2*$>+1} -endif
-l[$s] -rv[0,1]
-channels[0] 0 -to_rgb..
-to_rgba. -split_opacity. -!=. 0
-srgb2rgb[-3,-2] -rgb2lab8[-3,-2] -channels... 0 -channels.. 1,2
-+.. 1 -*.. [-1] --gradient_norm... -*. -1 -watershed... [-1] -rm. --.. 1
--diffusiontensors... $2,1,0.5,0.5 -==.. 0 -*. [-2] -rm..
-smooth.. [-1],{$1*80},0.8,60 -rm.
-a[-2,-1] c -lab82rgb. -rgb2srgb.
-if $3 -rgb2hsv. -s. c -i[2] 100%,100%,1,1,1 -i[3] 100%,100%,1,2,0 -a[0-2] c -a[^0] c -hsv2rgb -rv -endif
-endl
-done
gimp_recolorize_preview :
-gimp_recolorize $* -a x
gimp_bwrecolorize :
-remove_opacity
-if $4 -n 0,255 -endif
-if {$5==0}
(${9--2}) -r. 4,$8,1,1,-1 -permute. yzcx
-elif {$5==1}
(0,255^0,255^0,255^255,255)
-elif {$5==2}
(255,0^255,0^255,0^255,255)
-elif {$5==3}
(0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200^255,255,255,255,255,255)
-else
(0,359^1,1^1,1^255,255) -r. 256,1,1,4,3 -sh. 0,2 -hsv2rgb. -rm.
-endif
-if {$6==0} -r. 256,1,1,4,1
-elif {$6==1} -r. 256,1,1,4,3
-elif {$6==2} -r. 256,1,1,4,5 -c. 0,255
-else -r. 256,1,1,4,6
-endif
-if {$7==1} -sh. 0,2 -rgb2hsv. -sh. 2 -f. x/w -hsv2rgb.. -rm[-2,-1] -endif
-l[^-1] -luminance -apply_gamma {10^$1} -- 128 -* $2 -+ {$3+128} -c 0,255 -endl -map[^-1] [-1] -rm.
gimp_bwrecolorize_preview :
-gimp_split_preview "-gimp_bwrecolorize ${^0}",$-1
gimp_ditheredbw :
-repeat $! -l[$>] -split_opacity -l[0]
-luminance -n 0,255 -apply_gamma {10^$1} -- 128 -* $2 -+ 128 -+ $3 -b $4 -c 0,255 -ditheredbw
-if {$5||$6} -/ 255 -i[0] 100%,100%,1,2 -fc[0] $5,$6 -a c -hsv2rgb -endif
-endl -a c -endl -done
gimp_ditheredbw_preview :
-gimp_split_preview "-gimp_ditheredbw $*",$-1
gcd_emboss : -skip ${1=128}
-repeat $! -l[$>]
--norm --bilateral[0] 2%,30 -norm[-1] --[-2,-1]
--n[0] 0,255 -median[-1] 3 -bilateral[-1] 2%,30
-gcd_srgb2luma[-1] --[-1] $1
--abs[-1] -negative[-1]
--max[-2] 0 -min[-3] 0 -abs[-3]
-pde_flow[1] 20,7,iee
--n[-3] 0,2 -*[-1] [1] -+[0,-1]
--n[-1] 0,2 -*[-1] [1] -+[0,-1]
--n[-2] 0,2 -*[-1] [1] -+[0,-1]
-+[0,2] --[0,3] -k[0]
-gcd_srgb2luminance -c 0,255
-endl -done
gcd_emboss_preview :
-gimp_split_preview "-gcd_emboss ${1--2}",$-1
gimp_engrave :
f={arg(1+$14,1,1.5,2,3)}
r={$f*(0.2+$1)}
-repeat $! -l[$<]
nm=${-gimp_layer_name} pos=${-gimp_layer_pos}
-if $8 [0] -endif
-l[0] -split_opacity -l[0]
wh={w},{h}
-norm
-if $14 -r {100*$f}%,{100*$f}%,1,1,3 -endif
-if {$7>0} [0] -endif
-l[0]
amount={(0.5+$2)^2}
-repeat 5 -b $r -unsharp $r,{1+$2} -c 0,255 -done
-smooth 100,0.1,1,{$f*$3},{$f*$4}
->= {100-$5}%
-endl
-if {$7>0}
-gradient_norm[1] -b[1] $3 -lt[1] $7 -max[0,1]
-endif
-if {$6<0} -area_fg 0,0 -gt {$f*$6*$6}
-elif {$6>0} -== 0 -area_fg 0,0 -gt {$f*$6*$6} -== 0
-endif
-* 255
-if $14 -r $wh,1,1,2 -endif
-endl -a c -endl
-if {$!>1}
-l[1] -split_opacity -l[0]
f={arg(1+$14,1,1.5,2,3)}
-if $14 -r {100*$f}%,{100*$f}%,1,100%,3 -endif
-b {$f*$9} -segment_watershed 5
-if $14 -r $wh,1,100%,2 -endif
-repeat $10 -guided 10,{$10*80} -done
-rgb2hsv -s c -+... $11 -+.. {$12%} -+. $13% -a c -hsv2rgb
-endl -a c -endl
-nm[0] mode(darken),name($nm),pos($pos)
-nm[1] name($nm" [colors]"),pos($pos)
-endif
-endl -done
gimp_engrave_preview :
-repeat $! -l[$<]
-gimp_split_preview "-nm foo -gimp_engrave $* -gimp_merge_layers",$-1
-endl -done
gimp_freaky_bw :
-repeat $! -l[$>] -split_opacity -l[0]
-to_rgb
--expand_xy 1,0 -channels. 0,4
-f. ">if (c!=4,i,
Rx = i(x+1,y,0,0) - i(x,y,0,0);
Ry = i(x,y+1,0,0) - i(x,y,0,0);
Rn = Rx^2 + Ry^2;
Gx = i(x+1,y,0,1) - i(x,y,0,1);
Gy = i(x,y+1,0,1) - i(x,y,0,1);
Gn = Gx^2 + Gy^2;
Bx = i(x+1,y,0,2) - i(x,y,0,2);
By = i(x,y+1,0,2) - i(x,y,0,2);
Bn = Bx^2 + By^2;
n = 1e-5 + max(Rn,Gn,Bn)^"{$2%}";
val = 0;
if (Rn>=Gn && Rn>=Bn,
i(x,y,0,3) = Rx/n; val=Ry/n,
if (Gn>=Rn && Gn>=Bn,
i(x,y,0,3) = Gx/n; val=Gy/n,
i(x,y,0,3) = Bx/n; val=By/n));
val
)"
-channels. 3,4
-luminance[0] ia={0,ia}
-s. c
-f.. "i - i(x-1,y,0,0)"
-f. "i - i(x,y-1,0,0)"
-+[-2,-1]
-fft.
100%,100%,1,1,'cos(2*x*pi/w)+cos(2*y*pi/h)' -*. 2 --. 4
-=. 1 -/[-3,-2] [-1] -rm.
-=.. 0 -=. 0
-ifft[-2,-1] -rm.
-shrink_xy. 1 -+. $ia -n. 0,255
-j[0] [1],0,0,0,0,{$1%} -rm.
-- $ia -* {1+$4} -+ $ia -+ {$3*255} -c 0,255
-endl -a c -endl -done
gimp_freaky_bw_preview :
-gimp_split_preview "-gimp_freaky_bw $*",$-1
gimp_hardsketchbw :
-b $3
-if {$7==4} -repeat $! -l[$>] --hardsketchbw $1,$2,$4,$5,$6 -blend hardlight -endl -done -return -endif
-hardsketchbw $1,$2,$4,$5,$6
-if {$7&1} -negative -endif
-if {$7==2} -r 100%,100%,1,4 -repeat $! -sh[$>] 3 -*. -2 -+. {2*255} -c. 0,255 -rm. -done
-elif {$7==3} -r 100%,100%,1,4 -repeat $! -sh[$>] 3 -*. 2 -c. 0,255 -rm. -done
-endif
gimp_hardsketchbw_preview :
-gimp_split_preview "-gimp_hardsketchbw $*",$-1
gimp_houghsketchbw :
-b $1 -n 0,255
-if {$6==4} -repeat $! -l[$>] --houghsketchbw ${2-5} -blend hardlight -endl -done -return -endif
-houghsketchbw ${2-5}
-if {$6&1} -negative -endif
-if {$6==2} -r 100%,100%,1,4 -repeat $! -sh[$>] 3 -*. -2 -+. {2*255} -c. 0,255 -rm. -done
-elif {$6==3} -r 100%,100%,1,4 -repeat $! -sh[$>] 3 -*. 2 -c. 0,255 -rm. -done
-endif
gimp_houghsketchbw_preview :
-gimp_split_preview "-gimp_houghsketchbw $*",$-1
gimp_ink_wash :
-repeat $! -l[$>] -split_opacity -l[0]
-gimp_pencilbw. $1,$2,0,0,0
-if {$3==1} -continue
-elif {$3==0} -gimp_anisotropic_smoothing. 60,$4,$5,$6,1.1,0.8,30,2,0,1,1,0,1,16
-endif
-if {$7==1} -normalize_local. 2,6,5,24,1,0,255
-elif {$7==2} -normalize_local. 2,6,5,24,1,0,255 -gimp_contrast_swm 2,0,0.512
-elif {$7==3} -gimp_normalize_local. $8,$9,$10,$11,1,3,0
-endif
-endl -a c -endl -done
gimp_gcd_layeretch : -skip ${1=16},${2=7},${3=14},${4=0.12},${5=100},${6=5},${7=4.65},${8=0},${9=0},${10=3},${11=1},${12=1},${13=0}
-repeat $! -l[$>]
w={w} h={h} sc=800 ml=$1 wl={min($2,$ml-1)}
nwl={$ml-$wl} nwl={$nwl+($nwl%2==0)}
-if {!$13} nw=$w nh=$h
-elif {w>h} nw={min($sc,w)} nh={$nw/w*h}
-else nh={min($sc,h)} nw={$nh/h*w} -endif
-to_rgb[0] [0] -r[1] $nw,$nh
-norm[1] -n[1] 0,255 --tones[1] $ml
-repeat {$ml-1} -+[{-$<-1}] [{-$<-2}] -done
-b[-$ml--1] $4%
-repeat $ml
pc={($>+1)/$ml} msk={2+$>} {w},{h},1,1,0
-if $12 ang={$>/$nwl} -else ang=$pc -endif
-if {$<>=$wl}
-noise[-1] {(1-$pc)*$5},2
-blur_linear[-1] {$6+$pc*($7-$6)}%,0,{$ang*360+u(-$9,$9)+$8}
-quantize[-1] $3,0 -deform[-1] {u*$10+1}
-endif
-r[-1] $nw,$nh -n[-1] 0,255
-mul[$msk,-1] -progress {$pc*100}
-done
-add[-$ml--1] -c[-1] 0,255
-n[-1] 0,255 -negative[-1] -apply_gamma[-1] $11
-if $13 -r[-1] $w,$h,1,3,5 -c[-1] 0,255 -endif
-keep[-1]
-endl -done
gimp_pencilbw :
-pencilbw $1,$2
-if {$3||$4} -repeat $! -l[$>] -split_opacity
-/[0] 255 -i[0] 100%,100%,1,1,$4 -i[0] 100%,100%,1,1,$3 -a[0-2] c -hsv2rgb[0]
-a c -endl -done -endif
gimp_pencilbw_preview :
-gimp_split_preview "-gimp_pencilbw $*",$-1
gimp_pencil_portraitbw :
-repeat $! -l[$>] -split_opacity -l[0]
--b 2%
--blend divide -rm.. -luminance.
-gimp_ink_wash.. 0,167,0,0.5,0.54,2.25,0,2,6,5,20
--gimp_hardsketchbw. 80,32,1.89,0.21,31.46,0,0
--gimp_sketchbw.. 1,$2,180,$1,$3,0.03,0,0.6,0.1,0.6,0.25,1,0,1,0
-blend[0,1] darken
-blend[0,1] multiply,0.5
-blend[0,1] lighten,$4
-normalize_local ,
-to_rgb --fc ${5-7} -blend softlight
-endl -a c -endl -done
gimp_pencil_portraitbw_preview :
-gimp_split_preview "-gimp_pencil_portraitbw $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_sketchbw :
-if {$15==4} -repeat $! -l[$>] --sketchbw ${1-14} -blend hardlight -endl -done -return -endif
-sketchbw ${1-14}
-if {$15&1} -negative -endif
-if {$15==2} -r 100%,100%,1,4 -repeat $! -sh[$>] 3 -*. -2 -+. {2*255} -c. 0,255 -rm. -done
-elif {$15==3} -r 100%,100%,1,4 -repeat $! -sh[$>] 3 -*. 2 -c. 0,255 -rm. -done
-endif
gimp_sketchbw_preview :
-gimp_split_preview "-gimp_sketchbw $*",$-1
gimp_stamp :
-repeat $! -l[$>] -split_opacity -l[0]
wh={w},{h}
-norm
-if $7 -r 150%,150%,1,1,3 -endif
-noise $5
-if $1 -otsu 256 -else ->= $2% -endif
-b {if($7,1.5,1)*$3},0 -sharpen $4 -n 0,255
-apply_curve 1,0,0,101,33,170,229,255,255
-if $7 -r $wh,1,1,2 -endif
-if $6 -negative -endif
-endl -a c -endl -done
gimp_stamp_preview :
-gimp_split_preview "-gimp_stamp $*",$-1
gimp_gcd_etch :
-skip ${1=125},${2=153},${3=171},${4=185},${5=0.1} -skip ${6=50},${7=80},${8=50},${9=10}
-skip ${10=15},${11=12},${12=20},${13=0} -skip ${14=1},${15=0.3},${16=1},${17=0}
-repeat $! -l[$>]
w={w} h={h} sc=800 ml=4
-if {w>h} nw={min($sc,w)} nh={$nw/w*h} -else nh={min($sc,h)} nw={$nh/h*w} -endif
-to_rgb[0] [0] -if $16 -r[1] $nw,$nh -endif
-b[1] $5% -norm[1] -negative[1] -n[1] 0,255
--c[1] 0,{255-$4} --c[1] {255-$3},128 --c[1] {255-$2},192 --c[1] {255-$1},255 -n[-3--1] 0,255
{w},{h},1,1,0 -noise[-1] $6,2 -deriche[-1] $10,0,x,0
{w},{h},1,1,0 -noise[-1] $7,2 {w},{h},1,3,0 -fc[-1] 0,-1,0 -smooth[-2] [-1],30,30,0 -rm[-1]
-if $13 -mirror[-1] x -endif
{w},{h},1,1,0 -noise[-1] $8,2 -deriche[-1] $11,0,y,0
{w},{h},1,1,0 -noise[-1] $9,2 -deriche[-1] $12,0,y,0
-quantize[-$ml--1] 2,0 -deform[-$ml--1] $14
-repeat $ml -mul[{2+$>},-1] -done
-add[-$ml--1] -n[-1] 0,255 -rm[1]
-negative[-1] -apply_gamma[-1] $15
-if $16 -r[-1] $w,$h,1,3,5 -c[-1] 0,255 -endif
-if $17 -blend[0,1] shapeaverage -else -keep[-1] -endif
-endl -done
gimp_gcd_etch_preview :
-gimp_split_preview "-gimp_gcd_etch ${1--2}",$-1
gimp_color_abstraction :
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-b $1 -s c -quantize $2,1,0 -area 0 -^ $3 -n 0,255
-endl -a c -endl -done
gimp_color_abstraction_preview :
-gimp_split_preview "-gimp_color_abstraction $*",$-1
gimp_boost_fade :
-i[0] 640,480,1,3 -rand[0] 0,1 -b[0] {10-$1} -n[0] 0,255 -transfer_colors[^0] [0] -rm[0]
gimp_boost_fade_preview :
-gimp_split_preview "-gimp_boost_fade $*",$-1
gimp_boost_chroma :
-repeat $! -l[$>] -split_opacity -l[0]
--to_rgb
-if $2
-srgb2rgb -rgb2lab.
-sh. 1,2 -equalize. -rm.
-lab2rgb. -rgb2srgb
-else
-rgb2ycbcr.
-sh. 1,2 -equalize. -rm.
-ycbcr2rgb.
-endif
-blend alpha,$1
-endl -a c -endl -done
gimp_boost_chroma_preview :
-gimp_split_preview "-gimp_boost_chroma $*",$-1
gimp_channels2layers :
-repeat $! -l[$<] nm=${-gimp_layer_name} -to_rgb
-if {$1==0}
-s[0] c
-r[0] 100%,100%,1,3,0,0,0,0,0,0 -nm[0] name($nm" "[red]),mode(add)
-r[1] 100%,100%,1,3,0,0,0,0,0,0.5 -nm[1] name($nm" "[green]),mode(add)
-r[2] 100%,100%,1,3,0,0,0,0,0,1 -nm[2] name($nm" "[blue]),mode(add)
-elif {$1==1}
-rgb2cmy[0] --[0] 255 -s[0] c
-r[0] 100%,100%,1,3,0,0,0,0,0,0 -nm[0] name($nm" "[cyan]),mode(difference)
-r[1] 100%,100%,1,3,0,0,0,0,0,0.5 -nm[1] name($nm" "[magenta]),mode(difference)
-r[2] 100%,100%,1,3,0,0,0,0,0,1 -nm[2] name($nm" "[yellow]),mode(difference)
-+[0-2] 255
-i[0] 100%,100%,1,3,255 -nm[0] name($nm" "[base]),mode(difference)
-else
-rgb2hsv[0] -s[0] c,-2
-r[0] 100%,100%,1,3,0,0 -sh[0] 2 -f. 1 -rm. -nm[0] name($nm" "[color]),mode(normal)
-r[1] 100%,100%,1,3,0,0,0,0,0,1 -nm[1] name($nm" "[value]),mode(value)
-hsv2rgb[0,1] -rv[0,1]
-endif
-endl -done
gimp_channels2layers_preview :
-repeat $! -l[$>]
-gimp_channels2layers $*
-repeat $! -l[$>] -text_outline "#"{1+$>},1,1,43,7,1,255 -endl -done
-frame 1,1,0 -frame 3,3,255 -append_tiles ,
-endl -done
_gimp_channel_processing :
-apply_gamma. {10^$1}
-if {$2!=1} --. 128 -*. $2 -+. 128 -endif
-+. $3
-b. $4% -c. 0,255
-if {$5==1} -c. $6%,$7%
-elif {$5==2} -c. $6%,$7% -n. 0,255
-elif {$5==3} -n. $6%,$7%
-elif {$5==4} -ir. $6%,$7% -*. 255
-endif
-if {$8!=256} -quantize. $8,1,0 -endif
-if $9 -equalize. -endif
-if $10 -negative. -endif
gimp_channel_processing :
-repeat $! -l. -split_opacity -rv -to_rgb.
-gimp_start_mix $11,$12
-ac. "-_gimp_channel_processing $1,$2,$3,$4,$5,$6,$7,$8,$9,$10",$13,1
-gimp_end_mix $11
-if {$!!=3} -rv -a c -endif -endl -mv. 0 -done
gimp_channel_processing_preview :
-gimp_split_preview "-gimp_channel_processing $*",$-1
iain_cmyk_tone_p:
-apply_parallel_overlap "-iain_cmyk_tone ${1--2}",0,${-1}
iain_cmyk_tone:
-repeat $! -l[$>] -split_opacity -l[0]
-rgb2cmyk
--split c
--apply_curve[1] 0,0,$1,128,$2,255,$3
--apply_curve[2] 0,0,$4,128,$5,255,$6
--apply_curve[3] 0,0,$7,128,$8,255,$9
--apply_curve[4] 0,0,$10,128,$11,255,$12
-add[-1,-2,-3,-4]
--apply_curve[1] 0,0,$13,128,$14,255,$15
--apply_curve[2] 0,0,$16,128,$17,255,$18
--apply_curve[3] 0,0,$19,128,$20,255,$21
--apply_curve[4] 0,0,$22,128,$23,255,$24
-add[-1,-2,-3,-4]
--apply_curve[1] 0,0,$25,128,$26,255,$27
--apply_curve[2] 0,0,$28,128,$29,255,$30
--apply_curve[3] 0,0,$31,128,$32,255,$33
--apply_curve[4] 0,0,$34,128,$35,255,$36
-add[-1,-2,-3,-4]
--apply_curve[1] 0,0,$37,128,$38,255,$39
--apply_curve[2] 0,0,$40,128,$41,255,$42
--apply_curve[3] 0,0,$43,128,$44,255,$45
--apply_curve[4] 0,0,$46,128,$47,255,$48
-add[-1,-2,-3,-4]
-add[1,5]
-add[2,5]
-add[3,5]
-add[4,5]
-a[-1,-2,-3,-4] c
--sub[0,1]
--cmyk2rgb[0] -rgb2hsv[-1] -split[-1] c -remove[-1,-3] -mul[-1] 255
-apply_curve[-1] 0,0,$49,64,$50,128,$51,192,$52,255,$53
-compose_multiply[-1,-2]
--sub[0,-1]
-if {$54==0}
-cmyk2rgb
-luminance[0]
--luminance[-1]
-compose_grainextract[-1,-2]
-compose_grainmerge[0,-1]
-keep[0]
-endif
-if {$54==1}
-keep[-1]
-c 0,255
-cmyk2rgb
-endif
-if {$54==2}
-keep[-1]
-cmyk2rgb
-c 0,255
-endif
-if {$54==3}
-keep[-1]
-n 0,255
-cmyk2rgb
-endif
-if {$54==4}
-keep[-1]
-cmyk2rgb
-n 0,255
-endif
-endl -a c -endl -done
gimp_colormap :
-repeat $! -l[$>] -split_opacity -to_rgb[0]
-if {$1>=2}
-index[0] {$1-2},$2,1
-elif {$1==1}
(${5-28}) -z. 0,{3*$4-1}
-r. 3,{w/3},1,1,-1 -permute. yzcx -r. $3,1,1,3,3
-index[0] [-1],$2,1 -rm.
-else
-autoindex[0] $3,$2,{if($3<=32,1,0)}
-endif
-a c
-endl -done
gimp_colormap_preview :
-gimp_split_preview "-gimp_colormap $*",$-1
gimp_balance_gamma :
-repeat $! -l[$>] -split_opacity
-if {$!>1} --!=. 0 -*[0,-1] -endif
-l[0]
-balance_gamma ${1-3}
-if $4 -n 0,255 -endif
-endl
-a c -endl
-done
gimp_balance_gamma_preview :
-gimp_split_preview "-gimp_balance_gamma $*",$-1
gimp_colorblind_preview :
-gimp_split_preview "-colorblind $*",$-1
jl_colorgrading :
-if {$1>0.01}
-map_tones_fast 5%,$1
-endif
_ystr=""
-if {$2>0}
_mymin={$2}
_mymax={255-$2}
-apply_channels "-apply_curve 0,0,$_mymin,255,255",ycbcr_cr,0
-apply_channels "-apply_curve 0,0,0,255,$_mymax",ycbcr_cb,0
-endif
-if {$2<0}
_mymin={-$2}
_mymax={255+$2}
-apply_channels "-apply_curve 0,0,$_mymin,255,255",ycbcr_cb,0
-apply_channels "-apply_curve 0,0,0,255,$_mymax",ycbcr_cr,0
-endif
-if {$3!=1.0}
-gimp_equalize_s $3,0
-endif
-if {$4!=1.0}
-apply_channels "-apply_gamma $4",hsv_s,0
-endif
-if {$5!=0}
_p1={64-$5}
_p2={192+$5}
_ystr=$_ystr" -apply_curve 1,0,0,64,$_p1,192,$_p2,255,255"
-endif
-if {$6!=0}
_p3={64-$6}
_ystr=$_ystr" -apply_curve 1,0,0,64,$_p3,128,128,192,192,255,255"
-endif
-if {$7!=0}
_p4={192+$7}
_ystr=$_ystr" -apply_curve 1,0,0,64,64,128,128,192,$_p4,255,255"
-endif
-if {$8>0}
_ystr=$_ystr" -apply_curve 1,$8,0,64,64,255,255"
-endif
-if {$9>0}
_p5=0
_ystr=$_ystr" -apply_curve 0,0,$9,255,255"
-endif
-if {$9<0}
_p5={255+$9}
_ystr=$_ystr" -apply_curve 0,0,0,255,$_p5"
-endif
-if {$10>0}
_p6=$10
_p7={255-$10}
_ystr=$_ystr" -apply_curve 0,0,0,$_p6,0,$_p7,255,255,255"
-endif
-if {$10<0}
_p6={-$10}
_p7={255+$10}
_ystr=$_ystr" -apply_curve 0,0,$_p6,255,$_p7"
-endif
-if {$11!=1.0}
_ystr=$_ystr" -apply_gamma $11"
-endif
-if {'$_ystr'!=0}
-apply_channels $_ystr,hsv_v,0
-endif
-if {$12>0}
-to_rgb --rgb2hsl -split[-1] c -rm[-2] -rm[-2] -*[-1] 255 -apply_curve[-1] 1,0,0,63,0,127,255,192,0,255,0 --unsharp[0] 5%,$12,0 -cut[-1] 0,255 -cut[-2] 0,255 -reverse[-1,-2] -append[-1,-2] c -blend alpha
-endif
-if {$13>0}
-unsharp 1%,$13,0
-cut[-1] 0,255
-endif
-if {$14}
-if {$16+$22>360}
_shh={($16+$22-360)/360}
-else
_shh={($16+$22)/360}
-endif
_shs={$21/100}
_shlev={$23}
_midh={$19/360}
_mids={$18/100}
_midlev={$20}
_highh={$16/360}
_highs={$15/100}
_highlev={$17}
_satlev={$24}
-color_grade $_shh,$_shs,$_shlev,$_midh,$_mids,$_midlev,$_highh,$_highs,$_highlev,$_satlev
-endif
-if {$24!=1.0}
-gimp_equalize_s $24,0
-endif
-if {$25>0}
-unsharp 0.5,$25
-cut 0,255
-endif
-if {$26>0}
-apply_channels "-denoise_haar $26",ycbcr_cb,0
-apply_channels "-denoise_haar $26",ycbcr_cr,0
-endif
color_grade :
_shadownrgb=${-jl_hsv_to_rgb" "$1,1.0,{$2*0.40}}
_midtonesrgb=${-jl_hsv_to_rgb" "$4,1.0,{$5*0.40}}
_highlightsrgb=${-jl_hsv_to_rgb" "$7,1.0,{$8*0.40}}
_crsh=${-arg" 1,"$_shadownrgb}
_mgsh=${-arg" 2,"$_shadownrgb}
_ybsh=${-arg" 3,"$_shadownrgb}
_shlev=$3
_crmid=${-arg" 1,"$_midtonesrgb}
_mgmid=${-arg" 2,"$_midtonesrgb}
_ybmid=${-arg" 3,"$_midtonesrgb}
_midlev=$6
_crhigh=${-arg" 1,"$_highlightsrgb}
_mghigh=${-arg" 2,"$_highlightsrgb}
_ybhigh=${-arg" 3,"$_highlightsrgb}
_highlev=$9
_satlev=$10
_lowinred=0
_hiinred=255
_lowingreen=0
_hiingreen=255
_lowinblue=0
_hiinblue=255
_gammared=0.
_gammagreen=0.
_gammablue=0.
_lowoutred=0
_hioutred=255
_lowoutgreen=0
_hioutgreen=255
_lowoutblue=0
_hioutblue=255
-if {$_crmid>0.}
_gammared={$_gammared+0.4*$_crmid/100.}
_gammagreen={$_gammagreen-0.3*$_crmid/100.}
_gammablue={$_gammablue-0.3*$_crmid/100.}
-endif
-if {$_crmid<0.}
_gammared={$_gammared+0.3*$_crmid/100.}
_gammagreen={$_gammagreen-0.4*$_crmid/100.}
_gammablue={$_gammablue-0.4*$_crmid/100.}
-endif
-if {$_mgmid>0.}
_gammared={$_gammared-0.3*$_mgmid/100.}
_gammagreen={$_gammagreen+0.4*$_mgmid/100.}
_gammablue={$_gammablue-0.3*$_mgmid/100.}
-endif
-if {$_mgmid<0.}
_gammared={$_gammared-0.4*$_mgmid/100.}
_gammagreen={$_gammagreen+0.3*$_mgmid/100.}
_gammablue={$_gammablue-0.4*$_mgmid/100.}
-endif
-if {$_ybmid>0.}
_gammared={$_gammared-0.3*$_ybmid/100.}
_gammagreen={$_gammagreen-0.3*$_ybmid/100.}
_gammablue={$_gammablue+0.4*$_ybmid/100.}
-endif
-if {$_ybmid<0.}
_gammared={$_gammared-0.4*$_ybmid/100.}
_gammagreen={$_gammagreen-0.4*$_ybmid/100.}
_gammablue={$_gammablue+0.3*$_ybmid/100.}
-endif
_gammared={$_gammared+1.}
_gammagreen={$_gammagreen+1.}
_gammablue={$_gammablue+1.}
-if {$_midlev>0.}
_gammared={$_gammared+0.4*$_midlev/100.}
_gammagreen={$_gammagreen+0.4*$_midlev/100.}
_gammablue={$_gammablue+0.4*$_midlev/100.}
-endif
-if {$_midlev<0.}
_gammared={$_gammared+0.3*$_midlev/100.}
_gammagreen={$_gammagreen+0.3*$_midlev/100.}
_gammablue={$_gammablue+0.3*$_midlev/100.}
-endif
_crsh={$_crsh*0.3}
_mgsh={$_mgsh*0.3}
_ybsh={$_ybsh*0.3}
-if {$_crsh>0}
_lowingreen={$_lowingreen+$_crsh}
_lowinblue={$_lowinblue+$_crsh}
_lowoutred={$_lowoutred+$_crsh}
-else
_lowinred={$_lowinred-$_crsh}
_lowoutgreen={$_lowoutgreen-$_crsh}
_lowoutblue={$_lowoutblue-$_crsh}
-endif
-if {$_mgsh>0}
_lowinred={$_lowinred+$_mgsh}
_lowinblue={$_lowinblue+$_mgsh}
_lowoutgreen={$_lowoutgreen+$_mgsh}
-else
_lowingreen={$_lowingreen-$_mgsh}
_lowoutred={$_lowoutred-$_mgsh}
_lowoutblue={$_lowoutblue-$_mgsh}
-endif
-if {$_ybsh>0}
_lowinred={$_lowinred+$_ybsh}
_lowingreen={$_lowingreen+$_ybsh}
_lowoutblue={$_lowoutblue+$_ybsh}
-else
_lowinblue={$_lowinblue-$_ybsh}
_lowoutred={$_lowoutred-$_ybsh}
_lowoutgreen={$_lowoutgreen-$_ybsh}
-endif
-if {$_shlev>0}
_lowoutred={$_lowoutred+$_shlev}
_lowoutgreen={$_lowoutgreen+$_shlev}
_lowoutblue={$_lowoutblue+$_shlev}
-endif
-if {$_shlev<0}
_lowinred={$_lowinred-$_shlev}
_lowingreen={$_lowingreen-$_shlev}
_lowinblue={$_lowinblue-$_shlev}
-endif
_crhigh={$_crhigh*0.3}
_mghigh={$_mghigh*0.3}
_ybhigh={$_ybhigh*0.3}
-if {$_crhigh>0}
_hiinred={$_hiinred-$_crhigh}
_hioutgreen={$_hioutgreen-$_crhigh}
_hioutblue={$_hioutgreen-$_crhigh}
-else
_hiingreen={$_hiingreen+$_crhigh}
_hiinblue={$_hiinblue+$_crhigh}
_hioutred={$_hioutred+$_crhigh}
-endif
-if {$_mghigh>0}
_hiingreen={$_hiingreen-$_mghigh}
_hioutred={$_hioutred-$_mghigh}
_hioutblue={$_hioutblue-$_mghigh}
-else
_hiinred={$_hiinred+$_mghigh}
_hiinblue={$_hiinblue+$_mghigh}
_hioutgreen={$_hioutgreen+$_mghigh}
-endif
-if {$_ybhigh>0}
_hiinblue={$_hiinblue-$_ybhigh}
_hioutred={$_hioutred-$_ybhigh}
_hioutgreen={$_hioutgreen-$_ybhigh}
-else
_hiinred={$_hiinred+$_ybhigh}
_hiingreen={$_hiingreen+$_ybhigh}
_hioutblue={$_hioutblue+$_ybhigh}
-endif
-if {$_highlev>0}
_hiinred={$_hiinred-$_highlev}
_hiingreen={$_hiingreen-$_highlev}
_hiinblue={$_hiinblue-$_highlev}
-endif
-if {$_highlev<0}
_hioutred={$_hioutred+$_highlev}
_hioutgreen={$_hioutgreen+$_highlev}
_hioutblue={$_hioutblue+$_highlev}
-endif
-levels $_lowinred,$_hiinred,$_gammared,$_lowoutred,$_hioutred,19
-levels $_lowingreen,$_hiingreen,$_gammagreen,$_lowoutgreen,$_hioutgreen,20
-levels $_lowinblue,$_hiinblue,$_gammablue,$_lowoutblue,$_hioutblue,21
jl_colorgrading_preview :
-gimp_split_preview "-jl_colorgrading $*",$-1
gimp_tk_colortemp :
-repeat $! -l[$>] -if {$2==1} --luminance[-1] -to_rgb[-2]
-s[-2] c  avb={-2,127.5-ia} avg={-3,127.5-ia} avr={-4,127.5-ia}
-+[-4] $avr -+[-3] $avg -+[-2] $avb -a[-4,-3,-2] c -rv -compose_luminance -endif
-gimp_mix_lab 1,0,0,1,{if({$1>=0},{$1/4},{$1*0.75})},0,1,$1,0,0,2,0 -endl -done
gimp_tk_colortemp_preview :
-gimp_split_preview "-gimp_tk_colortemp ${1--2}",$-1
gimp_apply_curve :
-ac "-_gimp_apply_curve ${1-13}",$14,$15
_gimp_apply_curve :
-apply_curve $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
gimp_apply_curve_preview :
-function1d $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
-mv. 0
-repeat {$!-1}
--gimp_split_preview. "-gimp_apply_curve $*",$-1
100%,100% -axes. 0,255,255,0,13,1,255 --dilate. 3 -r.. [-3] -j... [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
-grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
-line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
-if $-2
[-1],[-1] -to_gray... -histogram... 256,0,255 -graph. [-3],3,0,0,0,1,1 -!=. 0 -*. 255 -rm...
--xor[-2,-1] -j... [-1],0,0,0,0,$16,[-2],255 -rm[-2,-1]
-else -rm.. -endif
100%,100% -graph. [0],1,0,255,0,1,255 --dilate. 3 -r.. [-3] -j... [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
-_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
-_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
-_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
-_gimp_apply_curve_preview 255,$12,6
-mv. 1 -done -rm[0]
_gimp_apply_curve_preview :
-if {$1>=0}
x={$1*100/255}% y={100-$2*100/255}%
-ellipse. $x,$y,3,3,0,1,0xFFFFFFFF,0,0,0 -ellipse. $x,$y,2,2,0,1,0,255,0
-t. $3,$x,{$y*h-20},13,1,255
-endif
gimp_curves_interactive :
-nm "Color curves"
-repeat 4 __xcc_C$>=0,0,100,100 -done
-if {$4==$1} -l[] (${5--1}) -s -,-1 -repeat $! __xcc_C$>={$>,^} -done -rm -endl -endif
-if $3 _xcc_colorbase=${-arg\ {$4+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr} -x_color_curves last
-else
-x_color_curves ${-arg\ {$1+1},rgb,cmy,cmyk,hsi,hsl,hsv,lab,lch,ycbcr}
-u "{$1}{$2}{$3}{$1}{"$__xcc_C0,-1,$__xcc_C1,-1,$__xcc_C2,-1,$__xcc_C3,-1,$__xcc_C4"}"
-endif
-if $2
(0,255) (0;255) (0/255) -r[-3--1] 2,2,2 -a[-3--1] c
-if {$2==2} -r. 256,256,256,3,3 -r. 4096,4096,1,3,-1
-else -r. 64,64,64,3,3 -r. 512,512,1,3,-1
-endif
-x_color_curves. last
-endif
gimp_curves_interactive_preview :
-gimp_curves_interactive $1,0,1,${4--1}
gimp_apply_Labcurve : -skip $1
-gimp_apply_Labcurve_configfile
-repeat {$!-1} -l[$>,-1]
-to_colormode[0] {max(3,s)} -sh[0] 0,2 -rgb2lab. -rm.
-sh[0] 0 -*. 2.55 -_gimp_apply_Labcurve. {-2,@0-12} -/. 2.55 -rm.
-sh[0] 1 -+. 86 -*. 1.38587 -_gimp_apply_Labcurve. {-2,@13-25} -/. 1.38587 --. 86 -rm.
-sh[0] 2 -+. 108 -*. 1.25616 -_gimp_apply_Labcurve. {-2,@26-38} -/. 1.25616 --. 108 -rm.
-sh[0] 0,2 -lab2rgb. -rm.
-endl -done
-rm.
_gimp_apply_Labcurve :
-apply_curve $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
-c 0,255
gimp_apply_Lcurve_preview :
-gimp_apply_Labcurve_configfile
-sh. 0,0,0,0 -f. ${1--3} -rm.
-gimp_apply_Labcurve_preview[^-1] {^},0,${-2,-1} -rm.
gimp_apply_acurve_preview :
-gimp_apply_Labcurve_configfile
-sh. 1,1,0,0 -f. ${1--3} -rm.
-gimp_apply_Labcurve_preview[^-1] {^},1,${-2,-1} -rm.
gimp_apply_bcurve_preview :
-gimp_apply_Labcurve_configfile
-sh. 2,2,0,0 -f. ${1--3} -rm.
-gimp_apply_Labcurve_preview[^-1] {^},2,${-2,-1} -rm.
gimp_apply_Labcurve_configfile :
filename=${-path_tmp}.gmic_Labcurve.dlm
-if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r. 100%,3 -endif
gimp_apply_Labcurve_preview :
(${1--3}) -r. 13,3,1,1,-1 -o. ${-path_tmp}.gmic_Labcurve.dlm -rm.
-function1d $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
-function1d $26,0,$14,\
${"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
${"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
${"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
${"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
${"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
255,$25
-function1d $39,0,$27,\
${"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
${"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
${"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
${"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
${"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
255,$38
-a[-3--1] y -mv. 0
-repeat {$!-1}
--gimp_split_preview. "-gimp_apply_Labcurve 0",$-1
-axes. 0,255,255,0,13,1,255
100%,100% -axes. 0,255,255,0,13,1,255 --dilate. 3 -r.. [-3] -j... [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
-grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
-line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
-if $-2
[-1],[-1],1,1,-{$-2*255/100} -to_gray... -histogram... 256,0,255 -graph. [-3],3,0,0,0,1,0
-rm... -+. {$-2*255/100} -+[-2,-1] -c. 0,255
-else -rm.. -endif
-line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
-sh[0] 0,0,0,0
-graph.. [-1],1,0,255,0,1,255,255,255 --. 1
-graph.. [-1],1,0,255,0,0.5,200,200,200 -rm.
-sh[0] 1,1,0,0
-graph.. [-1],1,0,255,0,1,255,128,128 --. 1
-graph.. [-1],1,0,255,0,0.5,200,0,0 -rm.
-sh[0] 2,2,0,0
-graph.. [-1],1,0,255,0,1,128,128,255 --. 1
-graph.. [-1],1,0,255,0,0.5,0,0,200 -rm.
-if {$40==0}
-_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
-_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
-_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
-_gimp_apply_curve_preview 255,$12,6
-elif {$40==1}
-_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
-_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
-_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
-_gimp_apply_curve_preview 255,$25,6
-else
-_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
-_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
-_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
-_gimp_apply_curve_preview 255,$38,6
-endif
-mv. 1 -done -rm[0]
gimp_apply_RGBcurve : -skip $1
-gimp_apply_RGBcurve_configfile
-repeat {$!-1} -l[$>,-1]
-to_colormode[0] {max(3,s)}
-sh[0] 0 -_gimp_apply_RGBcurve. {-2,@0-12} -rm.
-sh[0] 1 -_gimp_apply_RGBcurve. {-2,@13-25} -rm.
-sh[0] 2 -_gimp_apply_RGBcurve. {-2,@26-38} -rm.
-endl -done
-rm.
_gimp_apply_RGBcurve :
-apply_curve $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
-c 0,255
gimp_apply_Rcurve_preview :
-gimp_apply_RGBcurve_configfile
-sh. 0,0,0,0 -f. ${1--3} -rm.
-gimp_apply_RGBcurve_preview[^-1] {^},0,${-2,-1} -rm.
gimp_apply_Gcurve_preview :
-gimp_apply_RGBcurve_configfile
-sh. 1,1,0,0 -f. ${1--3} -rm.
-gimp_apply_RGBcurve_preview[^-1] {^},1,${-2,-1} -rm.
gimp_apply_Bcurve_preview :
-gimp_apply_RGBcurve_configfile
-sh. 2,2,0,0 -f. ${1--3} -rm.
-gimp_apply_RGBcurve_preview[^-1] {^},2,${-2,-1} -rm.
gimp_apply_RGBcurve_configfile :
filename=${-path_tmp}.gmic_RGBcurve.dlm
-if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r. 100%,3 -endif
gimp_apply_RGBcurve_preview :
(${1--3}) -r. 13,3,1,1,-1 -o. ${-path_tmp}.gmic_RGBcurve.dlm -rm.
-function1d $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
-function1d $26,0,$14,\
${"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
${"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
${"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
${"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
${"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
255,$25
-function1d $39,0,$27,\
${"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
${"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
${"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
${"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
${"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
255,$38
-a[-3--1] y -mv. 0
-repeat {$!-1}
--gimp_split_preview. "-gimp_apply_RGBcurve 0",$-1
100%,100% -axes. 0,255,255,0,13,1,255 --dilate. 3 -r.. [-3] -j... [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
-grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
-line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
-if $-2
[-1],[-1],1,1,-{$-2*255/100} -to_gray... -histogram... 256,0,255 -graph. [-3],3,0,0,0,1,0
-rm... -+. {$-2*255/100} -+[-2,-1] -c. 0,255
-else -rm.. -endif
-line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
-sh[0] 0,0,0,0
-graph.. [-1],1,0,255,0,1,255,128,128 --. 1
-graph.. [-1],1,0,255,0,0.5,200,0,0 -rm.
-sh[0] 1,1,0,0
-graph.. [-1],1,0,255,0,1,128,255,128 --. 1
-graph.. [-1],1,0,255,0,0.5,0,200,0 -rm.
-sh[0] 2,2,0,0
-graph.. [-1],1,0,255,0,1,128,128,255 --. 1
-graph.. [-1],1,0,255,0,0.5,0,0,200 -rm.
-if {$40==0}
-_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
-_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
-_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
-_gimp_apply_curve_preview 255,$12,6
-elif {$40==1}
-_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
-_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
-_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
-_gimp_apply_curve_preview 255,$25,6
-else
-_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
-_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
-_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
-_gimp_apply_curve_preview 255,$38,6
-endif
-mv. 1 -done -rm[0]
gimp_apply_YCbCrcurve : -skip $1
-gimp_apply_YCbCrcurve_configfile
-repeat {$!-1} -l[$>,-1]
-to_colormode[0] {max(3,s)} -sh[0] 0,2 -rgb2ycbcr. -rm.
-sh[0] 0 -_gimp_apply_YCbCrcurve. {-2,@0-12} -rm.
-sh[0] 1 -_gimp_apply_YCbCrcurve. {-2,@13-25} -rm.
-sh[0] 2 -_gimp_apply_YCbCrcurve. {-2,@26-38} -rm.
-sh[0] 0,2 -ycbcr2rgb. -rm.
-endl -done
-rm.
_gimp_apply_YCbCrcurve :
-apply_curve $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
-c 0,255
gimp_apply_Ycurve_preview :
-gimp_apply_YCbCrcurve_configfile
-sh. 0,0,0,0 -f. ${1--3} -rm.
-gimp_apply_YCbCrcurve_preview[^-1] {^},0,${-2,-1} -rm.
gimp_apply_Cbcurve_preview :
-gimp_apply_YCbCrcurve_configfile
-sh. 1,1,0,0 -f. ${1--3} -rm.
-gimp_apply_YCbCrcurve_preview[^-1] {^},1,${-2,-1} -rm.
gimp_apply_Crcurve_preview :
-gimp_apply_YCbCrcurve_configfile
-sh. 2,2,0,0 -f. ${1--3} -rm.
-gimp_apply_YCbCrcurve_preview[^-1] {^},2,${-2,-1} -rm.
gimp_apply_YCbCrcurve_configfile :
filename=${-path_tmp}.gmic_YCbCrcurve.dlm
-if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r. 100%,3 -endif
gimp_apply_YCbCrcurve_preview :
(${1--3}) -r. 13,3,1,1,-1 -o. ${-path_tmp}.gmic_YCbCrcurve.dlm -rm.
-function1d $13,0,$1,\
${"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
${"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
${"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
${"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
${"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
255,$12
-function1d $26,0,$14,\
${"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
${"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
${"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
${"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
${"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
255,$25
-function1d $39,0,$27,\
${"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
${"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
${"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
${"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
${"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
255,$38
-a[-3--1] y -mv. 0
-repeat {$!-1}
--gimp_split_preview. "-gimp_apply_YCbCrcurve 0",$-1
-axes. 0,255,255,0,13,1,255
100%,100% -axes. 0,255,255,0,13,1,255 --dilate. 3 -r.. [-3] -j... [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
-grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
-line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
-if $-2
[-1],[-1],1,1,-{$-2*255/100} -to_gray... -histogram... 256,0,255 -graph. [-3],3,0,0,0,1,0
-rm... -+. {$-2*255/100} -+[-2,-1] -c. 0,255
-else -rm.. -endif
-line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
-sh[0] 0,0,0,0
-graph.. [-1],1,0,255,0,1,255,255,255 --. 1
-graph.. [-1],1,0,255,0,0.5,200,200,200 -rm.
-sh[0] 1,1,0,0
-graph.. [-1],1,0,255,0,1,128,128,255 --. 1
-graph.. [-1],1,0,255,0,0.5,0,0,200 -rm.
-sh[0] 2,2,0,0
-graph.. [-1],1,0,255,0,1,255,128,128 --. 1
-graph.. [-1],1,0,255,0,0.5,200,0,0 -rm.
-if {$40==0}
-_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
-_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
-_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
-_gimp_apply_curve_preview 255,$12,6
-elif {$40==1}
-_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
-_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
-_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
-_gimp_apply_curve_preview 255,$25,6
-else
-_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
-_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
-_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
-_gimp_apply_curve_preview 255,$38,6
-endif
-mv. 1 -done -rm[0]
gimp_decompose_channels :
-if {!$2}
-if $4 -to_rgba -else -to_rgb -endif
-repeat $! -l.
nm={0,n}
-split_opacity -_gimp_decompose_channels$1[0]
-s[0] c -if {!$3} -a x -endif
nb=$!
-nm $nm
-endl -mv[-$nb--1] 0 -done
-else
-channels 0 nbc={3+($1==10)} nb={$nbc+$4}
-if $3 -repeat {int($!/$nb)} -l[0-{$nb-1}]
-a[0-{$nbc-1}] c -_gimp_recompose_channels$1[0] -a c
-endl -mv. 0 -done
-else -repeat $! -l[$>]
-s x,$nb -a[0-{$nbc-1}] c -_gimp_recompose_channels$1[0] -a c
-endl -mv. 0 -done -endif
-endif
gimp_decompose_channels_preview :
-gimp_decompose_channels ${^0} -append_tiles ,
_gimp_decompose_channels0 :
_gimp_decompose_channels1 : -rgb2hsv8
_gimp_decompose_channels2 : -rgb2hsl8
_gimp_decompose_channels3 : -rgb2hsi8
_gimp_decompose_channels4 : -rgb2yuv8
_gimp_decompose_channels5 : -rgb2ycbcr
_gimp_decompose_channels6 : -rgb2xyz8
_gimp_decompose_channels7 : -rgb2lab8
_gimp_decompose_channels8 : -rgb2lch8
_gimp_decompose_channels9 : -rgb2cmy
_gimp_decompose_channels10 : -rgb2cmyk
_gimp_decompose_channels11 : -rgb2yiq8
_gimp_recompose_channels0 :
_gimp_recompose_channels1 : -hsv82rgb
_gimp_recompose_channels2 : -hsl82rgb
_gimp_recompose_channels3 : -hsi82rgb
_gimp_recompose_channels4 : -yuv82rgb
_gimp_recompose_channels5 : -ycbcr2rgb
_gimp_recompose_channels6 : -xyz82rgb
_gimp_recompose_channels7 : -lab82rgb
_gimp_recompose_channels8 : -lch82rgb
_gimp_recompose_channels9 : -cmy2rgb
_gimp_recompose_channels10 : -cmyk2rgb
_gimp_recompose_channels11 : -yiq82rgb
gimp_detect_skin :
-to_rgb
-m "_gimp_detect_skin :
-if $5 -balance_gamma 128,128,128 -endif
-if $1 -detect_skin $2 -else -detect_skin $2,$6%,$7%,$8% -endif
M={iM} -b $3% -* {255*$M/iM} -* $4 -c 0,255"
-repeat $! -l[$>]
-if $9
--_gimp_detect_skin -a c
-if {$9>1} -sh 100% -*. -1 -+. 255 -rm. -endif
-else -_gimp_detect_skin
-endif
-endl -done
-uncommand _gimp_detect_skin
gimp_detect_skin_preview :
-gimp_split_preview "-gimp_detect_skin $*",$-1
-to_rgba
-if {!$1}
-circle $6%,$7%,$8%,0.3,0,255,0,255
-circle $6%,$7%,$8%,1,0xFFFFFFFF,0,255,0,255
-line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
-line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
-endif
gimp_hsv_equalizer :
-repeat $! -l[$>]
-to_rgb -rgb2hsv -s c
--f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
--f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
--f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0)
--threshold[1,2] 0.01 -*[-1,-2] [-1]x2 -*[-1,3] -*[-1,4] -*[-1,5]
--*[3] $4 --*[4] $9 --*[5] $14 -+[-1,-2,-3]
-+[-1,0] -%[0] 360
-if {$5>=0} --*[3] -$5 -else --*[3] {1/(1+$5)-1} -endif -+. 1
-if {$10>=0} --*[4] -$10 -else --*[4] {1/(1+$10)-1} -endif -+. 1
-if {$15>=0} --*[5] -$15 -else --*[5] {1/(1+$15)-1} -endif -+. 1
-*[-1,-2,-3] -^[1,-1]
-if {$6>=0} --*[3] -$6 -else --*[3] {1/(1+$6)-1} -endif -+. 1
-if {$11>=0} --*[4] -$11 -else --*[4] {1/(1+$11)-1} -endif -+. 1
-if {$16>=0} --*[5] -$16 -else --*[5] {1/(1+$16)-1} -endif -+. 1
-*[-1,-2,-3] -^[2,-1]
-rm[3,4,5] -a[0,1,2] c -hsv2rgb
-endl -done
gimp_hsv_equalizer_preview :
-l.
-if {$1==0} -gimp_hsv_equalizer $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
-else
-to_rgb -rgb2hsv -s c
(0,359) -r. [-2],{{0,h}/10},1,1,3 [-1] -f. 1
-j[0] [3],0,91% -j[1] [4],0,91% -j[2] [4],0,91% -rm[-1,-2]
--f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
--f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
--f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0)
-|[-3--1] -+. 0.33 -/. 1.33
-*[2,-1] -a c -hsv2rgb
-endif -endl
gcd_hsl : -skip ${1=1},${2=0},${3=0},${4=180},${5=0.2},${6=0},${7=1},${8=1}
-repeat $! -l[$>]
-split_opacity -to_rgb[0] -rgb2hsv[0]
-if $6
--channels[0] 0
-histogram[-1] 360,0,360
hue={(xM+180)%360} -rm[-1]
-else hue=$4 -endif
-sh[0] 1,1
-if $3 sat={-max(0,ia-0.5)} -else sat=$2 -endif
--[-1] 0.5 -*[-1] $1 -+[-1] $sat
-+[-1] 0.5 -c[-1] 0,1 -rm[-1]
-hsv2rgb[0]
--channels[0] 0 -*[-1] 66
--channels[0] 1 -*[-1] 129 -+[-2,-1]
--channels[0] 2 -*[-1] 25 -+[-2,-1]
-+[-1] 128 -/[-1] 256 -+[-1] 16
-apply_gamma[-1] {max(0.001,$7)}
-if {$8!=1} --[-1] 128 -*[-1] $8 -+[-1] 128 -endif
-c[-1] 0,255
-sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
($hue^1^1) -hsv2rgb[-1] -n[-1] {1-$5},1
-*[-4] {@0} -*[-3] {@1} -*[-2] {@2}
-rm[-4--1] -rgb2ycbcr[0] -j[0] [-1] -rm[-1]
-ycbcr2rgb[0] -a c
-endl -done
gcd_hsl_preview :
-gimp_split_preview "-gcd_hsl ${1--2}",$-1
gcd_hsv_select :
-skip ${1=0},${2=0.5},${3=1} -skip ${4=180},${5=0.5},${6=0.5}
-skip ${7=2},${8=2} -skip ${9=18},${10=0},${11=0},${12=0}
-repeat $! -l[$>]
-to_rgba[0] -remove_opacity[0]
-if {!$12} [0] -endif
-l[-1]
-gcd_shrink
--rgb2hsv[0] -s[-1] c
bh={$1-$4} th={$1+$4}
--ge[1] {360+$bh} --le[1] {$th-360}
-ir[1] {max($bh,0)},{min($th,360)}
-or[-2,-1] -or[1,-1]
-ir[2] {$2-$5},{$2+$5}
-ir[3] {$3-$6},{$3+$6}
-and[-2,-1] -and[-2,-1]
-meancurvature_flow[0] 3 -median[0] 3
-+[0] 1 --gradient_norm[0] --b[-1] 2,1,1 -min_patch[-1] $9
-*[0,-1] -*[-1] -1
--*[0] [1] -gt[0] 0 -negative[1] -*[0,1] -*[0] 0.5 -max[0,-1]
--watershed[0] [-1] -k[-1] --[-1] 1
-gcd_unshrink
-endl
-if {!$12}
-channels[-1] 0 -ge[-1] 0
--area[-1] 0 --le[-1] {($10%*max(w,h))^2}
--negative[-3] -*[-2,-1] -inpaint[-3] [-1] -rm[-1]
-le[-1] {($11%*max(w,h))^2} -*[-1] [-2]
-inpaint[-2] [-1] -rm[-1] -*[-1] 255
-if {$7>0} -dilate[-1] $7
-elif {$7<0} -erode[-1] {abs($7)} -endif
-if $8 -b[-1] $8,1,1 -endif
-a[-2,-1] c
-endif
-c[-1] 0,255
-endl -done
iain_hue_light_dark_p:
-repeat $! -l[$>]
-apply_parallel_overlap "-iain_hue_light_dark ${1--2}",0,${-1}
-endl -done
iain_hue_light_dark:
-repeat $! -l[$>] -split_opacity -l[0]
--l[0]
-to_rgb
-if {$20==0}
-rgb2hsv8
-else
-rgb2hsl8
-endif
-s c
--apply_curve[0] 0,0,{128+$1},16,{128+$2},30,{128+$3},42,{128+$4},60,{128+$5},75,{128+$6},85,{128+$7},105,{128+$8},127,{128+$9},135,{128+$10},150,{128+$11},170,{128+$12},180,{128+$13},195,{128+$14},213,{128+$15},225,{128+$16},240,{128+$17},255,{128+$18}
-sub[-1] 128
-add[-1] $19
-add[-1,-2]
-a c
-if {$20==0}
-hsv82rgb
-else
-hsl82rgb
-endif
-endl
--rgb2hsv[0]
-s[-1] c
-keep[0,1,-1,-2]
-mul[-1,-2] 255
-apply_curve[-2] 0,0,0,$22,0,$21,255,255,255
-apply_curve[-1] 0,0,0,$24,0,$23,255,255,255
-mul[-1] [-2]
-div[-1] 255
-remove[-2]
-c[-1] 0,255
-a[1,2] c
-blend[0,1] alpha
-if {$25==1}
-to_gray
-endif
-endl -a c -endl -done
gimp_tk_metallic :
-repeat $! -l[$>]
-gimp_gaussian_blur $2,0,0,1,1,0,0
-luminance --luminance
-gimp_apply_curve[1] 0,31,111,64,17,110,176,148,75,177,235,186,1,0,0,0,0
-gimp_apply_curve[1] 0,31,111,64,17,110,176,148,75,177,235,186,1,0,0,0,0
-rv[0,1] -gimp_compose_value[0,1] $1,0
-if {$3==1} -gimp_mix_rgb 1,50,0,1,50,0,1,-50,0,0,2,0
-elif {$3==2} -gimp_mix_rgb 1,75,0,1,5,0,1,-25,0,0,2,0
-elif {$3==3} -gimp_mix_rgb 1,70,0,1,40,0,1,-20,0,0,2,0
-elif {$3==4} -gimp_mix_rgb 1,-5,0,1,0,0,1.1,12,0,0,2,0
-endif -endl -done
gimp_tk_metallic_preview :
-gimp_split_preview "-gimp_tk_metallic ${1--2}",$-1
gimp_mix_cmyk :
-repeat $! -l. -split_opacity -rv -to_rgb.
-gimp_start_mix $13,$14
-rgb2cmyk. -s. c
-*[-4] $1 -+[-4] $2 -b[-4] $3%
-*... $4 -+... $5 -b... $6%
-*.. $7 -+.. $8 -b.. $9%
-*. $10 -+. $11 -b. $12%
-a[-4--1] c -cmyk2rgb.
-gimp_end_mix $13
-if {$!!=3} -rv -a c -endif -endl -mv. 0 -done
gimp_mix_cmyk_preview :
-gimp_split_preview "-gimp_mix_cmyk $*",$-1
gimp_mix_hsv :
-repeat $! -l. -split_opacity -rv -to_rgb.
-gimp_start_mix $10,$11
-rgb2hsv. -s. c --[-2,-1] 0.5
-*... $1 -+... $2 -b... $3%
-*.. $4 -+.. $5 -b.. $6%
-*. $7 -+. $8 -b. $9%
-%... 360 -+[-2,-1] 0.5 -c[-2,-1] 0,1 -a[-3--1] c -hsv2rgb.
-gimp_end_mix $10
-if {$!!=3} -rv -a c -endif -endl -mv. 0 -done
gimp_mix_hsv_preview :
-gimp_split_preview "-gimp_mix_hsv $*",$-1
gimp_mix_lab :
-repeat $! -l[$>] -split_opacity -to_rgb[0]
-gimp_parallel_overlap[0] "-_gimp_mix_lab $*",0,{3*max($3,$6,$9)}
-a c
-endl -mv[$>] 0 -done
_gimp_mix_lab :
-gimp_start_mix $10,$11
-rgb2lab. -s. c
-*... $1 -+... $2 -b... $3%
-*.. $4 -+.. $5 -b.. $6%
-*. $7 -+. $8 -b. $9%
-a[-3--1] c -lab2rgb.
-gimp_end_mix $10
gimp_mix_lab_preview :
-gimp_split_preview "-gimp_mix_lab $*",$-1
gimp_start_mix :
-if {$1==1} --tones. 3 -+[-2,-1] -b[-2,-1] $2% -r[-2,-1] [-3] -*. [-3] -mv... $!
-elif {$1==2} --tones. 3 -+[-3,-1] -b[-2,-1] $2% -r[-2,-1] [-3] -*.. [-3] -mv... $!
-elif {$1==3} --tones. 3 -+[-3,-2] -b[-2,-1] $2% -r[-2,-1] [-3] -*.. [-3] -mv... $!
-endif
gimp_end_mix :
-if {$1==1} -*[-3,-1] -+[-2,-1]
-elif {$1==2} -*[-2,-1] -+[-2,-1]
-elif {$1==3} -*[-2,-1] -+[-2,-1]
-endif
gimp_mix_rgb :
-repeat $! -l. -split_opacity -rv -to_rgb.
-gimp_start_mix $10,$11
--. 128 -s. c
-*... $1 -+... $2 -b... $3%
-*.. $4 -+.. $5 -b.. $6%
-*. $7 -+. $8 -b. $9%
-a[-3--1] c -+. 128 -c. 0,255
-gimp_end_mix $10
-if {$!!=3} -rv -a c -endif -endl -mv. 0 -done
gimp_mix_rgb_preview :
-gimp_split_preview "-gimp_mix_rgb $*",$-1
gimp_mix_ycbcr :
-repeat $! -l. -split_opacity -rv -to_rgb.
-gimp_start_mix $10,$11
-rgb2ycbcr. --. 128 -s. c
-*... $1 -+... $2 -b... $3%
-*.. $4 -+.. $5 -b.. $6%
-*. $7 -+. $8 -b. $9%
-a[-3--1] c -+. 128 -c. 0,255 -ycbcr2rgb.
-gimp_end_mix $10
-if {$!!=3} -rv -a c -endif -endl -mv. 0 -done
gimp_mix_ycbcr_preview :
-gimp_split_preview "-gimp_mix_ycbcr $*",$-1
iain_rgb_tone:
-repeat $! -l[$>] -split_opacity -l[0]
-to_rgb
--split c
--apply_curve[1] 0,0,$1,128,$2,255,$3
--apply_curve[2] 0,0,$4,128,$5,255,$6
--apply_curve[3] 0,0,$7,128,$8,255,$9
-add[-1,-2,-3]
--apply_curve[1] 0,0,$10,128,$11,255,$12
--apply_curve[2] 0,0,$13,128,$14,255,$15
--apply_curve[3] 0,0,$16,128,$17,255,$18
-add[-1,-2,-3]
--apply_curve[1] 0,0,$19,128,$20,255,$21
--apply_curve[2] 0,0,$22,128,$23,255,$24
--apply_curve[3] 0,0,$25,128,$26,255,$27
-add[-1,-2,-3]
-add[1,4]
-add[2,4]
-add[3,4]
-a[-1,-2,-3] c
--sub[0,1]
--rgb2hsv[0] -split[-1] c -remove[-1,-3] -mul[-1] 255
-apply_curve[-1] 0,0,$28,64,$29,128,$30,192,$31,255,$32
-compose_multiply[-1,-2]
--sub[0,-1]
-if {$33==0}
-luminance[0]
--luminance[-1]
-compose_grainextract[-1,-2]
-compose_grainmerge[0,-1]
-keep[0]
-endif
-if {$33==1}
-keep[-1]
-c 0,255
-endif
-if {$33==2}
-keep[-1]
-n 0,255
-endif
-endl -a c -endl -done
#
####################################
variance_noise :
-u {${-std_noise}^2}
Saturation_EQ_p:
-repeat $! -l[$>]
-apply_parallel_overlap "-Saturation_EQ ${1-19}",
-endl -done
Saturation_EQ:
-repeat $! -l[$>] -split_opacity -l[0]
-to_rgb -rgb2hsl8
-split[-1] c
--apply_curve[2] .5,0,{128+$1},31,{128+$2},63,{128+$3},95,{128+$4},128,{128+$5},160,{128+$6},192,{128+$7},224,{128+$8},255,{128+$9}
--+[0] {((($19/360)*255))*-1}
-mod[-1] 255
-apply_curve[-1] .5,0,{128+$10},31,{128+$11},63,{128+$12},95,{128+$13},128,{128+$14},160,{128+$15},192,{128+$16},224,{128+$17},255,{128+$18}
-sub[-1,-2] 128
-add[-1,-2]
-mul[-1] 2
-add[1,3]
-c[1] 0,255
-append c
-hsl82rgb
-endl -a c -endl -done
_gimp_select_color :
-if {$1==1} -to_rgb
-elif {$1==2} -to_rgb -rgb2ycbcr
-elif {$1==3} -channels 0
-elif {$1==4} -channels 1
-elif {$1==5} -channels 2
-elif {$1==6} -to_rgba -channels 3
-elif {$1==7} -to_rgb -rgb2ycbcr -channels 0
-elif {$1==8} -to_rgb -rgb2ycbcr -channels 1,2
-elif {$1==9} -to_rgb -rgb2hsv -channels 0
-elif {$1==10} -to_rgb -rgb2hsv -channels 1
-endif
gimp_select_color :
($5^$6^$7^$8) -_gimp_select_color. $1 color={^} -rm.
-repeat $! -l[$>] -to_rgba
--_gimp_select_color $1
-select_color[1] $2%,$color
-if $4 --area. 0,0 -<=. {round($4^1.5)} -inpaint.. [-1],0,3 -rm. -endif
-b[1] $3 -n[1] 0,255
-if {$9==0} -sh[0] 100% -&. [1]
-elif {$9==1} -rm[0]
-elif {$9==2} --[1] 255 -*[1] -1 -sh[0] 100% -&. [1]
-elif {$9==3} -rm[0] -- 255 -* -1
-else
-/[1] 255 --*[0,1] --*[1] $11 --*[1] $12 --*[1] $13 -*[1] $10 -a[1,-3--1] c --[1,2] -+
-endif
-k[0]
-endl -done
gimp_select_color_preview :
-gimp_split_preview "-gimp_select_color $*",$-1
gimp_selective_desaturation :
-repeat $! -l[$>] -to_color -split_opacity -l[0]
--fc $1,$2,$3
--[1] [0] -norm[1] -/[1] {1e-6+iM}
-if $4 -*[1] -{max(0.01,$5)} -+[1] 1
-else -ge[1] {5*$5}%
-endif
-c[1] 0,1
-rgb2hsl[0] -s[0] c
mM={im},{iM} -repeat $6 -guided. [2],1,0.1 -done -n. $mM
-if {$7==0} -*[1,-1]
-elif {$7==1} ($1^$2^$3) -rgb2hsl. -*[1] {i[1]} -rm[-2,-1]
-else -rv[1,-1] -rm.
-endif
-a c -hsl2rgb
-endl -a c -endl -done
gimp_selective_desaturation_preview :
-gimp_split_preview "-gimp_selective_desaturation $*",$-1
gimp_sepia :
-sepia
-repeat $!
-sh. 0,2 -apply_gamma. {10^$1} --. 128 -*. $2 -+. {128+$3} -c. 0,255
-rm. -mv. 0 -done
gimp_sepia_preview :
-gimp_split_preview "-gimp_sepia $*",$-1
gcd_hio_levels : -skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0},${8=0},${9=0},${10=0}
-if {$8} -_gcd_hio_levels[0] ${1--4} -else -_gcd_hio_levels ${1--4} -endif
-if {$10" && "$!>1} -rv -blend alpha -endif
_gcd_hio_levels : -skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0}
-repeat $! -l[$>]
-split_opacity -to_rgb[0] --gcd_srgb2luma[0]
-if {$4!=0}
-sh[0] 0 -sh[0] 1 -sh[0] 2,2
({$3%360}^1^1) -hsv2rgb. -max. 0 -*. $4 --. {ia}
-+[-4] {@0} -+[-3] {@1} -+[-2] {@2} -rm[-4--1] -max[0] 0
-endif
-gcd_hue_chroma[0] $3,$1,$2
-gcd_srgb2jpeg[0] -j[0] [-1] -rm.
-max[0] 0 -sh[0] 0 srgb={($5!=1" || "$6!=1)" && "$7}
-if $srgb -srgb2rgb. -endif
-gcd_gamma. $5
-if {$6!=1}
m={iM/2} --. $m --sign. -abs..
-gcd_gamma.. $6,1,$m -*[-2,-1] -+. $m
-endif
-if $srgb -rgb2srgb. -endif
-rm. -gcd_jpeg2srgb[0] -a c -c 0,255
-endl -done
gcd_hio_levels_preview :
-if {$-2==7} -gcd_hio_levels ${1--2},1
-else -gimp_split_preview "-gcd_hio_levels $*",$-2 -endif
gcd_hue_chroma : -skip ${1=0},${2=1},${3=1}
-if {$2==1" && "$3==1} -return -endif
-repeat $! -l[$>]
h={($1%360)/60} x={1-abs($h%2-1)} y={if($x>0,1/$x,0)} h={int($h)+1}
p={arg($h,0,1,1,2,2,0)} s={arg($h,1,0,2,1,0,2)} z={arg($h,2,2,0,0,1,1)}
[0] -sh. $p -sh.. $s --*.. $x
--le. [-2] -j[-3] [-2],0,0,0,0,1,[-1] -rm..
-eq. 0 --*.. $y -j[-4] [-1],0,0,0,0,1,[-2]
-rm[-4--1] -sh. $z -f. 0 -rm.
-sh. $p --compose_channels[0] min --eq.. 0 -+. [-3]
-if {$3!=1}
--/[-2,-1] --. 1 -r. 100%,100%,1,3 -*. [-5] -+[0] [-1]
--compose_channels[0] min --[0] [-1] -*[0] $3 -+[0,-1] --[0,-1]
-endif
-if {$2!=1} ---[-3,-2] -*. $2 -+[-3,-1] -/[-2,-1] --. 1 -*[-3,-1] -rm. -+
-else -k[0] -endif
-endl -done
iain_tone_presets_p:
-repeat $! -l[$>]
-apply_parallel_overlap "-iain_tone_presets ${1--2}",0,${-1}
-endl -done
iain_tone_presets:
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0}
--iain_rgb_tone 00,10,00,00,00,00,00,00,00,00,00,00,00,10,00,00,00,00,00,20,00,00,20,00,00,00,00,255,0,0,0,0,0
-endif
-if {$1==1}
--iain_cmyk_tone 00,00,00,00,00,00,-8,-20,00,00,00,-49,00,00,00,00,00,00,00,-25,00,00,17,0,00,00,00,00,00,00,35,-25,17,8,26,31,00,00,00,00,17,00,-9,-31,29,00,00,-9,188,255,181,133,72,1
-endif
-if {$1==2}
--iain_cmyk_tone 00,-38,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,-164,88,255,00,00,00,00,00,00,00,00,00,65,33,-15,00,00,00,00,00,00,00,00,00,00,00,-25,128,92,62,45,38,1
-endif
-if {$1==3}
--iain_cmyk_tone -25,50,00,25,00,00,25,00,00,00,00,00,025,25,00,-50,00,00,25,00,00,00,00,00,025,00,00,25,00,00,-50,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,36,178,255,169,94,2
-endif
-if {$1==4}
--iain_cmyk_tone 25,-50,00,-25,00,00,-25,00,00,00,00,00,-025,-25,00,50,00,00,-25,00,00,00,00,00,-025,00,00,-25,00,00,50,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,17,120,240,255,255,4
-endif
-if {$1==5}
--iain_cmyk_tone 000,00,00,00,00,00,00,00,00,00,00,-60,000,00,00,00,00,00,00,00,00,-22,40,161,000,00,00,0,00,00,00,00,28,33,33,16,00,00,00,00,00,00,00,00,00,77,-8,-80,255,255,255,255,255,0
-endif
-if {$1==6}
--iain_cmyk_tone 000,00,00,00,00,00,00,00,00,00,00,00,000,00,00,00,00,00,00,00,00,07,-20,-33,000,00,00,00,00,00,00,00,00,48,-65,-77,000,00,00,00,00,00,00,00,00,45,45,00,255,255,255,255,255,0,0
-endif
-if {$1==7}
--iain_cmyk_tone 000,20,00,00,08,00,00,00,00,00,-23,00,000,-13,00,0,17,00,00,00,00,-1,29,00,000,00,00,00,00,-12,00,00,00,19,68,18,000,00,00,00,00,00,00,00,00,-5,55,-15,128,255,255,255,255,0,0
-endif
--sub[0,1]
-mul[-1] {{$2/100}*-1}
-+[0,-1]
-keep[0]
-if {$3==0}
-c 0,255
-else
-n 0,255
-endif
-endl -a c -endl -done
#
#######################################
gimp_transfer_rgb :
-to_rgb
ref={if($4,0,-1)}
-transfer_rgb[^$ref] [$ref],0.25,$1,$2,{2^(4+$3)},$5,0
gimp_transfer_rgb_preview :
-if {$!<2} -gimp_print_preview "Warning:",,"This filter requires at least two input layers to work properly." -return -endif
ref={if($4,0,-1)}
pf=${-path_tmp}gmic_tmp -o[$ref] $pf
-gimp_split_preview[^$ref] "-i "$pf" -gimp_transfer_rgb $1,$2,0,0,0 -rm.",$-1
-if $4 -mv[0] $! -endif
-if $6 -repeat {$!-1} -l[$>,-1]
--r2dy. {0,h/3} -text_outline. Reference,2,2,13,1,1,255 -frame. 2,2,255 -frame. 1,1,0
-if {$6==1} -j[0] [-1],5,5
-elif {$6==2} -j[0] [-1],{{0,w}-w-6},6
-elif {$6==3} -j[0] [-1],5,{{0,h}-h-6}
-else -j[0] [-1],{{0,w}-w-6},{{0,h}-h-6}
-endif
-rm.
-endl -done -endif
gimp_transfer_colors :
-if ${2=0} -_gimp_revert_layers -endif
-transfer_colors[^-1] [-1],$1
gimp_custom_transform :
-to_rgba -repeat $!
-f. "$1"
-s. c -a[-4--2] c -f.. "$2"
-s.. c -f[-4] "$3" -f... "$4" -f.. "$5" -f. "$6"
-if {$7==0} -a[-4--1] c -c. 0,255
-elif {$7==1} -a[-4--2] c -n.. 0,255 -c. 0,255 -a[-2,-1] c
-else -a[-4--1] c -n. 0,255
-endif
-mv. 0 -done
gimp_tk_vintage :
-repeat $! -l[$>]
-to_rgb[0] --luminance[0] --luminance[0] --luminance[0]
-gimp_mix_lab[0] $2,{$1*10},0,$3,0,0,$3,0,0,0,2,0
-tk_gimp_channel_processing[-1] 1,1,0,0,4,{$4/2.55},100,256,0,1,0,2,0,0
-tk_gimp_channel_processing[-2] 1,1,0,0,4,{$4/2.55},{$5/2.55},256,0,0,0,2,0,0
-tk_gimp_channel_processing[-3] 1,1,0,0,4,0,{$5/2.55},256,0,1,0,2,0,0
-to_gray[-1,-2,-3] -gimp_gaussian_blur[-1,-2,-3] $6,0,0,1,0,0,0
--fc[0] $7,$8,$9 --fc[0] $11,$12,$13 --fc[0] $15,$16,$17 -to_rgba[-1,-2,-3]
-s[-1] c -rv[-1,-9] -compose_multiply[-1,-9] -mv[-8] 9 -a[-4,-3,-2,-1] c
-s[-2] c -rv[-2,-8] -compose_multiply[-2,-8] -mv[-7] 7 -a[-5,-4,-3,-2] c
-s[-3] c -rv[-3,-7] -compose_multiply[-3,-7] -mv[-6] 5 -a[-6,-5,-4,-3] c
--fc[0] $19,$20,$21 -rv[-1,-5]
-if {$22==0} -gimp_compose_exclusion[-1,-5] $23
-elif {$22==1} -gimp_compose_overlay[-1,-5] $23
-elif {$22==2} -gimp_compose_softlight[-1,-5] $23
-elif {$22==3} -gimp_compose_multiply[-1,-5] $23
-elif {$22==4} -gimp_compose_screen[-1,-5] $23
-endif
-rv[-3,-4] -gimp_compose_lighten[-3,-4] $10
-rv[-2,-3] -gimp_compose_overlay[-2,-3] $14
-rv[-1,-2] -gimp_compose_darken[-1,-2] $18
-if {$25!=0}
--fc[0] 255,255,255 -gimp_frame_round[-1] 2,$24,0,0,0,0,0,255,100,0.1,3
-gimp_gaussian_blur[-1] {$6*5},0,0,1,0,0,0
-rv[-1,-2] -gimp_compose_multiply[-1,-2] $25 -endif
-endl -done
gimp_tk_vintage_preview :
-gimp_split_preview "-gimp_tk_vintage ${1--2}",$-1
gimp_zonesystem :
-repeat $! -l[$>] -to_rgb -rgb2lab -s c -n[0] {{$1-1}*10}%,{$2*10}%
-a c -lab2rgb -tk_gimp_channel_processing $3,$4,0,0,0,0,100,256,0,0,0,2,7,0
-gimp_apply_curve 0,$5,0,$6,255,-1,128,-1,128,-1,128,255,1,7,0,0,0
-endl -done
gimp_zonesystem_preview :
-gimp_split_preview "-gimp_zonesystem ${1--2}",$-1
gimp_convolve :
-ac "-_gimp_convolve $1,$2,\"$3\",${4--3}",$-2
_gimp_convolve :
-if $1 -_gimp_convolve$1[] -else ($3) -endif
-if {!$4} -*. $5 -endif
-convolve[0--2] [-1],$2
-if $4 -n 0,255 -else -c 0,255 -endif
-rm.
_gimp_convolve1 : 3,3 -f 1 -normalize_sum
_gimp_convolve2 : 5,5 -f 1 -normalize_sum
_gimp_convolve3 : 7,7 -f 1 -normalize_sum
_gimp_convolve4 : 9,9 -f 1 -normalize_sum
_gimp_convolve5 : (1,0,-1;1,0,-1;1,0,-1)
_gimp_convolve6 : (1,1,1;0,0,0;-1,-1,-1)
_gimp_convolve7 : (1,0,-1;2,0,-2;1,0,-1)
_gimp_convolve8 : (1,2,1;0,0,0;-1,-2,-1)
_gimp_convolve9 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,0,-$a;$b,0,-$b;$a,0,-$a)
_gimp_convolve10 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,$b,$a;0,0,0;-$a,-$b,-$a)
_gimp_convolve11 : (0,1,0;1,-4,1;0,1,0)
_gimp_convolve12 : (1,0;0,-1)
_gimp_convolve13 : (0,1;-1,0)
_gimp_convolve14 : 3,3 -f 1 -r 7,7,1,1,4,0,0.5,0.5 -autocrop -normalize_sum
_gimp_convolve15 : 3,3 -f 1 -r 9,9,1,1,4,0,0.5,0.5 -autocrop -normalize_sum
_gimp_convolve16 : 3,3 -f 1 -r 11,11,1,1,4,0,0.5,0.5 -autocrop -normalize_sum
gimp_convolve_preview :
-gimp_split_preview "-gimp_convolve $1,$2,\"$3\",${4--1}",$-1
gimp_curvature :
-repeat $! -l[$>] -split_opacity -l[0]
-b $1 -iee
-if $4 -abs -endif
-c $2%,$3%
-if $5 -negative -endif
-n 0,255
-endl -a c -endl -done
gimp_curvature_preview :
-gimp_split_preview "-gimp_curvature ${^0}",$-1
gimp_dog :
-dog $1%,$2%
-c $3%,{100-$3}%
-if $4 -negative -endif
-n 0,255
gimp_dog_preview :
-gimp_split_preview "-gimp_dog ${^0}",$-1
gimp_distance :
-repeat $! -l[$>] -split_opacity -l[0]
-distance $1,$2
-if {$3==0} -c 0,255
-elif {$3==1} -n 0,255
-else -% $4 -n 0,255
-endif
-endl -a c -endl -done
gimp_distance_preview :
-gimp_split_preview "-gimp_distance ${^0}",$-1
gimp_edges :
-to_rgb -b $1% -edges $2%
-if $3 -negative -endif
-n 0,255
gimp_edges_preview :
-gimp_split_preview "-gimp_edges ${^0}",$-1
gimp_edge_offsets :
-repeat $!
os={s}
-b. $1% -gradient_norm. ->=. $2% -skeleton. 0 -distance. 1 -round. 1 -%. $3 ->=. {max(1,$3-$4)}
-if {!$5} -negative. -endif
-n. 0,255 -to_colormode. $os
-mv. 0 -done
gimp_edge_offsets_preview :
-gimp_split_preview "-gimp_edge_offsets ${^0}",$-1
gimp_extract_foreground :
-if {!$!} -return -endif
resolution={arg(1+$3,512,1024,2048,0)}
-repeat $! -l[$<]
nm=${-gimp_layer_name}
-nm "[G"{`39`}"MIC] Interactive foreground extraction"
-if {$7==-1||$5!=w||$6!=h} _gimp_control_points= -else _gimp_control_points=${7--1} -endif
status=${-x_segment\ $resolution}
-sh 3 -b. $1% -if {$2>0} -dilate. {1+2*$2} -elif {$2<0} -erode. {1-2*$2} -endif
-rm.
-if {$3==1} -sh 3 -max. 1 -rm.
-elif {$3==2} -s c,-3 -r. 100%,100%,1,4 -rv -nm[0] name(Mask) -nm[1] name($nm)
-elif {$3==3}
[-1]
-sh.. 0,2 --channels... 3,3 ->=. 3 -*[-2,-1] -rm.
-sh. 0,2 --channels.. 3,3 -<=. {255-3} -*[-2,-1] -rm.
-sh. 3 -*. -1 -+. 255 -rm.
-gimp_autocrop_layers[0]
pos0=${-gimp_layer_pos[0]} pos1=${-gimp_layer_pos[1]}
-nm[0] name($nm" [foreground]"),pos($pos0)
-nm[1] name($nm" [background]"),pos($pos1)
-endif
-endl -done
-if {narg($status)>=4} -u \{$1\}\{$2\}\{$3\}\{$4\}\{{w},{h}\}\{$status\} -else -u "" -endif
gimp_gradient_norm :
-b $1 -gradient_norm -^ $2
-c $3%,$4%
-if $5 -negative -endif
-n 0,255
gimp_gradient_norm_preview :
-gimp_split_preview "-gimp_gradient_norm ${^0}",$-1
gimp_gradient2rgb :
-b $1 -gradient2rgb $4
-c $2%,$3%
-if $5 -negative -endif
-n 0,255
gimp_gradient2rgb_preview :
-gimp_split_preview "-gimp_gradient2rgb ${^0}",$-1
gimp_isophotes :
-if $3
-topographic_map $1,$2
-else
-b $2 -isophotes $1
-endif
gimp_isophotes_preview :
-gimp_split_preview "-gimp_isophotes ${^0}",$-1
gimp_laplacian :
-b $1 -laplacian
-if $4 -abs -endif
-c $2%,$3%
-if $5 -negative -endif
-n 0,255
gimp_laplacian_preview :
-gimp_split_preview "-gimp_laplacian ${^0}",$-1
_gimp_local_orientation :
-repeat $! -l[$>] -split_opacity -l[0]
-b $1% -gradient_orientation 2 -complex2polar -rm[0--1:2]
-c $2%,$3%
-if $4 -negative -endif
-n 0,255
-endl -a c -endl -done
gimp_local_orientation :
-ac "-_gimp_local_orientation $1,$2,$3,$4",$5,2
gimp_local_orientation_preview :
-gimp_split_preview "-gimp_local_orientation ${^0}",$-1
gimp_morpho :
-ac "-__gimp_morpho ${^0}",$5,$6
gimp_morpho_preview :
-gimp_split_preview "-gimp_morpho ${^0}",$-1
__gimp_morpho :
-if {$4==1} suf="_oct" -elif {$4==0} suf="" -else suf="_circ" -endif
-if {$1==0} -erode$suf $2
-elif {$1==1} -dilate$suf $2
-elif {$1==2} -erode$suf $2 -dilate$suf $2
-elif {$1==3} -dilate$suf $2 -erode$suf $2
-elif {$1==4} -repeat $! --erode$suf $2 --[-2,-1] -mv. 0 -done
-elif {$1==5} -repeat $! --dilate$suf $2 -rv[-2,-1] --[-2,-1] -mv. 0 -done
-elif {$1==6} -repeat $! --erode$suf $2 -dilate$suf. $2 --[-2,-1] -mv. 0 -done
-else -repeat $! --dilate$suf $2 -erode$suf. $2 -rv[-2,-1] --[-2,-1] -mv. 0 -done
-endif
-if $3 -repeat $! -l[$>] -split_opacity -negative[0] -a c -endl -done -endif
gimp_segment_watershed : -skip ${4=1}
-ac "-b $2 -segment_watershed $1",$3,$4
gimp_segment_watershed_preview :
-gimp_split_preview "-gimp_segment_watershed ${^0}",$-1
gimp_skeleton :
-remove_opacity
-if {!$4} -norm -endif
-b $2%
-if $1 -thinning -else -skeleton $3% -endif
-* 255
gimp_skeleton_preview :
-gimp_split_preview "-gimp_skeleton ${^0}",$-1
gimp_thin_edges :
-b $1% -gradient_norm ->= $2% -thinning
-if {!$3} -negative -endif
-n 0,255
gimp_thin_edges_preview :
-gimp_split_preview "-gimp_thin_edges ${^0}",$-1
gimp_custom_deformation :
-repeat $!
--norm. [-1] -f.. "$1" -f. "$2"
-a[-2,-1] c -warp.. [-1],$3,$4,$5,1 -rm.
-mv. 0 -done
gimp_circle_transform :
-repeat $! -l[$>] -to_rgba
r={$5*sqrt(w^2+h^2)}
-if {$6==0} cond="i(X,Y,z,c,$7,$8)"
-elif {$6==1} cond="if(N<"$r",i(X,Y,z,c,$7,$8),i)"
-else cond="if(N>"$r",i(X,Y,z,c,$7,$8),i)"
-endif
-f 'U=x-w*$1%;V=y-h*$2%;N=sqrt(U*U+V*V);Nr=N-$r;X=x+$3*Nr*U/N;Y=y+$4*Nr*V/N;$cond'
-endl -done
gimp_circle_transform_preview :
-gimp_circle_transform $*
-repeat $! -l[$>]
x0={$1%*w}
y0={$2%*h}
r={$5*sqrt(w^2+h^2)}
-if $9
-circle $x0,$y0,{$r-1},1,0xFFFFFFFF,0,0,0,255
-circle $x0,$y0,{$r+1},1,0xFFFFFFFF,0,0,0,255
-circle $x0,$y0,$r,1,0xFFFFFFFF,0,255,0,255
-endif
-endl -done
souphead_droste10 :
-_souphead_droste10 ${1-26},0,${28-31}
souphead_droste10_preview :
-_souphead_droste10 ${1--1}
_souphead_droste10 :
-repeat $! -l[$>]
-to_a
--f. 0
-sh. 0
-f. "
init(InnerRadius = $1;
OuterRadius = $2;
Periodicity = $3;
Strands = $4;
Zoom = $5;
Rotate = $6;
XShift = $7;
YShift = $8;
XCenterShift = $9;
YCenterShift = $10;
StartingLevel = $11;
NumberOfLevels = $12;
LevelFrequency = $13;
ShowBothPoles = $14;
PoleRotation = $15;
PoleLong = $16;
PoleLat = $17;
TilePoles = $18;
HyperDroste = $19;
FractalPoints = $20;
AutoSetPeriodicity = $21;
NoTransparency = $22;
ExternalTransparency = $23;
MirrorEffect = $24;
Untwist = $25;
DoNotFlattenTransparency = $26;
ShowGrid = $27;
ShowFrame = $28;
Antialias = $29;
XEdgeType = $30;
YEdgeType = $31;
r1 = InnerRadius/100;
r2 = OuterRadius/100;
p1 = Periodicity;
p2 = Strands;
xCenterShift = XCenterShift/100;
yCenterShift = YCenterShift/100;
W = (w-1)/2;
H = (h-1)/2;
xShift = (XShift*w/W)/100;
yShift = (YShift*h/H)/100;
tileBasedOnTransparency=!(NoTransparency);
transparentPointsIn=!(ExternalTransparency);
levelsToLookOut=StartingLevel;
levelToShow=LevelFrequency;
retwist=!(Untwist);
if (AutoSetPeriodicity,p1=p2/2*(1+sqrt(1-(log(r2/r1)/pi)^2)));
if (p1>0,rotate=-(pi/180)*Rotate,rotate=(pi/180)*Rotate);
zoom=(Zoom+InnerRadius-1)/100;
epsilon=0.01;
if(retwist,xbounds0=-r2;xbounds1=r2;ybounds0=-r2;ybounds1=r2,ybounds0=0;ybounds1=2.1*pi;xbounds0=-log(r2/r1);xbounds1=-xbounds0);
minDimension=min(w,h);
xymiddle=0.5*(xbounds0+xbounds1);
xymiddlei=0.5*(ybounds0+ybounds1);
xyrangex=xbounds1-xbounds0;
xyrangey=ybounds1-ybounds0;
aspectRatio=w/h;
xyrangex=xyrangey*aspectRatio;
xbounds0=xymiddle-0.5*xyrangex;
xbounds1=xymiddle+0.5*xyrangex;
pLat = (PoleLat*w/W)/100;
pLon = (PoleLong*w/W)/100;
alpha=atan(p2/p1*log(r2/r1)/(2*pi));
f=cos(alpha);
beta=f*cos(alpha);
betai=f*sin(alpha);
if(p2>0,angle=2*pi*p1,angle=-2*pi*p1);
if(MirrorEffect,angle=angle/Strands);
);
X=x-((w-1)/2);
Y=((h-1)/2)-y;
z=xbounds0+(xbounds1-xbounds0)*(X+w/2)/w;
zi=ybounds0+(ybounds1-ybounds0)*(Y+h/2)/h;
if(retwist,
zinitial=z;
zinitiali=zi;
z=z-xShift;
zi=zi-yShift;
expo=cos(rotate);
expoi=sin(rotate);
zmid=(z-xymiddle)/zoom;
zmidi=(zi-xymiddlei)/zoom;
zx=(zmid*expo+zmidi*expoi);
zy=(zmidi*expo-zmid*expoi);
z=xymiddle+zx;
zi=xymiddlei+zy,
zinitial=r1*exp(z)*cos(zi);
zinitiali=r1*exp(z)*sin(zi);
expo=cos(rotate)*zoom;
expoi=sin(rotate)*zoom;
zx=zinitial*expo-zinitiali*expoi;
zy=zinitial*expoi+zinitiali*expo;
zinitial=zx;
zinitiali=zy
);
if(ShowBothPoles,
theta=(pi/180)*PoleRotation;
xx=z;
yy=zi;
div=0.5*(1+xx^2+yy^2+((1-xx^2-yy^2)*cos(theta))-(2*xx*sin(theta)));
xx=xx*cos(theta)+(0.5*(1-xx^2-yy^2)*sin(theta));
z=xx/div;
zi=yy/div,
if(HyperDroste,
zx=sin(z)*cosh(zi);
zy=cos(z)*sinh(zi);
z=zx;
zi=zy
);
if(TilePoles,
p=sqrt(z*z + zi*zi)^FractalPoints;
frac=FractalPoints*atan2(zi,z);
z=p*cos(frac);
zi=p*sin(frac);
z=2*z;
zi=2*zi;
p=cos(2*z)+cosh(2*zi);
zx=sin(2*z)/p;
zy=sinh(2*zi)/p;
z=zx;
zi=zy
);
);
z=z+pLat;
zi=zi+pLon;
if(retwist,
za=z/r1;
zb=zi/r1;
zx=0.5*log(za*za+zb*zb);
zy=atan2(zb,za);
z2=zx;
z2i=zy,
z2=z;
z2i=zi
);
p=beta*beta+betai*betai;
z=p1*(z2*beta+z2i*betai)/p;
zi=p1*(z2i*beta-z2*betai)/p;
rotatedscaledlogz=z;
rotatedscaledlogzi=zi;
logz=z2;
logzi=z2i;
zx=r1*exp(z)*cos(zi);
zy=r1*exp(z)*sin(zi);
z=zx;
zi=zy;
if(tileBasedOnTransparency && levelsToLookOut>0,
if(!transparentPointsIn,
ratio=r2/r1*cos(angle);
ratioi=r2/r1*sin(angle),
ratio=r1/r2*cos(angle);
ratioi=-r1/r2*sin(angle)
);
p=sqrt(ratio*ratio+ratioi*ratioi)^levelsToLookOut;
q=atan(ratioi/ratio);
rp=p*cos(levelsToLookOut*q);
rpi=p*sin(levelsToLookOut*q);
zx=z*rp-zi*rpi;
zy=z*rpi+zi*rp;
z=zx;
zi=zy;
);
colorSoFarR=0;
colorSoFarG=0;
colorSoFarB=0;
colorSoFarA=0;
alphaRemaining=1;
ix=minDimension/2*(z+xCenterShift);
iy=minDimension/2*(zi+yCenterShift);
realx=ix+((w-1)/2);
realy=((h-1)/2)-iy;
if(realx<0 || realx>=w,
if(XEdgeType==1,
realx=realx%w;
if(realx<0,realx=w+realx)
);
if(XEdgeType==2,
realx=abs(realx%w);
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
if(XEdgeType==3,
realx=abs(realx%w);
realy=h-realy;
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
);
if(realy<0 || realy>=h,
if(YEdgeType==1,
realy=realy%h;
if(realy<0,realy=h+realy)
);
if(YEdgeType==2,
realy=abs(realy%h);
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
if(YEdgeType==3,
realy=abs(realy%h);
realx=w-realx;
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
);
ColorOutR=i(#0,realx,realy,0,0,Antialias,0)/255;
ColorOutG=i(#0,realx,realy,0,1,Antialias,0)/255;
ColorOutB=i(#0,realx,realy,0,2,Antialias,0)/255;
ColorOutA=i(#0,realx,realy,0,3,Antialias,0)/255;
colorSoFarR=colorSoFarR+(ColorOutR*ColorOutA*alphaRemaining);
colorSoFarG=colorSoFarG+(ColorOutG*ColorOutA*alphaRemaining);
colorSoFarB=colorSoFarB+(ColorOutB*ColorOutA*alphaRemaining);
colorSoFarA=colorSoFarA+(ColorOutA*ColorOutA*alphaRemaining);
alphaRemaining=alphaRemaining*(1-ColorOutA);
sign=0;
if(tileBasedOnTransparency,
if(transparentPointsIn && alphaRemaining>epsilon,sign=-1);
if(!transparentPointsIn && alphaRemaining>epsilon,sign=1),
radius=sqrt(z*z+zi*zi);
if(radius<r1,sign=-1);
if(radius>r2,sign=1)
);
if(sign<0,
ratio=r2/r1*cos(angle);
ratioi=r2/r1*sin(angle)
);
if(sign>0,
ratio=r1/r2*cos(angle);
ratioi=-r1/r2*sin(angle)
);
if(levelToShow>1,
lograt=levelToShow*0.5*log(ratio*ratio+ratioi*ratioi);
lograti=levelToShow*atan2(ratioi,ratio);
ratio=exp(lograt)*cos(lograti);
ratioi=exp(lograt)*sin(lograti)
);
iteration=StartingLevel;
maxiteration=NumberOfLevels+StartingLevel-1;
whiledo(sign!=0 && iteration<maxiteration,
zx=z*ratio-zi*ratioi;
zy=z*ratioi+zi*ratio;
z2=zx;
z2i=zy;
z=z2;
zi=z2i;
rotatedscaledlogzi=rotatedscaledlogzi-sign*angle;
ix=minDimension/2*(z+xCenterShift);
iy=minDimension/2*(zi+yCenterShift);
realx=ix+((w-1)/2);
realy=((h-1)/2)-iy;
if(realx<0 || realx>=w,
if(XEdgeType==1,
realx=realx%w;
if(realx<0,realx=w+realx)
);
if(XEdgeType==2,
realx=abs(realx%w);
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
if(XEdgeType==3,
realx=abs(realx%w);
realy=h-realy;
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
);
if(realy<0 || realy>=h,
if(YEdgeType==1,
realy=realy%h;
if(realy<0,realy=h+realy)
);
if(YEdgeType==2,
realy=abs(realy%h);
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
if(YEdgeType==3,
realy=abs(realy%h);
realx=w-realx;
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
);
sign=0;
ColorOutR=i(#0,realx,realy,0,0,Antialias)/255;
ColorOutG=i(#0,realx,realy,0,1,Antialias)/255;
ColorOutB=i(#0,realx,realy,0,2,Antialias)/255;
ColorOutA=i(#0,realx,realy,0,3,Antialias)/255;
if(tileBasedOnTransparency,
colorSoFarR=colorSoFarR+(ColorOutR*ColorOutA*alphaRemaining);
colorSoFarG=colorSoFarG+(ColorOutG*ColorOutA*alphaRemaining);
colorSoFarB=colorSoFarB+(ColorOutB*ColorOutA*alphaRemaining);
colorSoFarA=colorSoFarA+(ColorOutA*ColorOutA*alphaRemaining);
alphaRemaining=alphaRemaining*(1-ColorOutA);
if(transparentPointsIn && alphaRemaining>epsilon,sign=-1);
if(!transparentPointsIn && alphaRemaining>epsilon,sign=1),
radius=sqrt(z*z+zi*zi);
if(radius<r1,sign=-1);
if(radius>r2,sign=1)
);
iteration=iteration+1;
);
ColorOutR=colorSoFarR;
ColorOutG=colorSoFarG;
ColorOutB=colorSoFarB;
ColorOutA=colorSoFarA;
if(ShowGrid,
gridzx=(logz+10*log(r2/r1))%log(r2/r1);
gridzy=(logzi+10*2*pi)%(2*pi);
if(gridzx<epsilon || gridzx>(log(r2/r1)-epsilon) || gridzy<epsilon || gridzy>(2*pi-epsilon),
ColorOutR=0;
ColorOutG=1;
ColorOutB=0;
ColorOutA=1;
);
gridzx=(rotatedscaledlogz+10*log(r2/r1))%log(r2/r1);
gridzy=(rotatedscaledlogzi+10*2*pi)%(2*pi);
if(gridzx<epsilon || gridzx>(log(r2/r1)-epsilon) || gridzy<epsilon || gridzy>(2*pi-epsilon),
ColorOutR=0;
ColorOutG=0;
ColorOutB=1;
ColorOutA=1;
);
);
if(ShowFrame,
gridzx=zinitial;
gridzy=zinitiali;
if(gridzx<(aspectRatio*r2) && gridzx>-(aspectRatio*r2) && gridzy<r2 && gridzy>-r2,
dx=min((aspectRatio*r2)-gridzx,gridzx+(aspectRatio*r2));
dy=min(r2-gridzy,gridzy+r2);
if(dx<(4*epsilon) || dy<(4*epsilon),
ColorOutR=1;
ColorOutG=1;
ColorOutB=1;
ColorOutA=1
);
if(dx<(2*epsilon) || dy<(2*epsilon),
ColorOutR=0;
ColorOutG=0;
ColorOutB=0;
ColorOutA=1
),
ColorOutR=0.75*ColorOutR;
ColorOutG=0.75*ColorOutG;
ColorOutB=0.75*ColorOutB;
ColorOutA=1
);
);
if(!DoNotFlattenTransparency,ColorOutA=1);
i(#1,x,y,0,1)=ColorOutG*255;
i(#1,x,y,0,2)=ColorOutB*255;
i(#1,x,y,0,3)=ColorOutA*255;
ColorOutR*255"
-k..
-endl -done
gimp_drop_water :
N={$!-$1}
-if {$N<=0} -error "At least two layers are required in this mode." -endif
-repeat $N -l[{$!-$>-1}] nm0={n} nm=${-gimp_layer_name}
-nm img
-srand $5
-if $1
-pass[0] 0 -to_a. -channels. 100% -ge. 50%
-r. [0],[0],1,1,0,0,0.5,0.5
-else
100%,100%
rmin={max(0.1,$3*(1-$4%))} rmax={max(0.1,$3)}
-repeat 10
100%,100%
-random3d {max(1,$2)} -*3d. {-2,w},{-2,h},0
-j3d.. [-1],0,0,0,1,1,0,0 -rm.
-b. {$rmin+($rmax-$rmin)*$>/9}%,0,1
-j.. [-1],0,0,0,0,0.5 -rm.
-done
-ge. 10%
-endif
-nm. shape
--b[shape] 1% -n. 0,30
-nm. elevation
-g[elevation] xy -a[-2,-1] c -nm. grad
--*[grad] {grad,$6*max(w,h)/100} -*. [shape] -b. $15%
--warp[img] [-1],1,1,1 -rm.. -nm. refraction
--*[grad] -1 100%,100%,1,1,1 -a[-2,-1] c -orientation.
a={$7*pi/180} ca={-cos($a)} sa={-sin($a)}
-mix_channels. ({(1-$10)*$ca},{(1-$10)*$sa},1) -c. {100-$8}%,100% -n. 0,1
-*. [shape] -nm. spots
-mix_channels[grad] ($ca,$sa)
-n[grad] 0,1 -*[grad] [shape]
--shift[shape] {-$11*$ca}%,{-$11*$sa}%,0,0,1
--. [shape] -ge. 1 -b. $13% -n. 0,1
-nm. shadow
-b[shape] $14% -n. 0,1
-nm[img] name($nm)
-*[shadow] 255 -channels[shadow] -1,0 -mv[shadow] 1
-nm[shadow] name($nm" [shadow]"),mode(alpha),opacity({$12*100})
-to_a[refraction] -sh[refraction] 100% --b[shape] $15% -*[-2,-1] -rm.
-mv[refraction] 2
-nm[refraction] name($nm" [refraction]"),mode(alpha)
-channels[spots] -1,0 -sh[spots] 0 -f. 1 -rm. -*[spots] 255
-nm[spots] name($nm" [specular spots]"),mode(alpha),opacity({$9*100})
-rv[shape,grad] -a[grad,shape] c -*[grad] 255 -b[grad] $15%
-nm[grad] name($nm" [gradient]"),mode(grainmerge)
-rv
-if {!$16} -gimp_merge_layers -nm $nm0 -endif
-endl -done
-if $1 -rm[0] -endif
gimp_drop_water_preview :
N={$!-$1}
-if {$N<=0} -gimp_warning_preview "At least two layers are required in this mode." -return -endif
-if $1
-repeat $N -l[{$!-$>-1}]
-pass[0] 0 -mv. 0
-gimp_drop_water $* -gimp_merge_layers
-endl -done
-rm[0]
-else
-repeat $! -l[$>]
-gimp_drop_water $* -gimp_merge_layers
-endl -done
-endif
gimp_equirectangular2nadirzenith :
-if $1 -nadirzenith2equirectangular -else -equirectangular2nadirzenith -endif
gimp_euclidean2polar :
-if $5 -polar2euclidean $1%,$2%,$3,$4 -else -euclidean2polar $1%,$2%,$3,$4 -endif
gimp_flower :
-flower $1,$2,$3%,$4,$5%,$6%,$7
gimp_rotoidoscope :
-rotoidoscope $1%,$2%,$3,$4%,$5
gimp_kaleidoscope :
-shift $3%,$4%,0,0,2 -kaleidoscope $1%,$2%,$5,$6,$7
gimp_symmetrizoscope :
-to_rgba -repeat $1
ang={$2+180*$>/max(1,$1-1)}
-symmetrize 50%,50%,$ang,$3,0,{if($4!=2,$4,$>%2)}
-done
gimp_warp_perspective :
-shift $6%,$7%,0,0,2 -warp_perspective $1,$2,$3,$4,$5,$8
gimp_transform_polar :
-if {$1==0}
-transform_polar "$4","$5",$2%,$3%,$6
-elif {$1==1}
-transform_polar R-r,a,$2%,$3%,$6
-else
-transform_polar a*R/(2*pi),r*2*pi/R,$2%,$3%,$6
-endif
gimp_reflect :
-repeat $!
-to_rgba. --rows. {100-$1}%,100% -mirror. y -water. $7,$8
-s. c
-f[-4] "(i*(255-$6) + $6*$3)/255"
-f... "(i*(255-$6) + $6*$4)/255"
-f.. "(i*(255-$6) + $6*$5)/255" -a[-4--1] c
-*. '(h^$2-y^$2)/h^$2' -a[-2,-1] y
100%,100%,100%,1,$11*$12*(x/w-0.5)
100%,100%,100%,1,$11*$12*(y/h-0.5)
100%,100%,100%,1,"$10*(x/w-0.5) + $9*(y/h-0.5) + $11"
-/... [-1] -+... 0.5 -*... {-3,w}
-/[-2,-1] -+. 0.5 -*. {h}
-a[-2,-1] c -warp.. [-1],0,1,0 -rm.
-mv. 0 -done
-autocrop 0,0,0,0
gimp_seamcarve :
-if $4
-if {$!<2} -error "Priority mask (top layer) is missing!" -endif
-_gimp_seamcarve
-endif
-seamcarve $1%,$2%,$4,$5,$3%
-if $4 -repeat $! -channels[$>] 0,{$>,s-2} -done -endif
-c 0,255
gimp_seamcarve_preview :
-if $4
-if {$!<2} -to_rgb -text_outline "Priority mask (top layer) is missing!",5,5,18,2 -return -endif
-_gimp_seamcarve
-endif
-repeat $! -l[$>]
w={w} h={h}
-seamcarve $1%,$2%,$4,$5,{max($3,10)}%
-if $4 -channels 0,{s-2} -endif
-to_rgba -r $w,$h,1,100%,0,0,0.5,0.5
-endl -done
-c 0,255
_gimp_seamcarve :
-mv[0] $!
-l.
-s c -k[0,1]
->[1] [0] -!=[0] 0 --[0] [1] -*[0] -1 -+ -* 256
-endl
-repeat {$!-1} -a[$>] [-1],c -done -rm.
gimp_map_sphere :
-rotate {$8*90}
-if $6
-repeat $!
-shift. {round(w/2)},0,0,0,2 --columns. {(1-$7/100)*w/2},{(1+$7/100)*w/2}
100% -gaussian. {0.1*w},{h},0 100% 100% -a[-3--1] c -r. [-2],[-2],1,3
-smooth.. [-1],$6,5,0 -rm.
-j.. [-1],{(1-$7/100)*{-2,w}/2} -rm. -shift. -{round(w/2)},0,0,0,2
-mv. 0 -done
-endif
-shift $5%,0,0,0,2 -to_rgba
-if $9
-repeat $!
--rows[$>] 0 -r. 1,1,1,4,2 RGBA$>={^}
-r. [$>],[$>],1,4 --[$>,-1]
-done
-endif
-map_sphere $1,$2,$3,$4,$10,$11
-if $9
-repeat $!
(${RGBA$>}) -y. c -r. [$>],[$>],1,4 -+[$>,-1]
-done
-endif
gimp_map_sphere_preview :
-gimp_map_sphere {w},{h},${3--1}
gimp_symmetrize :
-to_rgba -symmetrize $1%,$2%,$3,$4,$5,$6
gimp_symmetrize_preview :
-gimp_symmetrize $*
theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
-repeat $! -l[$>]
x0={w*$1%}
y0={h*$2%}
x1={$x0-max(w,h)*$u} y1={$y0-max(w,h)*$v}
x2={$x0+max(w,h)*$u} y2={$y0+max(w,h)*$v}
-line $x1,$y1,$x2,$y2,1,0x0F0F0F0F,0
-line $x1,$y1,$x2,$y2,1,0xF0F0F0F0,255
-circle $x0,$y0,3,1,0,255,0,255
-circle $x0,$y0,3,1,0xFFFFFFFF,0,0,0,255
-endl -done
gimp_textured_glass :
-repeat $! -l[$>]
100%,100%,1,1
-if $7 -plasma. 1,1,$7 -else -rand. 0,1 -endif
-g. xy
-if $5
--gradient_norm... -+. 1 -b. $6 -^. -$5
-*... [-1] -*[-2,-1]
-endif
-blur_xy[-2,-1] $3,$4
-*.. {-2,$1/max(abs(im),abs(iM))}
-*. {$2/max(abs(im),abs(iM))}
-a[-2,-1] c
-warp.. [-1],1,1 -rm.
-endl -done
gimp_textured_glass_preview :
-gimp_split_preview "-gimp_textured_glass $*",$-1
gimp_twirl :
-twirl $1,$2%,$3%,$4
gimp_wind :
-if {!$5} -negative -endif
-ac "-wind ${1-4}",$6,$7
-if {!$5} -negative -endif
gimp_wind_preview :
-gimp_split_preview "-gimp_wind $*",$-1
gimp_zoom :
-if {$1<1} -to_rgba -endif
-zoom $1,{$2%},{$3%},0,$4
gimp_blur_angular :
-ac "-blur_angular $1%,$2%,$3% -sharpen $4",$6,$7
gimp_blur_angular_preview :
-gimp_blur_angular $*
-if $5
-line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 -line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
-line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 -line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
-circle $2%,$3%,5,0.7,0 -circle $2%,$3%,3,0.7,0,255,0
-endif
gimp_blur_dof :
-_$0 ${1-10},0,$12
gimp_blur_dof_preview :
-_gimp_blur_dof $*
_gimp_blur_dof :
-if {!$3}
-repeat $! -l[$>] -if $11 -drgba -endif -split_opacity -l[0]
rmax={(w*w+h*h)^0.5} R={$7*$rmax/100} r={$8*$rmax/100}
t={$9*pi/180} u={cos($t)} v={sin($t)}
l1={($rmax/(1e-8+$R))^2} l2={($rmax/(1e-8+$r))^2}
a={$l1*($u)^2+$l2*($v)^2} b={$u*$v*($l1-$l2)} c={$l1*($v)^2+$l2*($u)^2}
100%,100%,1,1,'X=(x-$5*w/100)/max(w,h);Y=(y-$6*h/100)/max(w,h);f=$a*X*X+2*$b*X*Y+$c*Y*Y;exp(-f^$10/2.5)'
--[1] 1 -*[1] -$1 ms={im} Ms={iM}
-if $11
--isoline3d[1] {0.1*$1} -col3d. 255,255,0
--isoline3d[1] {0.5*$1} -col3d. 255,128,0
-+3d[-2--1]
-__gimp_dof_blur[0,1] $2,$ms,$Ms,$4
[0],[0],1,3 -j3d. [-2],0,0,0,1,1,0,0 -rm..
-circle. $5%,$6%,3,1,255,255,255
--compose_channels. + -!=. 0 -dilate. 3
-j[0] [-2],0,0,0,0,0.5,[-1],1 -rm[-2,-1]
-else -__gimp_dof_blur[0,1] $2,$ms,$Ms,$4
-endif
-endl -if $11 -k[0] -endif -a c -endl -done
-elif {$!>1}
-luminance. -n. 0,1 -^. {10^$12}
-repeat {$!-1} --r. {$>,w},{$>,h},1,1,3 -l[$>,-1] -split_opacity[0]
-__gimp_dof_blur[0,-1] $2,0,$1,$4
-a c -endl -done -rm.
-else -drgba -text_outline "Depth-of-field (bottom layer) is missing !",2,2,13,2,1,255
-endif
__gimp_dof_blur :
-n[1] 0,{$1-1} -round[1]
[0],[0],1,{0,s+1}
s=0
-repeat $1
--==[1] {if($4,$<,$>)} -b. 2%
-j.. [0],0,0,0,0,-1,[-1],1
-j.. [-1],0,0,0,100%,-1
-rm.
ns={$2+($3-$2)*($>+1)/($1-1)}
-b[0] {sqrt($ns^2-$s^2)}%
s=$ns
-done
-s. c,{-s+1} -/[-2,-1] -rm[0,1]
_gimp_gaussian_blur :
-b $1,$4
-if {$2>0} -repeat $! -l. -s y -b $2,$4 -a y -endl -mv. 0 -done -endif
-if {$3>0} -repeat $! -l. -s x -b $3,$4 -a x -endl -mv. 0 -done -endif
gimp_gaussian_blur :
-ac "-_gimp_gaussian_blur $1,$2,$3,$4",$5,$6
gimp_gaussian_blur_preview :
-gimp_split_preview "-gimp_gaussian_blur $*",$-1
gimp_glow :
-ac "-glow $1",$2,$3
gimp_glow_preview :
-gimp_split_preview "-gimp_glow $*",$-1
gimp_blur_linear :
-ac "-blur_linear $1,{$2*$1/100},$3,$5 -sharpen $4",$6,$7
gimp_blur_linear_preview :
-gimp_split_preview "-gimp_blur_linear $*",$-1
gimp_blur_radial :
-ac "-blur_radial $1%,$2%,$3% -sharpen $4",$6,$7
gimp_blur_radial_preview :
-gimp_blur_radial $*
-if $5
-line 0,$3%,100%,$3%,0.5,0xF0F0F0F0,255 -line 0,$3%,100%,$3%,0.5,0x0F0F0F0F,0
-line $2%,0,$2%,100%,0.5,0xF0F0F0F0,255 -line $2%,0,$2%,100%,0.5,0x0F0F0F0F,0
-circle $2%,$3%,5,0.7,0 -circle $2%,$3%,3,0.7,0,255,0
-endif
gimp_chromatic_aberrations :
-l[]
(${1-3}) (${6-8}) -y c -orientation[0]
--*[0,1] --*[0] {is} --[1,3] -rm[2] -orientation[1]
-_cross3d {0,^},{^} -y x -a y
M={^} -transpose Minv={^} -rm
-endl
-repeat $! -l[$>] -to_color -split_opacity -l[0]
-mix_rgb $M
-s c
100%,100%,1,2 -fc. {($9-$4)/2},{($10-$5)/2} -warp[0] [-1],1,2,1 -rm.
100%,100%,1,2 -fc. {($4-$9)/2},{($5-$10)/2} -warp[1] [-1],1,2,1 -rm.
100%,100%,1,2 -fc. {(-$4-$9)/2},{(-$5-$10)/2} -warp[2] [-1],1,2,1 -rm.
-a c
-mix_rgb $Minv
-endl -a c -endl -done
-c 0,255
gimp_chromatic_aberrations_preview :
-gimp_split_preview "-gimp_chromatic_aberrations $*",$-1
gimp_gcd_crt : -skip ${1=1.8},${2=1.8},${3=0},${4=0}
-repeat $! -l[$>]
-to_rgb[0]
-expand_xy 12,0 24,14,1,3,0
-f[-1] "if((x-c*4)%12<4,255,0)"
-f[-1] "if(x%4==0,0,i)"
-f[-1] "if((y%14==0)&&(x%24<12),0,i)"
-f[-1] "if(((y-7)%14==0)&&((x+12)%24<12),0,i)"
-array[-1] {0,round(w/24)},{0,round(h/14)},2
-z[-1] 0,0,{0,w-1},{0,h-1}
-s c -repeat 3 -blend[-4,-1] shapeaverage0 -done -a c
-n[-1] 0,255 -meancurvature_flow[-1] 4
-if $3
{w},{h},1,1,0
-rectangle[-1] 5%,5%,95%,95%,1,1
-b[-1] 10% -*[0,1]
-endif
-deriche[-1] $1,0,x -deriche[-1] $2,0,y
-shrink_xy[-1] 12 -n[-1] 0,255
-if $4 -equalize[-1] 256 -endif
-endl -done
gimp_dirty :
-ac "-_gimp_dirty ${1-2}",$3,$4
gimp_dirty_preview :
-gimp_split_preview "-gimp_dirty ${1--2}",$-1
_gimp_dirty :
-repeat $! -l[$>]
-dct 100%,100%,1,{if($2,1,s)} -noise. $1,2
-==. 0 -point. 0,0,0,1,1
-* -idct -c 0,255
-endl -done
gimp_lomo :
-remove_opacity -repeat $! -l[$>] -to_rgb
--gaussian {100-$1}%,{100-$1}% -normalize. 0,1 -*
-s c
-f[0] '255*atan((i-128)/128)'
-f[1] '255*tan((i-128)/128)'
-f[2] '255*atan((i-128)/255)'
-a c
-sharpen 1
-normalize 0,255
-endl -done
gimp_lomo_preview :
-gimp_split_preview "-gimp_lomo $*",$-1
gimp_noise :
-ac "-noise $1,$2",$3,$4
gimp_noise_preview :
-gimp_split_preview "-gimp_noise $*",$-1
gimp_spread :
-ac "-spread $1,$2",$3,$4
gimp_spread_preview :
-gimp_split_preview "-gimp_spread $*",$-1
gimp_stripes_y :
-ac "-stripes_y $1",$2,$3
gimp_stripes_y_preview :
-gimp_split_preview "-gimp_stripes_y $*",$-1
gimp_8bits :
-remove_opacity -repeat $! -l[$>]
w={w} h={h}
-r $1%,$1%,1,100%,2
--luminance -sharpen. $2 -otsu. 256 -blend[-2,-1] shapeaverage0
-l. -s c -quantize $3,1,1 -a c -endl
-r. $w,$h,1,100%,1
-endl -done
gimp_8bits_preview :
-gimp_split_preview "-gimp_8bits $*",$-1
gimp_pixelsort :
-_gimp_pixelsort ${1-8},0
_gimp_pixelsort :
-repeat {$!-($4==0)} -l[$>]
-if {$3==0} --compose_channels min
-elif {$3==1} --luminance
-elif {$3==2} --to_rgb -rgb2hsl. -channels. 2
-elif {$3==3} --compose_channels +
-elif {$3==4} --compose_channels max
-else 100%,100%,1,1 -rand. 0,100
-endif
-if {$4==0} -pass[-1] 0 -norm.
-elif {$4==1} [-1]
-elif {$4==2} --gradient_norm[0]
-else --rand. 0,100
-endif
-b. $7% -ir. $5%,{$6+0.01}%
-if $8 -==. 0 -endif
-if $9 -k. -* 255
-else -pixelsort[0] {`$1?_'+':_'-'`},{`$2==0?'x':$2==1?'y':$2==2?'xy':'yx'`},[1],[2] -k[0]
-endif
-endl -done
gimp_pixelsort_preview :
-_gimp_pixelsort $*
gimp_rain :
-repeat $! -l[$<] nm=${-gimp_layer_name}
100%,100% -l.
-noise 300 -c 0,255 -b 1,0
-c {100-$3}%,100%
--ge 40% -blend shapeaverage0
-blur_linear $2,$4,$1
-max -n 0,255 -apply_gamma $5
-nm name($nm),mode(screen),opacity({$6*100})
-endl
-rv
-endl -done
gimp_rain_preview :
-gimp_split_preview "-repeat $! -l[$>] -gimp_rain $* -rv -blend screen,$6 -endl -done",$-1
gimp_shade_stripes :
-ac "-shade_stripes $1,$2,$3,$4",$5,$6
gimp_shade_stripes_preview :
-gimp_split_preview "-gimp_shade_stripes $*",$-1
gimp_scanlines :
-ac "-scanlines ${1-5}",$6,$7
gimp_scanlines_preview :
-gimp_split_preview "-gimp_scanlines $*",$-1
gimp_watermark_visible :
-watermark_visible "$1",$2,$3,$4,$6,$5
_gimp_equalize_details :
-repeat $! -l[$>]
-split_details 5,{max(0.1,$1)},{max(0.1,$2)}
-__gimp_equalize_details[1] ${3-6},8
-__gimp_equalize_details[2] ${7-10},4
-__gimp_equalize_details[3] ${11-14},2
-__gimp_equalize_details[4] ${15-18},1
-+ -c 0,255
-endl -done
__gimp_equalize_details :
-threshold $1,1
-if {$3==0} -b {$2*$5/2}
-elif {$3==1}
-if {$2>0}
m={im} M={iM} -n. 0,255
-repeat {int($2/5)} -bilateral 15,{5*$5} -done
-bilateral 15,{($2%5)*$5}
-*. {($M-$m)/255} -+. $m
-endif
-else -smooth {$2*50},0.2,0.8,$5,$5 -endif
-* {10^$4}
gimp_equalize_details :
-ac "-gimp_parallel_overlap \"-_gimp_equalize_details ${1-18}\",$21,$22",$19,$20
gimp_equalize_details_preview :
-gimp_split_preview "-gimp_equalize_details $*",$-1
gimp_tk_dri :
-repeat $! -l[$>]
-if {$6==1}
--negative --to_rgba[0] --luminance[0] --to_rgba[0] --luminance[0]
-gimp_gaussian_blur[1] {{{w+h}/20}*{1.1-$1}},0,0,1,0,0,0 -to_gray[1]
-rv[0,1] -gimp_compose_softlight[0,1] $1
-gimp_gaussian_blur[2] {{w+h}/200},0,0,1,1,0,0 -negative[2] -to_gray[2]
-s[1] c -rv[4,5] -compose_multiply[4,5] -a[1,2,3,4] c -rv[0,1]
-gimp_compose_dodge[0,1] $2
-gimp_gaussian_blur[2] {{w+h}/200},0,0,1,1,0,0 -to_gray[2] -s[1] c
-rv[4,5] -compose_multiply[4,5] -a[1,2,3,4] c -rv[0,1]
-gimp_compose_colorburn[0,1] $3 -endif
-if {$7==1} --map_tones[0] 0.50,0.70,$4,50
--normalize_local[0] $4,6.00,5.00,1.00
-rv[0,1] -gimp_compose_value[0,1] $5,0
-rv[0,1] -gimp_compose_value[0,1] $5,0 -endif
-endl -done
gimp_tk_dri_preview :
-gimp_split_preview "-gimp_tk_dri ${1--2}",$-1
_gimp_freaky_details :
-repeat $! -l[$>]
-repeat $3
[-1] ---. 255 -*. -1
-repeat $1 -bilateral. $2,{1.5*$2} -done
-blend[-2,-1] vividlight -blend overlay
-done
-endl -done
gimp_freaky_details :
-ac "-gimp_parallel_overlap \"-_gimp_freaky_details ${1-3}\",$5,$6",$4
-n 0,255
gimp_freaky_details_preview :
-gimp_split_preview "-gimp_freaky_details $*",$-1
gimp_highpass :
-repeat $! -l[$>]
-to_rgb --negative
-if {$4==1} -to_gray -endif
-gimp_gaussian_blur[1] $1,0,0,1,0,0,0
-compose_interpolation
-tk_gimp_channel_processing 1,$2,0,0,0,0,100,256,0,0,0,2,0,0
-if {$2>=4} -tk_gimp_channel_processing 1,{$2-3},0,0,0,0,100,256,0,0,0,2,0,0  -endif
-tk_gimp_channel_processing 1,1,0,0,1,50,100,256,0,0,0,2,0,0
-if {$3==1} -negative -endif -endl -done
gimp_highpass_preview :
-gimp_split_preview "-gimp_highpass ${1--2}",$-1
_gimp_LCE :
SpatialRadius=$1
Amount=$2
DarknessLevel=$3
LightnessLevel=$4
Threshold=0
--blur[-1] $SpatialRadius
--[-1] [-2] -*[-1] -$Amount
--norm[-1] -ge[-1] $Threshold% -r[-1] [-2] -*[-2,-1]
--c[-1] 0,100% -c[-2] -100%,0 -*[-2] $DarknessLevel -*[-1] $LightnessLevel -+[-2,-1]
-+[-2,-1] -c[-1] 0,255
gimp_LCE :
-ac "-_gimp_LCE $1,$2,$3,$4",$5,0
gimp_LCE_preview :
-gimp_split_preview "-gimp_LCE ${1--2}",$-1
gimp_normalize_local :
-repeat $! -l[$>]
-ac "-normalize_local $1,$2,$3,$4,$5,0,255",$6
-endl -done
gimp_normalize_local_preview :
-gimp_split_preview "-gimp_normalize_local $*",$-1
jeje_normalize_local_variance :
-apply_channels "-normalize_local_variance $1,$2,$3,$4",$5,0
-c 0,255
jeje_normalize_local_variance_preview:
-gimp_split_preview "-jeje_normalize_local_variance $1,$2,$3,$4,$5",$-1
makeup_full:
-to_rgb
-sub[-1] 128 -*[-1] .5 -+[-1] 128
-split c
-name[0] red
-name[1] green
-name[2] blue
-sub[green] [red]
-bilateral[green] $1,$2
-add[green] [red]
-sub[blue] [red]
-bilateral[blue] $1,$2
-add[blue] [red]
-append[0,1,2] c
--[-1] 128 -*[-1] 2 -+[-1] 128
-c 0,255
make_up:
cropwidth={w}
cropheight={h}
-resize[0] {w+(2-w%2)},{h+(2-h%2)},1,{s},0,1
width={w}
height={h}
-if {$3==1}
--resize 50%,50%,1,3,5
--makeup_full[1] {$1/2},$2
--resize[1] 200%,200%,1,3,5
--compose_grainextract[0,3]
-resize[2] {w},{h},1,3,5
--compose_grainmerge[2,4]
-keep[0,-1]
-else
-if {$4==1}
--makeup_full[0] $1,$2
-else
-makeup_full[0] $1,$2
-endif
-endif
-if {$4==1}
--rgb2hsl8[1]
-split[-1] c -remove[-1,-2]
-+[-1] 128
-mod[-1] 255
-apply_curve[-1] 0,0,0,130,0,136,255,155,255,160,0,255,0
-median[-1] 3
--edges[1] 10% -n[-1] 0,1
-mul[-1,-2]
-a[1,2] c
-blend[0,1] alpha
-else
-keep[-1]
-endif
-crop 0,0,{$cropwidth-1},{$cropheight-1}
make_up_preview:
-gimp_split_preview "-make_up ${1--2}",$-1
#
gimp_tk_mask :
-repeat $! -l[$>]
-if {$8==1} --to_rgba[-1] -rv[-1,-2] -endif -to_rgb[-1]
-if {$2==1} -channels[-1] 0
-elif {$2==2} -channels[-1] 1
-elif {$2==3} -channels[-1] 2
-elif {$2==4} -rgb2cmy -channels[-1] 2
-elif {$2==4} -rgb2cmy -channels[-1] 1
-elif {$2==4} -rgb2cmy -channels[-1] 0
-elif {$2==5} -rgb2lab -channels[-1] 1
-elif {$2==6} -rgb2lab -channels[-1] 2
-endif -to_rgb[-1]
-if {$1==0} -luminance[-1] --luminance[-1]
-elif {$1==1} -rgb2hsv[-1] -channels[-1] 1
-n[-1] 0,255 [-1]
-elif {$1==2} -rgb2hsv[-1] -channels[-1] 0
-n[-1] 0,255  [-1]
-elif {$1==3} -rgb2lab[-1] -channels[-1] 0
-n[-1] 0,255  [-1]
-endif
-c[-1] $3,255 -n[-1] 0,255
-f[-2] "if(i<$4,if(c==0,i,i),0)"
-gimp_gaussian_blur[-1,-2] $5,0,0,1,0,0,0
-compose_darken
-if {$8==1} -rv[-1,-2] -endif
-tk_gimp_channel_processing[-1] 1,$6,0,0,0,0,100,256,0,0,0,2,0,0
-if {$7==1} -negative[-1] -endif
-if {$8==1} -s[-2] c  -rv[-1,-2]
-gimp_compose_multiply[-1,-2] $9
-a[-4,-3,-2,-1] c
-endif -endl -done
gimp_tk_mask_preview :
-gimp_split_preview "-gimp_tk_mask ${1--2}",$-1
_gimp_mighty_details :
--smooth $3,0,1,0.5,0.5 --[1] [0]
--abs. -sign.. M={iM} -^. {2-$2} -*. {$M/iM} -*[-2,-1]
--diffusiontensors[0] 0,1,0.5,0.5
-repeat $4 -smooth[1] [2],20 -done
-*[1] {-$1/5} -+
gimp_mighty_details :
-ac "-_gimp_mighty_details ${1-4}",$5,1
-n 0,255
gimp_mighty_details_preview :
-gimp_split_preview "-gimp_mighty_details $*",$-1
gimp_tk_portrait :
-repeat $! -l[$>] -to_rgb
-if {narg($_previewflag)==0} _previewflag=0 -endif
-if {{$1==3}||{$1==4}} --luminance[0] -elif {$1==2} --channels[0] 2 -gimp_unsharp[-1] 0,$21,30,$22,0.00,1.00,0.5,1,0,0,0 -endif
--gimp_edges[0] $24,$23,0,0 -if {$23==0} -fc[-1] 0 -endif --gimp_unsharp[0] 0,$21,30,$22,0.00,1.00,0.5,1,0,7,0
-if {{$_previewflag==4}&&{$29==5}} --tk_gimp_select_color[0] ${12-18},0,0 -else --tk_gimp_select_color[0] ${12-18},1,0 -endif
--gimp_split_freq[0] $6 -if {$19==1} -fc[-1] 128,128,128 -noise[-1] {$6*2},0 -luminance[-1] -endif
--gimp_split_freq[0] $7
-rm[-2,-4]
--gimp_tk_dri[0] {$8/100},{$8/200},{$8/200},0,0,1,0,0
-if {$9==0} -blur[-1] $5 -rv[-1,-2] -blur[-1] $4 -blur[-3] $3
-elif {$9==1} -bilateral[-1] $7,$5 -rv[-1,-2] -bilateral[-1] $6,$4 -bilateral[-3] {$3/5},$3
-elif {$9==2} -smooth[-1] $5 -rv[-1,-2] -smooth[-1] $4 -smooth[-3] $3
-elif {$9==3} -median[-1] $5 -rv[-1,-2] -median[-1] $4 -median[-3] $3
-endif
-if {{{$_previewflag!=0}&&{$_previewflag<=3}}||{{$10<=1}&&{$_previewflag==0}}}
-gimp_compose_freq[-1,-2] -rv[-1,-2] -gimp_compose_freq[-1,-2]
-if {$11==1} -to_rgba[-1] -blur[-2] $14 -s[-1] c -negative[-1] -+[-1] [-5] -a[-1,-2,-3,-4] c -endif -rm[-2] -mv[-1] 1
-to_rgba[-1] -s[-1] c -negative[-1,-5] -+[-1] [-5] -a[-1,-2,-3,-4] c -rm[-2] -if {$23==50} -fc[-1] 0,0,0,0 -endif
-if {{{$_previewflag==1}||{$_previewflag==2}}||{{$10==0}&&{$_previewflag==0}}}
-if {{$1!=0}&&{$1!=1}} -mv[-2] 0 -endif
-if {$20==1} -gimp_mix_lab[-2] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0
-elif {$20==2} -gimp_mix_lab[-1] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0
-elif {$20==3} -gimp_mix_lab[-1,-2] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0
-endif
-gimp_compose_alpha[-2,-3] {if({$1==0},{$2/100},1)},0 -gimp_compose_alpha[-1,-2] {if({$1==0},{$2/100},1)},0
-if {$23==50} -gimp_unsharp[0] 0,$21,30,$22,0.00,1.00,0.5,1,0,0,0 -endif
-if {$_previewflag<=1}
-if {$1==1} -gimp_glow[0] {$2/10},0,0
-elif {$1==2} -gimp_compose_hardlight[0,1] {$2/100}
-elif {$1==3} -gimp_compose_screen[0,1] {$2/100}
-elif {$1==4} -gimp_compose_multiply[0,1] {$2/100}
-endif
-if {$20==0} -gimp_mix_lab[0] $27,$26,0,$28,{if({$25>=0},{$25/4},{$25*0.75})},0,$28,$25,0,0,2,0  -endif
-endif -endif -endif -endl -done
gimp_tk_portrait_preview :
_previewflag=1
-if {$29==1} _previewflag=2 -elif {{$29==2}||{$29==3}} _previewflag=3 -elif {$29>=4} _previewflag=4 -endif
-if {$29>=2} -gimp_split_preview "-gimp_tk_portrait ${1--2}",0
-else -gimp_split_preview "-gimp_tk_portrait ${1--2}",$-1 -endif
-if {$29==1} -k[0] -elif {$29==2} -k[2] -elif {$29==3} -k[0] -elif {$29==4} -k[-3] -elif {$29==5} -k[-3]
-elif {$29==6} -k[-5] -negative -elif {$29==7} -k[-2] -elif {$29==8} -k[0] -elif {$29==9} -k[-1] -endif
_previewflag=0
gimp_deblur :
-ac "-gimp_parallel_overlap \"-deblur ${1-5} -c 0,255\",$7,$8",$6,1
gimp_deblur_preview :
-gimp_split_preview "-gimp_deblur $*",$-1
gimp_unsharp_goldmeinel:
-ac "-gimp_parallel_overlap \"-_gimp_unsharp_goldmeinel $*\",$7,$8",$6,1
_gimp_unsharp_goldmeinel :
-deblur_goldmeinel $*
-if $5 -c 0,255 -else -n 0,255 -endif
gimp_unsharp_goldmeinel_preview:
-gimp_split_preview "-gimp_unsharp_goldmeinel $*",$-1
gcd_sharpen_gradient : -skip ${1=0.5},${2=2},${3=0}
-repeat $! -l[$>]
-split_opacity
--norm[0] --bilateral[0] $2%,30 -norm[-1] --[-2,-1]
--gradient_norm[0] -negative[-1] -n[-1] 0,$1 -*[-2,-1] -+[0,-1]
-if {$3} -ac[0] "-n 0,255",ycbcr_y -else -c[0] 0,255 -endif
-a c
-endl -done
gcd_sharpen_gradient_preview :
-gimp_split_preview "-gcd_sharpen_gradient ${1--2}",$-1
gimp_sharpen_inversediff :
-ac "-gimp_parallel_overlap \"-repeat $2 -sharpen $1 -c 0,255 -done\",$4,$5",$3,1
gimp_sharpen_inversediff_preview :
-gimp_split_preview "-gimp_sharpen_inversediff $*",$-1
gimp_unsharp_octave :
-ac "-gimp_parallel_overlap \"-unsharp_octave $1,$2,$3,$4\",$6,$7",$5,1
gimp_unsharp_octave_preview :
-gimp_split_preview "-gimp_unsharp_octave $*",$-1
gimp_unsharp_richardsonlucy :
-deblur_richardsonlucy $*
-if $4 -c 0,255 -else -n 0,255 -endif
gimp_unsharp_richardsonlucy_preview :
-gimp_split_preview "-gimp_unsharp_richardsonlucy $*",$-1
gimp_sharpen_shock :
-ac "-gimp_parallel_overlap \"-repeat $5 -sharpen $1,$2,$3,$4 -c 0,255 -done\",$7,$8",$6,1
gimp_sharpen_shock_preview :
-gimp_split_preview "-gimp_sharpen_shock $*",$-1
gcd_sharpen_tones : -skip ${1=1},${2=128},${3=0}
-repeat $! -l[$>]
-split_opacity
--norm[0] --bilateral[0] 2%,30 -norm[-1] --[-2,-1]
--gradient_norm[0] -n[-1] 0,1 -oneminus[-1] -*[-2,-1]
--n[0] 0,255 -median[-1] 3 -bilateral[-1] 2%,30
-gcd_srgb2luma[-1] --[-1] $2
--max[-1] 0 -min[-2] 0 -abs[-2]
-n[-2,-1] 0,$1 -*[-2,-1] [-3] -rm[-3] -+[0,-2,-1]
-if {$3} -ac[0] "-n 0,255",ycbcr_y -else -c[0] 0,255 -endif
-a c
-endl -done
gcd_sharpen_tones_preview :
-gimp_split_preview "-gcd_sharpen_tones ${1--2}",$-1
_gimp_unsharp :
-repeat $! -repeat $8
-if {$1==0} --b. $2 -else --bilateral. $2,$3 -endif
--. [-2] -*. -$4
--norm. ->=. $5% -r. [-2] -*[-2,-1]
-if $9 -*. -1 -endif
--c. 0,100% -c.. -100%,0 -*.. $6 -*. $7 -+[-2,-1]
-+[-2,-1] -c. 0,255
-done -mv. 0 -done
gimp_unsharp :
-ac "-_gimp_unsharp $1,$2,$3,$4,$5,$6,$7,$8,$9",$10,1
gimp_unsharp_preview :
-gimp_split_preview "-gimp_unsharp $*",$-1
jeje_whiten_frequency :
-repeat $! -l[$>] -split_opacity -l[0]
-whiten_frequency {exp($1/100)-1}
-if $2 -c 0,255 -n 0,255 -else -n 0,255 -endif
-endl -a c -endl -done
jeje_whiten_frequency_preview :
-gimp_split_preview "-jeje_whiten_frequency $1,$2",$-1
simplelocalcontrast_p:
-to_rgb
[0]
-apply_parallel_overlap[1] "
-simplelocalcontrast[0] ${1-6}",{30+$3},$12
--luminance[-1]
-apply_curve[-1] 0,0,$7,64,$8,128,$9,196,$10,255,$11
-mul[-1] 255
-append[1,2] c
-blend alpha,1,0
simplelocalcontrast:
str1=$1
str2={$str1*0.7}
str3={$str2*0.7}
str4={$str3*0.7}
str5={$str4*0.7}
str6={$str5*0.7}
str7={$str6*0.7}
str8={$str7*0.7}
-apply_gamma $5
-conttest4 $4,$str1,$str2,$str3,$str4,$str5,$str6,$str7,$str8,$2,$3,$3,$3,$3,$3,$3,2,1
-apply_gamma $6
-n 0,255
conttest4:
-to_rgb
-if {$1==1}
--luminance
--smoothbase4[-1] $2,$3,$4,$5,$6,$7,$8,$9,$10
--compose_grainextract[-1,-2]
-ms_smooth[-1] $11,$12,$13,$14,$15,$16,$17,$18,1
-remove[1,2]
-sub[-1] 128 -mul[-1] 2 -add[-1] 128
--compose_grainmerge
-remove[0,1]
-else
--smoothbase4 $2,$3,$4,$5,$6,$7,$8,$9,$10
--compose_grainextract
-ms_smooth[-1] $11,$12,$13,$14,$15,$16,$17,$18,1
-remove[1]
-sub[-1] 128 -mul[-1] 2 -add[-1] 128
--compose_grainmerge
-remove[1]
-rgb2hsv
-split c
-remove[1,2,3]
-append c
-hsv2rgb
-endif
smoothbase4:
-repeat $9
cropwidth={w}
cropheight={h}
-resize[0] {w+(256-w%256)},{h+(256-h%256)},1,{s},0,1
width={w}
height={h}
-if {$1!=0}
-denoise[0] 10,$1,3,5,0,1
-endif
--resize[0] {$width/2},{$height/2},1,{s},2,1
--resize[-1] $width,$height,1,{s},3,1
-blur[-1] .5
-compose_grainextract[0,-1]
-if {$2!=0}
-denoise[-1] 10,$2,3,5,0,1
-endif
--resize[-1] {$width/4},{$height/4},1,{s},2,1
--resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainextract[1,-1]
-if {$3!=0}
-denoise[-1] 10,$3,3,5,0,1
-endif
--resize[-1] {$width/8},{$height/8},1,{s},2,1
--resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainextract[2,-1]
-if {$4!=0}
-denoise[-1] 10,$4,3,5,0,1
-endif
--resize[-1] {$width/16},{$height/16},1,{s},2,1
--resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainextract[3,-1]
-if {$5!=0}
-denoise[-1] 10,$5,3,5,0,1
-endif
--resize[-1] {$width/32},{$height/32},1,{s},2,1
--resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainextract[4,-1]
-if {$6!=0}
-denoise[-1] 10,$6,3,5,0,1
-endif
--resize[-1] {$width/64},{$height/64},1,{s},2,1
--resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainextract[5,-1]
-if {$7!=0}
-denoise[-1] 10,$7,3,5,0,1
-endif
--resize[-1] {$width/128},{$height/128},1,{s},2,1
--resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainextract[6,-1]
-if {$8!=0}
-denoise[-1] 10,$8,3,5,0,1
-endif
--resize[-1] {$width/256},{$height/256},1,{s},2,1
--resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainextract[7,-1]
-resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/1},{$height/1},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-done
gimp_split_details_alpha :
-remove_opacity
-repeat $! -l[$<]
-repeat {$1-1}
s={$3+($2-$3)*$>/if($1-2>0,$1-2,1)}
--_gimp_split_details_alpha_blur. $s
-sub_alpha.. [-1],$4
-done
-endl -done
_gimp_split_details_alpha_blur :
-if {$1>=0.1} -b. $1
-else
-if {$1>=0.05} (1,4,7,4,1;4,16,26,16,4;7,26,41,26,7;4,16,26,16,4;1,4,7,4,1)
-else (1,2,1;2,4,2;1,2,1) -endif
-normalize_sum. -convolve.. [-1] -rm.
-endif
gimp_split_details_alpha_preview :
-repeat $! -l[$>]
-gimp_split_details_alpha ${1-4}
-if $5 -remove_opacity[^-1] -else -to_rgba. -endif
N={int(sqrt($!))} N={round($!/$N,1,1)} -r2dy {100/$N}%
-repeat $! -l[$>] 0 -text. "#"{1+$>}" ",1,1,24,1,255 --dilate. 5 -to_rgba[1] -j[0] [1],2,0,0,0,1,[2],255 -k[0] -endl -done
-to_rgba -frame 1,1,0 -frame 3,3,255 -append_tiles ,
-endl -done
gimp_split_details_gaussian :
-remove_opacity -repeat $! -l[$>]
nm=${-gimp_layer_name}
pos=${-gimp_layer_pos}
-split_details $1,$2,$3
-+[^0] 128 -c[^0] 0,255 -round
-repeat {$!-1} -nm[{1+$>}] "mode(grainmerge), name"($nm" [scale ""#"{1+$>}"]), pos("$pos")" -done
-nm[0] "name"($nm" [residual]), pos("$pos")"
-rv
-endl -done
gimp_split_details_gaussian_preview :
-repeat $! -l[$>]
-gimp_split_details_gaussian $*
-if $4 -equalize[^-1] 256 -endif -n[^-1] 0,255
N={int(sqrt($!))} N={round($!/$N,1,1)} -r2dy {100/$N}%
-repeat $! -l[$>] 0 -text. "#"{1+$>}" ",1,1,24,1,255 --dilate. 5 -to_rgba[1] -j[0] [1],2,0,0,0,1,[2],255 -k[0] -endl -done
-to_rgba -frame 1,1,0 -frame 3,3,255 -append_tiles ,
-endl -done
gimp_split_details_wavelets :
-remove_opacity -repeat $! -l[$>]
nm=${-gimp_layer_name}
pos=${-gimp_layer_pos}
-split_details $1,0,0 -rv -+[^-1] 128 -c[^-1] 0,255 -round
-if $2 -to_a[^-1] -endif
-repeat {$!-1} -nm[$>] "mode(grainmerge), name"($nm" [scale ""#"{1+$>}"]), pos("$pos")" -done
-nm[-1] "name"($nm" [residual]), pos("$pos")"
-endl -done
gimp_split_details_wavelets_preview :
-repeat $! -l[$>]
-gimp_split_details_wavelets $1,0
-if $3 -equalize[^-1] 256 -endif -n[^-1] 0,255
N={int(sqrt($!))} N={round($!/$N,1,1)} -r2dy {100/$N}%
-repeat $! -l[$>] 0 -text. "#"{1+$>}" ",1,1,24,1,255 --dilate. 5 -to_rgba[1] -j[0] [1],2,0,0,0,1,[2],255 -k[0] -endl -done
-to_rgba -frame 1,1,0 -frame 3,3,255 -append_tiles ,
-endl -done
jeje_spotify:
-apply_channels "-spotify $1,$2  -apply_gamma $3 -if $4 -c 0,255 -else -n 0,255 -endif",$5,0
jeje_spotify_preview:
-gimp_split_preview "-jeje_spotify $1,$2,$3,$4,$5",$6
iain_texture_enhance_p:
-apply_parallel_overlap "-iain_texture_enhance ${1--2}",{$1*2},$-2
iain_texture_enhance_p_preview :
-gimp_split_preview "-iain_texture_enhance_p ${1--2}",$-1
iain_texture_enhance:
-tic
-ac "
-if {$1%2!=0}
--erode_circ[0] $1  -dilate_circ[-1] $1
--dilate_circ[0] $1  -erode_circ[-1] $1
-else
--erode_oct[0] $1  -dilate_oct[-1] $1
--dilate_oct[0] $1  -erode_oct[-1] $1
-endif
-sub[1] [0]
-sub[2] [0]
-add[1] [2]
-remove[2]
-mul[1] $2
--abs[1]
pt1={min(0,($4-10))}
-apply_curve[-1] 0,0,0,$pt1,0,{$4+1},1,255,1
(0.0579710145,0.1304347826,0.0579710145;0.1304347826,0.2463768116,0.1304347826;0.0579710145,0.1304347826,0.0579710145)
-convolve[-2] [-1]
-remove[-1]
-mul[1] [2]
-c[1] {$3*-1},$3
-sub[0] [1]
-keep[0]
",$5
-c 0,255
-toc
iain_texture_enhance_preview :
-gimp_split_preview "-iain_texture_enhance ${1--2}",$-1
gcd_tone_enhance : -skip ${1=1},${2=0},${3=0},${4=1},${5=0},${6=128},${7=0},${8=0},${9=0},${10=0}
-repeat $! -l[$>]
-split_opacity
--norm[0] --bilateral[0] 2%,30 -norm[-1] --[-2,-1]
--gradient_norm[0] -n[-1] 0,1 -oneminus[-1] -*[-2,-1]
--n[0] 0,255 -median[-1] 3 -bilateral[-1] 2%,30
-gcd_srgb2luma[-1] --[-1] $6
--abs[-1] -negative[-1]
--max[-2] 0 -min[-3] 0 -abs[-3]
-if $9 -pde_flow[-4] $9,7,iee -endif
--n[-3] 0,$1 -*[-1] [-5] -+[0,-1]
--n[-1] 0,$4 -*[-1] [-5] -+[0,-1]
--n[-2] 0,$7 -*[-1] [-5] -+[0,-1] -rm[-4]
--apply_gamma[-3] 0.3 -n[-1] 0,$3 -+[-1] 1 -*[0,-1]
-*[-3] $2 -*[-2] $8 -*[-1] $5 -+[0,-3--1]
-if {$10} -ac[0] "-n 0,255",ycbcr_y -else -c[0] 0,255 -endif
-a c
-endl -done
gimp_map_tones :
-ac "-map_tones ${1-4}",$5,1
-n 0,255
gimp_map_tones_preview :
-gimp_split_preview "-gimp_map_tones $*",$-1
gimp_map_tones_fast :
-ac "-map_tones_fast $1,$2",$3,2
gimp_map_tones_fast_preview :
-gimp_split_preview "-gimp_map_tones_fast ${^0}",$-1
gimp_yag_soften :
Darken=$1
Soften=$2
--gimp_laplacian[0] 0,0,100,0,0,0
-if {$Soften>0}
-gimp_gaussian_blur[1] {$Soften/10},0,0,1,0,0,0
-endif
--gimp_mix_lab[0] 0.5,50,0.2,1,2,1,1,2,1,0,10,0
-if {$Darken>0}
--blend[0,2] softlight
-blend[0,3] multiply,{$Darken/100}
-endif
-blend[0,2] hardlight
-if {$Soften!=100}
-blend[0,1] grainextract
-elif {$Soften==100}
-remove[1]
-endif
gimp_yag_soften_preview :
-gimp_split_preview "-gimp_yag_soften ${1--2}",$-1
gimp_emulate_grain :
-__gimp_emulate_grain ${-arg\ {1+$1},${-_gimp_emulate_grain}},${2-10},0,0
_gimp_emulate_grain :
-u grain_orwo_np20,grain_kodak_tmax400,grain_kodak_tmax3200,grain_kodak_trix1600,grain_unknown
gimp_emulate_grain_preview :
-gimp_split_preview "-_gimp_emulate_grain_preview $*",$-2
_gimp_emulate_grain_preview :
-__gimp_emulate_grain ${-arg\ {1+$1},${-_gimp_emulate_grain}},${2-12}
__gimp_emulate_grain :
bm0=alpha bm1=grainmerge bm2=hardlight bm3=overlay bm4=softlight bm5=alpha
-if ${_path_rc}$1.cimgz -i ${_path_rc}$1.cimgz
-else -i http://gmic.eu/data_film_presets/$1.cimgz -o. ${_path_rc}$1.cimgz
-endif
-repeat {$!-1} -l[$>,-1] -split_opacity[0]
--syntexturize. {0,max(10,100*w/$4)},{0,max(10,100*h/$4)}
-if $5 --syntexturize.. {w},{h} --syntexturize... {w},{h} -a[-3--1] c -endif
-r. {0,w},{0,h},1,100%,5 -c. 0,255
-apply_gamma. {10^$6}
--. 128 -*. $7 -+. 128 -+. $8 -c. 0,255
-if {$9||$10}
-to_color. -rgb2hsv.
-sh. 0 -+. $9 -%. 360 -rm.
-sh. 1 -+. $10 -rm.
-hsv2rgb.
-endif
-if $12 -k[0,-1] -rv
-else -blend[0,-1] ${bm$2},{if($2<=4,$3,1)}
-endif
-a[^-1] c -endl -done -rm.
gimp_emulate_film_bw :
-_gimp_emulate_film $1,${-arg\ {max(1,$1)},${-_$0}},${2--1}
-if {$1" && "$9} -to_pseudogray $9,1 -endif
_gimp_emulate_film_bw :
-u agfa_apx_100,agfa_apx_25,fuji_neopan_1600,fuji_neopan_acros_100,ilford_delta_100,ilford_delta_3200,ilford_delta_400,ilford_fp4_plus_125,\
ilford_hp5_plus_400,ilford_hps_800,ilford_pan_f_plus_50,ilford_xp2,kodak_bw_400_cn,kodak_hie_(hs_infra),kodak_t-max_100,kodak_t-max_3200,\
kodak_t-max_400,kodak_tri-x_400,polaroid_664,polaroid_667,polaroid_672,rollei_ir_400,rollei_ortho_25,rollei_retro_100_tonal,rollei_retro_80s
gimp_emulate_film_bw_preview :
-gimp_split_preview "-gimp_emulate_film_bw $*",$-1
gimp_emulate_film_instant_consumer :
-_gimp_emulate_film $1,${-arg\ {max(1,$1)},${-_$0}},${2--1}
_gimp_emulate_film_instant_consumer :
-u polaroid_px-100uv+_cold_--,polaroid_px-100uv+_cold_-,polaroid_px-100uv+_cold,polaroid_px-100uv+_cold_+,polaroid_px-100uv+_cold_++,polaroid_px-100uv+_cold_+++,\
polaroid_px-100uv+_warm_--,polaroid_px-100uv+_warm_-,polaroid_px-100uv+_warm,polaroid_px-100uv+_warm_+,polaroid_px-100uv+_warm_++,polaroid_px-100uv+_warm_+++,\
polaroid_px-680_--,polaroid_px-680_-,polaroid_px-680,polaroid_px-680_+,polaroid_px-680_++,\
polaroid_px-680_cold_--,polaroid_px-680_cold_-,polaroid_px-680_cold,polaroid_px-680_cold_+,polaroid_px-680_cold_++,polaroid_px-680_cold_++_alt,\
polaroid_px-680_warm_--,polaroid_px-680_warm_-,polaroid_px-680_warm,polaroid_px-680_warm_+,polaroid_px-680_warm_++,\
polaroid_px-70_--,polaroid_px-70_-,polaroid_px-70,polaroid_px-70_+,polaroid_px-70_++,polaroid_px-70_+++,\
polaroid_px-70_cold_--,polaroid_px-70_cold_-,polaroid_px-70_cold,polaroid_px-70_cold_+,polaroid_px-70_cold_++,\
polaroid_px-70_warm_--,polaroid_px-70_warm_-,polaroid_px-70_warm,polaroid_px-70_warm_+,polaroid_px-70_warm_++,\
polaroid_time_zero_(expired)_---,polaroid_time_zero_(expired)_--,polaroid_time_zero_(expired)_-,polaroid_time_zero_(expired),polaroid_time_zero_(expired)_+,polaroid_time_zero_(expired)_++,\
polaroid_time_zero_(expired)_cold_---,polaroid_time_zero_(expired)_cold_--,polaroid_time_zero_(expired)_cold_-,polaroid_time_zero_(expired)_cold
gimp_emulate_film_instant_consumer_preview :
-gimp_split_preview "-gimp_emulate_film_instant_consumer $*",$-1
gimp_emulate_film_instant_pro :
-_gimp_emulate_film $1,${-arg\ {max(1,$1)},${-_$0}},${2--1}
_gimp_emulate_film_instant_pro :
-u fuji_fp-100c_--,fuji_fp-100c_-,fuji_fp-100c,fuji_fp-100c_+,fuji_fp-100c_++,fuji_fp-100c_++_alt,fuji_fp-100c_+++,\
fuji_fp-100c_cool_--,fuji_fp-100c_cool_-,fuji_fp-100c_cool,fuji_fp-100c_cool_+,fuji_fp-100c_cool_++,\
fuji_fp-100c_negative_--,fuji_fp-100c_negative_-,fuji_fp-100c_negative,fuji_fp-100c_negative_+,fuji_fp-100c_negative_++,fuji_fp-100c_negative_++_alt,fuji_fp-100c_negative_+++,\
fuji_fp-3000b_--,fuji_fp-3000b_-,fuji_fp-3000b,fuji_fp-3000b_+,fuji_fp-3000b_++,fuji_fp-3000b_+++,fuji_fp-3000b_hc,\
fuji_fp-3000b_negative_--,fuji_fp-3000b_negative_-,fuji_fp-3000b_negative,fuji_fp-3000b_negative_+,fuji_fp-3000b_negative_++,fuji_fp-3000b_negative_+++,fuji_fp-3000b_negative_early,\
polaroid_665_--,polaroid_665_-,polaroid_665,polaroid_665_+,polaroid_665_++,\
polaroid_665_negative_-,polaroid_665_negative,polaroid_665_negative_+,polaroid_665_negative_hc,\
polaroid_669_--,polaroid_669_-,polaroid_669,polaroid_669_+,polaroid_669_++,polaroid_669_+++,\
polaroid_669_cold_--,polaroid_669_cold_-,polaroid_669_cold,polaroid_669_cold_+,\
polaroid_690_--,polaroid_690_-,polaroid_690,polaroid_690_+,polaroid_690_++,\
polaroid_690_cold_--,polaroid_690_cold_-,polaroid_690_cold,polaroid_690_cold_+,polaroid_690_cold_++,\
polaroid_690_warm_--,polaroid_690_warm_-,polaroid_690_warm,polaroid_690_warm_+,polaroid_690_warm_++
gimp_emulate_film_instant_pro_preview :
-gimp_split_preview "-gimp_emulate_film_instant_pro $*",$-1
gimp_emulate_film_negative_color :
-_gimp_emulate_film $1,${-arg\ {max(1,$1)},${-_$0}},${2--1}
_gimp_emulate_film_negative_color :
-u agfa_ultra_color_100,agfa_vista_200,fuji_superia_200,fuji_superia_hg_1600,fuji_superia_reala_100,fuji_superia_x-tra_800,\
kodak_elite_100_xpro,kodak_elite_color_200,kodak_elite_color_400,kodak_portra_160_nc,kodak_portra_160_vc,lomography_redscale_100
gimp_emulate_film_negative_color_preview :
-gimp_split_preview "-gimp_emulate_film_negative_color $*",$-1
gimp_emulate_film_negative_new :
-_gimp_emulate_film $1,${-arg\ {max(1,4*$1+$2-3)},${-_$0}},${3--1}
_gimp_emulate_film_negative_new :
-u fuji_160c_-,fuji_160c,fuji_160c_+,fuji_160c_++,\
fuji_400h_-,fuji_400h,fuji_400h_+,fuji_400h_++,\
fuji_800z_-,fuji_800z,fuji_800z_+,fuji_800z_++,\
fuji_ilford_hp5_-,fuji_ilford_hp5,fuji_ilford_hp5_+,fuji_ilford_hp5_++,\
kodak_portra_160_-,kodak_portra_160,kodak_portra_160_+,kodak_portra_160_++,\
kodak_portra_400_-,kodak_portra_400,kodak_portra_400_+,kodak_portra_400_++,\
kodak_portra_800_-,kodak_portra_800,kodak_portra_800_+,kodak_portra_800_++,\
kodak_tmax_3200_-,kodak_tmax_3200,kodak_tmax_3200_+,kodak_tmax_3200_++,\
kodak_tri-x_400_-,kodak_tri-x_400,kodak_tri-x_400_+,kodak_tri-x_400_++
gimp_emulate_film_negative_new_preview :
-gimp_split_preview "-gimp_emulate_film_negative_new $*",$-1
gimp_emulate_film_negative_old :
-_gimp_emulate_film $1,${-arg\ {max(1,4*$1+$2-3)},${-_$0}},${3--1}
_gimp_emulate_film_negative_old :
-u fuji_ilford_delta_3200_-,fuji_ilford_delta_3200,fuji_ilford_delta_3200_+,fuji_ilford_delta_3200_++,\
fuji_neopan_1600_-,fuji_neopan_1600,fuji_neopan_1600_+,fuji_neopan_1600_++,\
fuji_superia_100_-,fuji_superia_100,fuji_superia_100_+,fuji_superia_100_++,\
fuji_superia_400_-,fuji_superia_400,fuji_superia_400_+,fuji_superia_400_++,\
fuji_superia_800_-,fuji_superia_800,fuji_superia_800_+,fuji_superia_800_++,\
fuji_superia_1600_-,fuji_superia_1600,fuji_superia_1600_+,fuji_superia_1600_++,\
kodak_portra_160_nc_-,kodak_portra_160_nc,kodak_portra_160_nc_+,kodak_portra_160_nc_++,\
kodak_portra_160_vc_-,kodak_portra_160_vc,kodak_portra_160_vc_+,kodak_portra_160_vc_++,\
kodak_portra_400_nc_-,kodak_portra_400_nc,kodak_portra_400_nc_+,kodak_portra_400_nc_++,\
kodak_portra_400_uc_-,kodak_portra_400_uc,kodak_portra_400_uc_+,kodak_portra_400_uc_++,\
kodak_portra_400_vc_-,kodak_portra_400_vc,kodak_portra_400_vc_+,kodak_portra_400_vc_++
gimp_emulate_film_negative_old_preview :
-gimp_split_preview "-gimp_emulate_film_negative_old $*",$-1
gimp_emulate_film_print :
-_gimp_emulate_film $1,${-arg\ {max(1,$1)},${-_$0}},${2--1}
_gimp_emulate_film_print :
-u fuji3510_constlclip,fuji3510_constlmap,fuji3510_cuspclip,\
fuji3513_constlclip,fuji3513_constlmap,fuji3513_cuspclip,\
kodak2383_constlclip,kodak2383_constlmap,kodak2383_cuspclip,\
kodak2393_constlclip,kodak2393_constlmap,kodak2393_cuspclip
gimp_emulate_film_print_preview :
-gimp_split_preview "-gimp_emulate_film_print $*",$-1
gimp_emulate_film_colorslide :
-_gimp_emulate_film $1,${-arg\ {max(1,$1)},${-_$0}},${2--1}
_gimp_emulate_film_colorslide :
-u agfa_precisa_100,fuji_astia_100f,fuji_fp_100c,fuji_provia_100f,fuji_provia_400f,fuji_provia_400x,fuji_sensia_100,\
fuji_superia_200_xpro,fuji_velvia_50,generic_fuji_astia_100,generic_fuji_provia_100,generic_fuji_velvia_100,\
generic_kodachrome_64,generic_kodak_ektachrome_100_vs,kodak_e-100_gx_ektachrome_100,kodak_ektachrome_100_vs,kodak_elite_chrome_200,\
kodak_elite_chrome_400,kodak_elite_extracolor_100,kodak_kodachrome_200,kodak_kodachrome_25,kodak_kodachrome_64,lomography_x-pro_slide_200,\
polaroid_669,polaroid_690,polaroid_polachrome
gimp_emulate_film_colorslide_preview :
-gimp_split_preview "-gimp_emulate_film_colorslide $*",$-1
gimp_emulate_film_userdefined :
-if {$1<2}
-if {$!<2} -gimp_warning_preview "Input layer with Hald-CLUT is missing" -return -endif
ind={if($1,-1,0)} -map_clut[^$ind] [$ind] -rm[$ind]
-else
-l
0 -nm. "$2" ext={x} -rm.
-if {['$ext']=='cube'} -input_cube "$2"
-else -input "$2"
-endif
-onfail -gimp_warning_preview "Specified Hald-CLUT filename not found" -return
-endl
-map_clut[^-1] [-1] -rm.
-if {iM>255} -/ 255 -endif
-endif
-_gimp_emulate_film 0,1,${3--1}
gimp_emulate_film_userdefined_preview :
-gimp_split_preview "-gimp_emulate_film_userdefined $1,\"$2\",${3--2}",$-1
gimp_emulate_film_various :
-_gimp_emulate_film $1,${-arg\ {max(1,$1)},${-_$0}},${2--1}
_gimp_emulate_film_various :
-u 60{`39`}s,60{`39`}s_faded,60{`39`}s_faded_alt,alien_green,black_and_white,bleach_bypass,blue_mono,\
color_rich,faded,faded_alt,faded_analog,faded_extreme,faded_vivid,expired_fade,expired_polaroid,extreme,fade,\
faux_infrared,golden,golden_bright,golden_fade,golden_mono,golden_vibrant,green_mono,hong_kong,light_blown,lomo,\
mono_tinted,muted_fade,mute_shift,natural_vivid,nostalgic,orange_tone,pink_fade,purple,retro,rotate_muted,rotate_vibrant,\
smooth_cromeish,smooth_fade,soft_fade,solarized_color,solarized_color2,summer,summer_alt,sunny,sunny_alt,sunny_warm,\
sunny_rich,super_warm,super_warm_rich,sutro_fx,vibrant,vibrant_alien,vibrant_contrast,vibrant_cromeish,\
vintage,vintage_alt,vintage_brighter,warm,warm_highlight,warm_yellow
gimp_emulate_film_various_preview :
-gimp_split_preview "-gimp_emulate_film_various $*",$-1
_gimp_emulate_film :
-if $1
-input_clut "$2"
-repeat {$!-1}
-if {$3<1} --map_clut[$>] [-1] -j[$>] [-1],0,0,0,0,$3 -rm.
-else -map_clut[$>] [-1]
-endif
-done
-rm.
-endif
-repeat $! -l[$>] -split_opacity
-apply_gamma[0] {10^$4}
--[0] 128 -*[0] $5 -+[0] 128 -+[0] $6 -c[0] 0,255
-if {$7||$8||$9}
-rgb2hsv[0]
-sh[0] 0 -+. $7 -%. 360 -rm.
-sh[0] 1 -+. $8 -c. 0,1 -rm.
-hsv2rgb[0]
-if $9 -n[0] 0,255 -endif
-endif
-a c -endl -done
gimp_emulate_film_collage_bw :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_bw}
gimp_emulate_film_collage_instant_consumer :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_instant_consumer}
gimp_emulate_film_collage_instant_pro :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_instant_pro}
gimp_emulate_film_collage_negative_color :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_negative_color}
gimp_emulate_film_collage_negative_new :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_negative_new}
gimp_emulate_film_collage_negative_old :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_negative_old}
gimp_emulate_film_collage_print :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_print}
gimp_emulate_film_collage_colorslide :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_colorslide}
_gimp_emulate_film_collage :
$=arg -progress 0
-repeat $#
preset=${arg{$>+1}}
--l[0]
-_gimp_emulate_film[0] 1,$preset,1,0,1,0,0,0,0,0
({'$preset'}) -replace. {'_'},32 -f. if(x==0" && "i>=_'a'" && "i<=_'z',i+_'A'-_'a',i) title={t} -rm.
-text_outline. $title,2,2,$_label_size,2,1,255
-endl
-progress {(1+$>)*100/$#}
-done
-text_outline[0] "Original image",2,2,$_label_size,2,1,255
-if {!$_output_type} -frame 1,1,0 -frame 5,5,255 -- 255 -append_tiles {min($_nbc,$!)} -+ 255 -endif
gimp_emulate_film_collage_various :
-k[0] -to_rgb -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
_nbc=$2 _label_size=$3 _output_type=$4 -_gimp_emulate_film_collage ${-_gimp_emulate_film_various}
gimp_droste :
-repeat $!
-if {$16==1} 100%,100%,1,1,'x' 100%,100%,1,1,'y' -a[-2,-1] c -endif
-repeat $9
x0={round($1*w/100)} y0={round($2*h/100)} x1={round($3*w/100)} y1={round($4*h/100)}
x2={round($5*w/100)} y2={round($6*h/100)} x3={round($7*w/100)} y3={round($8*h/100)}
100%,100%,1,2,-32767 -polygon. 4,$x0,$y0,$x1,$y1,$x2,$y2,$x3,$y3,1,-65535
-sh. 0 -f. 'if(i==-65535,x03=$x0+(y-$y0)/($y3-$y0)*($x3-$x0);x12=$x1+(y-$y1)/($y2-$y1)*($x2-$x1);(x-x03)/(x12-x03)*(w-1),i)' -rm.
-sh. 1 -f. 'if(i==-65535,y01=$y0+(x-$x0)/($x1-$x0)*($y1-$y0);y32=$y3+(x-$x3)/($x2-$x3)*($y2-$y3);(y-y01)/(y32-y01)*(h-1),i)' -rm.
xshift={w*$10/100} yshift={h*$11/100} alpha={-$12*pi/180} ca={cos($alpha)/$13} sa={sin($alpha)/$13} w2={w/2} h2={h/2}
-f. 'if(i==-32767,i,X=i(x,y,0,0)-$w2;Y=i(x,y,0,1)-$h2;if(c==0,$w2-$xshift+X*$ca-Y*$sa,$h2-$yshift+X*$sa+Y*$ca))'
-if {$14==0} -sh. 0 -f. 'if(i==-32767,x,i)' -rm. -sh. 1 -f. 'if(i==-32767,y,i)' -rm.
-elif {$14==1} -sh. 0 -f. 'if(i==-32767,x,w-1-i)' -rm. -sh. 1 -f. 'if(i==-32767,y,i)' -rm.
-elif {$14==2} -sh. 0 -f. 'if(i==-32767,x,i)' -rm. -sh. 1 -f. 'if(i==-32767,y,h-1-i)' -rm.
-else -sh. 0 -f. 'if(i==-32767,x,w-1-i)' -rm. -sh. 1 -f. 'if(i==-32767,y,h-1-i)' -rm.
-endif
-if {$16<2} -warp.. [-1],0,{$16==0},$15 -rm.
-else
--warp.. [-1],0,1,$15 -rm..
-if {$16==3} -rv[-2,-1] -endif
-blend[-2,-1] alpha
-endif
-done
-if {$16==1} -warp.. [-1],0,1,1 -rm. -endif
-mv. 0 -done
gimp_droste_preview :
-if {!$17} -gimp_droste $* -else -polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,0.3,0,0,0,255 -endif
-polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,1,0xFFFFFFFF,0,0,0,255
-ellipse $1%,$2%,3,3,0,1,255,0,0,255 -ellipse $1%,$2%,3,3,0,1,0xFFFFFFFF,0,0,0,255
-ellipse $3%,$4%,3,3,0,1,255,0,255,255 -ellipse $3%,$4%,3,3,0,1,0xFFFFFFFF,0,0,0,255
-ellipse $5%,$6%,3,3,0,1,0,0,255,255 -ellipse $5%,$6%,3,3,0,1,0xFFFFFFFF,0,0,0,255
-ellipse $7%,$8%,3,3,0,1,0,255,255,255 -ellipse $7%,$8%,3,3,0,1,0xFFFFFFFF,0,0,0,255
gimp_frame_blur :
-repeat $! -l[$>] -to_rgb
sx={$1%*max(w,h)} sy={$2%*max(w,h)}
--r {w+$sx},{h+$sy},1,100%,3 -b[1] $4%
-if $6 -balance_gamma[1] ${7-9} -endif
-if {$10==1} -n[1] 0,255 -elif {$10==2} -n[1] 0,255 -equalize[1] 256 -endif
-rv
-z[1] {$3/2}%,{$3/2}%,{100-$3/2}%,{100-$3/2}%
-to_rgba[1]
-if $5 r={1+1/$5} -sh[1] 100% -f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
-c. $v,{$v+0.5/max(w,h)} -n. 0,255 -rm. -endif
s={$11%*max(w,h)}
-r[1] {w+$s},{h+$s},1,4,0,0,0.5,0.5
-i[1] 100%,100%,1,3 -fc[1] ${12-14} -blend[1,2] alpha -to_a.
-if $5 -sh[1] 100% -f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))}
-c. $v,{$v+0.5/max(w,h)} -n. 0,255 -rm. -endif
-rotate[1] $21,1,0
-r[1] [0],[0],1,4,0,0,$19,$20
--channels[1] 100% -b. $17%,0 -c. 0,{max(1,100-$18)}% -n. 0,255
-shift. {round(w*$15%)},{round(h*$16%)},0,0,0 -/. -255 -+. 1 -*[0,-1]
-blend alpha
-endl -done
gimp_frame_fuzzy :
-repeat $! -l[$>]
sx={$1%*max(w,h)/2} sy={$2%*max(w,h)/2}
-frame_fuzzy $sx,$sy,${3-7}
-endl -done
gimp_frame_painting :
-if $14
-repeat $! 100%,100%,1,4 -frame_painting. $1%,$2,$3%,${4-6},$7%,${8-13}
-rv[-2,-1] -to_a. -r. [-2],[-2],1,4,0,0,0.5,0.5 -mv[-2,-1] 0 -done
-else -frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}
-endif
gimp_frame_painting_preview :
-frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}
gimp_frame_pattern :
-if {$2||$!==1} -repeat $3 -frame_pattern $1,$4 -done
-else -repeat $3 -frame_pattern[^0] $1,[0],$4 -done -endif
gimp_frame_pattern_preview :
-gimp_frame_pattern ${1-3},1
gimp_frame :
-to_rgba -repeat $!
-z. $1%,$3%,$2%,$4%
-frame. $11,$11,${12-15}
sx={$5%*max(w,h)} sy={$6%*max(w,h)}
-frame. $sx,$sy,${7-10}
-mv. 0 -done
gimp_frame_round :
-frame_round ${1-8}
-if $9 -frame_blur $1,{min(99,$1+$9)},$3,$10,$11% -endif
gimp_frame_smooth :
-repeat $! -l[$>]
sx={$1%*max(w,h)} sy={$2%*max(w,h)}
100%,100%,1,1,0
-if $3 r={1+1/$3} -f. '1-(abs(x/w-0.5)^$r+abs(y/h-0.5)^$r)^(1/$r)'
v={min(i(w/2,0),i(w-1,h/2),i(w/2,h-1),i(0,h/2))} -le. $v
-endif
-frame $sx,$sy,1
-inpaint_diffusion[0] [1],100%,1,15
-rm.
-endl -done
gimp_old_photo :
-vignette ${1-3} -old_photo
gimp_polaroid :
-vignette ${7-9} -polaroid $1,$2 -drop_shadow $3%,$4%,$5% -rotate $6,1,0
gimp_tunnel :
-tunnel $1,$2%,${3-6}
gimp_vignette :
-repeat $! -to_rgb -l[$>]
-to_rgba -split_opacity
-=. 0 -vignette. ${1-3} -a c --fc ${4-7} -rv -blend alpha
-endl -done
gimp_bandpass :
-repeat $! -l[$>] -split_opacity -l[0]
-ac "-bandpass $1%,$2%",$3,$4
-endl -a c -endl -done
gimp_bandpass_preview :
-gimp_split_preview "-gimp_bandpass $*",$-1
gimp_display_fft :
-to_rgb -display_fft
gimp_fourier : -skip ${2=0}
-if $2 -remove_opacity -endif
-if $1 -repeat $! -l
-fft82float -c 0,255
-onfail -error "Image ["$>"] does not seem to be a FFT transform."
-endl -done
-else -float2fft8 -endif
gimp_fourier_preview :
-if $2 -remove_opacity -endif
-if $1 -gimp_no_preview 0
-else -dfft
-endif
gimp_watermark_fourier :
-watermark_fourier "$1",$2 -c 0,255
gimp_align_layers :
-to_colormode 0
-r ${-max_wh},1,100%,0,0,0.5,0.5
-if ${4=0} -_gimp_revert_layers -endif
-remove_opacity
-if $1 -register_nonrigid[^-1] [-1],$2,0.1,$3
-else -register_rigid[^-1] [-1],{3*$2}
-endif
gimp_align_layers_preview :
-gimp_align_layers $1,$2,0 -blend_edges 0.1
_gimp_revert_layers :
-repeat {int($!/2)} -rv[{2*$>},{2*$>+1}] -done
gimp_blend_average_all :
-if $! -to_rgba
N=$! -r ${-max_wh},1,100%,0,0,0.5,0.5
-_gb_fwd $1
-+ -/ $N
-_gb_bwd $1
-endif
_gb_fwd :
-to_color
-if {$1==1} -repeat $! -l[$>] -sh 0,2 -srgb2rgb. -rm. -endl -done
-elif {$1==2} -repeat $! -l[$>] -sh 0,2 -srgb2rgb. -rgb2lab. -rm. -endl -done
-endif
_gb_bwd :
-to_color
-if {$1==1} -repeat $! -l[$>] -sh 0,2 -rgb2srgb. -rm. -endl -done
-elif {$1==2} -repeat $! -l[$>] -sh 0,2 -lab2rgb. -rgb2srgb. -rm. -endl -done
-endif
gimp_blend_edges :
-repeat {int($!/2)} -l[$>,{$>+1}] -if $3 -rv -endif --blend_edges[-2,-1] $2 -rm... -blend[-2,-1] alpha,$1 -endl -done
gimp_blend_fade :
-if {$!==1} -return -endif
-to_colormode 4
-_gb_fwd $7
-if {$1==0} [0],[0],1,1,"$11"
-else -_gimp_blend_fade$1 $8,$9,$10 -r. [0],[0],1,1,3
-endif
-n. {-($!-2)*$3},{($!-2)*(1+$3)}
--. {$2*(1+$3)*($!-2)}
-c. 0,{$!-2}
-if $6 -rv[^-1] -endif
-if $5 -round. 1
-else -roundify. $4
-endif
-blend_fade[^-1] [-1] -rm.
-_gb_bwd $7
-c 0,255
_gimp_blend_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_gimp_blend_fade2 : [0],[0],1,1,0 -=. 1,{($1+1)*50}%,{($2+1)*50}% -distance. 1
_gimp_blend_fade3 : [0],[0],1,1,0 -=. 1,{($1+1)*50}%,{($2+1)*50}% -distance. 1 -*. {0.01+$3/2} -cos.
_gimp_blend_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"
gimp_blend_median :
-_gb_fwd $1
-blend_median
-_gb_bwd $1
gimp_blend_seamless :
-rv
-_gb_fwd $4
-to_a[^0] -r[^0] [0],[0],1,100%,0
-repeat $! pos=${-gimp_layer_pos[$>]} -shift[$>] ${-u\ $pos},0,0 -done
-if $5
--blend_seamless $1,$2%,$3%
-remove_opacity[0,-1] -k[0,-1] -rv -sub_alpha[0] [1],1
-else
-blend_seamless $1,$2%,$3%
-endif
-_gb_bwd $4
gimp_blend_seamless_preview :
-gimp_blend_seamless ${1-4},0
gimp_blend :
mode=${-arg\ 1+$1,add,alpha,and,average,blue,burn,darken,difference,\
divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
shapeaverage,shapeaverage0,softburn,softdodge,softlight,screen,stamp,subtract,value,\
vividlight,xor}
-if {$2==0} -repeat {int($!/2)} -l[$>,{$>+1}] -rv -blend $mode,$3 -endl -done
-elif {$2==1" && "$!>1} -blend[^0] [0],$mode,$3,0 -rm[0]
-elif {$2==2" && "$!>1} -blend[^-1] [-1],$mode,$3,1 -rm.
-endif
gimp_blend_preview :
-gimp_blend $*
-if $4 -append_tiles , -endif
gimp_split_colors : -skip ${2=0}
-to_rgb -repeat $! -l[$>]
nm=${-gimp_layer_name}
min_area={max(1,w*h*$3%)}
-split_colors $1,$2,$min_area
-nm name($nm)
-if $4 -gimp_autocrop_layers -endif
-endl -done
gimp_split_colors_preview :
-repeat $! -l[$>]
--gimp_split_colors ${1-4} -drgba
-repeat $! -l[$>] -text_outline ${-arg\ {1+!!$>},"Original","#"$>},1,1,43,7,1,255 -endl -done
-frame 1,1,0 -frame 3,3,255 -to_rgba -append_tiles ,
-endl -done
gimp_fade_layers :
-if {$!<2} -return -endif
-to_colormode 0
-r ${-max_wh},1,100%,0,0,0.5,0.5
-a z -r 100%,100%,{(d-1)*$1+1},100%,3 -s z
gimp_fade_layers_preview :
-if {$!<2} -return -endif
-to_colormode 0
-r ${-max_wh},1,100%,0,0,0.5,0.5
-k[0,1] -+ -/ 2
gimp_append_tiles_preview :
-frame 1,1,0,0,0,255 -append_tiles $1,$2
gimp_morph :
-if ${4=0} -_gimp_revert_layers -endif
-to_rgb -morph $1,$2,$3
gimp_apply_multiscale : -skip "${13=}"
-repeat $! -l[$<]
w0={w} h0={h}
-apply_scales "$13",$1,$2%,$3%,{10^$4},{arg(1+$5,1,3,5,6)}
-if {$8||($9&&$8!=$12)} -to_a N=$! -repeat $!
angle={$9?$8+($12-$8)*$>/max($N-1,1):$8}
-rotate[$>] $angle
-done -endif
-if $14
-if $15 siz=$w0,$h0 -else siz=${-max_wh} -endif
-r $siz,1,100%,{arg($14,1,3,5,6)}
-c 0,255
-endif
w=${-max_w} h=${-max_h} N=$!
-repeat $!
cx={$9?$6+($10-$6)*$>/max($N-1,1):$6}
cy={$9?$7+($11-$7)*$>/max($N-1,1):$7}
-gimp_set_layer_pos[$>] {$>,($w-w)*$cx},{$>,($h-h)*$cy}
-done
-endl -done
gimp_apply_multiscale_preview :
-repeat $! -l[$>]
-gimp_apply_multiscale $"*"
N={int(sqrt($!))} N={round($!/$N,1,1)} -r2dy {100/$N}%
-to_rgba
max_wh=${-max_wh}
N=$! -repeat $! -l[$>]
cx={$9?$6+($10-$6)*$>/max($N-1,1):$6}
cy={$9?$7+($11-$7)*$>/max($N-1,1):$7}
-r $max_wh,1,100%,0,0,$cx,$cy
0 -text. "#"{1+$>}" ",1,1,24,1,255 --dilate. 5 -to_rgba[1] -j[0] [1],2,0,0,0,1,[2],255 -k[0]
-endl -done
-frame 1,1,0 -frame 3,3,255 -append_tiles ,
-endl -done
gimp_pack : -skip "${5=}"
-if $3 -to_a -endif
-if $4 -repeat $! nm$>=${-gimp_layer_name[$>]} -done -endif
c0="w" c1="h" c2="max(w,h)" c3="w*h"
-pack $2,${c$1} coords=${}
-if $4
-repeat 256 -filename "$5/gmic_pack.txt",$> filename=${} -if $filename -else -break -endif -done
-if {!narg($filename)} filename="$5/gmic_pack.txt" -endif
-l[] -repeat {narg($coords)/2}
x={arg(1+2*$>,$coords)} y={arg(2+2*$>,$coords)}
({'"Image ""#"{1+$>}" ("${nm$>}"): "$x,$y\n'})
-done -a x -o raw:$filename,uchar -rm -endl
-endif
-nm "name(G'MIC packing),pos(0,0),mode(normal)"
gimp_pack_preview :
-if {!$!} -return -endif
w={w} h={h}
filled=0 -repeat $! filled={$>,$filled+w*h} -done
-gimp_pack $1,$2,$3,0
area={w*h}
-to_rgba -rr2d $w,$h,0
-i[0] $w,16,1,4,255 -t[0] "Filled: "{round(100*$filled/$area)}%,3,1,14,1,0,0,0,255
-a y,0.5
gimp_stroke :
-to_a -repeat $! -l[$<] nm={n}
-if {!$26" && "$5} -expand_xy $1,0 is_frame1=0 -else -expand_xy 1,0 is_frame1=1 -endif
-split_opacity --l.
-b $3
-if {$6>=100}
-shift $7,$8
-if {$6!=100} wh={w},{h} -r $6%,$6%,1,1,3 -r $wh,1,1,0,0,0.5,0.5 -endif
-else
-if {$6!=100} wh={w},{h} -r $6%,$6%,1,1,3 -r $wh,1,1,0,0,0.5,0.5 -endif
-shift $7,$8
-endif
-gt {99.99-min(99.99,$2)}%
-distance $5,$4
($9^$10^$11^$12)
-if {$1>1} ($13^$14^$15^$16) -a[-2,-1] x -r. $1,1,1,4,3 -c. 0,255 -endif
-i.. ($21^$22^$23^$24) ($17^$18^$19^$20) -if $5 -rv[-3,-1] -endif
-a[-3--1] x -map.. [-1],1 -rm.
-nm $nm
-endl
-a[0,1] c
-if $is_frame1 -shrink_xy 1 -endif
-if $25 -rv -endif
-endl -done
gimp_stroke_preview :
-repeat $! -l[$>]
-gimp_stroke $*
-nm foo
-gimp_merge_layers
-endl -done
gimp_tiles2layers_preview :
-split_tiles $1,$2,$3 -to_rgba -frame 1,1,0,0,0,255 -frame 3,3,0,0,0,0 -append_tiles ,
gimp_tones2layers :
sval=$2 eval={max($2,$3)}
-remove_opacity -repeat $! -l[$<]
--luminance -rv
-repeat {$1-1}
[1]
val0={$sval+($eval-$sval)*$>/($1-2)}
val1={$sval+($eval-$sval)*($>+1)/($1-2)-1}
--ir[0] $val0,$val1
-if $5 -*. [0] -b. $4% -n. 0,255
-else -b. $4% -n. 0,255
-endif
-a[-2,-1] c
-done
-rm[0] -rv
-endl -done
gimp_tones2layers_preview :
-gimp_tones2layers $* -rv
-r {100/$!}%,{100/$!}%,1,100%,2
-to_rgba -frame 1,1,0,0,0,255 -frame 3,3,0,0,0,0 -append_tiles ,
_gimp_burn :
-repeat $! -l[$>]
w={w} h={h}
--norm
-gimp_fourier. 0
--rows. 0,{$h-1} -r. $2%,$2%,1,100%,0,0,0.5,0.5 -b. $3%
-j.. [-1],{($w-w)/2},{($h-h)/2} -rm.
-gimp_fourier. 1
-blend overlay,$1
-endl -done
gimp_burn :
-ac "-_gimp_burn ${1-3}",$4,$5
gimp_burn_preview :
-gimp_split_preview "-gimp_burn ${^0}",$-1
gimp_contrast_swm :
-repeat $! -l[$>] -split_opacity -l[0]
--luminance -to_rgb
-blur_xy[1] $1,$1
-if {$2==0} -negative[1] -elif {$2==1} -gimp_do_nothing -endif
-rv -blend hardlight,$3
-endl -a c -endl -done
gimp_dodgeburn :
-repeat $! -l[$>] --luminance -if {$9==1} --fc[0] 128,128,128,255 -endif
-tk_gimp_channel_processing[1] 1,1,0,$2,4,0,{100-$1},256,0,1,0,2,0,0
-tk_gimp_channel_processing[1] 1,1,{-{256-$3}},0,0,0,100,256,0,0,0,2,0,0
-gimp_gaussian_blur[1] $4,0,0,1,0,0,0 --luminance[0]
-if {$9==0} -compose_dodge[0,1] -else -rv[1,2] -compose_dodge[1,2] -endif
-tk_gimp_channel_processing[-1] 1,1,0,$6,4,$5,100,256,0,0,0,2,0,0
-tk_gimp_channel_processing[-1] 1,1,{256-$7},0,0,0,100,256,0,0,0,2,0,0
-gimp_gaussian_blur[-1] $8,0,0,1,0,0,0
-if {$9==0} -compose_colorburn[0,1] -else -compose_colorburn[-1,-2] -endif
-if {$9==1} -gimp_gaussian_blur[-1] $11,0,0,1,0,0,0 -endif
-if {$10==0} -if {$9==1} -rm[0] -endif -endif -endl -done
gimp_dodgeburn_preview :
-gimp_split_preview "-gimp_dodgeburn ${1--2}",$-1
gimp_split_freq :
-repeat $!
--b[-1] $1 --[-2] [-1] -/[-2] 2 -+[-2] 128 -rv[-2,-1]
-mv[-2,-1] 0 -done
gimp_compose_freq :
-repeat {int($!/2)}
--[-1] 128 -*[-1] 2 -+[-2,-1] -c[-1] 0,255
-mv[-1] 0 -done
compose_alpha :
-e[^-1] "Compose image$? two-by-two, using alpha blending."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-r[-1] [-2],[-2],[-2],100%,0,0,0.5,0.5
-to_colormode[-2] {a1=!({-2,s}%2);a2=!(s%2);max({-2,s}-a1,s-a2)+a1}
-to_colormode[-1] {a=max({-2,s},s);a+(a%2)}
-if {-2,s==2" || "s==4}
-_compose_alpha[-2] -_compose_alpha[-1]
-sh[-1] {s-1},{s-1} --*[-3,-1] -rm[-2] -+[-3,-2] --[-2,-1]
-sh[-1] 0,{s-2} -sh[-2] {-2,s-1},{-2,s-1}
-max[-1] 1e-10 -/[-2] [-1] -*[-1] 255 -rm[-2,-1]
-else
-sh[-1] 0,{s-2} -sh[-2] {-2,s-1},{-2,s-1} --[-2] [-4] -*[-2,-1] -/[-1] 255 -rm[-1] -+[-2,-1]
-endif
-endl -done -c 0,255 -v +
_compose_alpha :
-sh[-1] 0,{s-2} -sh[-2] {-2,s-1},{-2,s-1} -max[-1] 1e-10 -/[-1] 255 -*[-2,-1] -rm[-1]
gimp_compose_alpha :
-if ${2=0} -_gimp_revert_layers -endif
-repeat {int($!/2)}
-to_rgba[-1] -sh[-1] 3,3 -*[-1] $1 -rm[-1]
-blend[-2,-1] alpha
-mv[-1] 0 -done
gimp_drop_shadow :
-* -1 -+ 255 -vignette {255*$5},80,95 -* -1 -+ 255
-drop_shadow $1%,$2%,$3%,$4 -rotate $6,1,0
gimp_drop_shadow3d :
-repeat $! -l[$<]
--_gimp_drop_shadow3d $*
-endl -done
gimp_drop_shadow3d_preview :
-repeat $! -l[$<]
-if $13 -_gimp_drop_shadow3d $*
-else --_gimp_drop_shadow3d $* -rv -blend alpha
-endif
-endl -done
_gimp_drop_shadow3d :
-point3d 0,0,1 -r3d. 1,0,0,$1 -r3d. 0,1,0,$2 -r3d. 0,0,1,$3
u={i(0,8)} v={i(0,9)} w={i(0,10)} -rm.
-to_a -channels 100% -if {im==iM} -return -endif
--f 'X=x/w-0.5;Y=y/h-0.5;A=($7-$4*$7/100)*$w/(X*$u+Y*$v+$7*$w);if(A<0,1e8,A)'
--*. 'y/h-0.5' -*.. 'x/w-0.5' -+.. {0.5-$5/100} -+. {0.5-$6/100} -*.. {w} -*. {h}
-a[-2,-1] c -warp[0] [-1],0,1,0 -rm.
-b $8% -n 0,$12 -i.. ($9^$10^$11) -r.. [-1],[-1],1,3 -a[-2,-1] c
gimp_equalize_shadow :
-repeat $! -l[$>] --negative -blend softlight,$1 -endl -done
gimp_equalize_shadow_preview :
-gimp_split_preview "-gimp_equalize_shadow $1",$-1
_gimp_lightglow :
mode=${-arg\ 1+$3,burn,dodge,freeze,grainmerge,hardlight,interpolation,lighten,multiply,overlay,reflect,softlight,stamp,value}
-repeat $!
--gradient_norm. ->=. {100-$1}% -distance. 1 -^. $2 -*. -1 -n. 0,255 -blend $mode,$4
-mv. 0 -done
gimp_lightglow :
-ac "-_gimp_lightglow ${1-4}",$5
gimp_lightglow_preview :
-gimp_split_preview "-gimp_lightglow $*",$-1
gimp_light_leaks :
filename=lightleak_${"-padint $1",6}.cimgz
-if ${_path_rc}$filename -i ${_path_rc}$filename
-else -i http://gmic.eu/data_lightleaks/$filename -o. ${_path_rc}$filename
-endif
mode=${-arg\ 1+$7,normal,lighten,screen,dodge,add,darken,multiply,burn,overlay,softlight,hardlight,difference,subtract,grainextract,grainmerge,divide,hue,saturation,value}
-mv. 0
-repeat {$!-1} -l[0,{1+$<}]
--r[0] {1,w},{1,h},1,3,5
-rotate. $2,1,1,50%,50%
-if {$3>1" || "$4>1} -f. 'w2=w/2;h2=h/2;X=x-w2;Y=y-h2;i(w2+X/$3,h2+Y/$4,0,c,1,0)' -endif
-c. 0,255
-if $5 -rgb2hsv. -sh. 0 -+. $5 -rm. -hsv2rgb. -endif
-if $8
nm=${-gimp_layer_name[1]}
-nm. name($nm),opacity({$6*100}),mode($mode) -rv[-2,-1]
-else -blend[1,-1] $mode,$6 -endif
-endl -done
-rm[0]
gimp_light_leaks_preview :
-gimp_split_preview "-gimp_light_leaks ${1--3},0",$-1,0,1
_gimp_light_leaks :
u="" -repeat 71 -if {narg($u)} u=$u, -endif u=${u}lightleak_${"-padint "$>,6} -done
-u $u
gimp_light_patch :
-repeat $! -l[$>] -split_opacity -l[0]
-ac "-light_patch $1,$2,$3",$4
-endl -a c -endl -done
gimp_lightrays :
-lightrays $1,$2%,$3%,$4,$5
-if $6 -repeat $! -r[$>] 100%,100%,1,{{$>,s}+({$>,s}%2)} -done -endif
gimp_light_relief :
-b $11% -light_relief ${1-10}
gimp_shadow_patch :
-repeat $! -l[$>] -split_opacity -l[0]
-ac "-shadow_patch $1",$2
-endl -a c -endl -done
gimp_slice_luminosity :
-remove_opacity -repeat $! -l[$<] -to_rgb
-_gimp_slice_luminosity $*
-if $2 -i[0] [0] -a[-2,-1] c -endif
-rv
-endl -done
gimp_slice_luminosity_preview :
-remove_opacity  -repeat $! -l[$>] -to_rgb
-_gimp_slice_luminosity $*
-if {$3==0} -rm[0] -channels {s-1}
-elif {$3==1} 100%,100%,1,1,128 -a[0,-1] c -r. 100%,100%,1,4 -blend alpha
-elif {$3==2} -a c
-else -+. 96 -c. 0,255 -a c
-endif
-endl -done
_gimp_slice_luminosity :
-if {$1==0} --compose_channels + -/. 3
-elif {$1==1} --luminance
-elif {$1==2} --srgb2rgb -rgb2lab8. -channels. 0
-else --compose_channels max
-endif
-if $4 --apply_curve[1] 0,{$5-$7-0.1},0,$5,255,$6,255,{$6+$8+0.1},0,512,0 -endif
-if $9 --apply_curve[1] 0,{$10-$12-0.1},0,$10,255,$9,255,{$11+$13+0.1},0,512,0 -endif
-if $14 --apply_curve[1] 0,{$15-$17-0.1},0,$15,255,$16,255,{$16+$18+0.1},0,512,0 -endif
-if $19 --apply_curve[1] 0,{$20-$22-0.1},0,$20,255,$21,255,{$21+$23+0.1},0,512,0 -endif
-rm[1] -max[^0]
gimp_boxfitting :
-boxfitting ${1-3},3
-if $4 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif
gimp_boxfitting_preview :
-boxfitting ${1-3},1
-if $4 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif
gimp_canvas :
-repeat $! -l.
-if $4
({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor. -r. [-2],[-2] --smooth.. [-1],$1 -rm.. -sharpen. $3 -c. 0,255
({cos($6*pi/180)}^{sin($6*pi/180)}) -vector2tensor. -r. [-2],[-2] -smooth... [-1],$5 -rm. -sharpen.. $7 -c.. 0,255 -+[-2,-1] -/. 2
-else
({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor. -r. [-2],[-2] -smooth.. [-1],$1 -rm. -sharpen. $3 -c. 0,255
-endif
-endl -mv. 0 -done
gimp_canvas_preview :
-gimp_split_preview "-gimp_canvas $*",$-1
jeje_clouds :
--clouds $1%,1,$2 -blend alpha
jeje_clouds_preview :
-jeje_clouds $1,$2
gimp_cracks :
-ac "-cracks $1,$2,$3",$4
gimp_cracks_preview :
-gimp_split_preview "-gimp_cracks $*",$-1
gimp_crystal :
-repeat $! -l[$>] -split_opacity -l[0]
s={s}
--gradient_norm ->=. {(100-$3)/5} -remove_pixels. {100-max(0.1,$1*$3%)}%,{is} -*
--norm -neq. 0 -a c
sigma=0.2
-do
--b. $sigma sigma*={(1+$2)}
-sh[0,-1] $s -max. [-2] -rm[-2,-1]
-f. 'W=i(x,y,z,$s);if(W<0.001||W>=1,0,if(c<$s,i/W,1))'
-if {!iM} -rm[1] -break -endif
-sh. $s
-j[0] [1],0,0,0,0,1,[2] -k[0]
-while 1
-channels 0,{$s-1}
-endl -a c -endl -done
gimp_crystal_preview :
-gimp_split_preview "-gimp_crystal $*",$-1
Denim_samj_en :
-Denim_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
jeje_fibers :
100%,100%,1,1,0
-l[-1]
-fibers $1,$2%,$3
-gt 0
-n 0,255
-endl
-r[-1] [0]
-max
jeje_fibers_preview :
-gimp_split_preview "-jeje_fibers $1,$2,$3",$-1
gimp_halftone :
-apply_gamma {10^$1} -- 128 -* $2 -+ 128 -+ $3 -b $4 -c 0,255
-repeat $! -l[$>] -split_opacity
-halftone[0] ${5-9}
-a c -endl -done
gimp_halftone_preview :
-gimp_split_preview "-gimp_halftone $*",$-1
iain_halftone_shapes:
-remove_opacity
scale=$1
-luminance
-if {$4==1}
-resize 400%,400%,1,1,3
scale={$scale*4}
-endif
-if {$3==0}
sx1=353
sx2=515
sx3=677
sx4=1000
sx5=1323
sx6=1485
sx7=1647
sx8=1485
sx9=1323
sx10=1000
sx11=677
sx12=515
sy1=1000
sy2=1280
sy3=1560
sy4=1560
sy5=1560
sy6=1280
sy7=1000
sy8=720
sy9=440
sy10=440
sy11=440
sy12=720
level=19
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 19
-polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level
sy3={$sy3-(78/16)}
sy5={$sy5-(78/16)}
sy9={$sy9+(78/16)}
sy11={$sy11+(78/16)}
sx1={$sx1+(90/16)}
sx3={$sx3+(45/16)}
sx5={$sx5-(45/16)}
sx7={$sx7-(90/16)}
sx9={$sx9-(45/16)}
sx11={$sx11+(45/16)}
level={$level+10}
-done
radius={560}
level=209
-repeat 57
-circle 50%,50%,$radius,1,$level
radius={$radius-10}
level={$level+10}
-done
-n 0,255
--shift[0] 972,560,0,0
--shift[0] 972,-560,0,0
--shift[0] -972,560,0,0
--shift[0] -972,-560,0,0
-add
-crop 29,440,1972,1560
-endl
-resize[1] 194,112,1,1,2
-equalize[1] 65555
-resize[1] $scale%,$scale%,1,1,3
-if {$2==1}
-negative[1]
-endif
-endif
-if {$3==1}
sx1=50
sx2=194
sx3=281
sx4=511
sx5=742
sx6=829
sx7=972
sx8=829
sx9=742
sx10=511
sx11=281
sx12=192
sy1=450
sy2=633
sy3=849
sy4=817
sy5=849
sy6=633
sy7=450
sy8=267
sy9=50
sy10=83
sy11=50
sy12=267
level=10
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 128
-polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level
sx2={$sx2+(40/16)}
sx6={$sx6-(40/16)}
sx8={$sx8-(40/16)}
sx12={$sx12+(40/16)}
sy2={$sy2-(23/16)}
sy4={$sy4-(47/16)}
sy6={$sy6-(23/16)}
sy8={$sy8+(23/16)}
sy10={$sy10+(47/16)}
sy12={$sy12+(23/16)}
level={$level+12}
-done
-n 0,255
-resize 200,200,1,1,3
--shift[0] -69,-40,0,0
--shift[0] -69,40,0,0
--shift[0] 69,-40,0,0
--shift[0] 69,40,0,0
-add
-crop 5,5,142,84
-endl
-resize[1] 194,112,1,1,2
-equalize[1] 65555
-resize[1] $scale%,$scale%,1,1,3
-if {$2==1}
-negative[1]
-endif
-endif
-if {$3==2}
sx1=161
sx2=1000
sx3=1839
sy1=273
sy2=1727
sy3=273
level=10
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 375
-polygon 3,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,1,$level
sx1={$sx1+2.21}
sx3={$sx3-2.21}
sy1={$sy1+1.28}
sy2={$sy2-2.56}
sy3={$sy3+1.28}
level={$level+1}
-done
--rotate[0] 180
--shift[1] {840+2}
-shift[1] -840
-add
-crop 160,{216+56},1842,1727
-n 0,255
-endl
-equalize[1] 256
-resize[1] 168,145,1,1,2
-resize[1] $scale%,$scale%,1,1,3
-if {$2==1}
-negative[1]
-endif
-endif
-if {$3==3}
-luminance
--l
-rm
-l
190,190,1,1,0
-circle 50,50,50,1,10
-circle 140,50,50,1,10
-polygon 5,10,80,50,50,140,50,180,80,95,190,1,10
-resize[-1] {0,w+2},{0,h+2},1,1,0,0,0.5,0.5
--resize[0] 95%,95%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 90%,90%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 85%,85%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 75%,75%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 65%,65%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 55%,55%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 50%,50%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 45%,45%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 40%,40%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 35%,35%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 30%,30%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 25%,25%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 20%,20%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 15%,15%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 10%,10%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 5%,5%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
-add
-endl
[0]
-append y
-resize 200%,100%,1,1,0,0,0.5,0.5
--shift[0] 160,100,0,0
--shift[0] -160,100,0,0
-add
-crop 30,190,350,100%
-n 0,255
-endl
-resize[-1] $scale,$scale,1,1,2
-if {$2==1}
-negative[1]
-endif
-endif
width={w}
height={h}
w_tiles={round({0,w}/$width)}
h_tiles={round({0,h}/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
-append_tiles[1--1] $w_tiles,$h_tiles
-equalize[-1] 256
-rotate[-1] $5,1,2,50%,50%,1
-twirl[-1] $6,.5,.5,2
-blend alpha,0.5,1
-gt 128
-mul 255
-if {$4==1}
-resize 25%,25%,1,1,3
-endif
gimp_hearts :
-ac "-hearts $1",$2
gimp_hearts_preview :
-gimp_split_preview "-gimp_hearts $*",$-1
gimp_lava :
-repeat $! -l[$>] -split_opacity -l[0] -norm
100%,100% -plasma. 1,1,{16-$1} -smooth. $2,0,1,$3,$3,0.8,90 -*
-gradient_norm -n 0,255
-equalize -map 3
-sharpen $4
-endl -a c -endl -done
gimp_lava_preview :
-gimp_split_preview "-gimp_lava $*",$-1
gimp_marble :
-repeat $! -l[$>] -split_opacity -l[0]
-marble $1/10,$2/10,$3,$4,$5,$6,$7,$8,$9%,$10%
-endl -a c -endl -done
gimp_maze :
-repeat $!
w={w} h={h}
-r. {100/$1}%,{100/$1}%,1,100%,2
-if {$3==0} -f. 1
-elif {$3==1} -negative.
-endif
-maze_mask. $1 -dilate. $2 -*. 255
-if {!$5} -negative. -endif
-if $4 -r. $w,$h,100%,100% -endif
-mv. 0 -done
gimp_mineral_mosaic :
-repeat $! -l[$>] -to_rgb
--b $3 -segment_watershed. $1 --norm.
-area. 0 --<=. {$2^2} -inpaint.. [-1] -rm. -label.
--f[0] 'if(c==0,x,y)' -rv[-2,-1] --blend[-2,-1] shapeaverage,1,1
--[-3,-1] -rm[0,-2] -channels. 0,1
alpha={$5*pi/180} -sh. 0 -*. {cos($alpha)} -rm. -sh. 1 -*. {sin($alpha)} -rm. -compose_channels. +
-normalize_local. 1000 -n. -$4,$4
-+ -c 0,255
-endl -done
gimp_mosaic :
-ac "-mosaic $1",$2
gimp_mosaic_preview :
-gimp_split_preview "-gimp_mosaic $*",$-1
gimp_shapes :
-if $1
-remove_opacity -repeat $! -l[$>]
-if {!$7} -_gimp_shapes $* -* 255
-elif {$7==1} -split_opacity -to_rgb[0] -s[0] c -repeat 3 -_gimp_shapes[$>] $* -done -*[0-2] 255 -a[0-2] c -a c
-else --_gimp_shapes $* -r[0] $3%,$3% -r[0] [1],[1] -*
-endif
-endl -done
-else
-if {$!<=$2} -error[] "Command '-gimp_shapes': Some layers are missing in 'Custom layers' mode ("{$2+1}" expected at least, "$!" provided)." -endif
-to_colormode[0-{$2-1}] ${-max_s[0-{$2-1}]} -remove_opacity[$2--1]
-repeat {$!-$2} -l[0-{$2-1},{$2+$>}]
-norm. w={w} h={h} -r. $3%,$3%,1,1,2
s={$4*max(round($w/w),round($h/h))}
r0={$s*$5%} r1={$s*$6%}
-repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} -if $r --r[$>] $r,$r,1,100%,3 -else 1,1 -endif -done
-r[-$2--1] $s,$s,1,100%,0,0,0.5,0.5
-map_sprites[$2--1] $2,$8
-endl -done -rm[0-{$2-1}]
-endif
gimp_shapes_preview :
-if $1 -repeat $! -l[$>]
w={w} h={h}
-gimp_split_preview "-gimp_shapes ${1-3},1,${5--2}",$-1
-r $w,$h,1,100%,0,0,0.5,0.5
-endl -done
-else
-if {$!>$2} -repeat {$!-$2} -l[0-{$2-1},{$2+$>}]
w={w} h={h}
--gimp_shapes ${1-3},1,${5--2} -rm..
-r. $w,$h,1,100%,0,0,0.5,0.5
-endl -done -rm[0-{$2-1}]
-else -gimp_warning_preview "Missing input layers!"
-endif
-endif
_gimp_shapes :
-norm w={w} h={h} -r $3%,$3%,1,1,2
s={(1+$10)*$4*max(round($w/w),round($h/h))}
r0={$s*$5%} r1={$s*$6%}
-repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} -if $r -_gimp_shapes{$1-1}[] $r,$s -else 1,1 -endif -done
-r[-$2--1] $s,$s,1,1,0,0,0.5,0.5
-if $9 -rv[-$2--1] -*[-$2--1] -1 -+[-$2--1] 1 -endif
-map_sprites $2,$8
-if $10 -r 50%,50%,1,1,2 -endif
_gimp_shapes0 :
-shape_circle $1
_gimp_shapes1 :
$1,$1,1,1,1
_gimp_shapes2 :
$1,$1,1,1 -= 1,50%,50% -distance 1,1 -< {$1/2}
_gimp_shapes3 :
$2,$2,1,1,'x+y<=2*$1-1'
_gimp_shapes4 :
$2,$1,1,1,1
_gimp_shapes5 :
$1,$2,1,1,1
_gimp_shapes6 :
-ball $1,200 -n 0,1
_gimp_shapes7 :
-shape_heart 65 -r $1,$1,1,1,2 ->= 50%
_gimp_shapes8 :
-shape_star $1
_gimp_shapes9 :
-arrow3d 0,0,0,1,0,0,15%,40%,30% -col3d 1 -*3d $1 -c3d
$2,$2 -j3d. [-2],50%,50%,0,1,2,0,0
-rm.. --mirror y -max
_gimp_shapes10 :
S={$2+1-($2%2)}
$S,$S,1,1,"X=x/(w-1);Y=y/(h-1);r=abs(0.5-sqrt(X^2+Y^2));a=atan2(y,x);r<0.1-0.17*(0.5-$1/$2)*sin(2*a)"
--mirror xy -max
_gimp_shapes11 :
-_gimp_shapes0 $* -expand_xy 1,0 --erode 3 --
_gimp_shapes12 :
-_gimp_shapes1 $* -expand_xy 1,0 --erode 3 --
_gimp_shapes13 :
-_gimp_shapes2 $* -expand_xy 1,0 --erode 3 --
_gimp_shapes14 :
-_gimp_shapes3 $* -expand_xy 1,0 --erode 3 --
_gimp_shapes15 :
-_gimp_shapes7 $* -expand_xy 1,0 --erode 3 --
_gimp_shapes16 :
-_gimp_shapes8 $* -expand_xy 1,0 --erode 3 --
_gimp_shapes17 :
-_gimp_shapes9 $* -expand_xy 1,0 --erode 3 --
gimp_pack_sprites :
-if $6
-if {$!<2} -error[] "Command '-gimp_pack_sprites': Masking requires at least two input layers ! (please check that 'Input Layers' is correctly set)." -endif
-repeat {$!-1} -l[$>] -to_rgba -split_opacity --!=[1] 0 -*[0] [-1] -a c -autocrop 0 -endl -done
-remove_empty[0--2] --channels. 100% -channels. -4,0 -mv. 0
-pack_sprites[0--2] ${1-5}
-else
-repeat $! -l[$>] -to_rgba -split_opacity --!=[1] 0 -*[0] [-1] -a c -autocrop 0 -endl -done
-remove_empty -i[0] $7,$8,1,5 -pack_sprites ${1-5}
-endif
-channels[0] 0,{0,s-2}
gimp_paper :
-ac "-texturize_paper",$1
gimp_paper_preview :
-gimp_split_preview "-gimp_paper $*",$-1
jeje_periodic_dots:
tW={max(w,h)/$4}
$tW,$tW
-periodic_dots[-1] $*
-repeat {$4*$4-1}
-i [-1]
-done
-append_tiles[1--1] $4,$4 -k[-1]
-if {$5>0} -n 0,255 -map {$5-1} -endif
jeje_periodic_dots_preview:
-jeje_periodic_dots $*
gimp_plaid_texture :
-repeat $! -l[$>]
w={w} h={h} s={s}
-rows $1%
-b $5% -sharpen $6
-r $w,$h,1,$s,2
--rotate[0] $3,1,2,50%,50%
-repeat {$2-1} --rotate[0] {$3+$4*($>+1)/($2-1)},1,2,50%,50% -+[-2,-1] -done -rm[0]
-/ $2
-endl -done
gimp_polka_dots :
-to_rgba -polka_dots {$1*$2/100},${2--1}
gimp_color_ellipses :
-color_ellipses $1,$2,$3
jeje_rays :
-s c
-l[0] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $6,$9 -endl
-l[1] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $7,$10 -endl
-l[2] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $8,$11 -endl
-a c
jeje_rays_preview:
-gimp_split_preview "-jeje_rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11",$-1
samj_reptile_en :
-samj_reptile $1,$2,$3,$4,{$5/100},$6,$7
gimp_syntexturize_preview :
-gimp_split_preview "-syntexturize 100%",$-1
_gimp_syntexturize_patchmatch_preview :
-repeat $! -l[$>] w={w} h={h}
-syntexturize_patchmatch 100%,100%,${3--1}
-to_rgba -r $w,$h,1,4,0,0,0.5,0.5
-endl -done
gimp_syntexturize_patchmatch_preview :
-gimp_split_preview "-_gimp_syntexturize_patchmatch_preview ${1--2}",$-1
gimp_rorschach :
-repeat $! -remove_opacity -l[$>]
-if {$3==0} -norm -rorschach $1%,$2 -* 255
-elif {$3==1} -to_rgb -rorschach $1%,$2 -* 255
-else --norm -rorschach. $1%,$2 -blend shapeaverage0
-endif
-endl -done
gimp_mad_rorscharchp :
-gimp_rorschach $1,1,1
--mirror y
-if {$2==0} -gimp_compose_average 1,0
-elif {$2==1} -gimp_compose_grainextract 1,0
-elif {$2==1} -gimp_compose_vividedges 1,1,0.5,1 -endif
--gimp_plaid_texture $3,2,0,90,$4,$5
-if {$6==0} -gimp_compose_vividedges 1,1,0.5,1
-elif {$6==1} -gimp_compose_average 1,0
-elif {$6==2} -gimp_compose_difference 1,0
-elif {$6==3} -gimp_compose_negation 1,0
-elif {$6==4} -gimp_compose_negation 1,0
-elif {$6==5} -gimp_compose_darkedges 1,1,0.8,1 -endif
-if {$7==0} -gimp_graphic_novelfxl 0,2,6,5,20,0,0.62,14,0,1,0.5,0.78,1.92,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==1}-gimp_graphic_novelfxl 0,7.2,14.65,5,20,0,1.06,36.14,0,1,0.5,0.85,1.93,0,0,8,1,1,1,0.5,0.95,2.89,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==2} -gimp_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.6,36.1,0,1,0.5,0.6,3.6,0,0,11,1,1,1,0.5,0.8,2.16,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$7==3}  -gimp_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,17,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$7==4} -gimp_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.855422,1.92771,0,0,8,1,1,1,0.5,0.373494,2.89157,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==5} -gimp_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,14,0,1,0.5,0.855422,1.3253,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==6} -gimp_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,36.1446,0,1,0.5,0.855422,1.92771,0,0,7,1,1,1,0.5,0.951807,1.92771,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$7==7} -gimp_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,18,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1 -endif
-if {$8==1} -gimp_array_mirror 1,0,0,2,0,$9
-elif {$8==2} -gimp_array_mirror 1,0,0,3,0,$9 -endif
gimp_seamless_turbulence :
-repeat $! -l[$>]
wh={w},{h} -rm
$wh,1,{if($6,3,1)} -rand. 0,255
$wh -rand. {$3*pi/180-$4*10*pi},{$3*pi/180+$4*10*pi} --sin. -cos.. -a[-2,-1] c
-r[-2,-1] 130%,130%,1,100%,0,2,0.5,0.5 -b. $2 -orientation.
-vector2tensor.
-smooth.. [-1],$1,0.5,20 -rm.
-r. $wh,1,100%,0,0,0.5,0.5
-if {$5!=1} ia={ia} -- $ia -* $5 -+ $ia -endif
-endl -done
-c 0,255 -n 0,255
_gimp_shockwaves :
-dct
100%,100%,1,1,1 -circle. 0,0,{$2+$3}%,1,{$1+1} -circle. 0,0,$2%,1,1
-* -idct -c 0,255
gimp_shockwaves :
-ac "-_gimp_shockwaves ${1-3}",$4
gimp_shockwaves_preview :
-gimp_split_preview "-gimp_shockwaves $*",$-1
gimp_SimpleNoiseCanvas :
CanvasScale={$1}
NoiseAmplitude=$2
NoiseType=$3
ThreadHorizLen=$4
ThreadVertLen=$5
OverAllBlurr=$6
HighCut=$7
LowCut=$8
CanvasMergeChoice=$9
InvertCanvasColors=$10
InvertImageColors=$11
ReverseChoice=$12
MergeChoice=$13
PreserveCanvas=$14
-to_rgb[0]
CanvasScale={1.2-$CanvasScale}
(255^255^255)
-r[-1] [0]
-r[1] {100*$CanvasScale}%,{100*$CanvasScale}%
-if {$NoiseType!=2} NoiseAmplitude={($NoiseAmplitude*10)} -endif
-gimp_noise[1] $NoiseAmplitude,$NoiseType,0,1,0
-gimp_ditheredbw[1] 1,1,0,0,0,0
--gimp_gaussian_blur[1] 0,$ThreadHorizLen,0,1,0,0,0
--gimp_gaussian_blur[1] 0,0,$ThreadVertLen,1,0,0,0
-normalize[2] 0,255
-normalize[3] 0,255
-if {$CanvasMergeChoice==0} -blend[2,3] average
-elif {$CanvasMergeChoice==1} -blend[2,3] multiply
-elif {$CanvasMergeChoice==2} -blend[2,3] darken
-elif {$CanvasMergeChoice==3} -blend_edges[2,3] 0.9
-endif
-gimp_gaussian_blur[2] $OverAllBlurr,0,0,1,0,0,0
-remove[1]
-r[1] [0]
($15^$16^$17)
-r[2] [0]
-blend[1,2] multiply
-gimp_apply_curve {$LowCut},-1,128,-1,128,-1,128,-1,128,-1,128,{$HighCut},1,3,0,0,0
-if {$ReverseChoice==1} -reverse[0,1] -endif
-if {$InvertCanvasColors==1} -negative[1] -endif
-if {$InvertImageColors==1} -negative[0] -endif
-if {$MergeChoice==0} --blend[1,0] average
-elif {$MergeChoice==1} --blend[1,0] multiply
-elif {$MergeChoice==2} --blend[1,0] screen
-elif {$MergeChoice==3} --blend[1,0] darken
-elif {$MergeChoice==4} --blend[1,0] lighten
-elif {$MergeChoice==5} --blend[1,0] difference
-elif {$MergeChoice==6} --blend[1,0] negation
-elif {$MergeChoice==7} --blend[1,0] exclusion
-elif {$MergeChoice==8} --blend[1,0] overlay
-elif {$MergeChoice==9} --blend[1,0] hardlight
-elif {$MergeChoice==10} --blend[1,0] softlight
-elif {$MergeChoice==11} --blend[1,0] dodge
-elif {$MergeChoice==12} --blend[1,0] colorburn
-elif {$MergeChoice==13} --blend[1,0] reflect
-elif {$MergeChoice==14} --blend[1,0] freeze
-elif {$MergeChoice==15} --blend[1,0] stamp
-elif {$MergeChoice==16} --blend[1,0] interpolation
-elif {$MergeChoice==17} --blend[1,0] grainextract
-elif {$MergeChoice==18} --blend[1,0] grainmerge
-elif {$MergeChoice==19} --blend[1,0] xor
-elif {$MergeChoice==20} --blend_edges[1,0] 0.8
-endif
-if {$ReverseChoice==1} -reverse[0,1] -endif
-if {$PreserveCanvas==0} -remove[1]  -endif
-if {$PreserveCanvas==1" && "$MergeChoice!=21} -reverse[1,2]  -endif
-if {$MergeChoice!=21} -remove[0] -endif
-if {$MergeChoice!=21" && "$PreserveCanvas==1} -reverse[0,1] -endif
gimp_SimpleNoiseCanvasPreview :
-gimp_split_preview "-gimp_SimpleNoiseCanvas ${1--2}",$-1
gimp_sponge :
-ac "-sponge $1",$2
gimp_sponge_preview :
-gimp_split_preview "-gimp_sponge $*",$-1
gimp_stained_glass :
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-stained_glass $1,$2,$3
-n 0,255
-if $4 -equalize. -endif
-rgb2lab. -sh. 1,2 -*. $5 -rm. -lab2rgb.
-apply_gamma. {10^$6} --. 128 -*. $7 -+. {128+$8}
-c. 0,255
-endl -a c -endl -done
gimp_stained_glass_preview :
-gimp_split_preview "-gimp_stained_glass $*",$-1
gimp_stars :
-repeat $! -l[$>] -split_opacity -rv
-stars $1%,$2,$3,$4,$5,$6%,${7-9},{$10/255}
-rv -a c -endl -done
gimp_stencil :
-v -
-if {$5==0} -norm -stencil $1,$2,$3
-elif {$5==1} -stencil $1,$2,$3
-else -repeat $!
--norm. -stencil. $1,$2,$3 ->=. 50% -blend[-2,-1] shapeaverage0
-mv. 0 -done -endif
-if $6 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif
-if $4 -smooth {30*$4},0,1,1 -endif
gimp_stencil_preview :
-gimp_split_preview "-gimp_stencil $*",$-1
jeje_strip :
theta={pi*$1/180}
-f '0.5*i*(1+$4*sin(2*pi*$2*(cos($theta)*x/w+sin($theta)*y/h)+2*pi*$3/180))'
-c 0,255
jeje_strip_preview :
-gimp_split_preview "-jeje_strip $*",$-1
gimp_tetris :
-tetris $1
gimp_truchet :
-repeat $! -l[$>]
100%,100% -truchet $1,$2,$4 -rm..
-if {$5==1} -* -1
-elif {$5==2} -i[0] 100%,100%,1,1,1
-elif {$5==3} -i[0] 100%,100%
-elif {$5==4} -* -1 -i[0] 100%,100%
-elif {$5==5} -* -1 -i[0] 100%,100%,1,1,-1
-elif {$5==6} -label 0,1 {iM+1},1,1,3 -rand. 0,255 -map.. [-1] -rm.
-endif
-a c -b $3 -n 0,255
-endl -done
jeje_turing_pattern:
--l
-r {$1*w},{$1*h},1,2
-turing_pattern $2,$3,$4,$5,$6,$7,$8
-endl
-r[1] 100%,100%,100%,3,0 -r[1] [0],5 -rm[0] -blur .75 -n 0,255
gimp_whirls :
-ac "-whirls $1,$2,$3,$4",$5
gimp_whirls_preview :
-gimp_split_preview "-gimp_whirls $*",$-1
gimp_blocks3d :
-repeat $! -l[$>]
nm=${"-gimp_layer_name"}
W={w} H={h} M={max(w,h)}
-if {w>h} -r2dx $1 -else -r2dy $1 -endif
w={w} h={h} m={max(w,h)}
-if {$3>0} -mirror y -endif
-imageblocks3d $3,$2%
--3d. {$w/2},{$h/2} f={$4*$M/($m*(2-$16))} -*3d $f,$f,{$f*abs($3*$1/100)}
-if {$3>0} -r3d 1,0,0,180 -endif
-r3d 0,0,1,$5 -r3d 1,0,0,$6
-if $16 {2*$M},{2*$M},1,4,-1 -else $M,$M,1,4,-1 -endif
f3d={0.5*w/tan($7*pi/360)} -f3d $f3d
-l3d {$10*$f3d},{$11*$f3d},{$12*$f3d} -sl3d $13 -ss3d $14
-j3d. [0],$8%,$9%,0,1,{if($15,3,2)},0,1
-sh. 100% -+. 1 -*. 255 -rm.
-if $20
[-1],[-1],1,3,-1
-j3d. [0],$8%,$9%,0,1,3,0,1 -rm[0]
-g. xy,1 -+[-2,-1] -norm. -!=. 0
--r. 100%,100%,1,3
-sh. 0 -*. $17 -rm.
-sh. 1 -*. $18 -rm.
-sh. 2 -*. $19 -rm.
-j[0] [-1],0,0,0,0,{$20/255},[-2] -rm[-2,-1]
-else -rm[0]
-endif
-replace_color 0,0,-1,-1,-1,0,0,0,0,0
-if $16 -r 50%,50%,1,4,2 -endif
-c 0,255 -nm name($nm)
-endl -done
_gimp_coloredobject3d :
-to_rgb -_gimp_coloredobject3d$1$2 ${6-8} -col3d. ${3-5}
-db3d 0
gimp_coloredobject3d :
-_gimp_coloredobject3d "_",${1-4,6-8}
-repeat {$!-1}
--gimp_render3d. {$>,w},{$>,h},$6,${9--1}
-sh. 3 -*. {$5/255} -rm.
-blend[$>,-1] alpha
-done
-rm.
gimp_coloredobject3d_preview :
-_gimp_coloredobject3d "_preview_",${1-4,6-8}
-repeat {$!-1}
--gimp_render3d. {$>,w},{$>,h},$6,${9--1}
-sh. 3 -*. {$5/255} -rm.
-blend[$>,-1] alpha
-done -rm.
_gimp_coloredobject3d_0 : -plane3d 1 -*3d. $1,$2,1
_gimp_coloredobject3d_1 : -box3d 1 -*3d. $1,$2,$3
_gimp_coloredobject3d_2 : -pyramid3d 1,1 -*3d. $1,$2,$3
_gimp_coloredobject3d_3 : -sphere3d 1 -*3d. 1,{2*$2},{2*$3}
_gimp_coloredobject3d_4 : -torus3d $1,{$2/2},100,50 -*3d. $3,0.5,0.5
_gimp_coloredobject3d_5 : -gyroid3d 24 -*3d. $1,$2,$3
_gimp_coloredobject3d_6 : -weird3d 32 -*3d. $1,$2,$3
_gimp_coloredobject3d_7 : -cup3d 128 -*3d. $1,$2,$3
_gimp_coloredobject3d_preview_0 : -plane3d 1 -*3d. $1,$2,1
_gimp_coloredobject3d_preview_1 : -box3d 1 -*3d. $1,$2,$3
_gimp_coloredobject3d_preview_2 : -pyramid3d 1,1 -*3d. $1,$2,$3
_gimp_coloredobject3d_preview_3 : -sphere3d 1 -*3d. 1,{2*$2},{2*$3}
_gimp_coloredobject3d_preview_4 : -torus3d $1,{$2/2},100,50 -*3d. $3,0.5,0.5
_gimp_coloredobject3d_preview_5 : -gyroid3d 8 -*3d. $1,$2,$3
_gimp_coloredobject3d_preview_6 : -weird3d 12 -*3d. $1,$2,$3
_gimp_coloredobject3d_preview_7 : -cup3d 64 -*3d. $1,$2,$3
_gimp_elevation3d :
-repeat {$!/2} -l[$>,{min($>+1,$!-1)}]
-if {$!==1} --norm -else -r[1] [0],3 -endif
-n[1] 0,$1 -b[1] $2
-elevation3d[0] [1] -rm[1]
-endl -done
-db3d
gimp_elevation3d :
-_gimp_elevation3d ${1-2} -gimp_render3d ${3--1}
gimp_elevation3d_preview :
-gimp_elevation3d ${1-2},{w},{h},${5--1}
_gimp_extrude3d :
-repeat {$!/2} -l[$>,{min($>+1,$!-1)}]
-extrude3d. $1,$2,$3%
-if {$!==2} -t3d. [-2] -rm.. -endif
-endl -done
-db3d 0
gimp_extrude3d :
-_gimp_extrude3d ${1-3} -gimp_render3d ${4--1}
gimp_extrude3d_preview :
-gimp_extrude3d ${1-3},{w},{h},${6--1}
_gimp_imageobject3d :
-to_rgb -repeat $! -l[$>] -_gimp_imageobject3d$1$2 -endl -done
-db3d 0
gimp_imageobject3d :
-_gimp_imageobject3d "_",$1 -gimp_render3d ${2--1}
gimp_imageobject3d_preview :
w={w} h={h} -_gimp_imageobject3d "_preview_",$1 -gimp_render3d $w,$h,${4--1}
_gimp_imageobject3d_0 : -imageplane3d
_gimp_imageobject3d_1 : -imagecube3d
_gimp_imageobject3d_2 : -imagepyramid3d
_gimp_imageobject3d_3 : -imagesphere3d 64,32
_gimp_imageobject3d_4 : -torus3d 100,30,100,50 -t3d. [-2] -rm..
_gimp_imageobject3d_5 : -gyroid3d 24 -t3d. [-2] -rm..
_gimp_imageobject3d_6 : -weird3d 32 -t3d. [-2] -rm..
_gimp_imageobject3d_7 : -cup3d 128 -t3d. [-2] -rm..
_gimp_imageobject3d_8 : -imagerubik3d 5,5
_gimp_imageobject3d_preview_0 : -imageplane3d
_gimp_imageobject3d_preview_1 : -imagecube3d
_gimp_imageobject3d_preview_2 : -imagepyramid3d
_gimp_imageobject3d_preview_3 : -imagesphere3d 16,8
_gimp_imageobject3d_preview_4 : -torus3d 100,30,100,50 -t3d. [-2] -rm..
_gimp_imageobject3d_preview_5 : -gyroid3d 8 -c3d. -n3d. -t3d. [-2] -rm..
_gimp_imageobject3d_preview_6 : -weird3d 12 -t3d. [-2] -rm..
_gimp_imageobject3d_preview_7 : -cup3d 64 -t3d. [-2] -rm..
_gimp_imageobject3d_preview_8 : -imagerubik3d 3,3,5,5
_gimp_lathing3d :
-repeat {$!/2} -l[$>,{min($>+1,$!-1)}]
-lathe3d. $1,$2%,$3
-if {$!==2} -t3d. [-2] -rm.. -endif
-endl -done
-db3d 0
gimp_lathing3d :
-_gimp_lathing3d ${1-3} -gimp_render3d ${4--1}
-nm name("[3d lathing]"),pos(0,0),mode(alpha)
gimp_lathing3d_preview :
-gimp_lathing3d ${1-3},{w},{h},${6--1}
gimp_random3d :
-repeat $! -l[$>]
f3d={0.5*max(w,h)/tan($5*pi/360)} -f3d $f3d -l3d {$6*$f3d},{$7*$f3d},{$8*$f3d} -sl3d $9 -ss3d $10
-to_rgb ({w},{h},{d},{s}) -/. 2 -repeat $2
({1,@0}) -+. {1,@1} -*. $3 -/. 100 -_gimp_random3d$1 {^} -rm..
-r3d. 1,1,0,{u(0,360)}
({u(-1,1)}) -*. {1,@0} ({u(-1,1)}) -*. {1,@1}
-+3d... {-2,^},{^},{u(-$4,$4)} -rm[-2,-1]
-col3d. {u(255)},{u(255)},{u(255)} -done -+3d[2--1] -j3d[0] [-1],50%,50%,0,$12,$11,0,1
-k[0]
-endl -done
_gimp_random3d0 : -box3d $1
_gimp_random3d1 : ($1) -/. 2 -cone3d {^},$1 -rm..
_gimp_random3d2 : ($1) -/. 2 -cylinder3d {^},$1 -rm..
_gimp_random3d3 : -sphere3d $1,2
_gimp_random3d4 : ($1) -/. 3 -torus3d $1,{^} -rm..
samj_Adjacent_Annular_Steiner_Chains_en :
-samj_Adjacent_Annular_Steiner_Chains $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48
samj_en_Annular_Steiner_Chains :
-samj_Annular_Steiner_Chains $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40
gimp_ball :
-ball $1,${5-7},${2-4} -mv. 0 -nm[0] "name(Ball)"
gimp_ball_preview :
-gimp_ball $*
-if {$!>1} -rv[-2,-1] -blend[-2,-1] alpha -endif
gimp_circle_art :
-if {!$2} -f 0 -return -endif
-if {$1==0}
{round(2*($2^1.5))}
-rand. -1,1 --rand. -1,1 --rand. -$3,$3 -a[-3--1] y
-else
{max(1,round($2*$7))}
t0={$8*2*pi/180}
-rows. 0,2 -f. 'r=x/(w-1);t=2*pi*x/$2;if(y==0,(r^$11)*cos($t0+$13*t),if(y==1,(r^$12)*sin($t0+$14*t),max(0,$3*($9+($10-$9)*r))))'
-endif
-l.
-transpose -s x,-1 h={h}
-i[0] ({'CImg3d'},{2*$h},$h)
--+... [-1] --[-4,-2] -i [-2] -i[-3,-1] 1,100% -a[-6--1] x
1,$h,1,1,5 1,$h,1,1,2*y --+. 1 -a[-3--1] x -z. 0,5
3,$h,1,1,1 1,$h,1,1,-1 -y -a y
-endl
-repeat {$!-1} -l[$>,-1]
s={0,max(w,h)} -rm[0]
-if $5 {2*$s},{2*$s} --*3d[0] $s
-else $s,$s --*3d[0] {$s/2}
-endif
-j3d[1] [2],50%,50%,0,1,2,0,0 -rm[2]
-%. $4
-if $6 -i.. 100%,100%,1,3 -rand.. 0,255 -plasma.. 1,1 -equalize.. 256 -n.. 0,255 -blend[-2,-1] shapeaverage -endif
-rv
-endl -done
-rm.
-n 0,255
-if $5 -r 50%,50%,1,100%,2 -endif
gimp_cupid :
-if {$!>0} siz={min(${-min_w},${-min_h})} -else siz=512 -endif
-shape_cupid $siz -to_rgba.
-replace_color. 0,0,0,0,0,255,$2,$3,$4,0
-replace_color. 0,0,1,1,1,255,$2,$3,$4,$5
-frame. {2.5*$1}%,{2.5*$1}%,$2,$3,$4,0 -b. $1%
-blend[-2,-1] alpha
gimp_equation_parametric :
-repeat $! -l[$>]
w={w} h={h} -rm
$5,1,1,2,'"t=$3+x*($4-$3)/($5-1);if(c==0,$1,$2)"'
-channels. 0,2
($8,$11^$9,$12^$10,$13) -r. {-2,w},1,1,3,3 -a c
-display_parametric $w,$h,{$6+$14*1.001},$7,$15,$16
-endl -done
gimp_equation_plot :
-repeat $! -l[$>]
w={w} h={h} -rm
$4,1,1,$5,"X=$2+($3-$2)*x/($4-1);$1"
-dg $w,$h,$6,$7,$2,$3
-endl -done
samj_en_Linear_Gradient_CIE_Lab :
-samj_Linear_Gradient_CIE_Lab $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
samj_en_Shape_Linear_Gradient_CIE_Lab :
-samj_Shape_Linear_Gradient_CIE_Lab $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20
gimp_corner_gradient : -skip ${17=0}
-repeat $! -l[$>]
wh={w},{h} -rm
($1,$5;$9,$13^$2,$6;$10,$14^$3,$7;$11,$15^$4,$8;$12,$16)
-_gb_fwd $17
-r. $wh,1,100%,3
-_gb_bwd $17
-endl -done
gimp_custom_gradient_preview : -skip "${15=}"
-repeat $! -l[$>]
-if $4
--_gimp_custom_gradient1 ${1-14},"$15",${16--1} --erode. 3 --[-2,-1] --dilate. 5 -a[-2,-1] c -n. 0,255
-gimp_custom_gradient[0] ${1-14},"$15",${16--1},-1 -blend alpha
-else -gimp_custom_gradient ${1-14},"$15",${16--1},-1
-endif
-if $14
--_gimp_custom_gradient0[] ${1-14},"$15",${16--1} -r. {{0,w}-16},16,1,4 -frame. 1,1,0 -j[0] [-1],8,{0,h-25} -rm.
-endif
-endl -done
gimp_custom_gradient : -skip "${15=}"
-_gimp_custom_gradient0 ${1-14},"$15",${16--1}
-if {$-1>=0&&narg("$15")}
dir_ggr=${-path_gimp}gradients
0 -nm. ${"-normalize_filename \"$15\""} name_ggr={b} -rm. -output_ggr. $dir_ggr/$name_ggr.ggr,"$15"
-endif
-i.. (0^0^0^0) -a[-2,-1] x
-repeat {$!-1} -l[$>,-1]
-_gimp_custom_gradient1[0] ${1-14},"$15",${16--1}
--distance[0] 1,$11 --distance[0] 0,$11 -*. -1 -+[0] 1 -+[0,-2,-1]
m={$9%*{0,im}} M={$10%*{0,iM}}
--[0] $m -*[0] {1,(w-2)/($M-$m)} -+[0] 1
-round[0] -map[0] [-1]
-endl -done
-rm.
_gimp_custom_gradient0 :
-if $16 4,8,1,1,${18-56} -permute. yzcx
-else 8,1,1,3 -srand $17 -rand. 0,255 -to_rgba.
-endif
-z. 0,{$5-1}
-if $13
-r. {200*$6}%,1,1,4,0,2
-__gimp_custom_gradient0. $12,$8
-shift. {-round(w*0.5*$7%)},0,0,0,2 -z. 0,{w/2-1}
-else
-__gimp_custom_gradient0. $12,$8
-r. {100*$6}%,1,1,4,0,2 -shift. {-round(w*$7%)},0,0,0,2
-endif
__gimp_custom_gradient0 :
-if {$1==1} -sh. 0,2 -rgb2hsv. -rm.
-elif {$1==2} -sh. 0,2 -srgb2rgb. -rgb2lab. -rm.
-endif
-r. {$2*w},1,1,4,3
-if {$1==1} -sh. 0,2 -hsv2rgb. -rm.
-elif {$1==2} -sh. 0,2 -lab2rgb. -rgb2srgb. -rm.
-endif
_gimp_custom_gradient1 :
-b $2%
-if {$1==0}
-to_a -split_opacity
-if {iM>im+32}
-rm.. ->=[0] {100-$3}%
-else
-rm. -norm -n 0,1
-if {ia>0.5} -<=[0] $3% -else ->=[0] {100-$3}% -endif
-endif
-elif {$1==1}
-remove_opacity -norm -<= $3%
-elif {$1==2}
-remove_opacity -norm ->= {100-$3}%
-else
-to_a -channels 100% ->= {100-$3}%
-endif
gimp_line_gradient : -skip "${10=}"
-_gimp_line_gradient $*
-if {narg("$10")}
dir_ggr=${-path_gimp}gradients
0 -nm. ${"-normalize_filename \"$10\""} name_ggr={b} -rm. -output_ggr. $dir_ggr/$name_ggr.ggr,"$10"
-endif
-repeat $! -r[$>] 100%,64,1,100% -done
gimp_line_gradient_preview :
-repeat $! -l[$>]
-to_rgba
-if $9 --_gimp_line_gradient $* -endif
-l[0]
-line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,255,255,255,255
-line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,0,0,0,255
-circle $1%,$2%,4,1,255,0,0,255
-circle $3%,$4%,4,1,0,0,255,255
-circle $1%,$2%,4,1,0xFFFFFFFF,0,0,0,255
-circle $3%,$4%,4,1,0xFFFFFFFF,0,0,0,255
-endl
-if {$!>1} -r. {{0,w}-32},32,1,4,1 -frame. 1,1,0,0,0,255 -j[0] [1],16,{{0,h}-48} -rm. -endif
-endl -done
_gimp_line_gradient :
-at_line $1%,$2%,0,$3%,$4%,0 -r {max(0.1,$5)}%,1,1,100%,1
-m "feature1 : -channels 0"
-m "feature2 : -channels 1"
-m "feature3 : -channels 2"
-m "feature4 : -to_rgb -luminance"
-m "feature5 : -to_rgb -rgb2ycbcr -channels 1"
-m "feature6 : -to_rgb -rgb2ycbcr -channels 2"
-m "feature7 : -to_rgb -srgb2rgb -rgb2lab -channels 0"
-if $7 -repeat $! -l[$>] --feature$7 -rv -a y -sort +,x -rows 1 -endl -done -endif
-if $6 -r $6,1,1,100%,3 -endif
-if $8 -mirror x -endif
gimp_linear_gradient : -skip ${13=0}
-repeat $! -l[$>]
wh={w},{h} -rm
($1^$2^$3^$4) ($5^$6^$7^$8)
-if $9 -rv[-2,-1] -endif
-r $wh
-_gb_fwd $13
-fade_linear $10,$11,$12
-_gb_bwd $13
-endl -done
gimp_radial_gradient : -skip ${14=0}
-repeat $! -l[$>]
wh={w},{h} -rm
($1^$2^$3^$4) ($5^$6^$7^$8)
-if $9 -rv[-2,-1] -endif
-r $wh
-_gb_fwd $14
100%,100% -=. 1,$12%,$13% -distance. 1 -_fade $10,$11
-_gb_bwd $14
-endl -done
gimp_random_gradient :
-repeat $! -l[$>]
-to_rgba 100%,100% -srand $2
-skip {"for (n=0, n<$1, ++n,
x = round(u(w-1));
y = round(u(h-1));
i(x,y) = 1;
i(#0,x,y,0,0) = round(u(255));
i(#0,x,y,0,1) = round(u(255));
i(#0,x,y,0,2) = round(u(255));
i(#0,x,y,0,3) = $7*255 + (1-$7)*round(u(255));
)"}
-if {$7!=1} -sh.. 100% -n. 0,255 -rm. -endif
-eq. 0
-sh.. 0,2 -srgb2rgb. -rm.
-inpaint_diffusion.. [1],100%,1 -rm.
-b $3% -n 0,255
-sh 0,2 -rgb2srgb. -balance_gamma. ${4-6} -rm.
-endl -done
gtutor_hairlock :
($4^$5^$6)
-rgb2hsl[-1]
hue={i[0]}
sat={0.97*i[1]}
light={i[2]}
opac={$7/255}
var={0.1*$8}
-rm[-1]
-repeat $!
-local[$>]
--diffusiontensors[-1] 1,0,0.1,{8*$1},0
-diffusiontensors[-2] 0,1,0.1,{20*$1},0
-eigen[-2,-1]
-rm[-1]
-split[-1] c
-rm[-1]
-mul[-1] -1
-add[-1]
-normalize[-1] 0,1
-mv[-1] 0
-split[-2] c
-rm[-3]
-mul[-2] -1
-add[-2] 1
--mul[-2] 0
-reverse[-1,-2]
-append[-3,-2] c
-eigen2tensor[-2,-1]
-input 100%,100%,1,3
-_hcolor[-1] $hue,$sat,$light,$var,{0.05+0.5*$2},0.98,1
-dilate_circ[-1] {2+2*$2}
--luminance[-1]
-gt[-1] 0.01
-mul[-4,-1]
-normalize[-1] 0,255
-replace_color[-1] 0,0,0,0,0,$4,$5,$6
-reverse[-2,-1]
-repeat 3
-smooth[-3,-2] [-1],{5+595*$3}
-done
-rm[-1]
-reverse[-2,-1]
-sharpen[-1] {1.2*(1-$2)}
-normalize[-1] 0,1
--_hlight[-1] $9,$10,1
-mul[-1] [-3]
-add[-3,-1]
--_hlight[-1] $9,$10,$11
-input [-3],[-3],[-3],[-3],255,255,255
-image[-4] [-1],0,0,0,0,1,[-2]
-keep[-4,-3]
-normalize[-1] 0,{51*(1+4*$opac)}
-append[-2,-1] c
-normalize[-1] 0,255
-endlocal
-done
gtutor_hairlock_preview :
-gimp_split_preview "-gtutor_hairlock ${^0}",$-1
_hlight : -check "${1=45}<=360 && $1>=0 && ${2=0.5}>=0 && ${3=0.5}>=0"
-if {$2>0}
-resize2dx[-1] 400%,5
-blur[-1] 2,1
-gradient_orientation[-1] 2
-append[-2,-1] c
-input ({cos(2*$1*pi/360)}^{sin(2*$1*pi/360)})
-resize[-1] [-2],[-2],[-1],[-1],1
-mul[-2,-1]
-compose_channels[-1] add
-cut[-1] {ia},{iM}
-normalize[-1] {195*$3-200},0
-exp[-1]
-resize2dx[-1] 25%,5
-normalize[-1] 0,{$2}
-else
-fill_color[-1] 0
-endif
-to_rgb[-1]
#@gmic _hcolor : h_mean,s_mean,l_mean,var,density,coverage,is_mod
#@gmic : Plot in selected images impulses centered around h,s,l means +/- var
#@gmic : at relative 0<=density<=1 wrt 1/2 image area: related to density=1
#@gmic : coverage: wrt image area, relative coverage 0<=coverage<=1 smaller
#@gmic : values give rise to unplotted regions around edges equal 1.0-coverage.
#@gmic : is_mod, boolean, if true, wraps negative values around to one.
#@gmic : Default values: mean=40,var=0,density=0.5,coverage=1,is_mod=True
_hcolor : -skip ${1=40},${2=0.5},${3=0.5},${4=0},${5=0.5},${6=1},${7=1}
-repeat $!
-local[$>]
pcnt={0.5*w*h*$5}
{$pcnt},1,1,1,({0,w}*(1-$6)/2)+{0,w}*$6*u
{$pcnt},1,1,1,({0,h}*(1-$6)/2)+{0,h}*$6*u
{$pcnt},1,1,1
ra={$1/360.0}
-if $7
{$pcnt},{s},1,1,360.0*($ra+$4*(2*g-1))%1
{$pcnt},{s},1,1,($2+$4*(2*g-1))%1
{$pcnt},{s},1,1,($3+$4*(2*g-1))%1
-else
{$pcnt},{s},1,1,360.0*($ra+$4*(2*g-1))
{$pcnt},{s},1,1,$2+$4*(2*g-1)
{$pcnt},{s},1,1,$3+$4*(2*g-1)
-endif
-append[^0] y
-pointcloud[-1] 0,{-2,w},{-2,h},1,{-2,s}
-rm[-2]
-hsl2rgb[-1]
-endlocal
-done
Harmonograph_samj_en :
-Harmonograph_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32
gimp_heart :
-if {$!>0} wh=${-max_wh} w={$1%*min(512,arg(1,$wh))} h={$1%*min(512,arg(2,$wh))} -else w={$1%*512} h={$1%*512} -endif
-shape_heart {min($w,$h)} -to_rgba.
-replace_color. 0,0,1,1,1,255,$3,$4,$5,$6
-replace_color. 0,0,0,0,0,255,$3,$4,$5,0
-b. $2% -mv. 0
gimp_heart_preview :
-gimp_heart $* -blend[^0] [0],alpha -rm[0]
KittyRings_preview :
-KittyRings ${1--1}
KittyRings :
-repeat $! -l[$>]
-sh. 0
-f. "
init(
sectors=$1;
zoom=$2;
inner=$3;
outer=$4;
R1=$5;
G1=$6;
B1=$7;
R2=$8;
G2=$9;
B2=$10
);
X=(2*x/(w-1))-1;
Y=1-(2*y/(h-1));
a=atan2(Y,X);
if (a<0,a=a+(2*pi));
r=sqrt(X*X+Y*Y);
rfloor=int(log(r)*zoom);
if(log(r)*zoom<0,rfloor=rfloor-1);
v=(sectors*a/(pi*2))+(rfloor*0.5);
vfloor=int(v);
if(v<0,vfloor=vfloor-1);
v=v-vfloor;
outR=0;
outG=0;
outB=0;
if (r>inner && r<outer,
if (v>0.15 && v <0.5,outR=R1; outG=G1; outB=B1);
if (v>0.5 && v <0.65,outR=255; outG=255; outB=255);
if (v>0.65 && v <1,outR=R2; outG=G2; outB=B2);
);
i(#0,x,y,0,1)=outG;
i(#0,x,y,0,2)=outB;
outR"
-rm[-1]
-endl -done
gimp_lightning :
-repeat $! -l[$<]
100%,100% -l. fact={max(w,h)/$3*$2%} -srand $11
-repeat $1
-if {$!<=1}
i=0
new_level=1
new_length=$3
new_x=0
new_y=0
new_angle=$14
-else
i={round(u(1,max(1,($!-1)*$6)))}
level={$i,@-2}
angle={$i,@-1}
nb_points={$i,i[6]}
p={round(($nb_points-2)*u($17%,$18%))}
new_level={$level+1}
new_length={max(2,round(($nb_points-$p)*u($19%,$20%)))}
new_x={$i,i[8+3*$p]}
new_y={$i,i[9+3*$p]}
new_angle={$angle+u($21,$22)*if(u>0.5,1,-1)}
-endif
-_gimp_lightning $new_length,$4,$5
-r3d. 0,0,1,$new_angle
-+3d. $new_x,$new_y
--*3d. $fact [0],[0] -j3d. [-2],$12%,$13%,0,1,1,0,0 -rm..
dilation={$15*(if($23>0,1.5,10)^($23*($new_level-1)))}
blur={max(0,-1+(1+$16)*(if($24>0,2,5)^($24*($new_level-1))))}
opacity={min(1,$10/255*(2^($25*($new_level-1))))}
-dilate. $dilation -b. $blur% -n. 0,1 -*. $opacity -max[0,-1]
($new_level;$new_angle) -a[-2,-1] y
-progress {($>*100)/($1-1)}
-done
-k[0] -* 255 -i[0] 100%,100%,1,3 -fc[0] ${7-9} -a c
-endl
-rv
-endl -done
gimp_lightning_preview :
-repeat $! -l[$>]
-gimp_lightning $* -rv -blend alpha
-endl -done
_gimp_lightning :
-l[]
({'CImg3d'},$1,{$1-1})
1,$1 -noise. $2,1 -cumulate. -b. $3 -shift. 0,1 1,100%,1,1,y 1,100% -a[-3--1] x
1,{h-1},1,1,2 --f. y --+. 1 -a[-3--1] x
4,100%,1,1,1
-y -a y
-endl
gimp_lissajous :
-repeat $! -l[$>] -to_rgba
{w},{h}
-f3d {0.5*max(w,h)/tan($4*pi/360)}
-lissajous3d $1,$5,$8,$6,$9,$7,$10
-r3d. 0,0,1,$13 -r3d. 0,1,0,$12 -r3d. 1,0,0,$11
-*3d. {0.5*$2*{-2,w}},{0.5*$3*{-2,h}},{0.5*$4*max({-2,w},{-2,h})}
-col3d. 1 -j3d.. [-1],50%,50%,0,1,1,0,0 -rm.
-distance. 1 ->. $14% -*.. [-1] -==. 0
-r. 100%,100%,1,4
-sh. 0 -*. $15 -rm.
-sh. 1 -*. $16 -rm.
-sh. 2 -*. $17 -rm.
-sh. 3 -*. $18 -rm.
-+[-2,-1]
-endl -done
gimp_mandelbrot :
(0^0^0) ($8^$9^$10) ($11^$12^$13) ($14^$15^$16) ($17^$18^$19)
-a[-4--1] x -r. $4,1,1,3,3 -a[-2,-1] x -mv. 0
-repeat {$!-1}
wh={w},{h} -rm. $wh
-mandelbrot. {$1-2/(1+$3)},{$2-2/(1+$3)},{$1+2/(1+$3)},{$2+2/(1+$3)},$4,$5,{if($5,$6,0)},{if($5,$7,0)}
-map. [0]
-mv. 1 -done -rm[0]
gimp_mandelbrot_preview :
-gimp_mandelbrot ${^0}
-line 0,50%,100%,50%,0.5,255
-line 50%,0,50%,100%,0.5,255
gimp_neon_lightning :
d={$13*255}
-repeat $! -l[$>]
100%,100%,1,4 -rm[0]
-repeat $7
x0={max(0,min(w,$1+u(-$3,$3)))} y0={max(0,min(h,$2+u(-$3,$3)))}
x1={max(0,min(w,$4+u(-$6,$6)))} y1={max(0,min(h,$5+u(-$6,$6)))}
u0={u(0,100)} v0={u(0,100)} u1={u(0,100)} v1={u(0,100)}
R={max(0,min(255,u($10-$d,$10+$d)))}
G={max(0,min(255,u($11-$d,$11+$d)))}
B={max(0,min(255,u($12-$d,$12+$d)))}
-spline $x0%,$y0%,$u0%,$v0%,$x1%,$y1%,$u1%,$v1%,256,1,$R,$G,$B,1
-done
-s c,-3
-b[0] 3%
-distance. 1 -*. -1 -c. -{$9+1e-5},0 -n. 0,1 -sqrt.
--b. $8%,1 -n. 0,1 -sqrt. -n[-2,-1] 0,255 -max[-2,-1]
[-1] -blend[0,1] value
-smooth 5,0,1,0.5,2,10,0
-/. 255 -^. $14 -*. 255
-a c -c 0,255
-endl -done
gimp_plasma :  -skip ${4=0},${5=0}
-if $5 -to_rgba -else -to_rgb -endif
-if $4 -rand 0,255 -endif
-plasma $1,$2,$3 -n 0,255
-balance_gamma ${6-8}
gimp_quick_copyright :
-i[0] 0 -t[0] "$1",0,0,$2,1,$3,$4,$5 -autocrop[0] 0 -r[0] {{0,w}+2*$7},{{0,h}+2*$7},1,3,0,0,0.5,0.5
-i[1] 0 -t[1] "$1",0,0,$2,1,1 -autocrop[1] 0 -r[1] {{1,w}+2*$7},{{1,h}+2*$7},1,1,0,0,0.5,0.5 -dilate[1] {1+2*$7}
-rotate[0,1] {90*($10-1)}
-repeat {$!-2}
-if {$8==0} -j. [0],$9,$9,0,0,{$6/255},[1]
-elif {$8==1} -j. [0],{w-1-{0,w}-$9},$9,0,0,{$6/255},[1]
-elif {$8==2} -j. [0],$9,{h-1-{0,h}-$9},0,0,{$6/255},[1]
-else -j. [0],{w-1-{0,w}-$9},{h-1-{0,h}-$9},0,0,{$6/255},[1]
-endif
-mv. 2 -done
-rm[0,1]
gimp_rainbow :
-repeat $! -l[$>]
100%,100% -spline. 0,$1%,100,{-$3}%,100%,$2%,100,$4%,256,1,1
-flood. 0,0,0,0,0,1,1 -flood. {w-1},0,0,0,0,1,1
-distance. 0 -c. 0,255 -n. 0,{$5*255}
-rainbow_lut --luminance. -c. 0,{min(100,200-$6)}% -n. 0,255 -a[-2,-1] c
-map.. [-1] -rm.
-if {$6<100} -sh. 3 -*. {$6/100} -rm. -endif
-blend alpha
-endl -done
samj_en_Cercles_Qui_Tournent :
-samj_Cercles_Qui_Tournent $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33
gimp_shadebobs :
-channels 0 -f 0
-repeat $! -l[$>]
t=0
-repeat $3
-repeat $1
r={$6+$5*cos(6*$7*$t)+(1-$5)*sin(6*$8*$t)}
a={(360*sin($7*$t)+30*$6*$>)*pi/180}
ax={2*$>*pi/$1+$t}
cx={(1+$9*cos($ax)+$r*cos($a))*w/2}
cy={(1+$9*sin($ax)+$r*sin($a))*h/2}
-ellipse. $cx,$cy,$2%,$2%,0,-1,1
-done
t+={$4%}
-done
-endl -done
-& 255 -if $10 -map {$10-1} -endif
gimp_sierpinski :
-repeat $! -l[$>] -split_opacity -l[0]
100%,100% -sierpinski. ${1-7}
--fc.. $8,$9,$10 -j[0] [-1],0,0,0,0,$11,[-2],255 -rm[-2,-1]
-endl -a c -endl -done
samj_en_Formes_Geometriques_Simples :
-samj_Formes_Geometriques_Simples $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21
gimp_snowflake :
-repeat $! -l[$>] -to_color -split_opacity -l[0]
-shape_snowflake {min(w,h)},$1 100%,100%,1,3,[${3-5}]
-j[0] [-1],{([w#0,h#0]-[w#1,h#1])/2},0,0,$2,[-2] -k[0]
-endl -a c -endl -done
samj_en_Flocon_De_Neige :
-samj_Flocon_De_Neige $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32
Spirographe_samj_en :
-Spirographe_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31
gimp_superformula :
-repeat $! -l[$>] -to_rgba
{w},{h}
-f3d {0.5*max(w,h)/tan($4*pi/360)}
-superformula3d $1,${4-7}
-r3d. 0,0,1,$10 -r3d. 0,1,0,$9 -r3d. 1,0,0,$8
-*3d. {0.5*$2*{-2,w}},{0.5*$3*{-2,h}}
-col3d. 1 -j3d.. [-1],50%,50%,0,1,1,0,0 -rm.
-distance. 1 ->. $11% -*.. [-1] -==. 0
-r. 100%,100%,1,4
-sh. 0 -*. $12 -rm.
-sh. 1 -*. $13 -rm.
-sh. 2 -*. $14 -rm.
-sh. 3 -*. $15 -rm.
-+[-2,-1]
-endl -done
gimp_turbulence :
-remove_opacity -turbulence ${^0}
gimp_animate_preview : -skip ${4=1},${5=0},${6=$5}
-repeat $!
-if $5 width=$5 -else width={w} -endif
-if $6 height=$6 -else height={h} -endif
-if $4 -s. x,2 -else [-1] -endif
-$1.. $2 -$1. $3
-r[-2,-1] {max(w,{-2,w})},{max(h,{-2,h})},1,100%,3
-if {!$4} -columns.. 0,50% -columns. 50%,100% -endif
-a[-2,-1] x -r. $width,$height,1,100%,2 -drgba.
-line. 50%,0,50%,100%,1,0,0,0,255
-text_outline. "Start",3,-1,13,2,1,255 -text_outline. "End",{w-24},{h-18},13,2,1,255
-mv. 0 -done
Twisted_Rays_en:
-Twisted_Rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49
gcd_wiremap : -skip ${1=100},${2=100},${3=0.5},${4=0.5},${5=0}
dm={$!>1" && "$5%2}
-l[${-arg\ 1+$dm,0,0-1}]
-if {$dm} op=0
-if {s==2||s==4} -split_opacity. -rv[^0] op=1 -remove_opacity[0]
-elif {0,s==2||s==4} -split_opacity[0] op=1 -endif
-else -split_opacity op={$!>1} -endif
--norm[0] -b. $3% -n. 0,$2 -*. -1 w={w/2} h={h/2}
-r. $1,{round(h/w*$1)},1,3,2 v={w*h} p={(w-1)*h+(h-1)*w} ln={h}
-sh. 0 -f. x -n. -$w,$w -rm.
-sh. 1 -f. y -n. -$h,$h -rm. -permute. cxyz -y.
(67.5;73.5;109.5;103.5;51.5;100.5)
($v;$p)
{($1-1)*2},$ln,1,1,if(x%2,-1,2) {($1-1)*2},$ln,1,1,"y*$1+round(x/2)"
-a[-2,-1] c -permute. cxyz -discard. -1
{($ln-1)*2},$1,1,1,if(x%2,-1,2) {($ln-1)*2},$1,1,1,"round(x/2)*$1+y"
-a[-2,-1] c -permute. cxyz -discard. -1 -a[-2,-1] y
-if {$5%2}
--r[{$dm?$dm+$op:0}] $1,{0,round(h/w*$1)},1,3,3 --z. 0,0,100%,{h-2}
-permute. cyxz -z.. 0,0,{-2,w-2},100% -permute.. cxyz -y[-2,-1] -a[-2,-1] y
-else 1,{$p*3},1,1,255 -endif
-if {$op}
--r[1] $1,{0,round(h/w*$1)},1,1,3 -gt. 1 --z. 0,0,100%,{h-2} -permute. cyxz
-z.. 0,0,{-2,w-2},100% -permute.. cxyz -y[-2,-1] -a[-2,-1] y -rm[1]
-else 1,$p,1,1,1 -endif
-mv[-6] -3 -a[-6--1] y
-if {$5>1}
-f[0] 0 -to_a[0] -sh[0] 100% -f. 255
-j3d[0] [-2],50%,50%,{$2*$4},1,1,1,0 -negative. -rm[-2,-1]
-else -f[0] 0 -j3d[0] [-1],50%,50%,{$2*$4},1,1,1,0 -rm. -endif
-endl
banding_denoise:
-repeat 2 --bilateral[-1] $3,$4 -keep[0,-1] -done
--compose_grainextract[0,1]
-fftpolar[-1]
-polygon[-2] 4,0,{(h/2)+1},{50-$1}%,{(h/2)+1},{50-$1}%,{(h/2)-1},0,{(h/2)-1}
-polygon[-2] 4,{50+$1}%,{(h/2)+1},{w},{(h/2)+1},{w},{(h/2)-1},{50+$1}%,{(h/2)-1}
-polygon[-2] 4,{(w/2)+1},0,{(w/2)+1},{50-$2}%,{(w/2)-1},{50-$2}%,{(w/2)-1},0
-polygon[-2] 4,{(w/2)-1},{h},{(w/2)+1},{h},{(w/2)+1},{50+$2}%,{(w/2)-1},{50+$2}%
-ifftpolar[-1,-2]
-compose_grainmerge[1,2]
-keep[-1]
banding_denoise_preview:
-if {$5==0}
-banding_denoise ${1--1}
-else
--banding_denoise ${1--1}
-compose_grainextract[0,1]
--[-1] 128 -*[-1] 5 -+[-1] 128
-endif
gimp_deinterlace :
-deinterlace 0 -skip ${^0}
gimp_deinterlace_preview :
-gimp_split_preview "-gimp_deinterlace $*",$-1
gcd_deinterlace2x : -skip ${1=40},${2=0},${3=0},${4=2},${5=0}
-repeat $! -l[$>]
-if {$3}
ca={if($5,1,h/w)} na={arg($3,1,{4/3},{5/4},{16/9},{1.6},{2.35},{1.85})}
-r {$ca*$na*w},100%,1,3,{arg($4+1,3,5,6)} -c 0,255
-endif -if {$2==2} -continue -endif
w={w} h={h} d={d} hh={int($h/2)} -rgb2yuv -s c
-l[0] --shift 0,-1 -r $w,$hh,$d,1,4 -endl
-l[-2,-1] -r $w,2,$d,$hh,-1 --shift 0,0,0,-1 -r $w,2,$d,50%,4 -r $w,$hh,$d,1,-1 -endl
-a[0,2,3] c -a[^0] c -yuv2rgb
-if {!$2} -scale_dcci2x ,,1 -r 50%,100%,1,3,4 -else
a={2/3} b={-1/12} ($b,$a,$b;$b,$a,$b) --convolve[^-1] [-1] -rm...
-r 100%,200%,1,3,4 -shift[-2,-1] 0,1 -+[-3,-1] -+[-3,-1]
-endif
-c 0,255 -shift. 0,1 --- --norm. a={-192^-.5/$1} ($a,$a,$a;$a,0,$a;$a,$a,$a)
-convolve.. [-1] -rm. -max. -1 -+. 1 -*[-2,-1] --[0,-1] -rm.
-endl -done
gcd_despeckle : -skip ${1=15},${2=30}
-repeat $! -l[$>]
ma={if(!$2,w*h,$2)}
--label[-1] $1,1 nb={1+iM}
--histogram[-1] $nb,0,{$nb-1}
-map[-2] [-1] -rm[-1]
-le[-1] $ma -*[-1] 255
-inpaint[-2] [-1] -rm[-1]
-endl -done
iain_fast_denoise_p:
-tic
-if $7
-apply_parallel_overlap "-iain_fast_denoise ${1--1}",128,0
-else
-iain_fast_denoise ${1--1}
-endif
-toc
iain_fast_denoise:
-repeat $! -l[$>] nm={0,n} -split_opacity -l[0]
fastluma1={$1*5000}
fastluma2={$fastluma1*.9}
fastluma3={$fastluma1*.65}
fastluma4={$fastluma1*.44}
fastchroma1={$2*5000}
fastchroma2=$fastchroma1
fastchroma3={$fastchroma2/2}
fastchroma4={$fastchroma3/2}
despeckle_threshold={($4/25)*100000}
-if {$3!=1}
scale={255*1000}
ex={$3}
pt1x={$scale*0.025}
pt2x={$scale*0.05}
pt3x={$scale*0.075}
pt4x={$scale*0.1}
pt5x={$scale*0.125}
pt6x={$scale*0.15}
pt7x={$scale*0.175}
pt8x={$scale*0.2}
pt9x={$scale*0.225}
pt10x={$scale*0.25}
pt11x={$scale*0.275}
pt12x={$scale*0.3}
pt13x={$scale*0.325}
pt14x={$scale*0.35}
pt15x={$scale*0.375}
pt16x={$scale*0.4}
pt17x={$scale*0.425}
pt18x={$scale*0.45}
pt19x={$scale*0.475}
pt20x={$scale*0.5}
pt21x={$scale*0.525}
pt22x={$scale*0.55}
pt23x={$scale*0.575}
pt24x={$scale*0.6}
pt25x={$scale*0.625}
pt26x={$scale*0.65}
pt27x={$scale*0.675}
pt28x={$scale*0.7}
pt29x={$scale*0.725}
pt30x={$scale*0.75}
pt31x={$scale*0.775}
pt32x={$scale*0.8}
pt33x={$scale*0.825}
pt34x={$scale*0.85}
pt35x={$scale*0.875}
pt36x={$scale*0.9}
pt37x={$scale*0.925}
pt38x={$scale*0.95}
pt39x={$scale*0.975}
pt40x={$scale*1}
pt1y={(0.025^$ex)*$scale}
pt2y={(0.05^$ex)*$scale}
pt3y={(0.075^$ex)*$scale}
pt4y={(0.1^$ex)*$scale}
pt5y={(0.125^$ex)*$scale}
pt6y={(0.15^$ex)*$scale}
pt7y={(0.175^$ex)*$scale}
pt8y={(0.2^$ex)*$scale}
pt9y={(0.225^$ex)*$scale}
pt10y={(0.25^$ex)*$scale}
pt11y={(0.275^$ex)*$scale}
pt12y={(0.3^$ex)*$scale}
pt13y={(0.325^$ex)*$scale}
pt14y={(0.35^$ex)*$scale}
pt15y={(0.375^$ex)*$scale}
pt16y={(0.4^$ex)*$scale}
pt17y={(0.425^$ex)*$scale}
pt18y={(0.45^$ex)*$scale}
pt19y={(0.475^$ex)*$scale}
pt20y={(0.5^$ex)*$scale}
pt21y={(0.525^$ex)*$scale}
pt22y={(0.55^$ex)*$scale}
pt23y={(0.575^$ex)*$scale}
pt24y={(0.6^$ex)*$scale}
pt25y={(0.625^$ex)*$scale}
pt26y={(0.65^$ex)*$scale}
pt27y={(0.675^$ex)*$scale}
pt28y={(0.7^$ex)*$scale}
pt29y={(0.725^$ex)*$scale}
pt30y={(0.75^$ex)*$scale}
pt31y={(0.775^$ex)*$scale}
pt32y={(0.8^$ex)*$scale}
pt33y={(0.825^$ex)*$scale}
pt34y={(0.85^$ex)*$scale}
pt35y={(0.875^$ex)*$scale}
pt36y={(0.9^$ex)*$scale}
pt37y={(0.925^$ex)*$scale}
pt38y={(0.95^$ex)*$scale}
pt39y={(0.975^$ex)*$scale}
pt40y={(1^$ex)*$scale}
-endif
interpolation=1
-tic
-to_rgb
-mul[0] 1000
-if {$3!=1}
-apply_curve[0] 0,0,0,$pt1x,$pt1y,$pt2x,$pt2y,$pt3x,$pt3y,$pt4x,$pt4y,$pt5x,$pt5y,$pt6x,$pt6y,$pt7x,$pt7y,$pt8x,$pt8y,$pt9x,$pt9y,$pt10x,$pt10y,$pt11x,$pt11y,$pt12x,$pt12y,$pt13x,$pt13y,$pt14x,$pt14y,$pt15x,$pt15y,$pt16x,$pt16y,$pt17x,$pt17y,$pt18x,$pt18y,$pt19x,$pt19y,$pt20x,$pt20y,$pt21x,$pt21y,$pt22x,$pt22y,$pt23x,$pt23y,$pt24x,$pt24y,$pt25x,$pt25y,$pt26x,$pt26y,$pt27x,$pt27y,$pt28x,$pt28y,$pt29x,$pt29y,$pt30x,$pt30y,$pt31x,$pt31y,$pt32x,$pt32y,$pt33x,$pt33y,$pt34x,$pt34y,$pt35x,$pt35y,$pt36x,$pt36y,$pt37x,$pt37y,$pt38x,$pt38y,$pt39x,$pt39y,$pt40x,$pt40y
-endif
redmul=.299
greenmul=.587
bluemul=.114
-to_rgb[0]
--split[0] c
-mul[1] $redmul
-mul[2] $greenmul
-mul[3] $bluemul
-add[1-3]
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[3] luma
--sub[blue] [luma]
-name[-1] cb
--sub[red] [luma]
-name[-1] cr
-keep[luma,cb,cr]
-if {$despeckle_threshold>0}
-iain_fast_despeckle[0] {1-$despeckle_threshold}
-endif
-if {$1>0}
-iain_fast_denoise_main[0] {$fastluma1},{$fastluma2},{$fastluma3},{$fastluma4},$interpolation
-endif
-if {$2>0}
-iain_fast_denoise_main[1] {$fastchroma1},{$fastchroma2},{$fastchroma3},{$fastchroma4},$interpolation
-iain_fast_denoise_main[2] {$fastchroma1},{$fastchroma2},{$fastchroma3},{$fastchroma4},$interpolation
-endif
-name[0] luma
-name[1] cb
-name[2] cr
--add[cb] [luma]
-name[-1] blueout
--add[cr] [luma]
-name[-1] redout
-remove[1,2]
--mul[redout] $redmul
--mul[blueout] $bluemul
-sub[luma] [-1]
-sub[luma] [-2]
-div[luma] $greenmul
-remove[-1,-2]
-move[2] 0
-append c
-if {$5==1}
100%,100%,1,1,0
-noise[-1] 0.7,0
--laplacian[0]
-threshold[-1] 4
-dilate[-1] 3
-mul[-1] -1
-add[-1] 1
-mul[-2] [-1]
-remove[-1]
-add
-endif
-if {$3!=1}
scale={255*1000}
ex={1/$3}
pt1y={(0.025^$ex)*$scale}
pt2y={(0.05^$ex)*$scale}
pt3y={(0.075^$ex)*$scale}
pt4y={(0.1^$ex)*$scale}
pt5y={(0.125^$ex)*$scale}
pt6y={(0.15^$ex)*$scale}
pt7y={(0.175^$ex)*$scale}
pt8y={(0.2^$ex)*$scale}
pt9y={(0.225^$ex)*$scale}
pt10y={(0.25^$ex)*$scale}
pt11y={(0.275^$ex)*$scale}
pt12y={(0.3^$ex)*$scale}
pt13y={(0.325^$ex)*$scale}
pt14y={(0.35^$ex)*$scale}
pt15y={(0.375^$ex)*$scale}
pt16y={(0.4^$ex)*$scale}
pt17y={(0.425^$ex)*$scale}
pt18y={(0.45^$ex)*$scale}
pt19y={(0.475^$ex)*$scale}
pt20y={(0.5^$ex)*$scale}
pt21y={(0.525^$ex)*$scale}
pt22y={(0.55^$ex)*$scale}
pt23y={(0.575^$ex)*$scale}
pt24y={(0.6^$ex)*$scale}
pt25y={(0.625^$ex)*$scale}
pt26y={(0.65^$ex)*$scale}
pt27y={(0.675^$ex)*$scale}
pt28y={(0.7^$ex)*$scale}
pt29y={(0.725^$ex)*$scale}
pt30y={(0.75^$ex)*$scale}
pt31y={(0.775^$ex)*$scale}
pt32y={(0.8^$ex)*$scale}
pt33y={(0.825^$ex)*$scale}
pt34y={(0.85^$ex)*$scale}
pt35y={(0.875^$ex)*$scale}
pt36y={(0.9^$ex)*$scale}
pt37y={(0.925^$ex)*$scale}
pt38y={(0.95^$ex)*$scale}
pt39y={(0.975^$ex)*$scale}
pt40y={(1^$ex)*$scale}
-apply_curve[0] 0,0,0,$pt1x,$pt1y,$pt2x,$pt2y,$pt3x,$pt3y,$pt4x,$pt4y,$pt5x,$pt5y,$pt6x,$pt6y,$pt7x,$pt7y,$pt8x,$pt8y,$pt9x,$pt9y,$pt10x,$pt10y,$pt11x,$pt11y,$pt12x,$pt12y,$pt13x,$pt13y,$pt14x,$pt14y,$pt15x,$pt15y,$pt16x,$pt16y,$pt17x,$pt17y,$pt18x,$pt18y,$pt19x,$pt19y,$pt20x,$pt20y,$pt21x,$pt21y,$pt22x,$pt22y,$pt23x,$pt23y,$pt24x,$pt24y,$pt25x,$pt25y,$pt26x,$pt26y,$pt27x,$pt27y,$pt28x,$pt28y,$pt29x,$pt29y,$pt30x,$pt30y,$pt31x,$pt31y,$pt32x,$pt32y,$pt33x,$pt33y,$pt34x,$pt34y,$pt35x,$pt35y,$pt36x,$pt36y,$pt37x,$pt37y,$pt38x,$pt38y,$pt39x,$pt39y,$pt40x,$pt40y
-endif
-mul[0] 0.001
-c 0,255
-toc
-endl -a c -nm $nm -endl -done
fastblur:
(0.0579710145,0.1304347826,0.0579710145;0.1304347826,0.2463768116,0.1304347826;0.0579710145,0.1304347826,0.0579710145)
-convolve[0] [1]
-remove[-1]
iain_fast_despeckle:
(0,0.2,0;0.2,0.2,0.2;0,0.2,0)
--convolve[0] [1]
--sub[-1] [0]
-abs[-1]
--convolve[-1] [1]
-sub[-1] [-2]
-abs[-1]
-keep[0,2,-1]
-threshold[-1] $1
-mul[-1] 255
-append[1,2] c
-blend alpha
iain_fast_denoise_main:
cropwidth={w}
cropheight={h}
-resize[0] {w+(8-w%8)},{h+(8-h%8)},1,{s},0,1
width={w}
height={h}
--resize[0] 50%,50%,{d},{s},2
--resize[1] $width,$height,{d},{s},$5
-fastblur[-1]
-sub[0] [2]
-remove[2]
--resize[1] 50%,50%,{d},{s},2
--resize[2] {$width/2},{$height/2},{d},{s},$5
-fastblur[-1]
-sub[1] [3]
-remove[3]
--resize[2] 50%,50%,{d},{s},2
--resize[3] {$width/4},{$height/4},{d},{s},$5
-fastblur[-1]
-sub[2] [4]
-remove[4]
--resize[3] 50%,50%,{d},{s},2
--resize[4] {$width/8},{$height/8},{d},{s},$5
-fastblur[-1]
-sub[3] [5]
-remove[5]
-rmsthresh[0] $1
-rmsthresh[1] $2
-rmsthresh[2] $3
-rmsthresh[3] $4
-resize[-1] {3,w},{3,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-resize[-1] {2,w},{2,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-resize[-1] {1,w},{1,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-resize[-1] {0,w},{0,h},{d},{s},$5
-fastblur[-1]
-add[-2] [-1]
-remove[-1]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
rmsthresh:
--abs[0]
-fastblur[1]
-threshold[1] {$1}
-fastblur[1]
-mul[0] [1]
-keep[0]
iain_fast_denoise_p_preview:
-if {$-2==0}
-iain_fast_denoise ${1--3}
-endif
-if {$-2==1}
--iain_fast_denoise_p $1,0,1,$4,0,0,$7
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
-if {$-2==2}
--iain_fast_denoise_p 0,$2,1,$4,0,0,$7
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
iain_iains_nr:
-repeat $! -l[$>] nm={0,n} -split_opacity -l[0]
lnr=$1
cnr=$2
despek=$3
highs=$4
shadow=$5
recovery_choice=$6
detail_recovery={5000-($7*500)}
fast=1
fine_det=$8
med_det=$9
large_det=$10
det_emphasis=$11
sharp=$12
-to_rgb
-apply_gamma {1/1.3}
-mul 900
-apply_curve 1,0,0,32000,{32000-$shadow},160000,{160000-$shadow},256000,{256000-$highs-$shadow}
-div 2000
-iain_rgb2ycbcr
-split c
-if {$lnr>0}
-if {$recovery_choice==0}
-iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
-unsharp[0] .7,$sharp,0
-endif
-if {$recovery_choice==1}
--iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
--sub[0] [-1]
-add[-1] {128}
-remove[0]
-unsharp[2] .7,$sharp,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
-rectangle[-1] 0,0,100%,48,1,128
-rectangle[-1] 0,0,48,100%,1,128
-rectangle[-1] 0,100%,100%,{h-48},1,128
-rectangle[-1] {w-48},100%,100%,0,1,128
-iains_nr_fft_tile3[-1] {$detail_recovery},48,0,$fine_det,$med_det,$large_det,1,3
-crop[-1] 48,48,{w-49},{h-49}
-sub[-1] {128}
-mul[-1] $det_emphasis
-add[2] [-1]
-remove[-1]
-move[-1] 0
-endif
-if {$recovery_choice==2}
--iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
--sub[0] [-1]
-add[-1] {128}
-remove[0]
-unsharp[2] .7,$sharp,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
-rectangle[-1] 0,0,100%,48,1,128
-rectangle[-1] 0,0,48,100%,1,128
-rectangle[-1] 0,100%,100%,{h-48},1,128
-rectangle[-1] {w-48},100%,100%,0,1,128
-iains_nr_fft_tile3[-1] {$detail_recovery},48,0,$fine_det,$med_det,$large_det,1,3
-crop[-1] 48,48,{w-49},{h-49}
-sub[-1] 128
-mul[-1] $det_emphasis
-add[-1] 128
-move[-2] 0
-endif
-endif
-if {$cnr>0}
-add[1,2] 300
-iains_nr_patchb[1] 10,$cnr,3,3,0,1,1,4,.5,.4,.2,0,1,1,2,0
-iains_nr_patchb[2] 10,$cnr,3,3,0,1,1,4,.5,.4,.2,0,1,1,2,0
-sub[1,2] 300
-endif
-append[0,1,2] c
-iain_ycbcr2rgb[0]
-mul[0] 2000
-apply_curve[0] 1,0,0,{32000-$shadow},32000,{160000-$shadow},160000,{256000-$highs-$shadow},256000
-div[0] 900
-apply_gamma[0] 1.3
-c 0,255
-endl -a c -nm $nm -endl -done
iains_nr_med3stack16:
--max[0,1]
--min[0,1]
-keep[2,3,4]
--max[0,2]
--min[1,3]
-keep[-1]
iains_nr_med5stack16:
--min[0,1]
--max[0,1]
-remove[0,1]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,1]
--max[0,1]
-remove[0,1]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[1,2]
--max[1,2]
-remove[1,2]
--max[1,4]
-keep[-1]
iains_nr_fft_tile3_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
--add[1] [-1]
-threshold[-1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-remove[0,1,2]
-keep[-1]
iains_nr_fft_tile3_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-iains_nr_fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
iains_nr_fft_tile3:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$8>2}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
-endif
-if {$8>1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$8==3}
-iains_nr_med5stack16
-endif
-if {$8==2}
-iains_nr_med3stack16
-endif
iains_nr_patchb_smoothing:
-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done
iains_nr_patchb_2:
--resize[0] 50%,50%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb_3:
--resize[0] 25%,25%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb_4:
--resize[0] 12.5%,12.5%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb_5:
--resize[0] 6.125%,6.125%,1,{s},2
--iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
iains_nr_patchb:
-apply_gamma {1/$14}
-if {$8==1}
-hybrid_median[-1] 1,0,0
-endif
-if {$8==2}
-hybrid_median[-1] 3,0,0
-endif
-if {$8==3}
-median[-1] 3
-endif
-if {$8==4}
-median[-1] 3
-median[-1] 3
-median[-1] 3
-endif
-repeat $15
-if {$8<4}
-if {$13==1}
-iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
-endif
-endif
-iains_nr_patchb_2 $1,{$2*$9},$3,$4,$5,$6,$7,$8
-iains_nr_patchb_3 $1,{$2*$10},$3,$4,$5,$6,$7,$8
-iains_nr_patchb_4 $1,{$2*$11},$3,$4,$5,$6,$7,$8
-iains_nr_patchb_5 $1,{$2*$12},$3,$4,$5,$6,$7,$8
-done
-apply_gamma $14
iain_rgb2ycbcr:
redmul=.299
greenmul=.587
bluemul=.114
-to_rgb[0]
--split[0] c
-mul[1] $redmul
-mul[2] $greenmul
-mul[3] $bluemul
-add[1-3]
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[3] luma
--sub[blue] [luma]
-name[-1] cb
--sub[red] [luma]
-name[-1] cr
-keep[luma,cb,cr]
-append[luma,cb,cr] c
iain_ycbcr2rgb:
redmul=.299
greenmul=.587
bluemul=.114
-split c
-name[0] luma
-name[1] cb
-name[2] cr
--add[cb] [luma]
-name[-1] blueout
--add[cr] [luma]
-name[-1] redout
-remove[1,2]
--mul[redout] $redmul
--mul[blueout] $bluemul
-sub[luma] [-1]
-sub[luma] [-2]
-div[luma] $greenmul
-remove[-1,-2]
-move[2] 0
-append c
iain_iains_nr_preview:
-if {$-1==0}
-iain_iains_nr ${1--2}
-endif
-if {$-1==1}
--iain_iains_nr $1,0,$3,$4,$5,$6,$7,$8,$9,$10,1.3,0
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
-if {$-1==2}
--iain_iains_nr 0,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,0
-compose_grainextract
-sub 128
-mul 3
-add 128
-endif
-if {$-1==3}
-iain_iains_nr $1,$2,$3,$4,$5,2,$7,$8,$9,$10,$11,0
-keep[-1]
-sub 128
-mul 3
-add 128
-endif
gimp_inpaint_holes :
-inpaint_holes {$1^1.5},$2,$3
gimp_inpaint_morpho :
-repeat $! -l[$>]
R=$1 G=$2 B=$3 A=$4
-if {!$A" && "(s==2" || "s==4)} -split_opacity --!=. 0 -*[0,-1] -a c R=0 G=0 B=0 -endif
--select_color 0,$R,$G,$B,$A
-if $5 -dilate. {1+2*$5} -endif
-inpaint_morpho.. [1]
-rm.
-endl -done
gimp_inpaint_morpho_preview :
-gimp_inpaint_morpho ${1-4},{1+$5}
gimp_inpaint_patchmatch :
-repeat $! -l[$>]
R=$6 G=$7 B=$8 A=$9
-if {!$A" && "(s==2" || "s==4)} -split_opacity --!=. 0 -*[0,-1] -a c R=0 G=0 B=0 -endif
--select_color 0,$R,$G,$B,$A
-if $10 -dilate. {1+2*$10} -endif
-if $11
visu_size=${-fitscreen[]" "{0,w},{0,h},1,25%,50%}
-w.. $visu_size,0,"[Preview] G'MIC: Inpaint [multi-scale]"
-endif
-srand 0 -inpaint_patchmatch.. [1],${1-5}
-rm.
-endl -done
gimp_inpaint_patchmatch_preview :
-gimp_inpaint_patchmatch ${1-9},{1+$10},0
gimp_inpaint_patch :
-repeat $! -l[$>]
--select_color 0,${9-12}
-if $13 -dilate. {1+2*$13} -endif
-inpaint.. [1],$1,{$1*$2},$3,1,{$4*$1},${5-8}
-rm.
-endl -done
gimp_inpaint_patch_preview :
-gimp_inpaint_patch ${1-12},{1+$13}
gimp_inpaint_diffusion :
-repeat $! -l[$>]
R=$4 G=$5 B=$6 A=$7
-if {!$A" && "(s==2" || "s==4)} -split_opacity --!=. 0 -*[0,-1] -a c R=0 G=0 B=0 -endif
--select_color 0,$R,$G,$B,$A
-if $8 -dilate. {1+2*$8} -endif
-inpaint_diffusion.. [1],$1%,$2,$3
-rm.
-endl -done
gimp_inpaint_diffusion_preview :
-gimp_inpaint_diffusion ${1-7},{1+$8}
local_similarity_mask:
-if {$6==1}
-resize 50%,50%,1,3,2
-endif
-to_rgb
-if {$5!=0}
-if {$5==1}  -split[0] c -keep[0] -endif
-if {$5==2}  -split[0] c -keep[1] -endif
-if {$5==3}  -split[0] c -keep[2] -endif
-if {$5==4} -luminance -endif
-if {$5==5} -rgb2lab[0] -split[0] c -keep[1] -endif
-if {$5==6} -rgb2lab[0] -split[0] c -keep[2] -endif
-if {$5==7} -rgb2hsv[0] -split[0] c -keep[0] -endif
-if {$5==8} -rgb2hsv[0] -split[0] c -keep[1] -endif
-if {$5==9} -rgb2hsv[0] -split[0] c -keep[2] -endif
-if {$5==10} -rgb2hsl[0] -split[0] c -keep[2] -endif
-if {$5==11} -rgb2cmyk[0] -split[0] c -keep[0] -endif
-if {$5==12} -rgb2cmyk[0] -split[0] c -keep[1] -endif
-if {$5==13} -rgb2cmyk[0] -split[0] c -keep[2] -endif
-if {$5==14} -rgb2cmyk[0] -split[0] c -keep[3] -endif
-endif
-n 0,255
-mul[0] 0.9
{w},{h},1,1,0
-repeat {$4-$3}
--flood[0] $1%,$2%,0,{$3+$>},0,1,255 -threshold[-1] 99%
-add[-1,-2]
-done
-keep[-1]
-n 0,255
-if {$6==1}
-resize 200%,200%,1,3,3
-endif
local_similarity_mask_preview:
-local_similarity_mask $1,$2,$3,$4,$5,0
-to_rgb
-line 100%,$2%,{$1+5}%,$2%,0.5,255,0,0
-line 0%,$2%,{$1-5}%,$2%,0.5,255,0,0
-line $1%,100%,$1%,{$2+5}%,0.5,255,0,0
-line $1%,0%,$1%,{$2-5}%,0.5,255,0,0
createbc:
(0.5,0.5,0;0,0,0;0,0,0)
(0.5,0,0.5;0,0,0;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbd:
(0.5,0,0;0,0,0.5;0,0,0)
(0.5,0,0;0,0,0;0,0,0.5)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbe:
(0.5,0,0;0,0,0;0,0.5,0)
(0.5,0,0;0,0,0;0.5,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbf:
(0.5,0,0;0.5,0,0;0,0,0)
(0,0.5,0.5;0,0,0;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbg:
(0,0.5,0;0,0,0.5;0,0,0)
(0,0.5,0;0,0,0;0,0,0.5)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbh:
(0,0.5,0;0,0,0;0,0.5,0)
(0,0.5,0;0,0,0;0.5,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbi:
(0,0.5,0;0.5,0,0;0,0,0)
(0,0,0.5;0,0,0.5;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbj:
(0,0,0.5;0,0,0;0,0,0.5)
(0,0,0.5;0,0,0;0,0.5,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbk:
(0,0,0.5;0,0,0;0.5,0,0)
(0,0,0.5;0.5,0,0;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbl:
(0,0,0;0,0,0.5;0,0,0.5)
(0,0,0;0,0,0.5;0,0.5,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbm:
(0,0,0;0,0,0.5;0.5,0,0)
(0,0,0;0.5,0,0.5;0,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbn:
(0,0,0;0,0,0;0,0.5,0.5)
(0,0,0;0,0,0;0.5,0,0.5)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbo:
(0,0,0;0.5,0,0;0,0,0.5)
(0,0,0;0,0,0;0.5,0.5,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbp:
(0,0,0;0.5,0,0;0,0.5,0)
(0,0,0;0.5,0,0;0.5,0,0)
--convolve[0] [1]
--convolve[0] [2]
-keep[0,-1,-2]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbq:
--createbc[0]
--createbd[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbr:
--createbe[0]
--createbf[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbs:
--createbg[0]
--createbh[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbt:
--createbi[0]
--createbj[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbu:
--createbk[0]
--createbl[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbv:
--createbm[0]
--createbn[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbw:
--createbo[0]
--createbp[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbx:
--createbq[0]
--createbr[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createby:
--createbs[0]
--createbt[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createbz:
--createbu[0]
--createbv[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createca:
--createbx[0]
--createby[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
createcb:
--createbz[0]
--createbw[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
megaclean:
--createca[0]
--createcb[0]
-iain_median_3_stack[0,1,2]
-keep[-1]
cross:
--shift[0] 0,1,0,0,2
--shift[0] 0,-1,0,0,2
--shift[0] 1,0,0,0,2
--shift[0] -1,0,0,0,2
-iain_median_5_stack
ex:
--shift[0] 1,1,0,0,2
--shift[0] 1,-1,0,0,2
--shift[0] -1,-1,0,0,2
--shift[0] -1,1,0,0,2
-iain_median_5_stack
hybrid_median:
-ac "
-repeat $1
--cross[0]
--ex[0]
-iain_median_3_stack[0,1,2]
-done
",$2
iain_hybrid_median:
-repeat $1
--cross[0]
--ex[0]
-iain_median_3_stack[0,1,2]
-done
iain_pixel_denoise:
-if {$1==0}
-ac "
-repeat $2
-megaclean
-done
",$3
-elif {$1==1}
-hybrid_median[0] $2,$3
-elif {$2==1}
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
-endif
iain_pixel_denoise_p:
-if $5
-if {$1==0}
-ac "
-repeat $2
-apply_parallel_overlap \"-megaclean \",4,0
-done
",$3
-elif {$1==1}
-ac "
-apply_parallel_overlap \"-iain_hybrid_median[0] $2\",4,0
",$3
-elif {$1==2}
-ac "
-apply_parallel_overlap \"
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
\",4,0
",$3
-endif
-else
-if {$1==0}
-ac "
-repeat $2
-megaclean
-done
",$3
-elif {$1==1}
-ac "
-iain_hybrid_median_p[0] $2
",$3
-elif {$1==2}
-ac "
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
",$3
-endif
-endif
time=$|
iain_pixel_denoise_p_preview:
-if {$4==0}
-iain_pixel_denoise_p ${1--1}
-endif
-if {$4==1}
--iain_pixel_denoise_p ${1--1}
-sub[0] [1]
-keep[0]
-n 0,255
-endif
iain_recursive_median_p:
-if $5
-ac "
-apply_parallel_overlap \"
-repeat $2 -median $1 -done
\",{$1*2},0
",$3,0
-else
-ac "
-repeat $2 -median $1 -done
",$3,0
-endif
recursive_median:
-ac "-repeat $3 -median $1 -done",$2,0
iain_recursive_median_p_preview:
-if {$-2==0}
-iain_recursive_median_p $1,$2,$3,$4,$5
-endif
-if {$-2==1}
-remove_opacity
--iain_recursive_median_p $1,$2,$3,$4,$5
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
gimp_remove_hotpixels :
-remove_hotpixels $1,$2
gimp_remove_hotpixels_preview :
-gimp_split_preview "-gimp_remove_hotpixels $*",$-1
jeje_scandoc :
-scandoc $1,$2%,$3%,$4%
jeje_scandoc_preview :
-gimp_split_preview "-jeje_scandoc $1,$2,$3,$4",$-1
gimp_anisotropic_smoothing :
-repeat $! -l[$>]
-ac "-repeat $11 -smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done",$12
-endl -done -c 0,255
gimp_anisotropic_smoothing_preview :
-gimp_split_preview "-gimp_anisotropic_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_bilateral : -skip ${5=0},${6=0}
-ac "-gimp_parallel_overlap \"-repeat $3 -bilateral $1,$2 -done\",$5,$6",$4
gimp_bilateral_preview :
-gimp_split_preview "-gimp_bilateral $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
jeje_denoise_patch_dict:
--denoise_patch_dict {2^($1+2)},$2,$3,$4
-*[0] $5 -*[1] {1-$5} -+ -c 0,255
jeje_denoise_patch_dict_preview :
-gimp_split_preview "-jeje_whiten_frequency ${1--2}",$-1
gimp_diffusion_smoothing :
-ac "-gimp_parallel_overlap \"-smooth $6,$1,$2,$3,$4,$5,0 -c 0,255\",$8,$9",$7
gimp_diffusion_smoothing_preview :
-gimp_split_preview "-gimp_diffusion_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_blur_guided : -skip ${5=0},${6=0}
-ac "-gimp_parallel_overlap \"-repeat $3 -guided $1,$2 -done\",$5,$6",$4
gimp_blur_guided_preview :
-gimp_split_preview "-gimp_blur_guided $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
jeje_denoise_iuwt :
-denoise_iuwt $1,$2,{$3+1}
jeje_denoise_iuwt_preview:
-gimp_split_preview "-jeje_denoise_iuwt $1,$2,$3",$-1
gimp_meancurvature_smoothing :
-ac "-gimp_parallel_overlap \"-meancurvature_flow $2,$1,$3 -c 0,255\",$5,$6",$4
gimp_meancurvature_smoothing_preview :
-gimp_split_preview "-gimp_meancurvature_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_median :
-ac "-median $1,$2",$3
gimp_median_preview :
-gimp_split_preview "-gimp_median $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_nlmeans:
-repeat $! -l[$>]
-if {s==1} -nlmeans $1,$2,$3,-_gimp_nlmeans$4
-else -ac "-gimp_parallel_overlap \"-nlmeans $1,$2,$3,-_gimp_nlmeans$4\",$6,$7",$5
-endif
-endl -done
_gimp_nlmeans0 : -s c -abs -max
_gimp_nlmeans1 : -s c -abs -+
_gimp_nlmeans2 : -norm
_gimp_nlmeans3 : -if {s>=3} -channels 0,2 -luminance -else -norm -endif
_gimp_nlmeans4 : -if {s>=3} -channels 0,2 -srgb2rgb -rgb2lab -channels 0 -else -norm -endif
_gimp_nlmeans5 :
gimp_nlmeans_preview:
-gimp_split_preview "-gimp_nlmeans $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_patch_smoothing :
-ac "-gimp_parallel_overlap \"-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done -c 0,255\",$9,$10",$8
gimp_patch_smoothing_preview :
-gimp_split_preview "-gimp_patch_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_pca_smoothing :
-ac "-denoise_patchpca ${1-4} -c 0,255",$5
gimp_pca_smoothing_preview :
-gimp_split_preview "-gimp_pca_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_peronamalik_smoothing :
-ac "-gimp_parallel_overlap \"-peronamalik_flow $1,$3,$2,$4 -c 0,255\",$6,$7",$5
gimp_peronamalik_smoothing_preview :
-gimp_split_preview "-gimp_peronamalik_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_selective_smoothing :
-ac "-gimp_parallel_overlap \"-repeat $4 -blur_selective $1,$2,$3 -done -c 0,255\",$6,$7",$5
gimp_selective_smoothing_preview :
-gimp_split_preview "-gimp_selective_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_smooth_skin :
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-if $5 --balance_gamma 128,128,128 -else [0] -endif
-if {$1==0} -channels. 0 -f. 1 -elif {$1==2} -detect_skin. $2 -else -detect_skin. $2,$6%,$7%,$8% -endif
M={iM} -b. $3% -*. {$M/iM} -*. $4 -c. 0,1
-split_details[0] 4,$9%,$10%
--_gimp_smooth_skin[2] $12,$11
-j[2] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-*. {10^$13} -+ -c 0,255
-endl -a c -endl -done
_gimp_smooth_skin :
-if {$1==0} -b {$2/8}%
-else
-if {$2>0}
m={im} M={iM} -n 0,255
-repeat {int($2/5)} -bilateral 3%,{5*3} -done
-bilateral 3%,{($2%5)*3}
-* {($M-$m)/255} -+ $m
-endif
-endif
gimp_smooth_skin_preview :
-if {$-2==0}
-gimp_split_preview "-if $5 -balance_gamma 128,128,128 -endif -if {$1==0} -f 1 -elif {$1==2} -detect_skin $2 -else -detect_skin $2,$6%,$7%,$8% -endif M={iM} -b $3% -* {255*$M/iM} -* $4 -c 0,255",$-1
-elif {$-2==1}
-gimp_split_preview "-b $9%",$-1
-elif {$-2==2}
-gimp_split_preview "-split_details 4,$9%,$10% -k.. -n 0,255",$-1
-elif {$-2==3}
-gimp_split_preview "-split_details 4,$9%,$10% -k.. -_gimp_smooth_skin $12,$11 -n 0,255",$-1
-elif {$-2==4}
-gimp_split_preview "-split_details 4,$9%,$10% -k. -n 0,255",$-1
-else
-gimp_split_preview "-gimp_smooth_skin $*",$-1
-endif
-if {$1==1}
-to_rgb
-circle $6%,$7%,$8%,0.2,0,255,0
-circle $6%,$7%,$8%,0.4,0xFFFFFFFF,0,255,0
-line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
-line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
-endif
gimp_tv_smoothing :
-ac "-gimp_parallel_overlap \"-tv_flow $2,$1,$3 -c 0,255\",$5,$6",$4
gimp_tv_smoothing_preview :
-gimp_split_preview "-gimp_tv_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
gimp_haar_smoothing :
-remove_opacity
-ac "-gimp_parallel_overlap \"-denoise_haar $1,$3,$2 -c 0,255\",$5,$6",$4
gimp_haar_smoothing_preview :
-gimp_split_preview "-gimp_haar_smoothing $*",$-1,{if(isval($GMIC_GIMP_TIMEOUT),0$GMIC_GIMP_TIMEOUT,8)}
jeje_local_wiener :
-ac "-local_wiener $1",$2,$3
jeje_local_wiener_preview:
-gimp_split_preview "-jeje_local_wiener $*",$-1
gimp_solidify_td :
-repeat $! -l[$>]
-to_a -sh 0,{s-2} -srgb2rgb. -rm.
-if $4
[-1] -sh. 100% -if {$4>0} -erode. {1+2*$4} -else -dilate. {1-2*$4} -endif -rm.
-solidify. $1%,$2,$3
-rv -blend alpha -rgb2srgb
-else
-solidify $1%,$2,$3 -rgb2srgb.
-endif
-endl -done
gimp_solidify_td_preview :
-gimp_split_preview "-gimp_solidify_td $*",$-1
jeje_unstrip :
-unstrip $1,$2,$3
-if $5 -tape -powerspectrum -else
-if -$4 -n 0,255 -else -c 0,255 -endif
-endif
jeje_unstrip_preview :
-gimp_split_preview "-jeje_unstrip $1,$2,$3,$4,$5",$-1
gimp_scale_dcci2x : -skip ${1=1.15},${2=5},${3=0}
-repeat $! -l[$>]
-split_opacity -scale_dcci2x ${1-3} -a c -c 0,255
-endl -done
gimp_scale_dcci2x_preview :
-z 25%,25%,75%,75% -gimp_scale_dcci2x $*
gimp_render3d : -skip ${14=1}
width={(1+$14)*$1} height={(1+$14)*$2}
-n3d -c3d -m3d {round($13)} f3d={0.5*max($width,$height)/tan($7*pi/360)}
-f3d $f3d -l3d {$8*$f3d},{$9*$f3d},{$10*$f3d} -sl3d $11 -ss3d $12
-repeat $! -l[$>]
-*3d {$3*max($width,$height)} -r3d 0,0,1,$6 -r3d 0,1,0,$5 -r3d 1,0,0,$4
$width,$height,1,3,-1
-j3d. [-2],50%,50% -rm..
-to_rgba -replace_color 0,0,-1,-1,-1,255,0,0,0,0
-if $14
-r $1,$2,1,100%,2 -s c,-3 -+. 1e-5 -/[0] [1] -*[0] 255 -a c
-endif
-endl -done
gimp_upscale_smart :
-to_rgb -upscale_smart $1,$2,1,$3,$4,$5 -c 0,255
gimp_upscale_smart_preview :
-repeat $!
--r. $1,$2,1,1,0
-if {w<{-2,w}||h<{-2,h}}
-rm. -/. 4
0 -t. "Downscaling is\nnot allowed!",5,5,20,1,255 -r. [-2],[-2],1,1,0,0,0.5,0.5
-|[-2,-1]
-else
-z.. {50-50*{-2,w}/w}%,{50-50*{-2,h}/h}%,{50+50*{-2,w}/w}%,{50+50*{-2,h}/h}%
-rm. -gimp_upscale_smart. $1,$2,$3,$4,$5 -c. 0,255
-endif
-mv. 0 -done
gimp_scalenx :
-repeat $! -l[$>] -split_opacity
-if {$2==1} -rgb2ycbcr[0] -round[0]
-elif {$2==2} -rgb2lab8[0] -round[0]
-endif
-if {$1==0} -scale2x
-elif {$1==1} -scale3x
-elif {$1==2} -scale2x -scale2x
-elif {$1==3} -scale3x -scale2x
-elif {$1==4} -scale2x -scale2x -scale2x
-elif {$1==5} -scale3x -scale3x
-elif {$1==6} -scale3x -scale2x -scale2x
-elif {$1==7} -scale2x -scale2x -scale2x -scale2x
-elif {$1==8} -scale3x -scale3x -scale2x
-elif {$1==9} -scale3x -scale3x -scale3x
-endif
-if {$2==1} -ycbcr2rgb[0]
-elif {$2==2} -lab82rgb[0]
-endif
-a c -endl -done
gimp_scalenx_preview :
-z 40%,40%,60%,60%
-gimp_scalenx $1,$2
gimp_animate_elevation3d :
-if $3 filename="$4/gmic_elevation3d.png" -else filename="" -endif
-_gimp_elevation3d ${5-6}
-animate gimp_render3d,"${7-8},${10-19},$9",\
"${7-8},${20-29},$9",$1,$2,{``$filename}
gimp_animate_elevation3d_preview :
w={w} h={h}
-_gimp_elevation3d ${5-6}
-gimp_animate_preview gimp_render3d,$w","$h",${10-19},$9",\
$w","$h",${20-29},$9",0,$w,$h
gimp_animate_extrude3d :
-if $3 filename="$4/gmic_extrude3d.png" -else filename="" -endif
-_gimp_extrude3d ${5-7}
-animate gimp_render3d,"${8-9},${11-20},$10",\
"${8-9},${21-30},$10",$1,$2,{``$filename}
gimp_animate_extrude3d_preview :
w={w} h={h}
-_gimp_extrude3d ${5-7}
-gimp_animate_preview gimp_render3d,$w","$h",${11-20},$10",\
$w","$h",${21-30},$10",0,$w,$h
gimp_animate_imageobject3d :
-if $3 filename="$4/gmic_imageobject3d.png" -else filename="" -endif
-_gimp_imageobject3d "_",$5
-animate gimp_render3d,"${6-7},${9-18},$8",\
"${6-7},${19-28},$8",$1,$2,{``$filename}
gimp_animate_imageobject3d_preview :
w={w} h={h}
-_gimp_imageobject3d "_preview_",$5
-gimp_animate_preview gimp_render3d,$w","$h",${9-18},$8",\
$w","$h",${19-28},$8",0,$w,$h
gimp_text_pointcloud3d :
W={w} H={h} M={round(1.5*max(w,h))} -rm
-text_pointcloud3d "$2","$3",$4
-col3d. ${5-7} -*3d. {0.7*$M}
-f3d 4000 -db3d 0 -m3d
-repeat $1
-rprogress {60*$>/$1}
angle={$>*360/$1}
--r3d[0] 1,0,1,$angle
$M,$M,1,3,-1 -j3d. [-2],50%,50%,0,1 -rm..
-done
-rm[0] -a z -autocrop -1 -to_rgba -s z -replace_color 0,0,-1,-1,-1,255,0,0,0,0
-if $11 N=$! -repeat $! -l[$>] -rprogress {60+40*$>/$N}
-i[0] 100%,100%,1,4 -fc[0] ${8-11} --channels. 3,3 --negative. -b[-2,-1] $14% -to_rgba.
-j[0] [-1],$12%,$13%,0,0,1,[-2],255 -rm[-2,-1] -blend alpha
-endl -done -endif
-if {$W>$H} -r2dx $W -else -r2dy $H -endif
-if {$15>1}
-i[{int($1/2)}] [{int($1/2)}]x{$15-1}
-i[0] [0]x{$15-1}
-endif
gimp_text_pointcloud3d_preview :
-gimp_text_pointcloud3d 4,"$2","$3",$4,${5-7},${8-11},${12-14},1 -drgba
-frame 1,1,0 -append_tiles 2,2
gimp_transition3d :
-f3d $7
-transition3d $1,$2,$3,"$4","$5","$6",$8
gimp_transition3d_preview :
-if {$!==1} -gimp_warning_preview "Missing input layer" -return -endif
-f3d $7
-k[0,1] -transition3d 4,$2,$3,"$4","$5","$6",$8
-k[1,2]
-r[0] 50%,100%,1,100%,0
-r[1] 50%,100%,1,100%,0,0,1
-a x
-line 50%,0,50%,100%,1,0,0,0,255
gimp_animate_pencilbw :
-if $3 filename="$4/gmic_pencilbw.png" -else filename="" -endif
-animate pencilbw,"${5-6}",\
"${7-8}",$1,$2,{``$filename}
gimp_animate_pencilbw_preview :
-gimp_animate_preview pencilbw,"${5-6}",\
"${7-8}"
gimp_animate_stencilbw :
-if $3 filename="$4/gmic_stencilbw.png" -else filename="" -endif
-animate stencilbw,"${5-6}",\
"${7-8}",$1,$2,{``$filename}
gimp_animate_stencilbw_preview :
-gimp_animate_preview stencilbw,"${5-6}",\
"${7-8}"
gimp_animate_cartoon :
-if $3 filename="$4/gmic_cartoon.png" -else filename="" -endif
-animate cartoon,"${6-10},$5",\
"${11-15},$5",$1,$2,{``$filename}
gimp_animate_cartoon_preview :
-gimp_animate_preview cartoon,"${6-10},$5",\
"${11-15},$5"
gimp_fire_edges :
-fire_edges ${1-7} -rv
gimp_fire_edges_preview :
-gimp_split_preview "-fire_edges $1,$2,$3,$4,1,$6,0",$-1
gimp_animate_edges :
-if $3 filename="$4/gmic_edges.png" -else filename="" -endif
-animate gimp_edges,"${6-7},$5",\
"${8-9},$5",$1,$2,{``$filename}
gimp_animate_edges_preview :
-gimp_animate_preview gimp_edges,"${6-7},$5",\
"${8-9},$5"
gimp_lavalampbw :
-if {!$!} (255;100^64;16^128;0) -r. 512,512,1,3,3 -endif
-repeat $! -l[$<]
w={w} h={h}
--r $4%,$4%,1,1,0 [-1]x{$1-1} -rand[^0] 0,1 -stencil[^0] $5,0
-if $3 [1] -endif
-morph[^0] $2,$6,0
-stencil[^0] $5,0
-r[^0] $w,$h,1,1,3 -b[^0] 10 ->=[^0] 50% -*[^0] 255
-r[^0] 100%,100%,1,4 -j[^0] [0] -rm[0]
-if $3 -rm. -endif
-endl -done
-if {!$7} -repeat $! -l[$>] -split_opacity -n. 0,1 -*[^-1] [-1] -rm. -endl -done -endif
gimp_lavalampbw_preview :
-gimp_lavalampbw 2,2,1,$4,$5,$6,$7 -k[0]
gimp_animate_lissajous :
-if $3 filename="$4/gmic_lissajous.png" -else filename="" -endif
-animate gimp_lissajous,"${5-22}",\
"${23-40}",$1,$2,{``$filename}
gimp_animate_lissajous_preview :
-gimp_animate_preview gimp_lissajous,"${5-22}",\
"${23-40}",0
gimp_animate_morpho :
-if $3 filename="$4/gmic_morpho.png" -else filename="" -endif
-animate gimp_morpho,"$5,$8,$6,$7,0,1",\
"$5,$9,$6,$7,0,1",$1,$2,{``$filename}
gimp_animate_morpho_preview :
-gimp_animate_preview gimp_morpho,"$5,$8,$6,$7,0,1",\
"$5,$9,$6,$7,0,1"
gimp_tk_animateobject :
-if {$!<=1} -return -endif
-if {$15==0}
-to_rgb -if {$9==0}
-r {w*{$6/max(w,h)}},{h*{$6/max(w,h)}},1,{s},6 -c 0,255
-if {$14==0}
[-1,-2] [0] -rv[0,1]
-blur_xy[0] $11 -ir[0] $13,256 -n[0] 0,255
-tk_gimp_replace_color[0] 1,0,0,0,0,255,0,0,0,0
-blur_xy[0] $12 -inpaint[1] [0]
-rm[0] -rv[-1,-2]
-else [0] -rv[0,1] -rv[-1,-2]
[0] [0]
[-3] [-1]
-to_gray[-1,-2] -ir[-1,-2] 128,256 -n[-1,-2] 0,255
-s[1] c -a[1,2,3,-1] c
-s[2] c -a[2,3,4,-1] c
-rv[1,-1] -compose_rgba[1,-1]
-rv[2,-1] -compose_rgba[2,-1]
-to_rgb[1,2]
-endif
dx={$1/$7} dy={$2/$7} dz=1 -repeat $7
-shift[-1,-2] $dx%,$dy%
-if {$3>=0} dz={$dz+{{$3}/$7}}
-else dz={$dz-{{{1-{10.01+$3}/10}}/$7}} -endif
--gimp_zoom[-1,-2] $dz,$4,$5,0
-to_gray[-1] -ir[-1] 128,256 -n[-1] 0,255 -to_rgb[-2]
-s[-2] c -a[-4,-3,-2,-1] c
-if {$10!=0} -unsharp[-1] {$10/5},{$10/2},0 -cut[-1] 0,255  -endif
-mv[-1] -3 -done -rm[-1,-2] -rv -rv[-1,-2]
index={-3} -repeat $7
[-2] -rv[-1,-2] index={$index-1}
-rv[-3,$index] -compose_rgba[-3,$index]
-done -rm[-2] -if {$8==1} -rv -endif
-else
-if {$14==0} frames={$!-1} counter={-5}
[-1,-2]
--blur_xy[-1] $11 -ir[-1] $13,256 -n[-1] 0,255
-tk_gimp_replace_color[-1] 1,0,0,0,0,255,0,0,0,0
-blur_xy[-1] $12
-repeat $frames -inpaint[$counter] [-1]
counter={$counter-1} -done -rm[-1,-4]
[-1,-2]
-else frames={$!-2} --to_gray[-1]
-s[-3] c -a[-5,-4,-3,-1] c
--to_gray[-1] --fc[-1] 0,0,0
-rv[-1,-4] -compose_rgba[-1,-4] -mv[-1] -3
-endif
counter={-6} dx=0 dy=0 dz=1 -repeat {$frames}
[-1,-2]
-shift[-1,-2] $dx%,$dy%
-if {$3>=0} dz={$dz+{{$3}/$frames}}
-else dz={$dz-{{{1-{10.01+$3}/10}}/$frames}} -endif
--gimp_zoom[-1,-2] $dz,$4,$5,0
-to_gray[-1] -ir[-1] 128,256 -n[-1] 0,255 -to_rgb[-2]
-s[-2] c -a[-4,-3,-2,-1] c
-if {$10!=0} -unsharp[-1] {$10/5},{$10/2},0 -cut[-1] 0,255 -endif
-mv[-1] $counter
-compose_rgba[$counter,{$counter-1}]
dx={$dx+{$1/$frames}} dy={$dy+{$2/$frames}}
counter={$counter-1}
-rm[-1,-2]
-done  -rm[-1,-2,-3,0]
-endif
#camera motion only
-else
-to_rgb -if {$9==0}
-r {w*{$6/max(w,h)}},{h*{$6/max(w,h)}},1,{s},6 -c 0,255 -endif
dx=0 dy=0 dz=1 -if {$9==0} counter=$7 -else counter={$!-1} -endif
index={-2} -repeat $counter
-if {$9==0} [-1] -mv[-1] $index -endif
dx={$dx+{$1/$7}} dy={$dy+{$2/$7}}
-shift[$index] $dx%,$dy%
-if {$3>=0} dz={$dz+{{$3}/$7}}
-else dz={$dz-{{{1-{10.01+$3}/10}}/$7}} -endif
-gimp_zoom[$index] $16,$4,$5,0
-gimp_zoom[$index] $dz,$4,$5,0
-if {$10!=0} -unsharp[$index] {$10/5},{$10/2},0 -cut[$index] 0,255 -endif
index={$index-1} -done
-if {$16!=1} -rm[-1] -endif -endif
#preview function
gimp_tk_animateobject_preview:
-if {$15==0} start_x={{xM/w}*100} start_y={{yM/h}*100} -else start_x=50 start_y=50 -endif
-gimp_tk_animateobject ${1-6},1,${8--1} -k[0]
-line[0] {$1+$start_x}%,{$2+$start_y-10}%,{$1+$start_x}%,{$2+$start_y+10}%,1,255,0,0
-line[0] {$1+$start_x-10}%,{$2+$start_y}%,{$1+$start_x+10}%,{$2+$start_y}%,1,255,0,0
-line[0] {$4*100}%,0%,{$4*100}%,{{$5*100}-5}%,1,255,255,0
-line[0] {$4*100}%,{{$5*100}+5}%,{$4*100}%,100%,1,255,255,0
-line[0] 0%,{$5*100}%,{{$4*100}-5}%,{$5*100}%,1,255,255,0
-line[0] {{$4*100}+5}%,{$5*100}%,100%,{$5*100}%,1,255,255,0
gimp_animate_rodilius :
-if $3 filename="$4/gmic_rodilius.png" -else filename="" -endif
-animate rodilius,"${6-10},$5",\
"${11-15},$5",$1,$2,{``$filename}
gimp_animate_rodilius_preview :
-gimp_animate_preview rodilius,"${6-10},$5",\
"${11-15},$5"
gimp_animate_glow :
-if $3 filename="$4/gmic_glow.png" -else filename="" -endif
-animate glow,"$5",\
"$6",$1,$2,{``$filename}
gimp_animate_glow_preview :
-gimp_animate_preview glow,"$5",\
"$6"
gimp_spatial_transition :
-to_rgba -r ${-max_wh},1,100%,0,0,0.5,0.5
shape=-1 formula=
-if {$3==0}
-elif {$3==1} shape=0
-elif {$3==2} formula="$4"
-elif {$3==3} formula="sin(x*0.5*pi/w*(1+100*A))"
-elif {$3==4} formula="sin(y*0.5*pi/h*(1+100*A))"
-elif {$3==5} formula="atan2(y-h/2,x-w/2)%((1-A)*2*pi+0.001)"
-elif {$3==6} formula="R=0.5*sqrt(w*w+h*h);sqrt((y-h/2)^2+(x-w/2)^2)%(0.001+R*(1-A))"
-elif {$3==7} 100%,100% -plasma. 1,1,{8/(1+$5)} -equalize. 1024
-endif
-if {narg($formula)}
{w},{h},1,1,"A=$5;"$formula -endif
-if $-1
-if {$6==0} -k[$shape] -norm -n 0,255
-elif {$6==1" && "$7==0} -rm[$shape] -rm.
-elif {$6==1" && "$7==1} -rm[$shape] -rm[0]
-elif {$6==1}
-transition[^$shape] [$shape],$1,$2,$7*($1-1) -rm[$shape] -rm[0--1:2]
-else
-transition[^$shape] [$shape],{$6*2},$2 -rm[$shape] -to_rgba
-endif
-if {$!>1} -to_rgba -frame 2%,2%,0,0,0,0 -append_tiles , -endif
-else
-transition[^$shape] [$shape],$1,$2
-rm.
-endif
-nm name(transition),pos(0,0)
-if {narg($formula)} -u "{$1}{$2}{$3}{\""$formula"\"}{$5}{$6}{$7}{0}" -endif
gimp_spatial_transition_preview :
-if {($3<=1" && "$!<3)" || "($3>1" && "$!<2)} -gimp_print_preview "Warning:",,"This filter requires more input layers to work properly." -return -endif
-gimp_spatial_transition ${1-3},"$4",${5-7},1
gimp_tk_make3D :
# prepare image
sh={-$2} sw={-$sh-$3} size1={w} size2={h} -to_rgb[0] -r[0] $size1,$size2 [0]
# create depth map
-if {$11==0}
--gimp_tk_depthmap[-1] $1,$4,$5,$6,$7,$8,$9,0,0,0 -r[-1] $size1,$size2
-gimp_gaussian_blur[-1] 0,{{w+h}/700},{{w+h}/350},1,0,0,0
# individual depth map
-else -if {{$!}!=3}
-error[] "For individual depth map select input mode ACTIVE AND BELOW" -endif
-rv[1,-1] -to_rgb[-1] -luminance[-1]
# analyze image features to enrich individual maps
-if {$11==1}
-if {$9!=0}
--fc[0] 128,128,128 --channels[0] 2 -negative[-1] -c[-1] 0,90
-n[-1] 0,128 -rv[-1,-2] -compose_darken[-1,-2]
--channels[0] 0 -negative[-1] -c[-1] 165,255 -n[-1] 128,255 -rv[-1,-2]
-compose_hardlight[-1,-2] -rv[-1,-2]
-if {$11==0} -if {$1!=20} -gimp_compose_average[-1,-2] {$9/5}
-else -gimp_compose_value[-1,-2] {$9/5},0
-tk_gimp_channel_processing[-1] 1,{$4/25},0,0,0,0,100,256,0,0,0,2,0,0
-endif
-else -gimp_compose_value[-1,-2] {$9/5},0 -endif -endif
-if {$8!=0} --gimp_highpass[0] 2,2,0,0,0
-tk_gimp_replace_color[-1] 5,0,128,128,128,255,0,0,0,255
-gimp_morpho[-1] 3,70,0,0,0,1,0   -to_gray[-1] av={ia}
-ir[-1] $av,255 -n[-1] 0,255 -blur_xy[-1] 25
-rv[-1,-2] -gimp_compose_overlay[-1,-2] {$8/5} -endif
-if {$5!=0} --gimp_isophotes[0] {{$5*3}+2},0,0,0
-gimp_morpho[-1] 3,{5-{$5/2}},0,0,0,1,0
-tk_gimp_channel_processing[-1] 1,1,255,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -gimp_compose_overlay[-1,-2] {$5/10}
--gimp_gradient_norm[0] {$6*2},{1.5-{0.1+{$5/3.6}}},0,100,0,0
-rv[-1,-2] -compose_lighten[-1,-2] -gimp_segment_watershed[-1] $5,$6,0,0
-endif
-if {$7!=0} --luminance[0] -gimp_map_tones[-1] 1,{0.25-{$7/20}},0,30,3,0
-rv[-1,-2] -gimp_compose_overlay[-1,-2] {$7/10} -endif
-n[-1] 0,255
-endif -endif
#frame size for multiple frames
-if {$20==1} -r {w*{$23/max(w,h)}},{h*{$23/max(w,h)}},1,3,6 -c 0,255 -endif
#create second view
-if {$20==0}
-if {$13!=15} -if {$19==0}
-if {$sw<=0} -negative[-1] -endif
-r[-1] $size1,$size2,1,2 -s[-1] c -f[-1] 0 -n[-2] 0,$sw -a[-1,-2] c
-warp[-2] [-1],1 -shift[-2] $sh,0 -rm[-1]
-else
[-1] -r[-1,-2] 100%,100%,1,2
-s[-1] c -f[-1] 0 -n[-2] 0,{abs($sw/2)} -a[-1,-2] c
-negative[-2] -s[-2] c -f[-2] 0 -n[-3] 0,{-abs($sw/2)} -a[-2,-3] c
-warp[-4] [-2],1 -warp[-3] [-1],1
-shift[-3] $sh,0 -rm[-1,-2]
-endif -endif
-else
#create multiple frames
-if {$19==0}
count={$22} dev=0 -repeat $count dev={$dev+{$sw/$22}}
[0] -rv[-1,-2]
-if {$sw<=0} -negative[-1] -endif
-r[-1] 100%,100%,1,2 -s[-1] c -f[-1] 0
-if {$21==0} -n[-2] 0,$dev -else -n[-2] {-$dev},$dev -endif
-a[-1,-2] c -warp[-2] [-1],1 -to_gray[-1] -n[-1] 0,255
-if {$sw<=0} -negative[-1] -endif
-done -rm[-1,0] -rv
-else
count={abs($22/2)} dev=0
-repeat $count dev={$dev+{$sw/$count}}
[-2] -rv[-1,-2]
[-2] -rv[-1,-2]
[-1] -r[-1,-2] 100%,100%,1,2
-s[-1] c -f[-1] 0
-if {$21==0} -n[-2] 0,{abs($dev/2)}
-else -n[-2] {-abs($dev/2)},{abs($dev/2)} -endif
-a[-1,-2] c
-negative[-2] -s[-2] c -f[-2] 0
-if {$21==0} -n[-3] 0,{-abs($dev/2)}
-else -n[-3] {-abs($dev/2)},{abs($dev/2)} -endif
-a[-2,-3] c
-warp[-4] [-2],1 -warp[-3] [-1],1 -rm[-2] -to_gray[-1] -n[-1] 0,255
-mv[-4] -1 -done -rm[-1,-2] -mv[0--1:2] -1 -rv[0-50%] -mv[0] 50%
-endif -endif
#crop images
-if {$20==0} -if {$18==1} -if {$13!=15}
-if {$sh>=0} -crop[-1,-2] $sh,0,{w},{h} -else -crop[-1,-2] 0,0,{w+$sh},{h} -endif
-if {$19==0}
-if {$sw>=0} -crop[-1,-2] $sw,0,{w},{h} -else -crop[-1,-2] 0,0,{w+$sw},{h} -endif
-else -crop[-1,-2] {abs($sw/2)},0,{w-abs($sw/2)},{h}
-endif -endif -endif -endif
#align stereoscopic image
-if {$12==1} -gimp_blackandwhite 0.299,0,0.587,0,0.114,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0 -endif
-if {$20==0}
-if {{$13!=14}&&{$13!=15}}
-gimp_tk_stereoimage[0,1] $13,$10,$14,$15,$16,$17
-elif {$13==14} -k[0,1]
-elif {$13==15} -k[-1]
-endif
-endif
-if {$13==14} -apply_gamma $14 -tk_gimp_channel_processing 1,1,$15,0,0,0,100,256,0,0,1,10,7,0
-gimp_mix_lab 1,0,0,$16,0,0,$16,0,0,0,2,0 -endif
gimp_tk_make3D_preview :
-if {$20==0} shpre={$2/3} swpre={$3/3} -else shpre={$2*{400/$23}} swpre={$3*{400/$23}} -endif
-if {{$11==1}&&{{$!}!=2}} -fc[0] 255,0,128,255 -k[0] -text "For individual depth map",10,80%,20,1,0,0,0,255
-text "select input mode ACTIVE AND BELOW.",10,90%,20,1,0,0,0,255
-else
-gimp_tk_make3D $1,$shpre,$swpre,${4-12},{if({$20==1},14,$13)},${14-19},0,${21-23} -if {{$13==14}||{$20==1}} -k[1] -endif
-endif
gimp_tk_video3D :
sh={-$2} sw={-$sh-$3} size1={w} size2={h}
-if {narg($_previewflag)==0} _previewflag=0 -endif
-if {$_previewflag!=0} sh={$sh*{400/$22}} sw={$sw*{400/$22}} -endif
-if {$26==0}
####layer based conversion####
-if {{$34!=0}||{$35!=0}}
-if {{$34>={{$!}-$35}}||{$35>={{$!}-$34}}} -error[] "Fade out of frame range."
-endif -endif
-if {$13!=14} -channels 0,2 -endif
-if {$_previewflag!=2}  frames={$!} -else frames=1  -endif
counter={$!} index=0
-if {$_previewflag!=0} -r 400,328 -endif
# image stream alignment and 2D filtering only modes
#-if {{$41==3}&&{$_previewflag==0}} -error[] "Anaglyph video reconstruction in batch processing mode only" -endif
flag3d=0 -if {$41!=2}
-if {!{{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}}} flag3d=1
# start 3D conversion per frame
-repeat {$frames}
# prepare images
[$index]
# create depth maps
-if {{$40==0}||{$40==1}}
--gimp_tk_depthmap[$index] $1,$4,$5,$6,$7,$8,$9,$38,$39,{w*{$37/1000}}
-r[-1] $size1,$size2 -endif
-if {$40==1}
infilec="correction.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-to_rgba[-1,-2] -compose_rgba[-1,-2] -to_rgb[-1]
-elif {$40==2}
infilec="depthmap.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-elif {$40==3}
-if {$_previewflag==2}
infilec="depthmap_"$_mapin".png" inpathc="$27/depthmaps/"$infilec""
-else
infilec="depthmap_"{$frames-$index}".png" inpathc="$27/depthmaps/"$infilec""
-endif
-input[-1] $inpathc
-rv[$index,-2]
-endif
-if {$_previewflag!=0} -r 400,328 -endif
# motion analysis
-if {$10!=0}
-if {$_previewflag==2} [0] -mv[-4] -1
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,{{$37/2}+1} -negative[-1] -n[-1] 0,255
-else
[$index] [{$index+1}]
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,{{$37/2}+1}
-negative[-1] -n[-1] 0,255
-if {$index<={$frames-2}} --negative[-1] -endif
-endif
-endif
index={$index+1} -done
-if {$10!=0}
-if {$_previewflag==2}
-if {$42==0}  infile={$29} -elif {$42==1} infile={$30} -elif {$42==2} infile={$43} -endif
-if {$infile==2} -rv[-1,-2] -else -if {$infile>={$29+2}}
-compose_difference[-4,-5] -luminance[-4] -n[-4] 0,255
-ir[-4] 0,1 -negative[-4] -n[-4] 0,255
-negative[-4] -compose_darken[-1,-4]
-mv[-3] -1 -endif -endif
-blur_xy[-2] {w*{$37/1000}}
-if {$infile!=$29} -if {$10>=0} -gimp_compose_lighten[-1,-2] {abs($10)/5}
-else -negative[-2] -gimp_compose_darken[-1,-2] {abs($10)/5} -endif -endif
-else
-rm[-1] -rm[{$counter+3}]
-repeat {$frames-2}
-mv[{$counter+6}] {$counter+2}
-compose_darken[{$counter+2},{$counter+3}]
-rv[{$counter+1},{$counter+2}]
-blur_xy[{$counter+1}] {w*{$37/1000}}
-if {$10>=0}
-gimp_compose_lighten[{$counter+1},{$counter+2}] {abs($10)/5}
-else -negative[{$counter+1}]
-gimp_compose_darken[{$counter+1},{$counter+2}] {abs($10)/5}
-endif
counter={$counter+2} -done
-rv[-3,-4] -blur_xy[-4] {w*{$37/1000}}
-if {$10>=0} -gimp_compose_lighten[-3,-4] {abs($10)/5}
-else -negative[-4] -gimp_compose_darken[-3,-4] {abs($10)/5} -endif
-endif
-endif
# create second view frameset
-if {$_previewflag==2} -if {$24!=0} -rm[-2] -endif -endif
index={-1} -repeat $frames
-if {$13!=15}
-if {$41==0} -if {$sw<=0} -negative[$index] -endif -endif
-if {$_previewflag!=2}
-if {$34!=0} -if {{-$index}<=$34} sw={{{-$index}/$34}*$sw} sh={{{-$index}/$34}*$sh}
-endif -endif
-if {$35!=0} -if {-{$index+1}>={$frames-$35}} sw={$sw*{{$frames-{-{$index+1}}}/$35}}
sh={$sh*{{$frames-{-{$index+1}}}/$35}} -endif -endif -endif
-if {$41==0}
-r[$index] 100%,100%,1,2 -s[$index] c -f[$index] 0 -n[{$index-1}] 0,$sw
-a[$index,{$index-1}] c -warp[{$index-1}] [$index],1
-shift[{$index-1}] $sh,0 -rm[$index]
-else
[$index]
-mv[-1] {$frames+{$index+1}}
-r[$index,{$frames+{$index+1}}] 100%,100%,1,2
-s[$index] c -f[$index] 0 -n[{$index-1}] 0,{abs($sw/2)} -a[$index,{$index-1}] c
-negative[{$frames+{$index+1}}] -s[{$frames+{$index+1}}] c
-f[{$frames+{$index+2}}] 0 -n[{$frames+{$index+1}}] 0,{-abs($sw/2)}
-a[{$frames+{$index+1}},{$frames+{$index+2}}] c
-warp[{$frames+{$index+0}}] [{$frames+{$index+1}}],1
-warp[{$index-1}] [$index],1
-shift[{$index-1}] $sh,0
-rm[$index,{$frames+{$index+1}}]
-endif
-endif
sh={-$2} sw={-$sh-$3}
-if {$_previewflag!=0} sh={$sh*{400/$22}} sw={$sw*{400/$22}} -endif
index={$index-1} -done
# frames offset
-if {$13!=15} -if {$_previewflag!=2}
-if {$24>=0} -repeat $24 -rm[-1] [$frames]
-mv[-1] $frames -done
-else counter={1} -repeat {abs($24)} -rm[$frames]
[{-$counter}] -mv[-1] {-$counter-1} counter={$counter+1} -done -endif
-endif -endif
# autocrop frames
-if {$20==1} -if {$13!=15}
-if {$sh>=0} -crop $sh,0,{w},{h} -else -crop 0,0,{w+$sh},{h} -endif
-if {$sw>=0} -crop $sw,0,{w},{h} -else -crop 0,0,{w+$sw},{h} -endif
-endif -endif
#end image stream alignment and 2D mode bypass
-endif -endif
# apply custom filter
-if {$_previewflag!=2}
-if {$32!=0} -if {$13!=15} -repeat $! -l[$>] -gimp_custom_code "$33",0,0,0 -endl -done -endif -endif
-else
-if {$32==1} -if {$13!=15} -gimp_custom_code[0,1] "$33",0,0,0 -endif
-elif {$32==2} -if {$13!=15} -l[0] -gimp_custom_code "$33",0,0,0 -endl -endif
-elif {$32==3} -if {$13!=15} -l[1] -gimp_custom_code "$33",0,0,0 -endl -endif
-endif -endif
# align stereoscopic images
-if {$41==2} -if {{$13==14}||{$13==15}} -error[] "Output format not allowed for image stream alignment" -endif -endif
-if {$12==1} -ac "-gimp_blackandwhite 0.3,0,0.6,0,0.1,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0",rgb -endif
counter={$frames-1} index={-2}
-repeat $frames
-if {{$13!=14}&&{$13!=15}}
-gimp_tk_stereoimage[-1,$counter] $13,$11,$16,$17,$18,$19
-elif {$13==15} -rm[0,$index]
-endif counter={$counter-1} index={$index-1} -done
# adjust output image streams
-if {$13==14} -apply_gamma $16 -tk_gimp_channel_processing 1,1,$17,0,0,0,100,256,0,0,1,10,7,0
-gimp_mix_lab 1,0,0,$18,0,0,$18,0,0,0,2,0 -endif
# resize frames to output format
-if {$21==1} -if {$13!=13}
-if {$23==0} -r $22,{$22*0.75},1,{s},6
-elif {$23==1} -r $22,{{$22*9}/16},1,{s},6
-elif {$23==2} -r $22,{{$22*2}/3},1,{s},6
-elif {$23==3} -r $22,{$22*0.5},1,{s},6
-elif {$23==4} -r $22,{{$22*9}/21},1,{s},6
-elif {$23==5} -r $22,{$22*{h/w}},1,{s},6 -endif
-endif -endif  -c 0,255
-if {$25==1} -rv -endif
# save frames to folder
-if {$14==1}
-if {{$31==0}||{$13==15}} end=".png" -else end=".bmp" -endif
-rv
index={0} name=0
-if {{$13==14}&&{$flag3d==1}}
fileleft="$15/frame_left_"{$name+1}$end fileright="$15/frame_right_"{$name+1}$end
-else  -if {$13!=15} filename="$15/frame_"{$index+1}$end
-else  filename="$15/depthmap_"{$index+1}$end -endif -endif
-repeat $frames
-if {{$13==14}&&{$flag3d==1}}
-output[$index] $fileright
-output[{$index+$frames}] $fileleft
index={$index+1} name={$name+1}
fileleft="$15/frame_left_"{$name+1}$end fileright="$15/frame_right_"{$name+1}$end
-else
-output[$index] $filename
index={$index+1} -if {$13!=15} filename="$15/frame_"{$index+1}$end -else filename="$15/depthmap_"{$index+1}$end -endif
-endif
-done -rv
-endif
####batch based conversion####
-else
# load images in batch mode
-if {$31==0} end=".png" -else end=".bmp" -endif
infile={$29} inpath="$27/$28"$infile""$end"" outfile={$29}
frames={{$30-$29}+1} counter=1
-if {{$34!=0}||{$35!=0}}
-if {{$34>={$frames-$35}}||{$35>={$frames-$34}}} -error[] "Fade out of frame range"
-endif -endif
-if {$41==2}
inpathleft="$27/$28""left_"$infile$end inpathright="$27/$28""right_"$infile$end
-endif
av=1 var=1 avprev=1 varprev=1
-repeat $frames
-if {$41!=2}
-rm -input[0] $inpath
-if {{$24==0}} [0]
-else infile2={$infile+$24}
-if {$infile2<=$29} infile2={$29} -endif
-if {$infile2>=$30} infile2={$30} -endif
inpath2="$27/$28"$infile2""$end""
-input[1] $inpath2 -endif
-else
-rm -input[0] $inpathleft
-input[1] $inpathright
-endif
size1={w} size2={h}
# image stream alignment and 2D filtering only modes
flag3d=0 -if {$41==3} flag3d=1 -endif -if {{$41!=2}&&{$41!=3}}
-if {!{{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}}} flag3d=1
# prepare images
-if {$13!=14} -channels[0,1] 0,2 -endif
# create depth map
-if {{$40==0}||{$40==1}}
av={0,ia} var={0,iv} diffav={{$av-$avprev}/$avprev*100} diffvar={{$var-$varprev}/$varprev*100}
-if {{abs($diffav)>=10}||{abs($diffvar)>=10}} scenechange=1 -else scenechange=0 -endif
-if {{$counter==1}||{$scenechange==1}||{{$counter/$36}=={round($counter/$36,1)}}}
--gimp_tk_depthmap[0] $1,$4,$5,$6,$7,$8,$9,$38,$39,{w*{$37/1000}} -r[-1] $size1,$size2
-if {$av!=0} avprev=$av -endif -if {$var!=0} varprev=$var -endif
-if {$36!=1} filename="$15/depthmap_temp.png"
-output[-1] $filename -endif
-else
filename="$15/depthmap_temp.png"
-input[-1] $filename
-endif
-endif
-if {$40==1}
infilec="correction.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-compose_rgba[-1,-2]
-elif {$40==2}
infilec="depthmap.png" inpathc="$27/"$infilec""
-input[-1] $inpathc
-elif {$40==3}
infilec="depthmap_"$infile".png" inpathc="$27/depthmaps/"$infilec""
-input[-1] $inpathc
-endif
# motion analysis
-if {$10!=0} -if {$infile!=$29}
[0]
infilemov={$infile-1} inpathmov="$27/$28"$infilemov""$end""
-input[-1] $inpathmov
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,{{$37/2}+1} -negative[-1] -n[-1] 0,255
-if {$infile>={$29+2}}
infilemov2={$infile-2} inpathmov2="$27/$28"$infilemov2""$end""
-input[-1] $inpathmov2
infilemov3={$infile-1} inpathmov3="$27/$28"$infilemov3""$end""
-input[-1] $inpathmov3
-compose_difference[-1,-2] -luminance[-1] -n[-1] 0,255
-ir[-1] 0,1 -n[-1] 0,255 -compose_darken[-1,-2]
-endif -blur_xy[-1] {w*{$37/1000}} -rv[-1,-2]
-if {$10>=0}
-gimp_compose_lighten[-1,-2] {abs($10)/5}
-else
-negative[-2]
-gimp_compose_darken[-1,-2] {abs($10)/5}
-endif
-endif -endif
# create second view
-if {$13!=15}
-if {$41==0}
-if {$sw<=0} -negative[2] -endif
-if {$34!=0} -if {$counter<=$34} sw={{$counter/$34}*$sw} sh={{$counter/$34}*$sh} -endif -endif
-if {$35!=0} -if {$counter>={$frames-$35}} sw={$sw*{{{$frames-$counter}+1}/$35}}
sh={$sh*{{{$frames-$counter}+1}/$35}} -endif -endif
-r[-1] 100%,100%,1,2 -s[-1] c -f[-1] 0 -n[-2] 0,$sw -a[-1,-2] c
-warp[-2] [-1],1 -shift[-2] $sh,0 -rm[-1]
-else
[-1] -r[-1,-2] 100%,100%,1,2
-s[-1] c -f[-1] 0 -n[-2] 0,{abs($sw/2)} -a[-1,-2] c
-negative[-2] -s[-2] c -f[-2] 0 -n[-3] 0,{-abs($sw/2)} -a[-2,-3] c
-warp[-4] [-2],1 -warp[-3] [-1],1
-shift[-3] $sh,0 -rm[-1,-2]
-endif
-endif
sh={-$2} sw={-$sh-$3}
# autocrop frames
-if {$20==1} -if {$13!=15}
-if {$sh>=0} -crop $sh,0,{w},{h} -else -crop 0,0,{w+$sh},{h} -endif
-if {$sw>=0} -crop $sw,0,{w},{h} -else -crop 0,0,{w+$sw},{h} -endif
-endif -endif
#end image stream alignment and 2D mode bypass
-endif  -endif
-if {$41==3} -gimp_tk_deana[0] $37,{{$38*2}+0.1} -to_rgb -endif
# apply custom filter
-if {$32==1} -if {$13!=15} -gimp_custom_code[0,1] "$33",0,0,0 -endif
-elif {$32==2} -if {$13!=15} -l[0] -gimp_custom_code "$33",0,0,0 -endl -endif
-elif {$32==3} -if {$13!=15} -l[1] -gimp_custom_code "$33",0,0,0 -endl -endif
-endif
# align stereoscopic image
-if {$12==1} -ac[0,1] "-gimp_blackandwhite 0.3,0,0.6,0,0.1,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0",rgb -endif
-if {{$41==2}&&{$13==14}} -error[] "Output format not allowed for image stream alignment"
-elif {{$41==3}&&{$13==15}} -error[] "Output format not allowed for anaglyph video reconstruction"
-elif {{$41==2}&&{$13==15}} --gimp_tk_depth_obtain[0,1] $11,{$37/100},{100-{$38*20}},{$39*20}
-if {$32!=0} -gimp_custom_code[0,1,-1] "$33",0,0,0 -endif -k[-1]
-elif {{$41!=2}&&{$13==15}} -k[-1]
-elif {{$41==3}&&{$13==14}} -k[0,1]
-else -gimp_tk_stereoimage[0,1] $13,$11,$16,$17,$18,$19 -endif
# adjust output image streams
-if {$13==14} -apply_gamma $16 -tk_gimp_channel_processing 1,1,$17,0,0,0,100,256,0,0,1,10,7,0
-gimp_mix_lab 1,0,0,$18,0,0,$18,0,0,0,2,0 -endif
# resize frame to output format
-if {$21==1} -if {$13!=13}
-if {$23==0}   -r $22,{$22*0.75},1,{s},6
-elif {$23==1} -r $22,{{$22*9}/16},1,{s},6
-elif {$23==2} -r $22,{{$22*2}/3},1,{s},6
-elif {$23==3} -r $22,{$22*0.5},1,{s},6
-elif {$23==4} -r $22,{{$22*9}/21},1,{s},6
-elif {$23==5} -r $22,{$22*{h/w}},1,{s},6
-endif -endif -endif -c 0,255
# save frame to folder
-if {{$13==14}&&{$flag3d==1}}
fileleft="$15/frame_left_"$outfile$end fileright="$15/frame_right_"$outfile$end
-else  -if {$13!=15} filename="$15/frame_"$outfile$end
-else  filename="$15/depthmap_"$outfile$end -endif -endif
-if {{$13==14}&&{$flag3d==1}}
-output[0] $fileleft -output[1] $fileright
-else -output[0] $filename
-endif
outfile={$outfile+1}
# end batch processing loops and delete temporary file
infile={$infile+1} inpath="$27/$28"$infile""$end""
-if {$41==2} inpathleft="$27/$28""left_"$infile$end inpathright="$27/$28""right_"$infile$end -endif
counter={$counter+1} -done -endif
-if {{$_previewflag==0}&&{$26==1}} -if {$36!=1}
-if ${-is_windows} path="$15" path=${path}{`92`}
-x "cd \""$path"\" && del depthmap_temp.png"
-else file="$15/depthmap_temp.png" -x "rm -f \"$file\"" -endif
-endif -endif
#####preview function####
gimp_tk_video3D_preview :
shpre={$2*{400/$22}} swpre={$3*{400/$22}}
-if {$26==0}
#####preview layer mode###
-if {{$!}==1} -fc[0] 255,0,128,255 -k[0] -text "Select multiple layer",10,80%,24,1,0,0,0,255
-text "input mode ALL.",10,90%,24,1,0,0,0,255
-elif {$41==2} -fc[0] 255,0,128,255 -k[0] -text "Alignment of image streams",10,80%,24,1,0,0,0,255
-text "in BATCH processing mode only!",10,90%,24,1,0,0,0,255
-elif {$41==3} -fc[0] 255,0,128,255 -k[0] -text "Anaglyph video reconstruction",10,80%,24,1,0,0,0,255
-text "in BATCH processing mode only!",10,90%,24,1,0,0,0,255
-else
_previewflag=1
-if {$40==3} -if {$42==0} _mapin=1 -elif {$42==1} _mapin={$!} -elif {$42==2}  _mapin=$43 -endif -endif
-if {$42==0} nr=1 pv={-1} -elif {$42==1} nr={$!} pv={-$!} -elif {{$42==2}||{$42==3}} nr=$43 pv={-$43} -endif
-if {{$42==2}||{$42==3}} -if {$43>={$!}} nr={$!} pv={-$!} _mapin={$!} -endif -endif
-if {$42!=3}
-gimp_tk_video3D[$pv] $1,$shpre,$swpre,${4-9},0,${11-13},0,"$15",${16-23},0,${25-26},"$27","$28",${29-32},"$33",0,0,${36-39},0,${41-43} -k[$pv]
-text[0] "layer "{``$nr},20,75%,{h*0.1},1,255,{if({{$13==2}||{$13==3}||{$13==15}},0,255)},0,255
-if {$24!=0} -text "For preview with frames offset ",20,70%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255 -endif
-if {{$34!=0}||{$35!=0}} -text "For fade in/out effect preview",20,65%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255  -endif
-if {$40!=0} -text "For preview with custom depth correction ",20,60%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255 -endif
-if {$10!=0} -text "For preview with motion analyzer ",20,55%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255
-text "use full layer stack preview mode!",20,85%,{h*0.05},1,255,{if({$13==15},0,255)},{if({$13==15},0,255)},255 -endif
-if {{$32==2}||{$32==3}} -text[0] "Separate stream filtering ignored in layer mode",20,50%,{h*0.05},1,255,255,0,255 -endif
-else
-gimp_tk_video3D $1,$shpre,$swpre,${4-13},0,"$15",${16-26},"$27","$28",${29-32},"$33",${34-43} -k[$pv]
-endif
-text[0] "layer "{``$nr},20,75%,{h*0.1},1,255,{if({{$13==2}||{$13==3}||{$13==15}},0,255)},0,255
-if {{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}} -text[0] "2D filter mode on!",50%,75%,{h*0.075},1,255,255,0,255 -endif
-if {$36!=1} -text "Key frame settings ignored in layer processing mode. ",20,50%,{h*0.05},1,255,255,0,255 -endif
_previewflag=0
-endif
-else
####preview batch mode####
_previewflag=2
-if {$42==3}
--fc[0] 255,0,128,255 -k[-1]
-text "No preview available",20,50,28,1,0,0,0,255
-text "for batch input stack!",20,80,28,1,0,0,0,255
-text "Please select frame to adjust settings.",20,150,16,1,0,0,0,255
-elif {{$42==2}&&{{$43<={$29-1}}||{$43>={$30+1}}}} -fc[0] 255,0,128,255 -k[0]
-text[0] "Selected frame out of range! ",10,80%,24,1,0,0,0,255
-elif {{$41==2}&&{$13==14}} -fc[0] 255,0,128,255 -k[0]
-text[0] "Output format not allowed!",10,80%,24,1,0,0,0,255
-elif {{$41==3}&&{$13==15}} -fc[0] 255,0,128,255 -k[0]
-text[0] "Output format not allowed!",10,80%,24,1,0,0,0,255
-else
-rm
-if {$31==0} end=".png" -else end=".bmp" -endif
-if {$42==0}  infile={$29}
-if {$34!=0} swpre={{1/$34}*$swpre} shpre={{1/$34}*$shpre} -endif
-elif {$42==1} infile={$30}
-if {$35!=0} swpre={{1-{1/$35}}*$swpre} shpre={{1-{1/$35}}*$shpre} -endif
-elif {$42==2} infile={$43}
-if {{$34!=0}||{$35!=0}}
-if {$43<={$29+$34}} swpre={{$43/$34}*$swpre} shpre={{$43/$34}*$shpre} -endif
-if {$43>={$30-$35}} swpre={{$30-$43}*{$swpre/$35}} shpre={{$30-$43}*{$shpre/$35}} -endif
-endif
-endif
-if {$41!=2}
inpath1="$27/$28"$infile""$end""
-input[0] $inpath1
-if {$24!=0} infileoff={$infile+$24}
-if {$infileoff<=$29} infileoff={$29} -endif
-if {$infileoff>=$30} infileoff={$30} -endif
inpathoff="$27/$28"$infileoff""$end""
-input[1] $inpathoff
-endif
-if {$infile!=$29} -if {$10!=0}
infilemov={$infile-1} inpathmov="$27/$28"$infilemov""$end""
-input[-1] $inpathmov
-if {$infile>={$29+2}}
infilemov2={$infile-2} inpathmov2="$27/$28"$infilemov2""$end""
-input[-1] $inpathmov2
infilemov3={$infile-1} inpathmov3="$27/$28"$infilemov3""$end""
-input[-1] $inpathmov3
-endif -endif -endif
-else
inpathleft="$27/$28""left_"$infile$end inpathright="$27/$28""right_"$infile$end
-rm -input[0] $inpathleft
-input[1] $inpathright
-endif
-if {$42==0} _mapin=$29 -elif {$42==1} _mapin=$30 -elif {$42==2} _mapin=$43 -endif
framesn={{$30-$29}+1}
-if {{{$34!=0}||{$35!=0}}&&{{$34>={$framesn-$35}}||{$35>={$framesn-$34}}}} -fc[0] 255,0,128,255 -k[0]
-text "Fade out of frame range! ",10,80%,{h*0.1},1,0,0,0,255
-else
-if {{$41==2}&&{$13==15}} --gimp_tk_depth_obtain[0,1] $11,{$37/100},{100-{$38*20}},{$39*20}
-if {$32!=0} -gimp_custom_code[0,1,-1] "$33",0,0,0  -endif -k[-1]
-else
-gimp_tk_video3D $1,$shpre,$swpre,${4-9},{if({$infile==$29},0,$10)},${11-13},0,"$15",${16-25},0,"$27","$28",${29-31},{if({{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}},2,$32)},"$33",0,0,1,${37-43}
-endif -to_rgb -if {$13==14} -k[-1] -endif
-text[0] "frame "{``$infile},20,75%,{h*0.1},1,255,{if({{$13==2}||{$13==3}||{$13==15}},0,255)},0,255
-if {$41!=2} -if {$36!=1} -if {{$40==0}||{$40==1}} -text[0] "Preview always forced to key frame. ",20,50%,{h*0.05},1,255,255,0,255 -else
-text[0] "No keyframe computation for individual maps. ",20,64%,{h*0.05},1,255,255,0,255 -endif -endif -endif
-if {{$2==0}&&{$3==0}&&{$1==24}&&{$13==14}&&{$32!=0}} -text[0] "2D filter mode on!",50%,75%,{h*0.075},1,255,255,0,255 -endif
-endif -endif -endif
_previewflag=0
gimp_tk_autodepth :
-repeat $! -l[$>] -to_rgb size1={w} -resize2dx 400,2
#coefficient settings
whpos=128 blpos=128 rpos=255 gpos=200 blupos=200 crga=1.5 crmix1=0.5 crmix2=0.5 geocomp1=75 geocomp2=30
geostr=0.3 focstr=0.3 featsize=60 featpos=128 feattr=35 tr=30 rtr=90 gtr=90 blutr=90 contstr=0.9
featinfl=1 foctol=5 focmorph=70 focavt=85 focavt2=140 focvart=2000 latinhib=0.5
#depth from gravity
--gimp_map_tones_fast[-1] 10,0.5,0,0 -luminance[-1]
-gimp_segment_watershed[-1] 0.5,1,0  -label[-1] 5,0
--gimp_gradient_norm[0] 0,0.5,0,100,0,0 -compose_lighten[-1,-2]
-gimp_segment_watershed[-1] 0.5,1,0 -label[-1] 5,0 -n[-1] 0,255
#depth from luminance and compensate over/underexposed areas
--luminance[0]
--channels[0] 1 -ir[-1] $gtr%,100%
-gimp_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$gpos
-tk_gimp_replace_color[-1] 1,0,0,0,0,255,0,0,0,0  -blend[-1,-2] alpha
--channels[0] 0 -ir[-1] $rtr%,100%
-gimp_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$rpos
-tk_gimp_replace_color[-1] 1,0,0,0,0,255,0,0,0,0 -blend[-1,-2] alpha
--channels[0] 2 -ir[-1] $blutr%,100%  -n[-1] 0,$blupos
-gimp_morpho[-1] 2,2,0,0,0,1,0
-tk_gimp_replace_color[-1] 1,0,0,0,0,255,0,0,0,0
-to_rgba[-1] --gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,100
-s[-2] c -rv[-1,-2] -compose_multiply[-1,-2] -to_gray[-1] -a[-4,-3,-2,-1] c
-blend[-1,-2] alpha
--channels[0] 0 --luminance[0] -compose_average[-1,-2] -ir[-1] 80%,95%
-gimp_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$whpos
-tk_gimp_replace_color[-1] 1,0,0,0,0,255,0,0,0,0 -blend[-1,-2] alpha
--channels[0] 0 --luminance[0] -compose_average[-1,-2] -ir[-1] 5%,20%
-gimp_morpho[-1] 2,2,0,0,0,1,0 -n[-1] 0,$blpos
-tk_gimp_replace_color[-1] 1,0,0,0,0,255,0,0,0,0 -blend[-1,-2] alpha
#depth from lateral inhibition
--gimp_gradient_norm[0] 0,0.5,0,50,0,0
[-1]
-gimp_morpho[-1] 2,$featsize,0,0,0,1,0
-ir[-1] $feattr%,100%
-n[-1] 0,$featpos
-blur_xy[-1] 2
-gimp_compose_lighten[-1,-2] $contstr
-blur_xy[-1] 2
#depth from color
-to_rgb[0] -rgb2ycbcr[0] --channels[0] 2 -ycbcr2rgb[0]
-n[-1] 0,255 -c[-1] 25%,100%  -apply_gamma[-1] $crga
--channels[0] 2 -negative[-1] -c[-1] 0,128
-to_rgba[-1] --gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,270,0,100
-s[-2] c -rv[-1,-2] -compose_multiply[-1,-2] -to_gray[-1]
-a[-4,-3,-2,-1] c -rv[-1,-2] -gimp_compose_darken[-1,-2] $crmix1
#depth from geometry
--luminance[0] -gimp_houghsketchbw[-1] 10,5,15,$tr,1,1,0 complex={ia}
-if {$complex>=$geocomp1}
-do tr={$tr+10} -rm[-1] --luminance[0] -gimp_houghsketchbw[-1] 10,5,15,$tr,1,1,0 complex={ia}
-while {{$complex>=$geocomp2}&&{$tr<=90}} -endif
-gimp_morpho[-1] 3,5,0,0,0,1,0 -blur_xy[-1] 1 -gimp_distance[-1] 255,0,1,1,0
complex={ia}
#depth from focus
--gimp_highpass[0] 2,2,0,0,0
-tk_gimp_replace_color[-1] $foctol,0,128,128,128,255,0,0,0,255
-gimp_morpho[-1] 3,$focmorph,0,0,0,1,0   -to_gray[-1]
av={ia} var={iv}
-if {{$av<=$focavt}||{{$av>=$focavt}&&{$av<=$focavt2}&&{$var<=$focvart}}}
-ir[-1] $av,255 -n[-1] 0,255 -blur_xy[-1] 10 -else -fc[-1] 128,128,128 -endif
#lateral inhibition emphaziser
--gimp_gradient_norm[0] 0,0.5,0,50,0,0
#composing depth representations
-rm[0]
-gimp_compose_overlay[-7,-6] 0.5
-gimp_compose_overlay[-6,-5] $featinfl
-gimp_compose_value[-5,-4] $crmix2
-rv[-4,-3]
-if {$complex!=0} -gimp_compose_overlay[-4,-3] $geostr -else -rm[-3] -endif
-rv[-3,-2]
-gimp_compose_overlay[-3,-2] $focstr
-rv[-2,-1]
-gimp_compose_lighten[-1,-2] $latinhib
#final segmentation and smoothing
-blur_xy[-1] 2  -gimp_morpho[-1] 3,20,0,0,0,1,0
-gimp_segment_watershed[-1] 15,0,0 -n[-1] 0,255
-blur_y[-1] 2 -blur_x[-1] 1
-resize2dx $size1,2
-endl -done
gimp_tk_deana :
-repeat $! -l[$>] -to_rgb --s c -rm[-1]
-to_rgb[-1,-2] -rgb2lab[-1,-2] -channels[-1,-2] 0
-rgb2lab[0] -s[0] c -blur_x[1,2] $1
-c[-1,-2] {0,im},{0,iM}
-apply_gamma[-1] {($2^({0,ia}/ia)-$2)*$2+1}
-apply_gamma[-2] {($2^({0,ia}/{-2,ia})-$2)*$2+1}
[1,2] -rm[0] -mv[2] 0
-a[0,1,2] c -a[1,2,3] c -lab2rgb[0,1]
-endl -done
gimp_tk_depthmap :
-repeat $! -l[$>] -to_rgb size1={w} -resize2dx 400,2
-if {{$8!=0}||{$8!=0}} -gimp_map_tones_fast {$8*4},{$9/5},3,0 -endif
-if {$1==0} --gimp_tk_autodepth[-1]
--luminance[0] -gimp_map_tones[-1] 1,0.25,0,30,3,0
-rv[-1,-2] -gimp_compose_value[-1,-2] 0.15
-tk_gimp_channel_processing[-1] 1,{$2/20},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==1} --channels[0] 2
-tk_gimp_channel_processing[-1] 1,{{$2/25}+0.1},0,0,0,0,100,256,0,1,0,2,0,0
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/1.5}}
-rv[-1,-2] -gimp_compose_lighten[-1,-2] {0.5+{$2/200}}
-elif {$1==2} --s[-1] c -gimp_dog[-1] 0.4,0,0,0,0
-negative[-2]  -gimp_dog[-3] 0.4,0,0,0,0
-gimp_compose_alpha[-1,-2] 0.44,0
-gimp_compose_alpha[-1,-2] 0.44,0
-tk_gimp_channel_processing[-1] 1,{$2/20},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==3} --luminance[-1]
-tk_gimp_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==4} --luminance[-1] -negative[-1]
-tk_gimp_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==5}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-$2}
-elif {$1==6}
--gimp_radial_gradient[-1] 0,0,0,255,255,255,255,255,1,$2,100,50,50
-elif {$1==7}
--gimp_radial_gradient[-1] 0,0,0,255,255,255,255,255,0,0,{100-$2},50,50
-elif {$1==8}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,0,$2,100
-elif {$1==9}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,315,$2,100
-elif {$1==10}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,0,{100-$2}
-elif {$1==11}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,45,0,{100-$2}
-elif {$1==12}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/2}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==13}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,180,100,{50+{$2/2}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,{50-{$2/2}},0
-compose_darken[-1,-2]
-elif {$1==14}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,50,{100-{$2/2}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,270,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==15}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/2}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==16}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/2}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,50,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==17}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/4}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/4}}
-compose_lighten[-1,-2]
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/2}}
-compose_lighten[-1,-2]
-elif {$1==18}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/4}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/4}}
-compose_lighten[-1,-2]
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/4}}
-compose_lighten[-1,-2]
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,270,50,{100-{$2/4}}
-compose_lighten[-1,-2]
-elif {$1==19} --channels[-1] 0
-tk_gimp_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
--gimp_radial_gradient[-1] 0,0,0,255,255,255,255,255,1,$2,100,50,50
-rv[-1,-2] -compose_multiply[-1,-2]
-elif {$1==20}
--gimp_gaussian_blur[-1] $6,0,0,1,0,0,0
-gimp_edges[-1] {$4/2},{50-{$2/2}},1,0
--gimp_gradient_norm[0] {$4/2},{1.5-{$2/67}},0,{100-$2},0,0
-rv[-1,-2] -compose_lighten[-1,-2] --channels[0] 0
-tk_gimp_channel_processing[-1] 1,{{$2/25}+1},0,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -compose_lighten[-1,-2]
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,50,{100-{$2/4}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,50,{100-{$2/4}}
-compose_lighten[-1,-2]
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,{100-{$2/2}}
-compose_lighten[-1,-2] -rv[-1,-2] -compose_lighten[-1,-2]
-elif {$1==21} --gimp_gaussian_blur[-1] $4,0,0,1,0,0,0
-gimp_edges[-1] {$4/2},{50-{$2/2}},1,0
--gimp_gradient_norm[0] {$4/2},{1.5-{$2/67}},0,{100-$2},0,0
-rv[-1,-2] -compose_lighten[-1,-2] --channels[0] 0
-tk_gimp_channel_processing[-1] 1,{{$2/25}+0.5},0,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -compose_lighten[-1,-2]
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,0,0,{100-$2}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,0,{100-$2}
-compose_darken[-1,-2] -rv[-1,-2] -compose_darken[-1,-2]
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,75,{100-{$2/4}}
-rv[-1,-2] -gimp_compose_lighten[-1,-2] 0.5
-elif {$1==22} --gimp_gaussian_blur[-1] $4,0,0,1,0,0,0
-gimp_edges[-1] {$4/2},{50-{$2/2}},1,0
--gimp_gradient_norm[0] {$4/2},{1.5-{$2/67}},0,{100-$2},0,0
-rv[-1,-2] -compose_lighten[-1,-2] --channels[0] 0
-tk_gimp_channel_processing[-1] 1,{{$2/25}+0.5},0,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -compose_lighten[-1,-2]
-elif {$1==23} --channels[-1] 0
-tk_gimp_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-elif {$1==24} --fc[-1] 0,0,0
-endif
# analyze image features
-if {$7!=0}
--fc[0] 128,128,128 --channels[0] 2 -negative[-1] -c[-1] 0,90
-n[-1] 0,128 -rv[-1,-2] -compose_darken[-1,-2]
--channels[0] 0 -negative[-1] -c[-1] 165,255 -n[-1] 128,255 -rv[-1,-2]
-compose_hardlight[-1,-2] -rv[-1,-2]
-if {$1!=19} -gimp_compose_average[-1,-2] {$7/5}
-else -gimp_compose_value[-1,-2] {$7/5},0
-tk_gimp_channel_processing[-1] 1,{$2/25},0,0,0,0,100,256,0,0,0,2,0,0
-endif -endif
-if {$6!=0} --gimp_highpass[0] 2,2,0,0,0
-tk_gimp_replace_color[-1] 5,0,128,128,128,255,0,0,0,255
-gimp_morpho[-1] 3,70,0,0,0,1,0   -to_gray[-1] av={ia}
-ir[-1] $av,255 -n[-1] 0,255 -blur_xy[-1] 25
-rv[-1,-2] -gimp_compose_overlay[-1,-2] {$6/5} -endif
-if {$3!=0} --gimp_isophotes[0] {{$3*3}+2},0,0,0
-gimp_morpho[-1] 3,{5-{$3/2}},0,0,0,1,0
-tk_gimp_channel_processing[-1] 1,1,255,0,0,0,100,256,0,0,0,2,0,0
-rv[-1,-2] -gimp_compose_overlay[-1,-2] {$3/10}
--gimp_gradient_norm[0] {$4*2},{1.5-{0.1+{$3/3.6}}},0,100,0,0
-rv[-1,-2] -compose_lighten[-1,-2] -gimp_segment_watershed[-1] $3,$4,0,0
-endif
-blur_y[-1] $10 -blur_x[-1] {$10/2}
-if {$5!=0} --luminance[0] -gimp_map_tones[-1] 1,{0.25-{$5/20}},0,30,3,0
-rv[-1,-2] -gimp_compose_overlay[-1,-2] {$5/10} -endif
-n[-1] 0,255 -rm[0] -resize2dx $size1,2 -endl -done
gimp_tk_depth_obtain :
-if {$!<=1} -return -endif
-l
-to_rgb size1={w} size2={h} -resize2dx 400,2
-if {$1==1} -rv -endif
-if {$3!=100}
-gimp_frame_round 10,{100-$3},$4,0,255,255,255,255,0,0.1,3
-endif
-displacement[0] [1],$2
-rm[1]
-channels 0
-n 0,255
-r $size1,$size2 -endl
gimp_tk_lenticular :
-if {$!<=1} -return -endif
frames={$!} index=0 -if {$4==0} length=$3 -else length={$3/2.54} -endif
lenses={$length*$1} lensewidth={w/$lenses}
picstripe={$lensewidth/$frames} x=0 y=0 end={$picstripe}
step={$lensewidth-$picstripe}
#automatic upscale
-if {$6==1}
-if {$picstripe!={int($picstripe)}} scale={{int($picstripe)+1}/$picstripe}
-r {w*$scale},{h*$scale} lensewidth={w/$lenses} picstripe={$lensewidth/$frames}
end={$picstripe} step={$lensewidth-$picstripe} -endif -endif
-to_rgb --fc[-1] 255,255,255 -repeat $lenses
-if {$2==0}
-fill[-1] if(x>=$end,0,i) x={$x+$step} end={$end+$step}
-fill[-1] if(x>=$end,255,i) x={$x+$picstripe} end={$end+$picstripe}
-else
-fill[-1] if(y>=$end,0,i) y={$y+$step} end={$end+$step}
-fill[-1] if(y>=$end,255,i) y={$y+$picstripe} end={$end+$picstripe}
-endif -done
-repeat {$frames-1} --to_gray[-1] -ir[-1] 128,256 -n[-1] 0,255
-if {$2==0} -shift[-1] {{$picstripe}*{$frames-{$index+1}}}
-else -shift[-1] 0,{{$picstripe}*{$frames-{$index+1}}} -endif
-s[$index] c -a[$index,{$index+1},{$index+2},-1] c
index={$index+1} -done
-repeat {$frames-1} -rv[0,-2] -compose_rgba[0,-2] -rv[0,-2] -done
-if {$5==1} -to_rgba[0]
-if {$2==0} -shift[0] 0,5 -else -shift[0] 5,0 -endif
-negative[-1] -rv -compose_rgba -else -rm[-1] -endif
gimp_tk_stereogram :
-repeat $! -l[$>] -to_gray --fc[-1] 255,255,255
-gimp_plasma[-1] $2,$3,8,0,0,128,128,128
-gimp_array[-1] 10,10,0,0,0,0
-gimp_array_fade[-1] {$5/10},{$5/10},0,0,80,90,3,0
-r[-1] [0],[0]
-gimp_noise[-1] {w/30},0,3,0,0
--gimp_rorschach[-1] $4,1,0 -rv[-1,-2] -gimp_compose_multiply[-1,-2] 0.5
--gimp_corner_gradient[-1] $6,$7,$8,255,$9,$10,$11,255,$12,$13,$14,255,$15,$16,$17,255
-rv[-1,-2] -gimp_compose_hardlight[-1,-2] $18
-rv[-1,-2]
-r[-1] 100%,100%,1,2
-s[-1] c -f[-1] 0 -n[-2] 0,$1 -a[-1,-2] c
-warp[-2] [-1],1
-rm[-1] -endl -done
gimp_tk_stereogram_preview :
-gimp_split_preview "-gimp_tk_stereogram ${1--2}",$-1
gimp_tk_stereoimage :
-if {$!<=1} -return -endif
-local -to_rgb
-if {$4!=0} -tk_gimp_channel_processing 1,1,$4,0,0,0,100,256,0,0,1,10,7,0 -endif
-if {{$1==0}||{$1==1}||{$1==2}||{$1==3}||{$1==4}||{$1==5}} -apply_gamma $3 -endif
-if {$1==0} -if {$2==0} -rv[-1,-2] -endif -s c
-rm[-3,-4,-5] -a[-1,-2,-3] c
-elif {$1==1} -if {$2==1} -rv[-1,-2] -endif
-apply_gamma[-1] 1.15 -apply_gamma[-2] 1.0 -s c
rlr=456 rlg=500 rlb=176 rrr={-43} rrg={-88} rrb={-2}
glr={-40} glg={-38} glb={-16} grr=378 grg=734 grb={-18}
blr={-15} blg={-21} blb={-5} brr={-72} brg={-113} brb=1226
[0-5]
-*[-3] $rlr -*[-2] $rlg -*[-1] $rlb -*[-6] $rrr -*[-5] $rrg -*[-4] $rrb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $glr -*[-2] $glg -*[-1] $glb -*[-6] $grr -*[-5] $grg -*[-4] $grb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $blr -*[-2] $blg -*[-1] $blb -*[-6] $brr -*[-5] $brg -*[-4] $brb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
-k[-1--3] -a[-1,-2,-3] c
-elif {$1==2} -if {$2==0} -rv[-1,-2] -endif -s c
-rm[-6,-5,-1] -mv[0] 3  -a[-1,-2,-3] c
-elif {$1==3} -if {$2==1} -rv[-1,-2] -endif
-apply_gamma[-1] 0.9 -apply_gamma[-2] 1.25 -s c
rrr=1062 rrg={-205} rrb=299 rlr={-16} rlg={-123} rlb={-17}
grr={-26} grg=908 grb=68 glr=6 glg=62 glb={-17}
brr={-38} brg={-173} brb=22 blr=94 blg=185 blb=911
[0-5]
-*[-3] $rlr -*[-2] $rlg -*[-1] $rlb -*[-6] $rrr -*[-5] $rrg -*[-4] $rrb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $glr -*[-2] $glg -*[-1] $glb -*[-6] $grr -*[-5] $grg -*[-4] $grb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $blr -*[-2] $blg -*[-1] $blb -*[-6] $brr -*[-5] $brg -*[-4] $brb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
-k[-1--3] -a[-3,-2,-1] c
-elif {$1==4} -if {$2==0} -rv[-1,-2] -endif  -s c
-rm[-1,-3,-5] -mv[-1] -2 -a[-3,-2,-1] c
-elif {$1==5} -if {$2==1} -rv[-1,-2] -endif  -s c
-apply_gamma[-1] 1 -apply_gamma[-2] 1.15 -s c
rrr={-62} rrg={-158} rrb={-39} rlr={529} rlg={705} rlb={24}
grr={284} grg=668 grb=143 glr={-16} glg={-15} glb={-65}
brr={-15} brg={-27} brb=21 blr=9 blg=75 blb=937
[0-5]
-*[-3] $rlr -*[-2] $rlg -*[-1] $rlb -*[-6] $rrr -*[-5] $rrg -*[-4] $rrb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $glr -*[-2] $glg -*[-1] $glb -*[-6] $grr -*[-5] $grg -*[-4] $grb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
[0-5]
-*[-3] $blr -*[-2] $blg -*[-1] $blb -*[-6] $brr -*[-5] $brg -*[-4] $brb
-+[-6] [-5] -+[-6] [-4] -+[-6] [-3] -+[-6] [-2] -+[-6] [-1] -rm[-1--5]
-/[-1] 1000 -n[-1] 0,255 -to_gray[-1]
-k[-1--3] -a[-3,-2,-1] c
-elif {$1==6} -if {$2==1} -rv[-1,-2] -endif
-r[-1,-2] 50%,50%,1,3,6 -a[-1,-2] x
-elif {$1==7} -if {$2==1} -rv[-1,-2] -endif -a[-1,-2] x
-elif {$1==8} -if {$2==1} -rv[-1,-2] -endif -a[-1,-2] y
-elif {$1==9} -if {$2==1} -rv[0,1] -endif
-r[0,1] 50%,100%,1,3,6 -a[0,1] x
-elif {$1==10} -if {$2==1} -rv[0,1] -endif
-r[0,1] 100%,50%,1,3,6 -a[0,1] y
-elif {$1==11} -to_rgba[0,1]
-if {$2==1} -rv[0,1] -endif
-fill[0] if(y%2==0,0,i) -rv[0,1] -compose_rgba[0,1] -to_rgb
-elif {$1==12} -to_rgba[0,1]
-if {$2==1} -rv[0,1] -endif
-fill[0] if(x%2==0,0,i) -rv[0,1] -compose_rgba[0,1] -to_rgb
-elif {$1==13}
-if {$2==1} -rv[0,1] -endif
-r[0,1] 1920,1080,1,3,6 --fc[-1] 0,0,0 -r[-1] 1920,45
-rv[-1,-2] -a[-1,-2] y -a[-1,-2] y
-endif -c 0,255
-if {{$1==6}||{$1==7}||{$1==8}||{$1==9}||{$1==10}||{$1==11}||{$1==12}||{$1==13}}
-apply_gamma $3 -endif
-gimp_mix_lab 1,0,0,$5,0,0,$5,0,0,0,2,0
-if {{$1==0}||{$1==1}} -gimp_mix_rgb 1,$6,0,1,0,0,1,0,0,0,2,0 -endif
-if {{$1==2}||{$1==3}} -gimp_mix_rgb 1,0,0,1,0,0,1,$6,0,0,2,0 -endif
-if {$1==4} -gimp_mix_rgb 1,0,0,1,$6,0,1,0,0,0,2,0 -endif
-if {$1==5} -gimp_mix_rgb 1,0,0,1,$6,0,1,{if({$6>=0},$6,0)},0,0,2,0 -endif
-endl
gcd_stereo_img : -skip ${1=0},${2=2},${3=1.2},${4=1},${5=0.25},${6=2},${7=4},${8=1},${9=0}
-repeat $! -l[$>]
-to_rgb[0] b={abs($3%*w*$4)}
--gcd_depth[0] $5,$6,$7,$8
-gcd_stereo[0,1] $1,$2,$3%,$4
-if {!$1" && "$9} -z[-1] $b,{w-1-$b} -endif
-endl -done
gcd_depth : -skip ${1=0.25},${2=2},${3=4},${4=1}
-repeat $! -l[$>]
-if {w>h} -if {w>700} --r[-1] 700,{h*700/w} -else [0] -endif
-elif {0,h>700} --r[-1] {0,w*700/h},700 -else [0] -endif
-median[-1] 7 -gcd_segment_ch0[-1] 1
-if $4 -gcd_label[-1] $3 -else -label[-1] $3,1 -endif
-c[-1] 0,255 -b[-1] 0.45% -n[-1] 0,$2 -r[-1] [0],[0]
-norm[0] -n[0] 0,1 -+[-2,-1] -b[-1] $1% -n[-1] 0,255
-endl -done
gcd_segment_ch0 : -check "${1=1}>=0"
-repeat $! -l[$>]
min={im} -+ {1+$min} --gradient_norm -channels[0] 0
--f[-1] "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
-*[0,-1] -*[-1] -1 -watershed[-2] [-1] -rm[-1] -- {1+$min}
-endl -done
gcd_stereo : -skip ${1=0},${2=1},${3=1.2%},${4=1}
-l[-2,-1]
-if {$1==2} -keep[-1] -return
-elif {$1==3} -keep[-1] -negative -return -endif
wfac={if(${"-is_percent $3"},$3*w,$3)} -n[-1] 0,$wfac
-if {$1<2" && "$2>0} -gcd_balance_anaglyph[0] {2-$2} -endif
-i[1] [0] -warp[0] [-1],1 -mul[-1] -1 -warp[1] [-1],1 -rm[-1]
-if $1 -rv[0,1] -append[0,1] x -else -shift[0] {round(-$wfac*$4)} -shift[1] {round($wfac*$4)}
-channels[0] 0 -channels[1] 1,2 -append[0,1] c
-endif
-endl
gcd_balance_anaglyph : -skip ${1=1},${2=0.43},${3=0.45}
-l[-1] -sh 0,0 -sh[0] 1,1 -sh[0] 2,2 ---[2] [1] inv={255^(1-$1)*$2}
-if {$1>1} --sign[-1] -abs[-2] -^[-2] $1 -*[-2] $inv -*[-2,-1] -else -*[-1] $2 -endif
--[2,3] [-1] -*[-1] {1/$2-1} -+[1,-1] --*[3] 0.65 --[-1] [1] -max[-1] 0 -*[-1] $3
--[3] [-1] -*[-1] {1/$3-1} -+[1,-1] -apply_gamma[1] 1.15 -rm[1-3] -c 0,255
-endl
gcd_unstereo : -skip ${1=5},${2=0.1},${3=0},${4=1},${5=1},${6=1},${7=0},${8=0}
-repeat $! -l[$>]
-if {$4" && "$8} pr=1 -else pr=$1 -endif
-to_rgb[0] -split_tiles[0] $5,$6
-repeat $! -l[$>]
-s[0] c --equalize[0,1] 256
--displacement[-2] [-1],$2,$pr
-if $3 -sh[-1] 1,1 -f[-1] 0 -rm[-1] -endif
-/[-1] 2 -warp[1,2] [-1],1 -*[-1] -1 -warp[0] [-1],1
-keep[0-2] -a c -c[0] 0,255
-endl -done
-append_tiles $5,$6
-endl -done
gcd_unstereo_preview :
-gimp_split_preview "-gcd_unstereo ${1--1},1",$-1
gimp_corvo_painting_5 :
--polygonize $1,$2,$3,10,10
--blend[0,1] alpha,$4
-texturize_canvas[2] $5,0.5,0.6
-smooth[2] $7,0.4,0.7,$8,$9
--plasma[2] 0.7,100,8 -n 0,255
-blend[3,2] grainmerge,$6
-bilateral[0,2] 10,7
-blend[0,2] alpha,$10
-rm[-1]
gcd_anti_alias : -skip ${1=10},${2=0.3},${3=10}
-repeat $! -l[$>]
-remove_opacity[-1]
--smooth[0] $1,0,1,1.6,1.1,0.8,30,0.6
--gradient_norm[0] --n[-1] 0,$3 -add[0,-1]
-pow[-1] $2 -n[-1] 0,255
--gradient_norm[-1] -pow[-1] $2 -n[-1] 0,255
-blend[-2,-1] overlay -append[-2,-1] c
-blend[0,1] alpha -c 0,255
-endl -done
gcd_anti_alias_preview :
-gimp_split_preview "-gcd_anti_alias ${1--2}",$-1
gcd_srgb2jpeg :
-repeat $! -l[$>]
-if {s<3} -continue -endif
-if {s==4} -split_opacity -endif
-mix_rgb[0] 0.299,0.587,0.114,-0.1687,-0.3313,0.5,0.5,-0.4187,-0.0813
-sh[0] 1,2 -+[-1] 128 -rm[-1] -a c
-endl -done
gcd_jpeg2srgb :
-repeat $! -l[$>]
-if {s<3} -continue -endif
-if {s==4} -split_opacity -endif
-sh[0] 1,2 --[-1] 128 -rm[-1]
-mix_rgb[0] 1,0,1.402,1,-0.34414,-0.71414,1,1.772,0 -a c
-endl -done
gcd_srgb2luma :
-repeat $! -l[$>]
-remove_opacity
-if {s!=3} -continue -endif
-sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
-*[1] 0.299 -*[2] 0.587 -*[3] 0.114
-+[1-3] -rm[1] -channels[0] 0
-endl -done
gcd_srgb2luminance :
-repeat $! -l[$>]
-remove_opacity
-if {s!=3} -continue -endif
-srgb2rgb[0] -sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
-*[1] 0.2126 -*[2] 0.7152 -*[3] 0.0722
-+[1-3] -rm[1] -channels[0] 0
-endl -done
gcd_gamma : -skip ${1=1},${2=0},${3=255}
-if {$1==1} -return -endif
-repeat $! -l[$>]
-if {!$2} g={1/max($1,0.001)} -^ $g -* {$3^(1-$g)}
-else -* -1 -+ $3 -max 0 -^ $1 -* {-$3^(1-$1)} -+ $3 -endif
-endl -done
gcd_label : -skip ${1=4},${2=0.067}
-repeat $! -l[$>]
-label[-1] $1,1 nb={1+iM}
--histogram[-1] $nb,0,{$nb-1}
--map[-2] [-1] -rm[-2]
-le[-1] {$2%*w*h} -*[-1] 255
-inpaint[-2] [-1] -rm[-1]
-endl -done
gcd_shrink :
_gcd_w={0,w} _gcd_h={0,h}
-repeat $! -l[$>] -if {max(w,h)>700} -rr2d[-1] 700,700,0,1 -endif -endl -done
gcd_unshrink :
-repeat $! -l[$>] -r $_gcd_w,$_gcd_h -endl -done
gcd_fix_gimp_alpha :
-repeat $! -l[$>] -if {s==2||s==4}
-sh 0,{s-2} -sh[0] 100%,100% -max[-1] 1 --neq[-1] 1 -*[-3,-1] -k[0]
-endif -endl -done
gcd_blend_feather : -skip ${1=100},${2=0.5},${3=2},${4=0},${5=0}
-r[^-1] [-1],[-1],1,100%,0,0,0.5,0.5
-if $5
--gcd_blend_maxdelta ${1-4}
-to_a[0] -split_opacity[0] -rv[1,-1] -a[1,-1] c -rm[0]
-else -gcd_blend_maxdelta ${1-4} -endif
gcd_blend_maxdelta : -skip ${1=100},${2=0.5},${3=2},${4=0}
-if {$!>1} -repeat {$!-1} -l[0,1]
-to_a -split_opacity -/[1,3] 255
-nm[0] upper -nm[1] alpha -nm[2] lower -nm[3] mask
--r[lower] 1,1,1,100%,2
--+[upper] 0.1 -*[-1] [alpha]
-s[-1] c -discard[-3--1] 0 -a[-3--1] c
-r[-1] 1,1,1,100%,2 -r[-2,-1] [upper]
-*[-2,-1] $2 -sub[upper,-1] -add[upper,-1] -c[upper] 0,255
--distance[alpha] 0 -nm[-1] dist
-eq[mask] 0 -*[mask] {dist,iM} -max[dist] [mask]
-if {$4>0}
[upper] [alpha] -a[-2,-1] c
-gcd_fgmask[-1] {20-$4} -b[-1] 3 -*[alpha,-1]
-endif
--n[dist] 0,$3 -c[-1] 0,1 -*[-1] [alpha]
-gcd_srgb2jpeg[upper,lower] -sh[upper,lower] 1,2
-j[-1] [-2],0,0,0,0,1,[-3] -rm[-3--1]
-gcd_jpeg2srgb[upper,lower]
-n[dist] 0,{255*$1%}
--sub[upper] [lower] -*[-1] [alpha]
--sign[-1] -abs[-2] -min[dist,-2] -*[dist,-1]
-+[lower] [dist] -k[lower] -c 0,255
-endl -done -endif
gcd_fgmask : -skip ${1=0}
-repeat $! -l[$>]
-to_a -expand_xy 20,0 -split_opacity -gt[-1] 0
--distance[-1] 0 -max_patch[-1] 3 -*[-1] 2
--erode[1] 20 -*[-2,-1] -dilate[-1] $1
--gradient_norm[-2] -gt[-1] 0
-gradient_norm[0] --eq[-1] 0 -*[0,-1]
-max[-2,-1] -*[0,1] -*[0] -1
-watershed[-1] [-2] -rm[-2]
-shrink_xy 20 -- 1
-endl -done
gcd_comp_blur : -skip ${1=2},${2=3},${3=1},${4=100},${5=1},${6=0}
gsz={2^(5-$1)}
-repeat $! -l[$>]
-remove_opacity[-1]
--to_gray[0] -edges[-1] 14.5% -n[-1] {100-$4}%,100%
-if {0,s>1" && "$5}
--ac[0] "-median 5",ycbcr_cbcr
-image[0] [-1],0,0,0,0,1,[-2] -rm[-1]
-endif
-if {$1==0} {w},{h},1,1,255 -mul[-2,-1] -else
{w},{h},1,1,0
-grid[-1] $gsz,$gsz,0,0,1,255
-if {$2>=2} -grid[-1] $gsz,$gsz,1,1,1,255 -endif
-if {$2==3} -grid[-1] $gsz,$gsz,-1,-1,1,255 -endif
-blur[-1] $3,0 -mul[-2,-1]
-endif
-i[-2] [0] -append[-2,-1] c
-smooth[1] {100*$6+100},0.6,0.3
-blend[0,1] alpha
-if {!$6} -sharpen[-1] 20 -endif
-endl -done
gcd_comp_blur_preview :
-gimp_split_preview "-gcd_comp_blur ${1--2}",$-1
gcd_depth_blur : -skip ${1=0},${2=15},${3=0.25},${4=2},${5=4},${6=0},${7=1}
-repeat $! -l[$>]
sa={$2*max(w,h)/1000}
-to_rgb[0]
--gcd_depth[0] $3,$4,$5
-if $7 -negative[-1] -endif
-threshold[-1] $1%,1 -n[-1] 0,255
-if $6 -keep[-1] -else
{w},{h},1,1,0 [-2] -a[-3--1] c
-smooth[-2] [-1],$sa,30,0 -rm[-1]
-c[-1] 0,255
-endif
-endl -done
gcd_infomap :
-repeat $! -l[$>] -to_rgb
-if {$1>1} -gcd_srgb2jpeg -channels 1,2 -equalize 256 -gcd_detail
-elif {$1} -gcd_detail -else -gcd_spectral -endif
-endl -done
gcd_detail :
-repeat $! -l[$>] --bilateral 2%,30 -norm -- -n 0,255 -endl -done
gcd_spectral :
-repeat $! -l[$>]
-to_rgb -gcd_srgb2luma -- 128
--max 0 --min[0] 0 -abs[^-2] -negative[0] -a c -n 0,255
-endl -done
gcd_jpeg_smooth : -skip ${1=1},${2=1},${3=0}
-repeat $! -l[$>]
-if $1 -gcd_comp_blur[-1] 2,3,1,100,1 -endif
-if $3 -r[-1] 140%,140%,1,3,5 -c[-1] 0,255 -endif
-if $2 -gcd_anti_alias[-1] 10,0.3,10 -endif
-endl -done
gcd_jpeg_smooth_preview :
-gimp_split_preview "-gcd_jpeg_smooth ${1--2}",$-1
gcd_layers : -skip ${1=100},${2=0},${3=1},${4=50},${5=50},${6=0},${7=0},${8=0},${9=1},${10=1},${11=0},${12=0},${13=0}
one={$!<2} -l${-arg\ 1+$one,[0-1],.}
-if {$3" && "!$one" && "$1>100} -r2dx. {w/$1%},{if($-1,2,6)} -c 0,255 -endif
w={w} h={h} -to_a[0] -i[0] $w,$h,1,{0,s}
-l[1]
-if {$11} -mirror ${-arg\ $11,x,y,xy} -endif
-if {!$3" || "$one" || "$1<100} -r2dx {w*$1%},{if($-1,2,6)} -c 0,255 -endif
-if {$2} -rotate $2,{2-($-1)} -c 0,255 -endif
-if {$6" || "$7}
-sh 100% --gt. 1 -expand_xy. 1,0 -distance. 0 -gt. {1+$6}% -shrink_xy. 1
-*. [-2] -if {$8" && "$7} -pde_flow. $7,30,iee,0 -max. 0 -endif -min[-2,-1] -rm.
-endif
-if {!$8" && "$7} -sh 100% -b. {$7/10}%,1,{!$-1} -rm. -endif
-endl
pos={round(($w-w#1)/2+$w*$4%)},{round(($h-h#1)/2-$h*$5%)}
-if {$-1" || "$12} -j[0] [1],$pos -rm[1] pos="" -else -rm[0] pos=,pos($pos) -endif
mode=${-arg\ 1+$10,alpha,add,burn,darken,difference,\
divide,dodge,grainextract,grainmerge,hardlight,hue,lighten,\
multiply,overlay,saturation,softlight,screen,subtract,value}
-if {$-1} -if {$!>1} -rv -blend $mode,$9 -else -sh 100% -*. $9 -rm. -endif
-else -nm[0] mode($mode),opacity({$9*100})$pos -endif
-endl
gcd_layers_preview :
-gcd_layers $*,1
gcd_pqct :
-repeat $! -l[$>]
({w*.1},{h*.2};{w*.2},{h*.6};{w*.2},{h*.9};{w*.5},{h*.1};\
{w*.6},{h*.8};{w*.9},0;{w*.85},{h*.4};{w},{h*.75})
-transpose. 9,2,1,1
-repeat 2
-sh[2] $>,$>,0,0 -sh[1] $>,$>,0,0
k={"k=(i[1]+i[3]+i[4]+i[6])/4; i(#-2,0)=k;
i(#-2,1)=(i[6]-i[1])/2; i(#-2,2)=(i[3]-i[4])/2;
i(#-2,3)=(i[6]+i[1])/2-k; i(#-2,4)=(i[3]+i[4])/2-k;
i(#-2,5)=(i[2]+i[5]-i[0]-i[7])/4;
i(#-2,6)=(i[0]+i[5]-i[2]-i[7])/4+(i[4]-i[3])/2;
i(#-2,7)=(i[5]+i[7]-i[0]-i[2])/4+(i[1]-i[6])/2;
i(#-2,8)=(i[0]+i[2]+i[5]+i[7])/4-k;0"}
-rm[-2,-1]
-done
--f[0] 0 -r. 100%,100%,1,2,-1 -sh[0] 0
-f. "init(cx0=i(#2,0);cx1=i(#2,1);cx2=i(#2,2);cx3=i(#2,3);
cx4=i(#2,4);cx5=i(#2,5);cx6=i(#2,6);cx7=i(#2,7);cx8=i(#2,8);
cy0=i(#2,0,1);cy1=i(#2,1,1);cy2=i(#2,2,1);cy3=i(#2,3,1);
cy4=i(#2,4,1);cy5=i(#2,5,1);cy6=i(#2,6,1);cy7=i(#2,7,1);cy8=i(#2,8,1));
s=(2*x/w-1); t=-(2*y/h-1); s2=s*s; t2=t*t;
i(#3,x,y,0,0)=cx8*s2*t2+cx7*s*t2+cx6*s2*t+cx5*s*t+cx4*t2+cx3*s2+cx2*t+cx1*s+cx0;
i(#3,x,y,0,1)=cy8*s2*t2+cy7*s*t2+cy6*s2*t+cy5*s*t+cy4*t2+cy3*s2+cy2*t+cy1*s+cy0; i"
-rm[-4,-3,-1] -round. [0],[0],[0],[0] -sh[0] 0 px=""
-repeat {0,s} px=$px;i(#2,a,b,0,$>)=i$>#0 -done
-f. 'a=i#1;b=i1#1$px' -rm. -j[0] [-1] -k[0]
-endl -done
gcd_recol :
-repeat {int($!/2)} -l[$>,{$>+1}]
-rv[-2,-1]
-channels[-2] 0 -to_rgb[-2]
-to_rgba[-1] -split_opacity[-1] -neq[-1] 0
-srgb2rgb[-3,-2] -rgb2lab8[-3,-2] -channels[-3] 0 -channels[-2] 1,2
-+[-2] 1 -*[-2] [-1]
--meancurvature_flow[-3] 3 -median[-1] 3
-gradient_norm[-1] -*[-1] -1 -watershed[-3] [-1] -rm[-1] --[-2] 1
-rm[-1] -a[-2,-1] c -lab82rgb[-1] -rgb2srgb[-1]
-rgb2hsv[-1] -s c --equalize[2] 512 -n[-1] $1,$2 -+[0,-1] -%[0] 360 -a c -hsv2rgb[-1]
-endl -done
gcd_srotate : -skip ${1=0},${2=50},${3=50},${4=1},${5=1},${6=6},${7=0.6},${8=0}
-repeat $! -l[$>]
-rotate $1,{$4+1},1,$2%,$3%,1 -c 0,255 -split_opacity
-l[0]
{w},{h},1,1,1 -rotate[-1] $1,0,0,$2%,$3%,1
-eq[-1] 0 --area[-1] 0 -*[-1] [-2]
ps={max(round(iM^0.5/6),4)} -rm[-1]
-if $8
--inpaint[0] [-1],$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08
-rv[-2,-1] -a[-2,-1] c -blend_seamless 0,0,25%
-else
-inpaint[0] [-1],$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08 -rm[-1]
-endif
-endl -a c
-endl -done
gcd_splitobj : -skip ${1=50},${2=3},${3=3},${4=0},${5=0},${6=0},${7=40},${8=0},${9=0}
-if {$!<2} -return -endif
-repeat {int($!/2)} -l[$>,{$>+1}]
-if {w!={0,w}" || "h!={0,h}} -continue -endif
-to_rgba [-1] -s[1] c,-3 -ge[2] $1% -luminance[1]
-meancurvature_flow[1] $2 -median[1] $3 -*[1,2]
-channels[0] 0,1 -s[0] c -gt[0,1] 50% -*[{$4!=0}] 2 -+[0,1]
-gradient_norm[1] -*[1] -1 -watershed[0] [1] --[0] 1 -rm[1]
-if {$5>0} -erode[0] $5 -elif {$5<0} -dilate[0] {abs($5)} -endif
-if $6 -b[0] $6,1,1 -c[0] 0,1 -endif
[1] -sh[-1] 3,3 -*[-1] [0] -rm[-1] -oneminus[0]
-if {$8>0}
-le[0] 80% --area[0] 0 -*[-1] [0]
ps={max(round(iM^0.5/6),4)} -rm[-1] -n[0] 0,255
-inpaint[1] [0],$ps,{$ps*6},1,{9-$8*2},{$ps*1.2},0,0.08,10,1
-else -sh[1] 3,3 -*[-1] [0] -rm[-1] -endif
-rm[0] -gcd_fix_gimp_alpha -nm[1] opacity($7)
-if {$9} -blend alpha,{$7/100} -endif
-endl -done
gcd_splitobj_preview :
-gcd_splitobj ${1--2},1
gcd_stereo_vid :
1 -l[-1]
-i "$1" st_folder={f} st_file={b} st_ext={x} ({'$st_file'}) cpx={w}
-do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} -while {($isnum)&&($cpx>0)}
-if {$cpx>0} --z[-1] 0,$cpx fsname={t} -rm[-1] -else fsname="" -endif
-z[-1] {$cpx+{!$isnum}},100% dgts={w} fsnum={{t}} -rm[-1]
1 -nm[-1] "$2" en_file={b} ({'$en_file'}) cpx={w}
-do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} -while {($isnum)&&($cpx>0)}
-z[-1] {$cpx+{!$isnum}},100% fenum={{t}} -rm[-2,-1]
bufsz=$11 ttlbuf={$bufsz*2} ttlimg={$fenum-$fsnum+1}
scene=1 scframe=0 ov={iv} oa={ia}
-repeat {$ttlimg}
-if {$scene" && "$>==$scframe}
-k[-1] scene=0
-repeat {min($ttlbuf,$ttlimg-$scframe-1)}
curnum={$fsnum+$scframe+$>+1} curnum=${-gcd_add0\ $curnum,$dgts}
-i ""${st_folder}${fsname}${curnum}.${st_ext}""
vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
ov=$vr oa=$av
-if {$12&&($pvr>0.1" || "$pav>0.1)} scene=1 scframe={$scframe+$>+1} -break
-endif
-done
--l[0--{1+$scene}] -ap "-gcd_depth $7,$8,$9,$10" --add[0--1] -a[0--2] z -endl
-mv[-1] 0 -mv[-1] 1 -a[2--{1+$scene}] z
-endif
--slices[2] 0 --div[0] {1,d} -gcd_stereo[-2,-1] $4,$5,$6%
curnum={$fsnum+$>} curnum=${-gcd_add0\ $curnum,$dgts}
-if ${-is_windows} -o[-1] "$3"""{`92`}${fsname}${curnum}.${st_ext}""
-else -o[-1] "$3"""{`47`}${fsname}${curnum}.${st_ext}"" -endif
-progress {($>+1)/$ttlimg*100}
-rm[-1] -slices[2] 1,100%
-if {!$scene" && "($>>=($scframe+$bufsz))" && "($><($ttlimg-$bufsz-1))}
curnum={$fsnum+$>+$bufsz+1} curnum=${-gcd_add0\ $curnum,$dgts}
-i ""${st_folder}${fsname}${curnum}.${st_ext}""
vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
ov=$vr oa=$av
-if {$12&&($pvr>0.1" || "$pav>0.1)} scene=1 scframe={$>+$bufsz+1}
-else
--gcd_depth[-1] $7,$8,$9,$10 -add[0] [-1] -a[1,-1] z -a[2,-1] z
--slices[1] 0 -sub[0,-1] -slices[1] 1,100%
-endif
-endif
-done
-rm
-endl
gcd_stereo_vid_preview : -skip "${1=}","${2=}"
-l -i "$1" -onfail 100,100,1,3,0 -text[-1] "Select\nStart\nImage   ",0,0,32,1,255 -endl
-l -i "$2" -onfail 100,100,1,3,0 -text[-1] "Select\nEnd\nImage   ",0,0,32,1,255 -endl
-k[-2,-1] -a[0,1] x -to_rgb[0] --gcd_depth[-1] $7,$8,$9,$10 -gcd_stereo $4,$5,$6%
gcd_add0 :
({'"$1"'}) -if {w<$2} {$2-w},1,1,1,48 -rv[-2,-1] -a[-2,-1] x -endif -u {t} -rm[-1]
gcd_unquantize : -skip ${1=6},${2=1},${3=1},${4=5},${5=15}
-repeat $! -l[$>]
-gcd_srgb2jpeg -s c
-if {$1>0}
--edges[0] 14.5% -n[-1] {1-$2},1
-if {$3" && "$!>2}
-a[1,2] c --apply_parallel_overlap[1] "-median 5",3
-j[1] [-1],0,0,0,0,1,[-2] -rm[-1]
-endif
{w},{h},1,1,0 -grid[-1] 8,8,0,0,1,1 -grid[-1] 8,8,-1,-1,1,1
-b[-1] 1,0 -*[-2,-1] -n[-1] 0,1 --pde_flow[0] $1,30,iee,0
-j[0] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-endif
-if {$4>0}
--median[0] 3 -sub[-1] [0]
-abs[-1] -ge[-1] $5
-dilate[-1] 3 -n[-1] 0,1
--apply_parallel_overlap[0] "-pde_flow "$4",7,iee,0",8
-j[0] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
-endif
-a c -gcd_jpeg2srgb -c 0,255
-endl -done
gcd_warpmap : -skip ${1=5},${2=0},${3=0},${4=0},${5=0}
-repeat {int($!/2)} -l[$>,{$>+1}]
-if $5 -rv -endif
-if {$4==3} bm=0 -i[0] [-1] -else bm=$4 -endif
-if $2 --gcd_warp[-2,-1] $1,$3 -rm[-3] -rv[-2,-1] -gcd_warp[-2,-1] $2,0,$bm
-else -gcd_warp[-2,-1] $1,$3,$bm -endif
-if {$4==3} -rv -endif
-endl -done
gcd_warp : -skip ${1=5},${2=0},${3=0}
-repeat {int($!/2)} -l[$>,{$>+1}]
wfac={$1%*w} -to_rgba[-2,-1] --norm[-1]
-blur_xy[-1] $2%,$2% -n[-1] 0,255 -g[-1] xy -a[-2,-1] c
-*[-1] -1 -n[-1] -$wfac,$wfac -warp[0] [-1],1 -rm[-1]
-if {$3==0} -rm[-1] -break -endif
-if {$3==1} -blend multiply,1,1 -else -blend softlight,1,1 -endif
-endl -done
gcd_xbr2x :
-repeat $! -l[$>] -to_rgb[0]
(-1,-1;0,-1;1,-1;-1,0;0,0;1,0;-1,1;0,1;1,1;\
-1,-2;0,-2;1,-2;-2,-1;-2,0;-2,1;2,-1;2,0;2,1;-1,2;0,2;1,2)
pa_=0 pb_=1 pc_=2  pd_=3 pe_=4 pf_=5  pg_=6 ph_=7 pi_=8
a1_=9 b1_=10 c1_=11  a0_=12 d0_=13 g0_=14
c4_=15 f4_=16 i4_=17  g5_=18 h5_=19 i5_=20
e0=21 e1=22 e2=23 e3=24
($pe_,$pi_,$ph_,$pf_,$pg_,$pc_,$pd_,$pb_,$f4_,$i4_,$h5_,$i5_,$e1,$e2,$e3;\
$pe_,$pc_,$pf_,$pb_,$pi_,$pa_,$ph_,$pd_,$b1_,$c1_,$f4_,$c4_,$e0,$e3,$e1;\
$pe_,$pa_,$pb_,$pd_,$pc_,$pg_,$pf_,$ph_,$d0_,$a0_,$b1_,$a1_,$e2,$e1,$e0;\
$pe_,$pg_,$pd_,$ph_,$pa_,$pi_,$pb_,$pf_,$h5_,$g5_,$d0_,$g0_,$e3,$e0,$e2)
-*[1] -1
-repeat 21 --shift[0] {1,round(i(0,$>))},{1,round(i(1,$>))},0,0,1 -done
[0] [0] [0] [0]
-nm[0] orig -mv[0] $! -rm[0] -nm[0] kern -mv[0] $!
-repeat 4
pe={kern,i(0,$>)}  pi={kern,i(1,$>)}  ph={kern,i(2,$>)}
pf={kern,i(3,$>)}  pg={kern,i(4,$>)}  pc={kern,i(5,$>)}
pd={kern,i(6,$>)}  pb={kern,i(7,$>)}  f4={kern,i(8,$>)}
i4={kern,i(9,$>)}  h5={kern,i(10,$>)} i5={kern,i(11,$>)}
n1={kern,i(12,$>)} n2={kern,i(13,$>)} n3={kern,i(14,$>)}
--gcd_eq[$pe,$pf] --gcd_eq[$pe,$ph] -or[-2,-1] -eq[-1] 0 -nm[-1] lvl1
--gcd_yuv[$pe,$pc] --gcd_yuv[$pe,$pg] -+[-2,-1]
--gcd_yuv[$pi,$h5] -+[-2,-1] --gcd_yuv[$pi,$f4] -+[-2,-1]
--gcd_yuv[$ph,$pf] -*[-1] 4 -+[-2,-1]
-nm[-1] red
--gcd_yuv[$ph,$pd] --gcd_yuv[$ph,$i5] -+[-2,-1]
--gcd_yuv[$pf,$i4] -+[-2,-1] --gcd_yuv[$pf,$pb] -+[-2,-1]
--gcd_yuv[$pe,$pi] -*[-1] 4 -+[-2,-1]
-nm[-1] blue
--gcd_yuv[$pe,$pf] --gcd_yuv[$pe,$ph] -le[-2,-1]
--image[$ph] [$pf],0,0,0,0,1,[-1] -nm[-1] px -rm[-2]
--lt[red,blue]
--gcd_neq[$pf,$i4] --gcd_neq[$ph,$i5] -and[-2,-1] --gcd_eq[$pe,$pi] -and[-2,-1]
--gcd_neq[$pf,$pb] --gcd_neq[$ph,$pd] -and[-2,-1] -or[-2,-1]
--gcd_eq[$pe,$pg] -or[-2,-1] --gcd_eq[$pe,$pc] -or[-2,-1]
-and[-2,-1] -nm[-1] lvl2
--gcd_yuv[$pf,$pg] -nm[-1] lver
--gcd_yuv[$ph,$pc] -nm[-1] uver
--*[lver] 2 -le[-1] [uver]
--gcd_neq[$pg,$pe] --gcd_neq[$pg,$pd] -and[-2,-1]
-and[-2,-1] -and[-1] [lvl2] -image[$n3] [px],0,0,0,0,1,[-1]
--*[uver] 2 -lt[-1] [lver]
--gcd_neq[$pc,$pe] --gcd_neq[$pc,$pb] -and[-2,-1]
-and[-2,-1] -and[-1] [lvl2] -image[$n3] [px],0,0,0,0,1,[-1]
-rm[-2,-1,lver,uver]
-rm[red,blue,lvl1,lvl2,px]
-done
{orig,w},{orig,h},1,1,1 -r2dx[-1] {orig,w*2},4 -nm[-1] msk
-r2dx[orig,$e0,$e1,$e2,$e3] {orig,w*2},1
-image[orig] [$e0],0,0,0,0,1,[msk] -shift[msk] 1
-image[orig] [$e1],0,0,0,0,1,[msk] -shift[msk] -1,1
-image[orig] [$e2],0,0,0,0,1,[msk] -shift[msk] 1
-image[orig] [$e3],0,0,0,0,1,[msk]
-k[orig]
-endl -done
gcd_eq : -l[-2,-1] --[-2,-1] -norm[-1] -eq[-1] 0 -endl
gcd_neq : -l[-2,-1] --[-2,-1] -norm[-1] -neq[-1] 0 -endl
gcd_yuv : -l[-2,-1] --[-2,-1] -abs[-1] -rgb2yuv[-1] -abs[-1] -s[-1] c -*[-3] 48 -*[-2] 7 -*[-1] 6 -+[-3--1] -endl
gimp_gb_cfx :
-if {$5==1}
-noise[0] {$1/1},4
--gimp_bwrecolorize 1,1,0,0,0,1,0,5,0,0,0,255,47,106,121,255,209,136,49,255,228,207,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0
-gimp_compose_edges 0.9,0.5
-else
-if {$4==1}
-gimp_bwrecolorize 1,1,0,0,0,1,0,6,0,0,0,255,27,25,55,255,137,152,189,255,191,217,228,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0
--noise[0] {$1/1},4
-compose_interpolation
-else
-if {$3==1}
-sepia
--fc[0] 0,65,00 -to_rgba[0]
-compose_interpolation
-noise[0] {$1/1},4
-compose_grainmerge
-else
-if {$2==0}
-sepia
--noise[0] $1,4
-compose_grainmerge
-else
-sepia
--fc[0] 0,0,255 -to_rgba[0]
-compose_interpolation
-noise[0] {$1/2},4
-compose_grainmerge -endif
-endif
-endif
-endif
gimp_gb_cfx_preview :
-gimp_split_preview "-gimp_gb_cfx ${1--2}",$-1
gimp_gb_about :
-gimp_logo "GB"'"s Filters"
gimp_gb_lb :
-spread 3
-heat_flow $1
-dilate_circ $2
-compose_lighten
gimp_gb_lb_preview :
-gimp_split_preview "-gimp_gb_lb ${1--2}",$-1
gimp_gb_mp :
-equalize 255
-if {$2==1}
--gimp_corner_gradient 255,246,219,255,255,144,100,255,54,164,54,255,0,0,255,255
-else
--gimp_corner_gradient 255,250,237,255,255,200,178,255,2,104,2,255,0,0,143,255
-endif
-rv
-gimp_transfer_colors [-2,-1]1
-compose_value
-equalize 255
-gimp_glow {$1},0,0
gimp_gb_mp_preview :
-gimp_split_preview "-gimp_gb_mp ${1--2}",$-1
gimp_gb_mcfx :
-if {$1==0}
--gimp_corner_gradient 255,255,255,255,0,93,131,255,248,121,2,255,0,0,0,255
-elif {$1==1}
--gimp_corner_gradient 219,247,251,255,255,145,115,255,238,222,151,255,0,0,0,255
-elif {$1==2}
--gimp_corner_gradient 238,251,228,255,0,117,7,255,28,73,63,255,0,0,0,255
-elif {$1==3}
--gimp_corner_gradient 228,251,250,255,0,78,117,255,28,28,73,255,0,0,0,255
-endif
-move[-1] 0
-if $2
--gimp_transfer_colors 0 -rm[0]
-compose_hardlight
-else
-gimp_transfer_colors 0
-endif
gimp_gb_mcfx_preview :
-gimp_split_preview "-gimp_gb_mcfx ${1--2}",$-1
gimp_gb_pp :
-rv
gimp_gb_ub :
-gimp_normalize_local 2,8,5,20,1,3,0
--gimp_gb_mp 3,0,0
-rv
-gimp_mix_hsv 1,0,0,1,{$1},.5,1,0,0,0,2,0
-compose_overlay
gimp_gb_ub_preview :
-gimp_split_preview "-gimp_gb_ub ${1--2}",$-1
gtutor_blur_img :
-local[-2,-1]
-if {s>3}
-remove_opacity[-1]
-endif
range={700*$1+700}
-rgb2hsl[-1]
-split[-1] c
-mul[-1] $2
-reverse[-2,-1]
-negative[-1]
-mul[-1] [-2]
-reverse[-3,-1]
-div[-1] 360
-mul[-1] {2*pi}
--sin[-1]
-cos[-2]
-append[-4,-3] c
-append[-2,-1] c
-eigen2tensor[-2,-1]
-repeat 3
-smooth[-2] [-1],$range
-done
-rm[-1]
-endlocal
gtutor_blur_img_preview :
-gtutor_blur_img ${^0}
#@gmic colorwheel : _size>0,_cclock={ 0 | 1 },_angle
#@gmic : Generates a square colorwheel in clockface orientation, with zero
#@gmic : degrees on top, corresponding to red, and colors transitioning
#@gmic : clockwise through green (120 degrees) and blue (240 degrees). size:
#@gmic : colorwheel edges, in pixels.  cclock, boolean, if true generates a
#@gmic : counterclockwise colorwheel, and angle, degrees, rotates the wheel
#@gmic : clockwise (negative: counterclockwise) from its reference orientation.
#@gmic : Default values: _size=512, _cclock=0, _angle=0
colorwheel : -check ${1=512}>=1 -skip ${2=0},${3=0}
-e[^-1] "Input colorwheel $1 pixels square; cclockwise=$2; oriented $3 degrees"
-v -
$1,$1,1,1,'x=x-w/2;y=y-h/2;((1-2*!!$2)*(atan2(y,x)*180/pi+90-$3))%360'
100%,100%,1,2,1 -a[-2,-1] c -hsv2rgb[-1] -nm[-1] [colorwheel]
-v +
gtutor_hedcut_preview :
-gimp_split_preview "-hedcut ${^0}",$-1
#@gmic hedcut : _contrast=0.5, _lumlevel=0.5, _patsmooth=0.5, _patsize=0.0, _patstep=0.5, _patquality=0 (low=0,high=1), _forcegray=1 (no=0,yes=1)
#@gmic : Make a hedcut with a faux intaglio etch pattern. Unless noted, all
#@gmic : arguments are floats that range from 0.0 to 1.0. contrast: larger
#@gmic : values increase contrast. lumlevel: larger values increases
#@gmic : brightness. patsmooth: larger values forces pattern to follow
#@gmic : geometry; lower induces turbulence. patsize: larger values increases
#@gmic : pattern size. patstep: values alter pattern geometry. Adjust to
#@gmic : taste. patquality: Boolean flag. 1=True/On/Yes. Renders oversize for
#@gmic : quality.  Longer rendering time and more memory will be required (2
#@gmic : GiB minimum for 3000x3000).  forcegray: Boolean
#@gmic : flag. 1=True/On/Yes. RGB input will be forced to single channel
#@gmic : grayscale before processing and returned to RGB after. Output: image
#@gmic : in 0-255 range. Channels match input.
hedcut : -check "${1=0.5}<=1 && $1>=0 && ${2=0.5}<=1 && $2>=0 && ${3=0.5}<=1 && $3>=0 && ${4=0.0}<=1 && $4>=0 && ${5=0.5}<=1 && $5>=0 && isbool(${6=0}) && isbool(${7=1})"
-echo[^-1] "Applying faux intaglio etch to selected images. Contrast: "{$1}". Lumenance Level: "$2". Pattern smoothing: "$3". Pattern size: "$4". Pattern stepping: "$5". Quality (low=0,1=high): "$6". Force gray (0=no,1=yes):"$7"."
-verbose -
con={(9.0^$1)}
llv={round(20000*(0.5-$2))/100}
smt={(round((100*(10^$3)/2))/100)+4*$4}
psz={0.0001*(1+99*(1-$4))}
del={$psz+round(1000*(10^(-$4-2)))/1000}
stp={round(2+10*$5)}
qfc={$6}
gry={$7}
tol=30
spn=0
-repeat $!
-local[$>]
-remove_opacity[-1]
-if {$gry}
-luminance[-1]
-endif
-split[-1] c
-repeat $!
-local[$>]
-if $qfc
--resize2dx[-1] 400%,5
-else
[-1]
-endif
spn={(iM-im)/2}
-mv[-1] 0
-_multigrad[-1] $stp,$tol,$smt
-bandpass[-1] {$psz},{$del}
-orientation[-1]
-if $qfc
-resize[-1] [-2],[-2],[-1],[-1],5,1
-blur[-1] {$con},1,1
-else
-blur[-1] {$con/4},1,1
-endif
-normalize[-2,-1] {-$spn},{$spn}
-add[-1] [-2]
-normalize[-1] -{(iM-im)/2},{(iM-im)/2}
-rm[-2]
-threshold[-1] {$llv}
-if $qfc
-resize2dx[-1] 25%,5
-endif
-normalize[-1] 0,255
-endlocal
-done
-append c
-if {$gry}
-to_rgb
-endif
-endlocal
-done
-verbose +
#@gmic _multigrad : _stepsize=5 _tolerance=10 _smooth=5
_multigrad : -skip ${1=50},${2=10},${3=5}
smt={$3}
stp={$1}
tol={$2}
-repeat $!
-local[$>]
-blur {$smt}
-normalize_local 3,32,4%,2%,1,0,255
-gradient_norm[-1]
ld={log(iM)}
-add[-1] 1e-10
-log[-1]
-div[-1] {$ld}
-cut[-1] 0,1
--ge[-1] $tol%
-if {round($smt)}
-erode_circ[-1] {round(1.5*$smt)}
-dilate_circ[-1] {round(1.5*$smt)}
-endif
-negative[-2]
-normalize[-2] 0,1
--distance[-1] 1,[-2],0
-rm[-3]
-round[-1] 2
-mod[-1] {1+$stp}
-threshold 90%
-add[-2,-1]
-mul[-1] -1
-add[-1] 1
-endlocal
-done
#@gmic tiletex : _texscale=8 autoangle=-1 _keepimag=0
#@gmic : Renders a tilable texture on selected images, taking polar formatted
#@gmic : (magnitude, phase angle) seed values from pairs of selected,
#@gmic : alternating "Magnitude" and "Angle" images or, if these are constant
#@gmic : black, then from internally generated random values. Unless
#@gmic : 'autoangle' is positive, input images must form "Magnitude" and
#@gmic : "Angle" pairs and each pair must have an equal number of
#@gmic : channels. Produces "real" and "imaginary" output images (But note
#@gmic : _keepimag, below). 'texscale' sets the size of a square window around
#@gmic : the spectral origin where random seeds are set. Larger 'texscales'
#@gmic : settings admit higher frequency coefficients, giving rise to finer
#@gmic : output details. 'texscale' ranges from 1 upward and defaults to 8. It
#@gmic : is ignored if the user has preset coefficients within the input
#@gmic : images. Setting 'autoangle' to a positive value in the range [0, 255]
#@gmic : eliminates the need for providing "Angle" input images. The provided
#@gmic : argument is applied as a default phase angle to all "Magnitude" data
#@gmic : and input images are taken to be "Magnitude" data only. 'keepimag' is
#@gmic : a trivalued flag: 0, 1 or 2. '0' requests both "Real" and "Imaginary"
#@gmic : output pairs and is the default. '1' requests the "Real" output image
#@gmic : only; '2' requests the "Imaginary" output image only.
#@gmic : Output images are unnormalized and range from negative to positive
#@gmic : values, Normalize data accordingly for use with bitmap editors.
tiletex : -check "${1=8}>0 && isval(${2=-1.0}) && ${3=0}>=0 && ${3}<3"
-verbose -
-if {$2>=0}
addenda2="Common default angle: $2."
-else
addenda2="Explicit angles from provided images."
-endif
addenda3="Real and imaginary"
-if {$3!=0}
-if {$3==1}
addenda3="Real"
-else
addenda3="Imaginary"
-endif
-endif
-verbose +
-echo[^-1] "Rendering tilable texture on $? at window size $1 "$addenda2". "$addenda3" output to be provided."
-verbose -
rsz={$1}
impla={2*pi*$2/255.0}
all={$3}
iszed=1
ccc={0,s}
badccc="Selected images have different number of channels. Have you accidently included alpha channels in some (but not all) images?"
-repeat $!
-if {$>,round(ia)!=0" || "round(iM-im)!=0}
iszed=0
-break
-endif
-done
-if $iszed
-repeat $!
-local[$<]
-if {$<,$ccc!=s}
-error $badccc
-endif
-input [-1]
-append[-2,-1] c
-input {2*$rsz+1},{2*$rsz+1},1,{s},(2*u-1)*{wh}
-image[-2] [-1],{({-2,w}-w)/2},{({-2,h}-h)/2},0,0,1
-remove[-1]
-endlocal
-done
-else
-if {$impla<0}
-if {$!%2!=0}
-error "Selected images contain data, but selection count is odd. Cannot determine angles for some coefficients. Consider setting an implied angle or providing an even number of images."
-endif
-repeat {$!/2}
-local[{2*$<},{2*$<+1}]
-if {$ccc!={$<,s}" || "$ccc!={{$<+1},s}}
-error $badccc
-endif
-split[-2,-1] c
-repeat {$!/2}
-local[{$>},{$!/2+$>}]
-div[0,1] 255
-mul[1] {2*pi}
-polar2complex[0,1]
-endlocal
-done
-append[0--1] c
-endlocal
-done
-else
-repeat $!
-local[$<]
-if {$ccc!={$<,s}}
-error $badccc
-endif
-input [0]
-split[-2,-1] c
-repeat {$!/2}
-local[{$>},{$!/2+$>}]
-div[0,1] 255
-mul[0] {cos($impla)}
-mul[1] {sin($impla)}
-endlocal
-done
-append[0--1] c
-endlocal
-done
-endif
-endif
-repeat $!
-local[$<]
-shift[-1] {-round(w/2)},{-round(h/2)},0,0,2
-split[-1] c,2
-ifft[-2,-1]
-if {$all!=0}
-if {$all==1}
-remove[-1]
-else
-remove[-2]
-endif
-endif
-endlocal
-done
-verbose +
automixer:
-to_rgb
--split[-1] c
-if {$2==1}
-crop[-1,-2,-3] 40%,40%,60%,60%
-endif
bluenoise=${-variance_noise}
-remove[-1]
greennoise=${-variance_noise}
-remove[-1]
rednoise=${-variance_noise}
-remove[-1]
greennoise={$greennoise*0.5}
redadjust={$greennoise/$rednoise}
blueadjust={$greennoise/$bluenoise}
-to_rgb
--split[0] c
-mul[1] {$redadjust/($redadjust+1+$blueadjust)}
-mul[2] {1/($redadjust+1+$blueadjust)}
-mul[3] {$blueadjust/($redadjust+1+$blueadjust)}
-add[1-3]
-if {$1==0}
-keep[-1]
-else
--compose_grainextract
-remove[0]
-endif
iain_brown_spot_clean:
red_radius={($1*2)+1}
green_radius={($1*2)+1}
blue_radius={($2*2)+1}
-to_rgb
--l
-split c
-l[0]
-median $red_radius
-median $red_radius
-median $red_radius
-endl
-l[1]
-median $green_radius
-median $green_radius
-median $green_radius
-endl
-l[2]
-median $blue_radius
-median $blue_radius
-median $blue_radius
-endl
-append c
-endl
-sub[0] [1]
-add[0] 128
--l[0]
-rgb2hsv8
-split c
-keep[0]
-apply_curve 0,0,0,11,0,13,255,65,255,67,0,255,0
-lt 1
-endl
-sub[0] 128
-mul[0,2]
-add
-c 0,255
nozip:
-remove_opacity
--l[0]
(1;-1)
-convolve[0] [1]
-rm[1]
-abs
-split c
-max
-endl
--l[1]
(1,-1)
-convolve[0] [1]
-rm[1]
-abs
-split c
-max
-endl
--l[0]
--l
-split c
-add
-div 3
-endl
-sub
-abs
-split c
-max
-endl
--l[1]
--l
-split c
-add
-div 3
-endl
-sub
-abs
-split c
-max
-endl
-mul[-1,-2] $1
-add[2,4]
-add[3,4]
-l[-1,-2]
-blur 2
-sub
-gt 0
-mul 255
-endl
-append[1,2] c
-blend alpha,1,0
iain_CA_correction:
-to_rgb
longest_side={max(w,h)}
-split c
-l[0]
$longest_side,$longest_side
50%,1
-fill[-1] 1-(x/w)
--mirror[-1] x
-mul[-2] -1
-append[-1,-2] x
-resize[-1] {1,w},{1,h},1,1,1
[-1]
-rotate[-1] 90
-append[-1,-2] c
-rm[1]
-resize[1] {0,w},{0,h},{d},{s},0,0,0.5,0.5
-mul[-1] $2
-warp[0] [1],1,$3,1
-keep[0]
-endl
-l[2]
$longest_side,$longest_side
50%,1
-fill[-1] 1-(x/w)
--mirror[-1] x
-mul[-2] -1
-append[-1,-2] x
-resize[-1] {1,w},{1,h},1,1,1
[-1]
-rotate[-1] 90
-append[-1,-2] c
-rm[1]
-resize[1] {0,w},{0,h},{d},{s},0,0,0.5,0.5
-mul[-1] $1
-warp[0] [1],1,$3,1
-keep[0]
-endl
-append c
-c 0,255
iain_CA_correction_pr:
-to_rgb
x_mul={w/max(w,h)}
y_mul={h/max(w,h)}
-if {$-1==0}
rx_shift={$2*-1*$x_mul}
ry_shift={$2*-1*$y_mul}
bx_shift={$1*-1*$x_mul}
by_shift={$1*-1*$y_mul}
-elif {$-1==1}
rx_shift={$2*$x_mul}
ry_shift={$2*-1*$y_mul}
bx_shift={$1*$x_mul}
by_shift={$1*-1*$y_mul}
-elif {$-1==2}
rx_shift={$2*$x_mul}
ry_shift={$2*$y_mul}
bx_shift={$1*$x_mul}
by_shift={$1*$y_mul}
-elif  {$-1==3}
rx_shift={$2*-1*$x_mul}
ry_shift={$2*$y_mul}
bx_shift={$1*-1*$x_mul}
by_shift={$1*$y_mul}
-endif
-split c
-l[0]
[0]
[0]
-fill[1] $rx_shift
-fill[2] $ry_shift
-append[1,2] c
-warp[0] [1],1,$3,1
-keep[0]
-endl
-l[2]
[0]
[0]
-fill[1] $bx_shift
-fill[2] $by_shift
-append[1,2] c
-warp[0] [1],1,$3,1
-keep[0]
-endl
-append c
-if {$-2}
-rgb2hsv
-split c
-fill[-1] .5
-append c
-hsv2rgb
-sub 128
-mul 2
-add 128
-c 0,255
-endif
iain_easy_skin_retouch:
-repeat $! -l[$>] -split_opacity -l[0]
str1=$1
str2={$str1*$3}
str3={$str2*$3}
str4={$str3*$3}
str5={$str4*$3}
str6={$str5*$3}
str7={$str6*$3}
str8={$str7*$3}
--l[0]
-repeat $2
cropwidth={w}
cropheight={h}
-resize[0] {w+(256-w%256)},{h+(256-h%256)},1,{s},0,1
width={w}
height={h}
-if {$str1!=0}
-denoise[0] 10,$str1,3,5,0,1
-endif
--resize[0] {$width/2},{$height/2},1,{s},2,1
--resize[-1] $width,$height,1,{s},3,1
-blur[-1] .5
-compose_grainextract[0,-1]
-if {$str2!=0}
-denoise[-1] 10,$str2,3,5,0,1
-endif
--resize[-1] {$width/4},{$height/4},1,{s},2,1
--resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainextract[1,-1]
-if {$str3!=0}
-denoise[-1] 10,$str3,3,5,0,1
-endif
--resize[-1] {$width/8},{$height/8},1,{s},2,1
--resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainextract[2,-1]
-if {$str4!=0}
-denoise[-1] 10,$str4,3,5,0,1
-endif
--resize[-1] {$width/16},{$height/16},1,{s},2,1
--resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainextract[3,-1]
-if {$str5!=0}
-denoise[-1] 10,$str5,3,5,0,1
-endif
--resize[-1] {$width/32},{$height/32},1,{s},2,1
--resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainextract[4,-1]
-if {$str6!=0}
-denoise[-1] 10,$str6,3,5,0,1
-endif
--resize[-1] {$width/64},{$height/64},1,{s},2,1
--resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainextract[5,-1]
-if {$str7!=0}
-denoise[-1] 10,$str7,3,5,0,1
-endif
--resize[-1] {$width/128},{$height/128},1,{s},2,1
--resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainextract[6,-1]
-if {$str8!=0}
-denoise[-1] 10,$str8,3,5,0,1
-endif
--resize[-1] {$width/256},{$height/256},1,{s},2,1
--resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainextract[7,-1]
-resize[-1] {$width/128},{$height/128},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/64},{$height/64},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/32},{$height/32},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/16},{$height/16},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/8},{$height/8},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/4},{$height/4},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/2},{$height/2},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-resize[-1] {$width/1},{$height/1},1,{s},3,1
-blur[-1] .5
-compose_grainmerge[-1,-2]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-done
-endl
-if {$4==1}
--compose_grainextract[0,-1]
--rgb2hsv8[-1]
-split[-1] c
-remove[-1,-2]
-add[-1] 30
-mod[-1] 255
-ge[-1]  40
-n[-1] 0,255
-negative[-1]
-blur[-1] 4
--split[-2] c
-remove[-1,-2]
-move[-1] -2
-append[-2,-1] c
--blend[-1,-2] alpha
-remove[-2]
-mul[-1] {$10}
-mul[-2] {1-$10}
-add[-1] [-2]
-remove[-2]
-l[-1]
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$5
-ellipse[-1] 50%,50%,25%,25%,0,1,$6
-ellipse[-1] 50%,50%,12%,12%,0,1,$7
-ellipse[-1] 50%,50%,6%,6%,0,1,$8
-ellipse[-1] 50%,50%,3%,3%,0,1,$9
-ellipse[-1] 50%,50%,0.1%,0.1%,0,1,1
-set[-1] 1,50%,50%
-mul[1] [-1]
-ifftpolar[1,2]
-keep[1]
-c 0,255
-endl
-remove[0]
-if {$11==0}
-compose_grainmerge[-1,-2]
-endif
-else
-keep[-1]
-endif
-endl -a c -endl -done
iain_easy_skin_retouch_preview:
-iain_easy_skin_retouch ${1--1}
exfuse:
cropwidth={w}
cropheight={h}
--mul[0] {2*$1}
--mul[0] {4*$1}
-c 0,255
--gimp_ExposureWeightMap[0] $2,$3,$4,$5,0
--gimp_ExposureWeightMap[1] $2,$3,$4,$5,0
--gimp_ExposureWeightMap[2] $2,$3,$4,$5,0
-parallel "
-freq_pyramid[0]","
-freq_pyramid[1]","
-freq_pyramid[2]","
-dumb_pyramid[3]","
-dumb_pyramid[4]","
-dumb_pyramid[5]"
-parallel "-blur[-1] $6","-blur[-2] $6","-blur[-3] $6"
-replace[-1,-2,-3] 0,0.000000001
--add[-1,-2,-3]
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-rm[-1]
-parallel "
-mul[0] [3]","
-mul[1] [4]","
-mul[2] [5]"
-add[0,1,2]
-keep[0]
-ifreq_pyramid[0]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-c 0,255
dumb_pyramid:
cropwidth={w}
cropheight={h}
-resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
newwidth={w}
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] 50%,50%,{d},{s},2
-append x
-resize {$newwidth*2},100%,1,3,0,0
ifreq_pyramid:
-split x,2
-split[1] x,2
-split[2] x,2
-split[3] x,2
-split[4] x,2
-crop[1] 0,0,100%,{0,h/2-1}
-crop[2] 0,0,100%,{0,h/4-1}
-crop[3] 0,0,100%,{0,h/8-1}
-crop[4] 0,0,100%,{0,h/16-1}
-crop[5] 0,0,{4,w/2-1},{0,h/32-1}
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
freq_pyramid:
cropwidth={w}
cropheight={h}
-resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
newwidth={w}
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
--resize[-1] 50%,50%,{d},{s},2
--resize[-1] {-2,w},{-2,h},{d},{s},3
-sub[-3,-1]
-append x
-resize {$newwidth*2},100%,1,3,0,0
exfusion:
cropwidth={w}
cropheight={h}
-resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
-repeat 10
-l[-1--4]
--l[0,1,2,3]
--resize[0] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[0,-1]
--resize[1] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[1,-1]
--resize[2] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[2,-1]
--resize[3] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,3
-sub[3,-1]
-endl
--iain_weightmap[0] 1,$1
--iain_weightmap[1] 1,$1
--iain_weightmap[2] 1,$1
--iain_weightmap[3] 1,$1
--add[-1,-2,-3,-4]
-replace[-1,-2,-3,-4,-5] 0,0.0000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-div[-5] [-1]
-rm[-1]
-mul[4,12]
-mul[5,12]
-mul[6,12]
-mul[7,12]
-add[4,5,6,7]
-rm[0,1,2,3]
-endl
-done
-l[-1,-2,-3,-4]
-parallel "
--iain_weightmap[0] 4,$1","
--iain_weightmap[1] 4,$1","
--iain_weightmap[2] 4,$1","
--iain_weightmap[3] 4,$1"
--add[-1,-2,-3,-4]
-replace[-1,-2,-3,-4,-5] 0,0.00000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-div[-5] [-1]
-rm[-1]
-mul[0,4]
-mul[1,4]
-mul[2,4]
-mul[3,4]
-add
-endl
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},1,3,3
-add[-1,-2]
-done
-crop 0,0,{$cropwidth-1},{$cropheight-1}
--l[0]
-resize 5%,5%,1,3,2
-endl
min={1,im}
max={1,iM}
-c[0] $min,$max
-keep[0]
-n 0,255
exfusion3:
cropwidth={w}
cropheight={h}
maxlevels={round(log2(min(w,h))+0.5)+$5}
size={2^$maxlevels}
-resize {w+($size-w%$size)},{h+($size-h%$size)},1,3,0,1
-repeat $maxlevels
-l[-1--3]
--l[0,1,2]
--resize[0] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,5
-sub[0,-1]
--resize[1] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,5
-sub[1,-1]
--resize[2] 50%,50%,1,3,2
--resize[-1] 200%,200%,1,3,5
-sub[2,-1]
-endl
[0]
-gimp_ExposureWeightMap[-1] $1,$2,$3,$4,0
[1]
-gimp_ExposureWeightMap[-1] $1,$2,$3,$4,0
[2]
-gimp_ExposureWeightMap[-1] $1,$2,$3,$4,0
-rm[0,1,2]
--add[-1,-2,-3]
-replace[-1,-2,-3,-4] 0,0.0000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-rm[-1]
-mul[0,6]
-mul[1,6]
-mul[2,6]
-add[0,1,2]
-endl
-done
-l[-1,-2,-3]
-if $6
-iain_fast_median_stack
-else
[0]
[1]
[2]
-parallel "
-gimp_ExposureWeightMap[-1] $1,$2,$3,$4,0","
-gimp_ExposureWeightMap[-2] $1,$2,$3,$4,0","
-gimp_ExposureWeightMap[-3] $1,$2,$3,$4,0"
--add[-1,-2,-3]
-replace[-1,-2,-3,-4] 0,0.0000000000001
-div[-2] [-1]
-div[-3] [-1]
-div[-4] [-1]
-rm[-1]
-mul[0,3]
-mul[1,3]
-mul[2,3]
-add
-endif
-endl
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},1,3,5
-add[-1,-2]
-done
-crop 0,0,{$cropwidth-1},{$cropheight-1}
--l[0]
-resize 5%,5%,1,3,2
-endl
min={1,im}
max={1,iM}
-c[0] $min,$max
-keep[0]
-n 0,255
exfusion5:
images=$!
cropwidth={w}
cropheight={h}
maxlevels={round(log2(min(w,h))+0.5)+0}
size={2^$maxlevels}
-remove_opacity
-resize {w+($size-w%$size)},{h+($size-h%$size)},1,3,0,1,0.5,0.5
--l[0-{$images-1}]
-repeat $! -local[$>]
-gimp_ExposureWeightMap[0] $1,$2,$3,$4,0
-endlocal -done
-endl
-l[-1--$images]
--add
-replace 0,0.0000000000001
-repeat {$!-1}
-div[$<] [-1]
-done
-rm[-1]
-endl
-repeat $maxlevels
-l[-1--{$images*2}]
--l[0-{$images-1}]
-repeat $! -local[$>]
--resize[0] 50%,50%,1,3,2
-resize[-1] 200%,200%,1,3,5,0
-sub[0,-1]
-endlocal -done
-endl
-l[-1--{$images*2}]
-repeat $images -local[$>,{$>+$images}]
-mul[-1] [-2]
-endlocal -done
-endl
-l[-1--$images]
-add
-endl
-move[-1] 0
-l[-1--{$images*2}]
-repeat $! -local[$>]
-resize[0] 50%,50%,1,3,2
-endlocal -done
-endl
-endl
-done
-l[-1--{$images*2}]
-if 1
-repeat $images -local[$>,{$>+$images}]
-mul[-1] [-2]
-endlocal -done
-keep[-1--$images]
-add
-else
-keep[0--{$images-1}]
-add
-div $images
-endif
-endl
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},1,3,5,0
-add[-1,-2]
-done
-resize $cropwidth,$cropheight,1,3,0,1,0.5,0.5
-n 0,255
-mul 1000
-apply_curve 1,0,0,128000,{($6*1000)+128000},255000,255000
-mul 0.001
--iain_fast_denoise $5,$5,1,{$5/100},0
-sub[1] [0]
-mul[1] -1
--add
-c 0,255
-rm[1]
-reverse
-rgb2lch
-split c
-keep[0,4,5]
-append c
-lch2rgb
iain_fast_formula:
256,1
-fill[-1] x
-local[1]
$1
-endlocal
crv0={1,[0]}
crv1={1,[1]}
crv2={1,[2]}
crv3={1,[3]}
crv4={1,[4]}
crv5={1,[5]}
crv6={1,[6]}
crv7={1,[7]}
crv8={1,[8]}
crv9={1,[9]}
crv10={1,[10]}
crv11={1,[11]}
crv12={1,[12]}
crv13={1,[13]}
crv14={1,[14]}
crv15={1,[15]}
crv16={1,[16]}
crv17={1,[17]}
crv18={1,[18]}
crv19={1,[19]}
crv20={1,[20]}
crv21={1,[21]}
crv22={1,[22]}
crv23={1,[23]}
crv24={1,[24]}
crv25={1,[25]}
crv26={1,[26]}
crv27={1,[27]}
crv28={1,[28]}
crv29={1,[29]}
crv30={1,[30]}
crv31={1,[31]}
crv32={1,[32]}
crv33={1,[33]}
crv34={1,[34]}
crv35={1,[35]}
crv36={1,[36]}
crv37={1,[37]}
crv38={1,[38]}
crv39={1,[39]}
crv40={1,[40]}
crv41={1,[41]}
crv42={1,[42]}
crv43={1,[43]}
crv44={1,[44]}
crv45={1,[45]}
crv46={1,[46]}
crv47={1,[47]}
crv48={1,[48]}
crv49={1,[49]}
crv50={1,[50]}
crv51={1,[51]}
crv52={1,[52]}
crv53={1,[53]}
crv54={1,[54]}
crv55={1,[55]}
crv56={1,[56]}
crv57={1,[57]}
crv58={1,[58]}
crv59={1,[59]}
crv60={1,[60]}
crv61={1,[61]}
crv62={1,[62]}
crv63={1,[63]}
crv64={1,[64]}
crv65={1,[65]}
crv66={1,[66]}
crv67={1,[67]}
crv68={1,[68]}
crv69={1,[69]}
crv70={1,[70]}
crv71={1,[71]}
crv72={1,[72]}
crv73={1,[73]}
crv74={1,[74]}
crv75={1,[75]}
crv76={1,[76]}
crv77={1,[77]}
crv78={1,[78]}
crv79={1,[79]}
crv80={1,[80]}
crv81={1,[81]}
crv82={1,[82]}
crv83={1,[83]}
crv84={1,[84]}
crv85={1,[85]}
crv86={1,[86]}
crv87={1,[87]}
crv88={1,[88]}
crv89={1,[89]}
crv90={1,[90]}
crv91={1,[91]}
crv92={1,[92]}
crv93={1,[93]}
crv94={1,[94]}
crv95={1,[95]}
crv96={1,[96]}
crv97={1,[97]}
crv98={1,[98]}
crv99={1,[99]}
crv100={1,[100]}
crv101={1,[101]}
crv102={1,[102]}
crv103={1,[103]}
crv104={1,[104]}
crv105={1,[105]}
crv106={1,[106]}
crv107={1,[107]}
crv108={1,[108]}
crv109={1,[109]}
crv110={1,[110]}
crv111={1,[111]}
crv112={1,[112]}
crv113={1,[113]}
crv114={1,[114]}
crv115={1,[115]}
crv116={1,[116]}
crv117={1,[117]}
crv118={1,[118]}
crv119={1,[119]}
crv120={1,[120]}
crv121={1,[121]}
crv122={1,[122]}
crv123={1,[123]}
crv124={1,[124]}
crv125={1,[125]}
crv126={1,[126]}
crv127={1,[127]}
crv128={1,[128]}
crv129={1,[129]}
crv130={1,[130]}
crv131={1,[131]}
crv132={1,[132]}
crv133={1,[133]}
crv134={1,[134]}
crv135={1,[135]}
crv136={1,[136]}
crv137={1,[137]}
crv138={1,[138]}
crv139={1,[139]}
crv140={1,[140]}
crv141={1,[141]}
crv142={1,[142]}
crv143={1,[143]}
crv144={1,[144]}
crv145={1,[145]}
crv146={1,[146]}
crv147={1,[147]}
crv148={1,[148]}
crv149={1,[149]}
crv150={1,[150]}
crv151={1,[151]}
crv152={1,[152]}
crv153={1,[153]}
crv154={1,[154]}
crv155={1,[155]}
crv156={1,[156]}
crv157={1,[157]}
crv158={1,[158]}
crv159={1,[159]}
crv160={1,[160]}
crv161={1,[161]}
crv162={1,[162]}
crv163={1,[163]}
crv164={1,[164]}
crv165={1,[165]}
crv166={1,[166]}
crv167={1,[167]}
crv168={1,[168]}
crv169={1,[169]}
crv170={1,[170]}
crv171={1,[171]}
crv172={1,[172]}
crv173={1,[173]}
crv174={1,[174]}
crv175={1,[175]}
crv176={1,[176]}
crv177={1,[177]}
crv178={1,[178]}
crv179={1,[179]}
crv180={1,[180]}
crv181={1,[181]}
crv182={1,[182]}
crv183={1,[183]}
crv184={1,[184]}
crv185={1,[185]}
crv186={1,[186]}
crv187={1,[187]}
crv188={1,[188]}
crv189={1,[189]}
crv190={1,[190]}
crv191={1,[191]}
crv192={1,[192]}
crv193={1,[193]}
crv194={1,[194]}
crv195={1,[195]}
crv196={1,[196]}
crv197={1,[197]}
crv198={1,[198]}
crv199={1,[199]}
crv200={1,[200]}
crv201={1,[201]}
crv202={1,[202]}
crv203={1,[203]}
crv204={1,[204]}
crv205={1,[205]}
crv206={1,[206]}
crv207={1,[207]}
crv208={1,[208]}
crv209={1,[209]}
crv210={1,[210]}
crv211={1,[211]}
crv212={1,[212]}
crv213={1,[213]}
crv214={1,[214]}
crv215={1,[215]}
crv216={1,[216]}
crv217={1,[217]}
crv218={1,[218]}
crv219={1,[219]}
crv220={1,[220]}
crv221={1,[221]}
crv222={1,[222]}
crv223={1,[223]}
crv224={1,[224]}
crv225={1,[225]}
crv226={1,[226]}
crv227={1,[227]}
crv228={1,[228]}
crv229={1,[229]}
crv230={1,[230]}
crv231={1,[231]}
crv232={1,[232]}
crv233={1,[233]}
crv234={1,[234]}
crv235={1,[235]}
crv236={1,[236]}
crv237={1,[237]}
crv238={1,[238]}
crv239={1,[239]}
crv240={1,[240]}
crv241={1,[241]}
crv242={1,[242]}
crv243={1,[243]}
crv244={1,[244]}
crv245={1,[245]}
crv246={1,[246]}
crv247={1,[247]}
crv248={1,[248]}
crv249={1,[249]}
crv250={1,[250]}
crv251={1,[251]}
crv252={1,[252]}
crv253={1,[253]}
crv254={1,[254]}
crv255={1,[255]}
-apply_curve[0] 0,0,$crv0,1,$crv1,2,$crv2,3,$crv3,4,$crv4,5,$crv5,6,$crv6,7,$crv7,8,$crv8,9,$crv9,10,$crv10,11,$crv11,12,$crv12,13,$crv13,14,$crv14,15,$crv15,16,$crv16,17,$crv17,18,$crv18,19,$crv19,20,$crv20,21,$crv21,22,$crv22,23,$crv23,24,$crv24,25,$crv25,26,$crv26,27,$crv27,28,$crv28,29,$crv29,30,$crv30,31,$crv31,32,$crv32,33,$crv33,34,$crv34,35,$crv35,36,$crv36,37,$crv37,38,$crv38,39,$crv39,40,$crv40,41,$crv41,42,$crv42,43,$crv43,44,$crv44,45,$crv45,46,$crv46,47,$crv47,48,$crv48,49,$crv49,50,$crv50,51,$crv51,52,$crv52,53,$crv53,54,$crv54,55,$crv55,56,$crv56,57,$crv57,58,$crv58,59,$crv59,60,$crv60,61,$crv61,62,$crv62,63,$crv63,64,$crv64,65,$crv65,66,$crv66,67,$crv67,68,$crv68,69,$crv69,70,$crv70,71,$crv71,72,$crv72,73,$crv73,74,$crv74,75,$crv75,76,$crv76,77,$crv77,78,$crv78,79,$crv79,80,$crv80,81,$crv81,82,$crv82,83,$crv83,84,$crv84,85,$crv85,86,$crv86,87,$crv87,88,$crv88,89,$crv89,90,$crv90,91,$crv91,92,$crv92,93,$crv93,94,$crv94,95,$crv95,96,$crv96,97,$crv97,98,$crv98,99,$crv99,100,$crv100,101,$crv101,102,$crv102,103,$crv103,104,$crv104,105,$crv105,106,$crv106,107,$crv107,108,$crv108,109,$crv109,110,$crv110,111,$crv111,112,$crv112,113,$crv113,114,$crv114,115,$crv115,116,$crv116,117,$crv117,118,$crv118,119,$crv119,120,$crv120,121,$crv121,122,$crv122,123,$crv123,124,$crv124,125,$crv125,126,$crv126,127,$crv127,128,$crv128,129,$crv129,130,$crv130,131,$crv131,132,$crv132,133,$crv133,134,$crv134,135,$crv135,136,$crv136,137,$crv137,138,$crv138,139,$crv139,140,$crv140,141,$crv141,142,$crv142,143,$crv143,144,$crv144,145,$crv145,146,$crv146,147,$crv147,148,$crv148,149,$crv149,150,$crv150,151,$crv151,152,$crv152,153,$crv153,154,$crv154,155,$crv155,156,$crv156,157,$crv157,158,$crv158,159,$crv159,160,$crv160,161,$crv161,162,$crv162,163,$crv163,164,$crv164,165,$crv165,166,$crv166,167,$crv167,168,$crv168,169,$crv169,170,$crv170,171,$crv171,172,$crv172,173,$crv173,174,$crv174,175,$crv175,176,$crv176,177,$crv177,178,$crv178,179,$crv179,180,$crv180,181,$crv181,182,$crv182,183,$crv183,184,$crv184,185,$crv185,186,$crv186,187,$crv187,188,$crv188,189,$crv189,190,$crv190,191,$crv191,192,$crv192,193,$crv193,194,$crv194,195,$crv195,196,$crv196,197,$crv197,198,$crv198,199,$crv199,200,$crv200,201,$crv201,202,$crv202,203,$crv203,204,$crv204,205,$crv205,206,$crv206,207,$crv207,208,$crv208,209,$crv209,210,$crv210,211,$crv211,212,$crv212,213,$crv213,214,$crv214,215,$crv215,216,$crv216,217,$crv217,218,$crv218,219,$crv219,220,$crv220,221,$crv221,222,$crv222,223,$crv223,224,$crv224,225,$crv225,226,$crv226,227,$crv227,228,$crv228,229,$crv229,230,$crv230,231,$crv231,232,$crv232,233,$crv233,234,$crv234,235,$crv235,236,$crv236,237,$crv237,238,$crv238,239,$crv239,240,$crv240,241,$crv241,242,$crv242,243,$crv243,244,$crv244,245,$crv245,246,$crv246,247,$crv247,248,$crv248,249,$crv249,250,$crv250,251,$crv251,252,$crv252,253,$crv253,254,$crv254,255,$crv255
-keep[0]
iain_fast_median_stack:
-if {$!>2}
-if {$!%2!=0}
-repeat {$!/2}
-repeat {$!-1}
-l[$>,{$>+1}]
--max[0,1]
-min[0,1]
-endl
-done
-progress {($>/$!)*200}
-done
-keep[{round(($!/2)-.5)}]
-else
-repeat {($!/2)+1}
-repeat {$!-1}
-l[$>,{$>+1}]
--max[0,1]
-min[0,1]
-endl
-done
-progress {($>/$!)*200}
-done
-keep[{round(($!/2)-.5)},{round({$!/2}-.5)-1}]
-add
-mul .5
-endif
-elif {$!==2}
-add
-mul .5
-elif {$!==1}
-endif
iain_median_3_stack:
-iain_fast_median_stack
iain_median_4_stack:
-iain_fast_median_stack
iain_median_5_stack:
-iain_fast_median_stack
fft_tile_fft:
--fftpolar[0]
--threshold[1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-keep[-1]
fft_tile_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile_fft[0--1] $1
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$3==0}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile_clean[-1] $1,$2
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$3==0}
-iain_median_5_stack
-endif
fft_tile_preview:
-fft_tile $1,$2,$3
-n 0,255
fill_holes:
-ac "
-if {$5==0}
-if {$6==1}
--dilate[-1] $1
-erode[-1] $2
-compose_lighten
-dilate[-1] $3
-erode[-1] $3
-endif
-if {$6==0}
--dilate_circ[-1] $1
-erode_circ[-1] $2
-compose_lighten
-dilate_circ[-1] $3
-erode_circ[-1] $3
-endif
-endif
-c 0,255
-if {$5==1}
-if {$6==1}
--erode[-1] $1
-dilate[-1] $2
-compose_darken
-erode[-1] $3
-dilate[-1] $3
-endif
-if {$6==0}
--erode_circ[-1] $1
-dilate_circ[-1] $2
-compose_darken
-erode_circ[-1] $3
-dilate_circ[-1] $3
-endif
-endif
-c 0,255
",$4
fill_holes_preview:
-fill_holes $1,$2,$3,$4,$5,$6
iain_descreen2:
-channels 0
-fftpolar
--blur[0] $1%
-sub[-1] [0]
-gt[-1] $2
-circle[-1] 50%,50%,$3%,1,1
-mul[0] [-1]
-keep[0,1]
-ifftpolar
-c 0,255
iain_hearttone:
-if {$2>0}
--iain_fast_denoise[0] $2,0,1,0,0
-sub[1] [0]
-mul[1] -1
-add
-n 0,255
-endif
-luminance
--l
-rm
-l
190,190,1,1,0
-circle 50,50,50,1,10
-circle 140,50,50,1,10
-polygon 5,10,80,50,50,140,50,180,80,95,190,1,10
-resize[-1] {0,w+2},{0,h+2},1,1,0,0,0.5,0.5
--resize[0] 95%,95%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 90%,90%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 85%,85%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 75%,75%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 65%,65%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 55%,55%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 50%,50%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 45%,45%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 40%,40%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 35%,35%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 30%,30%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 25%,25%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 20%,20%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 15%,15%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 10%,10%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
--resize[0] 5%,5%,1,1,2
-resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
-add
-endl
[0]
-append y
-resize 200%,100%,1,1,0,0,0.5,0.5
--shift[0] 160,100,0,0
--shift[0] -160,100,0,0
-add
-crop 30,190,350,100%
-n 0,255
-endl
-resize[-1] $1,$1,1,1,2
width={w}
height={h}
w_tiles={0,round(w/$width)}
h_tiles={0,round(h/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
-append_tiles[1--1] $w_tiles,$h_tiles
-equalize[-1] 256
-blend alpha,0.5,1
-gt 128
-mul 255
iain_2x:
-repeat $! -local[$>]
-resize[0] 200%,200%,1,3,4
-split c
-repeat $! -local[$>]
--l[0]
(0,0,0.5;0,1,0;0.5,0,0)
-convolve[0] [1]
-remove[1]
-endl
--l[0]
(0.5,0,0;0,1,0;0,0,0.5)
-convolve[0] [1]
-remove[1]
-endl
-remove[0]
--l[0]
(0,0,0.5;0,-1,0;0.5,0,0)
-convolve[0] [1]
-remove[1]
-abs
-endl
--l[1]
(0.5,0,0;0,-1,0;0,0,0.5)
-convolve[0] [1]
-remove[1]
-abs
-endl
-dilate[-1,-2] 3
-sub[-2] [-1]
-remove[-1]
-l[-1]
--lt[0] 0
--gt[0] 0
-fill[0] 0
-sub[0] [1]
-add[0] [-1]
-keep[0]
-add[0] 1
-mul[0] 127.5
-endl
-append[1,2] c
-blend alpha,1,0
--l[0]
(0.5,1,0.5)
-convolve[0] [1]
-remove[1]
-endl
--l[0]
(0.5;1;0.5)
-convolve[0] [1]
-remove[1]
-endl
-remove[0]
--l[0]
(0.5,-1,0.5)
-convolve[0] [1]
-remove[1]
-abs
-endl
--l[1]
(0.5;-1;0.5)
-convolve[0] [1]
-remove[1]
-abs
-endl
-blur[-1,-2] 3
-sub[-2] [-1]
-remove[-1]
-l[-1]
--lt[0] 0
--gt[0] 0
-fill[0] 0
-sub[0] [1]
-add[0] [-1]
-keep[0]
-add[0] 1
-mul[0] 127.5
-endl
-append[1,2] c
-blend alpha,1,0
-endlocal -done
-append c
-endlocal -done
iain_demosiac:
-to_rgb
-add 1000
-rgb2bayer $1,1
-replace 0,0.0000000001
--l[0]
-replace 0,0.000000001
--l[0]
-to_rgb
--split[0] c
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[-3] redblur
-name[-2] greenblur
-name[-1] blueblur
(0.25,.5,0.5,.5,0.25)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(1;1)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(0.5,1,0.5)
-convolve[greenblur] [-1]
-remove[-1]
--div[greenblur] [redblur]
--div[greenblur] [blueblur]
-name[-1] bluemul
-name[-2] redmul
-remove[redblur,greenblur,blueblur]
-mul[red] [redmul]
-mul[blue] [bluemul]
-keep[red,green,blue]
-add
-c -100000000,100000000
-endl
-l[0]
-to_rgb
--split[0] c
-split[0] c
-name[0] red
-name[1] green
-name[2] blue
-name[-3] redblur
-name[-2] greenblur
-name[-1] blueblur
(0.25;.5;0.5;.5;0.25)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(1,1)
-convolve[redblur] [-1]
-convolve[blueblur] [-1]
-remove[-1]
(0.5;1;0.5)
-convolve[greenblur] [-1]
-remove[-1]
--div[greenblur] [redblur]
--div[greenblur] [blueblur]
-name[-1] bluemul
-name[-2] redmul
-remove[redblur,greenblur,blueblur]
-mul[red] [redmul]
-mul[blue] [bluemul]
-keep[red,green,blue]
-add
-c -100000000,100000000
-endl
## choose one without zippers
(1,-2,1)
--convolve[1] [-1]
-abs[-1]
-remove[-2]
(1;-2;1)
--convolve[0] [-1]
-abs[-1]
-remove[-2]
--add[-2] [-1]
-div[-2] [-1]
-remove[-1,-3]
-lt[-1] 0.5
-mul[-1] 255
-blur[-1] 1
-append[0,-1] c
-blend alpha,1,1
-endl
-split[0] c
-remove[1]
-reverse[1,2]
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
-convolve[0] [-1]
-convolve[2] [-1]
-remove[-1]
--resize 50%,50%,{d},{s},2
-sub[-1] [-2]
-sub[-3] [-2]
-remove[-2]
-resize[-1,-2] {0,w},{0,h},{d},{s},3
-remove[0,2]
-add[1] [0]
-add[2] [0]
-reverse[0,1]
-append c
-sub 1000
-c 0,255
iain_star_burst:
-repeat $! -l[$>] -split_opacity -l[0]
width={w}
height={h}
-resize {w+($2*2)},{h+($2*2)},1,3,0,0,0.5,0.5
--gt[0] $1
-mul[1] 255
-skeleton[1] 0
-if $6
-rgb2hsl
-split c
[0]
-reverse[3,-1]
-rm[-1]
-append[0,1,2] c
-append[1,2,3] c
-hsl2rgb
-endif
-mul[1] 255
-l[1]
{$2*5},{$2*5},1,1,0
-set[-1] 1,50%,50%
-l[-1]
-repeat $5
--blur_linear[0] $2,.5,{$4+((180/$5)*($>+1))}
-done
-rm[0]
-add
-endl
-convolve_fft[0] [1]
-endl
-mul[1] {1/$5}
-mul[1] {$3*10}
-if $7
-keep[1]
-else
-max
-endif
-c 0,255
-crop {$2},{$2},{$width+$2-1},{$height+$2-1}
-endl -a c -endl -done
iain_unindex:
amplitude=$1
sharpness=.3
anisotropy=1
gradient_smoothness=.6
tensor_smoothness=1
spatial_precision=0.8
angular_precision=30
value_precision=2
interpolation=0
fast_approx=1
-to_rgb
--smooth[0] $amplitude,$sharpness,$anisotropy,$gradient_smoothness,$tensor_smoothness,$spatial_precision,$angular_precision,$value_precision,$interpolation,$fast_approx
--luminance[-1]
-laplacian[-1]
-abs[-1]
-blur[-1] .5
-threshold[-1] $2
-mul[-1] -1
-add[-1] 1
-mul[-1] 255
-append[1,2] c
-blend alpha,1,0
-keep[-1]
iain_unindex_preview:
-iain_unindex $1,$2
-if {$3==1}
topleftx={$4-25}
toplefty={$5-25}
botleftx={$4+25}
botlefty={$5+25}
-crop $topleftx%,$toplefty%,$botleftx%,$botlefty%
-endif
iain_weightmap:
-split c
-max
255,1
-set[-1] 255,128,0
-blur[-1] $2
-n[-1] 0,255
--map[0] [1]
-rm[1]
-laplacian[0]
-mul[0] $1
-abs[0]
-add
luminance_nr:
-apply_gamma {1/$12}
-ac"
--ms_patch_smooth[0] 10,$1,3,3,0,$2,$3,0,$4,$5,$6,$7,$8,$9,1
--compose_grainextract
-fft_tile[-1] $10,$11,0
-compose_grainmerge[1,2]
-keep[-1]
",7
-apply_gamma $12
fft_tile2_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
-box_blur[-1] {$2*0.01}
--add[1] [-1]
-threshold[-1] {$1/(128/$2)}
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-keep[-1]
fft_tile2_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile2_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile2:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$3==0}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$3==0}
-iain_median_5_stack
-endif
luminance_nr_two:
-ac "
-mul 9.99
-apply_curve 0,0,0,510,{510-$17},1020,{1020-$17-$18},1530,{1530-$17-$18-$19},2040,{2040-$17-$18-$19-$20},2550,{2550-$17-$18-$19-$20-$21},2550,2550
-mul 0.1
-if {$22==1}
--median[0] 3
-ms_patch_smooth[-1] 10,$1,3,3,0,$2,$3,0,{$1*$4},{$1*$5},{$1*$6},{$1*$7},{$1*$8},{$1*$9},1
-endif
-if {$22==0}
--ms_patch_smooth[0] 10,$1,3,3,0,$2,$3,0,{$1*$4},{$1*$5},{$1*$6},{$1*$7},{$1*$8},{$1*$9},1
-endif
-if {$16==1}
--compose_grainextract
-fft_tile2[-1] $10,$11,3,$13,$14,$15
-compose_grainmerge[1,2]
-endif
-keep[-1]
-mul 9.99
-apply_curve 0,0,0,{510-$17},510,{1020-$17-$18},1020,{1530-$17-$18-$19},1530,{2040-$17-$18-$19-$20},2040,{2550-$17-$18-$19-$20-$21},2550,2550,2550
-mul 0.1
",7
-c 0,255
iain_moire_removal:
tile_size=256
overlap=16
cropwidth={w}
cropheight={h}
-if {$cropwidth%$tile_size>0}
-resize[0] {w+($tile_size-w%$tile_size)},100%,1,{s},0,1
-endif
-if {$cropheight%$tile_size>0}
-resize[0] 100%,{h+($tile_size-h%$tile_size)},1,{s},0,1
-endif
h_tiles={w/$tile_size}
v_tiles={h/$tile_size}
-repeat $v_tiles,v_count
-repeat $h_tiles,h_count
--crop[0] {($h_count*$tile_size)-$overlap},{($v_count*$tile_size)-$overlap},{($h_count*$tile_size)+($tile_size+$overlap-1)},{($v_count*$tile_size)+($tile_size+$overlap-1)},1
-done
-done
-rm[0]
-repeat $! -l[$>]
-if {iM!=im}
[0]
-apply_parallel_channels[1] "
-l[0]
-repeat 3
-l[-1]
-repeat 2
-denoise[0] 10,{$1/($>+1)},5,5,0,{min($>,1)}
-done
--resize[0] 50%,50%,{d},{s},2
--resize[-1] 200%,200%,{d},{s},3
-sub[0,-1]
-endl
-done
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-done
-endl
"
-if {$3<2}
-sub[0] [1]
-l[0]
-fftpolar[0]
-if {$3==1}
-append[0,1] x
-split[0] c
-min
-split[0] x,2
-elif {$3==0}
-fill[1] if(max(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))-min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))<$2,min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2)),(i(x,y,z,c)))
-endif
-ifftpolar[0,1]
-keep[0]
-endl
-to_rgb
-add
-else
-keep[1]
-endif
-c 0,255
-endif
-endl
-progress {($>/$!)*100}
-done
-repeat $! -l[$>]
-crop $overlap,$overlap,{$tile_size+$overlap-1},{$tile_size+$overlap-1}
-endl
-done
-append_tiles $h_tiles,$v_tiles
-crop 0,0,{$cropwidth-1},{$cropheight-1}
iain_moire_removal_NP:
tile_size=256
overlap=16
cropwidth={w}
cropheight={h}
-if {$cropwidth%$tile_size>0}
-resize[0] {w+($tile_size-w%$tile_size)},100%,1,{s},0,1
-endif
-if {$cropheight%$tile_size>0}
-resize[0] 100%,{h+($tile_size-h%$tile_size)},1,{s},0,1
-endif
h_tiles={w/$tile_size}
v_tiles={h/$tile_size}
-repeat $v_tiles,v_count
-repeat $h_tiles,h_count
--crop[0] {($h_count*$tile_size)-$overlap},{($v_count*$tile_size)-$overlap},{($h_count*$tile_size)+($tile_size+$overlap-1)},{($v_count*$tile_size)+($tile_size+$overlap-1)},1
-done
-done
-rm[0]
-repeat $! -l[$>]
-if {iM!=im}
[0]
-l[1]
-l[0]
-repeat 3
-l[-1]
-repeat 2
-denoise[0] 10,{$1/($>+1)},5,5,0,{min($>,1)}
-done
--resize[0] 50%,50%,{d},{s},2
--resize[-1] 200%,200%,{d},{s},3
-sub[0,-1]
-endl
-done
-repeat {$!-1}
-resize[-1] {-2,w},{-2,h},{d},{s},3
-add[-1,-2]
-done
-endl
-endl
-if {$3<2}
-sub[0] [1]
-l[0]
-fftpolar[0]
-if {$3==1}
-append[0,1] x
-split[0] c
-min
-split[0] x,2
-elif {$3==0}
-fill[1] if(max(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))-min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))<$2,min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2)),(i(x,y,z,c)))
-endif
-ifftpolar[0,1]
-keep[0]
-endl
-to_rgb
-add
-else
-keep[1]
-endif
-c 0,255
-endif
-endl
-progress {($>/$!)*100}
-done
-repeat $! -l[$>]
-crop $overlap,$overlap,{$tile_size+$overlap-1},{$tile_size+$overlap-1}
-endl
-done
-append_tiles $h_tiles,$v_tiles
-crop 0,0,{$cropwidth-1},{$cropheight-1}
ms_nlmeans_c_noise2_p_preview:
-if $16
-remove_opacity
--ms_nlmeans_c_noise2[0] ${1--1}
-sub
-mul 2
-add 128
-c 0,255
-else
-ms_nlmeans_c_noise2[0] ${1--1}
-endif
ms_nlmeans_c_noise2_p:
-ms_nlmeans_c_noise2[0] ${1--1}
ms_nlmeans_c_noise2:
-remove_opacity
hf_strength={2^$1}
lf_strength={2^$2}
hf_patch=$9
hf_search=$10
lf_patch=$11
lf_search=$12
sc_rb=$13
sc_g=$14
blacks={2^$3}
shadows={2^$4}
midtones={2^$5}
highlights={2^$6}
whites={2^$7}
smooth=$8
shadow={2^$3}
highlight={2^$4}
levels=1
size={3^$levels}
cropwidth={w}
cropheight={h}
-resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1
--l[0]
-split c
-if $sc_rb
-median[0,2] 4
-endif
-if $sc_g
-l[1]
--l[0]
(1,1,1;1,0,1;1,1,1)
-dilate[0] [1]
-rm[1]
-endl
--l[0]
(1,1,1;1,0,1;1,1,1)
-erode[0] [1]
-rm[1]
-endl
-min[0,1]
-max[0,1]
-endl
-endif
-append c
-luminance
-endl
-if $11
--c_noise[0] 1.6
-else
[1]
-to_rgb[-1]
-negative[-1]
-add[-1] .1
-mul[-1] .1
-blur[-1] 2
-endif
--l[1]
255,1,1,1,1
-line[-1] 0,0,50,0,1,$blacks
-line[-1] 51,0,100,0,1,$shadows
-line[-1] 101,0,152,0,1,$midtones
-line[-1] 153,0,204,0,1,$highlights
-line[-1] 205,0,255,0,1,$whites
-blur[-1] $smooth
-map[0] [1]
-keep[0]
-endl
-mul[2,-1]
--l[0,1,2]
-mul[-1] $hf_strength
-f[-1] '-3.0/i' -nlmeans_core[0] [1],[2],$hf_patch,$hf_search
-keep[0]
-endl
-reverse[0,-1]
-rm[-1]
--l[0,1,2]
-resize[0,1,2] 33.33333%,33.33333%,{d},{s},2
-mul[-1] $lf_strength
-f[-1] '-3.0/i' -nlmeans_core[0] [1],[2],$lf_patch,$lf_search
-keep[0]
-endl
-rm[1,2]
--resize[0] 33.33333%,33.33333%,{d},{s},2
-linear_x3[-1]
-sub[0,-1]
-linear_x3[-1]
-add
-c 0,255
## -repeat {$!-1}
## -done
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-c 0,255
c_noise:
width={w}
height={h}
--l[0]
--shift[0] 0,1,0,0,2
--shift[0] 0,-1,0,0,2
-blend_median
-endl
-sub
-abs
-add .1
-pow $1
-resize 25%,25%,1,3,2
-median 3
-resize $width,$height,1,3,3
create_luma_mix:
--split[0] c
-mul[1] {$1/($1+$2+$3)}
-mul[2] {$2/($1+$2+$3)}
-mul[3] {$3/($1+$2+$3)}
-add[1-3]
-keep[-1]
-to_gray[-1]
ms_patch_c:
-to_rgb
--create_luma_mix[0] $11,$12,$13
-name[-1] luma
-if {$2==1}
-median[0] 3
-median[0] 3
-endif
-repeat $3
-ms_patch_smooth[0] 10,$1,3,5,0,1,1,0,$4,$5,$6,$7,$8,$9,$10
-done
--create_luma_mix[0] $11,$12,$13
-sub[0] [-1]
-add[0] [1]
-keep[0]
-c 0,255
ms_patch_c_preview:
-if {$-1==0}
-ms_patch_c ${1--2}
-endif
-if {$-1==1}
--ms_patch_c ${1--2}
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
linear_x3:
-resize 300%,300%,{d},{s},4,1,.5,.5,0
(.11111,.22222,.33333,.22222,.11111;.22222,.44444,.66666,.44444,.22222;.33333,.66666,1,.66666,.33333;.22222,.44444,.66666,.44444,.22222;.11111,.22222,.33333,.22222,.11111)
-convolve[0] [1],0
-rm[1]
MS_Patch_NR:
-if {$1!=1}
-apply_parallel_overlap "-div 255 -pow $1 -mul 255"
-endif
cropwidth={w}
cropheight={h}
-resize[0] {w+(90-w%90)},{h+(90-h%90)},1,{s},0,1
-l[0]
width={w}
height={h}
-if {$2>0}
-apply_parallel_overlap[-1] "-denoise 10,{$2/10},$5,$6,0,0",16
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$3>0}
-apply_parallel_overlap[-1] "-denoise 10,{$3/10},$5,$6,0,0",16
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$4>0}
-apply_parallel_overlap[-1] "-denoise 10,{$4/10},$5,$6,0,0",16
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-if {$1!=1}
-apply_parallel_overlap "-div 255 -pow {1/$1} -mul 255"
-endif
-c 0,255
MS_Patch_NR3_p:
-to_rgb
-MS_Patch_NR3[0] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
-n 0,255
linear_x3:
-resize 300%,300%,{d},{s},4,1,.5,.5,0
(.11111,.22222,.33333,.22222,.11111;.22222,.44444,.66666,.44444,.22222;.33333,.66666,1,.66666,.33333;.22222,.44444,.66666,.44444,.22222;.11111,.22222,.33333,.22222,.11111)
-convolve[0] [1],0
-rm[1]
MS_Patch_NR3:
-apply_parallel_overlap[-1] "
-if {$1!=1}
-div 255 -pow $1 -mul 255
-endif
-if {$8==1}
-iain_pixel_denoise_p 1,1,0,0,1
-elif {$8==2}
-iain_pixel_denoise_p 2,1,0,0,1
-elif {$8==3}
-hybrid16 -hybrid16 -hybrid16
-endif
cropwidth={w}
cropheight={h}
-resize[0] {w+(90-w%90)},{h+(90-h%90)},1,{s},0,1
-rgb2yuv8
-split c
-l[0]
width={w}
height={h}
-if {$2>0}
-denoise 10,{$2/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$3>0}
-denoise 10,{$3/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$4>0}
-denoise 10,{$4/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-l[1]
width={w}
height={h}
-if {$10>0}
-denoise 10,{$10/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$11>0}
-denoise 10,{$11/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$12>0}
-denoise 10,{$12/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-l[2]
width={w}
height={h}
-if {$10>0}
-denoise 10,{$10/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$11>0}
-denoise 10,{$11/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-if {$12>0}
-denoise 10,{$12/10},$5,$6,0,$7
-endif
--resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
--linear_x3[-1]
-sub[-3,-1]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-linear_x3[-1]
-add[-1,-2]
-endl
-append c
-yuv82rgb
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-if {$1!=1}
-div 255 -pow {1/$1} -mul 255
-endif
-if {$9==1}
-iain_pixel_denoise_p 1,1,0,0,1
-elif {$9==2}
-iain_pixel_denoise_p 2,1,0,0,1
-elif {$9==3}
-hybrid16 -hybrid16 -hybrid16
-endif
-c 0,255
",64
ms_patch_smoothsmoothing:
-ac "-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done",$8 -c 0,255
ms_patch_smooth:
lvl2=2
lvl3=3
lvl4=4
lvl5=5
lvl6=6
lvl7=8
-apply_gamma {1/$15}
-ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
-name[0] full
--resize[full] {full,w/$lvl2},{full,h/$lvl2},1,{s},2 -name[1] level2
--ms_patch_smoothsmoothing[level2] $1,$9,$3,$4,$5,$6,$7,$8  -name[2] level2clean
--resize[level2] {0,w},{0,h},1,{s},5  -name[3] low2
--sub[full] [low2]  -name[4] level2high
-remove[level2,low2]
--resize[level2clean] {full,w/$lvl3},{full,h/$lvl3},1,{s},2 -name[3] level3
--ms_patch_smoothsmoothing[level3] $1,$10,$3,$4,$5,$6,$7,$8  -name[4] level3clean
--resize[level3] {level2clean,w},{level2clean,h},1,{s},5  -name[5] low3
--sub[level2clean] [low3]  -name[6] level3high
-remove[level3,low3]
--resize[level3clean] {full,w/$lvl4},{full,h/$lvl4},1,{s},2 -name[5] level4
--ms_patch_smoothsmoothing[level4] $1,$11,$3,$4,$5,$6,$7,$8  -name[6] level4clean
--resize[level4] {level3clean,w},{level3clean,h},1,{s},5  -name[7] low4
--sub[level3clean] [low4]  -name[8] level4high
-remove[level4,low4]
--resize[level4clean] {full,w/$lvl5},{full,h/$lvl5},1,{s},2 -name[-1] level5
--ms_patch_smoothsmoothing[level5] $1,$12,$3,$4,$5,$6,$7,$8  -name[-1] level5clean
--resize[level5] {level4clean,w},{level4clean,h},1,{s},5  -name[-1] low5
--sub[level4clean] [low5]  -name[-1] level5high
-remove[level5,low5]
--resize[level5clean] {full,w/$lvl6},{full,h/$lvl6},1,{s},2 -name[-1] level6
--ms_patch_smoothsmoothing[level6] $1,$13,$3,$4,$5,$6,$7,$8  -name[-1] level6clean
--resize[level6] {level5clean,w},{level5clean,h},1,{s},5  -name[-1] low6
--sub[level5clean] [low6]  -name[-1] level6high
-remove[level6,low6]
-name[-2] base
-resize[base] {level6high,w},{level6high,h},1,{s},5
-add[base] [level6high]
-remove[level6high]
-resize[base] {level5high,w},{level5high,h},1,{s},5
-add[base] [level5high]
-remove[level5high]
-resize[base] {level4high,w},{level4high,h},1,{s},5
-add[base] [level4high]
-remove[level4high]
-resize[base] {level3high,w},{level3high,h},1,{s},5
-add[base] [level3high]
-remove[level3high]
-resize[base] {level2high,w},{level2high,h},1,{s},5
-add[base] [level2high]
-remove[level2high]
-keep[-1]
-c 0,255
-apply_gamma {$15}
-c 0,255
ms_patch_smooth_preview:
-if {$-1==0}
-ms_patch_smooth ${1--2}
-endif
-if {$-1==1}
--ms_patch_smooth ${1--2}
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
ms_smoothsmoothing:
-smooth {$1*5},0.7,0.7,0.6,$2,0.8,30,2,0,1
ms_smooth:
-if {$8==0}
lvl2=2
lvl3=3
lvl4=4
lvl5=5
lvl6=6
-endif
-if {$8==1}
lvl2=2
lvl3=4
lvl4=8
lvl5=16
lvl6=32
-endif
-repeat $9
-if {$1>0}
-ms_smoothsmoothing[-1] $1,$7
-endif
-name[0] full
--resize[full] {full,w/$lvl2},{full,h/$lvl2},1,{s},2 -name[1] level2
-if {$2>0}
--ms_smoothsmoothing[level2]  $2,$7
-else [level2]
-endif
-name[2] level2clean
--resize[level2] {0,w},{0,h},1,{s},5  -name[3] low2
--sub[full] [low2]  -name[4] level2high
-remove[level2,low2]
--resize[level2clean] {full,w/$lvl3},{full,h/$lvl3},1,{s},2 -name[3] level3
-if {$3>0}
--ms_smoothsmoothing[level3] $3,$7
-else [level3]
-endif
-name[4] level3clean
--resize[level3] {level2clean,w},{level2clean,h},1,{s},5  -name[5] low3
--sub[level2clean] [low3]  -name[6] level3high
-remove[level3,low3]
--resize[level3clean] {full,w/$lvl4},{full,h/$lvl4},1,{s},2 -name[5] level4
-if {$4>0}
--ms_smoothsmoothing[level4] $4,$7
-else [level4]
-endif
-name[6] level4clean
--resize[level4] {level3clean,w},{level3clean,h},1,{s},5  -name[7] low4
--sub[level3clean] [low4]  -name[8] level4high
-remove[level4,low4]
--resize[level4clean] {full,w/$lvl5},{full,h/$lvl5},1,{s},2 -name[-1] level5
-if {$5>0}
--ms_smoothsmoothing[level5] $5,$7
-else [level5]
-endif
-name[-1] level5clean
--resize[level5] {level4clean,w},{level4clean,h},1,{s},5  -name[-1] low5
--sub[level4clean] [low5]  -name[-1] level5high
-remove[level5,low5]
--resize[level5clean] {full,w/$lvl6},{full,h/$lvl6},1,{s},2 -name[-1] level6
-if {$6>0}
--ms_smoothsmoothing[level6]  $6,$7
-else [level6]
-endif
-name[-1] level6clean
--resize[level6] {level5clean,w},{level5clean,h},1,{s},5  -name[-1] low6
--sub[level5clean] [low6]  -name[-1] level6high
-remove[level6,low6]
-name[-2] base
-resize[base] {level6high,w},{level6high,h},1,{s},5
-add[base] [level6high]
-remove[level6high]
-resize[base] {level5high,w},{level5high,h},1,{s},5
-add[base] [level5high]
-remove[level5high]
-resize[base] {level4high,w},{level4high,h},1,{s},5
-add[base] [level4high]
-remove[level4high]
-resize[base] {level3high,w},{level3high,h},1,{s},5
-add[base] [level3high]
-remove[level3high]
-resize[base] {level2high,w},{level2high,h},1,{s},5
-add[base] [level2high]
-remove[level2high]
-keep[-1]
-c 0,255
-c 0,255
-done
ms_smooth_preview:
-if {$-1==0}
-ms_smooth $1,$2,$3,$4,$5,$6,$7,$8,$9
-endif
-if {$-1==1}
--ms_smooth $1,$2,$3,$4,$5,$6,$7,$8,$9
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
med3stack16:
--max[0,1]
--min[0,1]
-keep[2,3,4]
--max[0,2]
--min[1,3]
-keep[-1]
med5stack16:
--min[0,1]
--max[0,1]
-remove[0,1]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,1]
--max[0,1]
-remove[0,1]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[1,2]
--max[1,2]
-remove[1,2]
--max[1,4]
-keep[-1]
cross16:
--shift[0] 0,1,0,0,2
--shift[0] 0,-1,0,0,2
--shift[0] 1,0,0,0,2
--shift[0] -1,0,0,0,2
-med5stack16
ex16:
--shift[0] 1,1,0,0,2
--shift[0] 1,-1,0,0,2
--shift[0] -1,-1,0,0,2
--shift[0] -1,1,0,0,2
-med5stack16
hybrid16:
--cross16[0]
--ex16[0]
-med3stack16
autonr2:
--crop 30%,30%,70%,70%
noise0=${-variance_noise}
-remove[-1]
cropwidth={w}
cropheight={h}
-resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
width={w}
height={h}
-if {$noise0>$2}
-denoise[-1] 10,{$noise0*$1},3,5,0,1
-denoise[-1] 10,{$noise0*$1},3,5,0,1
-endif
--resize[0] {$width/2},{$height/2},1,{s},2,1
--resize[-1] $width,$height,1,{s},3,1
-sub[0] [-1]
-remove[-1]
noise1=${-variance_noise}
-if {$noise1>$2}
-denoise[-1] 10,{$noise1*$1},3,5,0,0
-endif
--resize[-1] {$width/4},{$height/4},1,{s},2,1
--resize[-1] {$width/2},{$height/2},1,{s},3,1
-sub[1] [-1]
-remove[-1]
noise2=${-variance_noise}
-if {$noise2>$2}
-denoise[-1] 10,{$noise2*$1},3,5,0,1
-endif
--resize[-1] {$width/8},{$height/8},1,{s},2,1
--resize[-1] {$width/4},{$height/4},1,{s},3,1
-sub[2] [-1]
-remove[-1]
noise3=${-variance_noise}
-if {$noise3>$2}
-denoise[-1] 10,{$noise3*$1},3,5,0,1
-endif
-resize[-1] {$width/4},{$height/4},1,{s},3,1
-add[-2] [-1]
-remove[-1]
-resize[-1] {$width/2},{$height/2},1,{s},3,1
-add[-2] [-1]
-remove[-1]
-resize[-1] {$width/1},{$height/1},1,{s},3,1
-add[-2] [-1]
-remove[-1]
-crop 0,0,{$cropwidth-1},{$cropheight-1}
fft_tile3_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
--add[1] [-1]
-threshold[-1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-remove[0,1,2]
-keep[-1]
fft_tile3_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile3:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-remove[0]
-med5stack16
nr3:
-mul 256
radius={0.05*(min(h,w))}
[0]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmin={xm}
ymin={ym}
-remove[-1]
--crop[0] {$xmin-$radius},{$ymin-$radius},{$xmin+$radius},{$ymin+$radius}
minnoise=${-variance_noise}
-remove[-1]
--sub[0] {250*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmax={xm}
ymax={ym}
--crop[0] {$xmax-$radius},{$ymax-$radius},{$xmax+$radius},{$ymax+$radius}
maxnoise=${-variance_noise}
-remove[-1]
--sub[0] {128*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xave={xm}
yave={ym}
-remove[-1]
--crop[0] {$xave-$radius},{$yave-$radius},{$xave+$radius},{$yave+$radius}
midnoise=${-variance_noise}
-text[-1] $midnoise,0,0,25,1,{iM}
--sub[0] {64*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xshadow={xm}
yshadow={ym}
-remove[-1]
--crop[0] {$xshadow-$radius},{$yshadow-$radius},{$xshadow+$radius},{$yshadow+$radius}
shadownoise=${-variance_noise}
--sub[0] {192*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xbright={xm}
ybright={ym}
-remove[-1]
--crop[0] {$xbright-$radius},{$ybright-$radius},{$xbright+$radius},{$ybright+$radius}
brightnoise=${-variance_noise}
shadows={(($minnoise/$shadownoise)*64)}
mids={(($minnoise/$midnoise)*64)}
brights={(($minnoise/$brightnoise)*64)}
whites={(($minnoise/$maxnoise)*64)}
point1={$shadows+32}
point2={$mids+$shadows+32}
point3={$brights+$mids+$shadows+32}
point4={$whites+$brights+$mids+$shadows+32}
-keep[0]
cropwidth={w}
cropheight={h}
-resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
width={w}
height={h}
-apply_curve[0] 0,0,0,{32*256},{32*256},{96*256},{$point1*256},{160*256},{$point2*256},{223*256},{$point3*256},{287*256},{$point4*256}
-sub {128*256} -mul .5 -add {128*256}
--hybrid16[0]
-autonr2[-1] $1,$2
-autonr2[-1] $1,$2
--sub[0] [1]
-add[-1] {128*256}
-remove[0]
-div[-1] 256
-fft_tile3[-1] {2000-$3},48,0,$4,$5,$6,1
-mul[-1] 256
-sub[-1] {128*256} -mul[-1] $7 -add[-1] {128*256}
-unsharp[0] $8,$9,$10
-unsharp[1] $11,$12,$13
-sub[1] {128*256}
-add[0] [1]
-remove[1]
-sub {128*256} -mul 2 -add {128*256}
-apply_curve[0] 0,0,0,{32*256},{32*256},{$point1*256},{96*256},{$point2*256},{160*256},{$point3*256},{223*256},{$point4*256},{287*256}
-div 256
-c 0,255
-crop 0,0,{$cropwidth-1},{$cropheight-1}
med3stack16:
--max[0,1]
--min[0,1]
-keep[2,3,4]
--max[0,2]
--min[1,3]
-keep[-1]
med5stack16:
--min[0,1]
--max[0,1]
-remove[0,1]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,1]
--max[0,1]
-remove[0,1]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[0,4]
--max[0,4]
-remove[0,4]
--min[1,2]
--max[1,2]
-remove[1,2]
--max[1,4]
-keep[-1]
fft_tile3_fft:
--fftpolar[0]
100%,100%,1,1,1
-ellipse[-1] 50%,50%,50%,50%,0,1,$4
-ellipse[-1] 50%,50%,15%,15%,0,1,$5
-ellipse[-1] 50%,50%,5%,5%,0,1,$6
--add[1] [-1]
-threshold[-1] $1
-set[-1] 1,50%,50%
-mul[1] [-1]
--ifftpolar[1,2]
-remove[0,1,2]
-keep[-1]
fft_tile3_clean:
tc={round(w/$2)} tr={round(h/$2)}
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
-endlocal -done
-append_tiles $tc,$tr
-c 0,255
fft_tile3:
--resize[0] {w+$2},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,$2,{w-$2-1},{h-$2-1}
-if {$8>2}
push={round($2*1.5)}
pull={$2-$push}
--resize[0] {w+$push},{h+$2},1,1,0,1,1,1
-resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}
--resize[0] {w+$2},{h+$push},1,1,0,1,1,1
-resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
-endif
-if {$8>1}
dia1={round($2/3)}
dia2={$2-$dia1}
--resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
-resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}
--resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
-resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
-fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
-crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
-endif
-remove[0]
-if {$8==3}
-med5stack16
-endif
-if {$8==2}
-med3stack16
-endif
nr5:
luma_strength=$1
colour_strength=$2
recovery=$3
detail_recovery={5000-($4*500)}
fine_detials=$13
medium_detials=$14
large_details=$15
detail_radius=$5
detail_amount=$6
detail_threshold=$7
edge_radius=$8
edge_amount=$9
edge_threshold=$10
quality=3
-if {$16==1}
-mul[0] 256
radius={0.05*(min(h,w))}
[0]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmin={xm}
ymin={ym}
-remove[-1]
--crop[0] {$xmin-$radius},{$ymin-$radius},{$xmin+$radius},{$ymin+$radius}
minnoise=${-variance_noise}
-remove[-1]
--sub[0] {250*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xmax={xm}
ymax={ym}
--crop[0] {$xmax-$radius},{$ymax-$radius},{$xmax+$radius},{$ymax+$radius}
maxnoise=${-variance_noise}
-remove[-1]
--sub[0] {128*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xave={xm}
yave={ym}
-remove[-1]
--crop[0] {$xave-$radius},{$yave-$radius},{$xave+$radius},{$yave+$radius}
midnoise=${-variance_noise}
-text[-1] $midnoise,0,0,25,1,{iM}
--sub[0] {64*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xshadow={xm}
yshadow={ym}
-remove[-1]
--crop[0] {$xshadow-$radius},{$yshadow-$radius},{$xshadow+$radius},{$yshadow+$radius}
shadownoise=${-variance_noise}
--sub[0] {192*256}
-abs[-1]
-rectangle[-1] 0,0,100%,$radius,1,{ia}
-rectangle[-1] 0,0,$radius,100%,1,{ia}
-rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
-rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
-blur[-1] {$radius/2}
xbright={xm}
ybright={ym}
-remove[-1]
--crop[0] {$xbright-$radius},{$ybright-$radius},{$xbright+$radius},{$ybright+$radius}
brightnoise=${-variance_noise}
shadows={(($minnoise/$shadownoise)*64)}
mids={(($minnoise/$midnoise)*64)}
brights={(($minnoise/$brightnoise)*64)}
whites={(($minnoise/$maxnoise)*64)}
point1={$shadows+32}
point2={$mids+$shadows+32}
point3={$brights+$mids+$shadows+32}
point4={$whites+$brights+$mids+$shadows+32}
-keep[0]
## cropwidth={w}
## cropheight={h}
## -resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
## width={w}
## height={h}
-apply_curve[0] 0,0,0,{32*256},{32*256},{96*256},{$point1*256},{160*256},{$point2*256},{223*256},{$point3*256},{287*256},{$point4*256}
-div[0] 256
-else
-apply_gamma {1/$17}
-endif
-rgb2ycbcr
-split c
-if {$1>0}
-if {$11==0}
--denoise_haar[0] $luma_strength,0,{$quality*10}
-endif
-if {$11==1}
--ms_patch[0] 10,{$luma_strength*2.5},3,5,0,1,1,0,{$luma_strength*.75},{$luma_strength*.5},{$luma_strength*0},{$luma_strength*0},1,1,1,0
-endif
-if {$11==2}
--autonr2[0] $luma_strength,1
-endif
-if {$11==3}
--median[0] 3
-ms_patch[-1] 10,{$luma_strength*2.5},3,5,0,1,1,0,{$luma_strength*.75},{$luma_strength*.5},{$luma_strength*0},{$luma_strength*0},1,1,1,0
-endif
-if {$11==4}
--msmed2[0] 3
-repeat $1
-msmed2[-1] 3
-done
-endif
--sub[0] [-1]
-add[-1] {128}
-remove[0]
-if {$recovery==1}
-resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
-resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
-rectangle[-1] 0,0,100%,48,1,128
-rectangle[-1] 0,0,48,100%,1,128
-rectangle[-1] 0,100%,100%,{h-48},1,128
-rectangle[-1] {w-48},100%,100%,0,1,128
-fft_tile3[-1] {$detail_recovery},48,0,$fine_detials,$medium_detials,$large_details,1,$quality
-crop[-1] 48,48,{w-49},{h-49}
-else
-fill[-1] 128
-endif
-unsharp[-1] $detail_radius,$detail_amount,$detail_threshold
-unsharp[2] $edge_radius,$edge_amount,$edge_threshold
-sub[-1] {128}
-add[2] [-1]
-remove[-1]
-else
-move[0] 3
-endif
-if {$2>0}
-median[0,1] 3
-median[0,1] 3
-if {$12==1}
-ms_patch[0] 10,1,3,5,0,1,1,0,{$colour_strength*1},{$colour_strength*.5},{$colour_strength*.25},{$colour_strength*0},0,1,1,0
-ms_patch[1] 10,1,3,5,0,1,1,0,{$colour_strength*1},{$colour_strength*.5},{$colour_strength*.25},{$colour_strength*0},0,1,1,0
-endif
-if {$12==0}
-denoise_haar[0] $colour_strength,0,{$quality*3}
-denoise_haar[1] $colour_strength,0,{$quality*3}
-endif
-endif
-move[-1] 0
-append c
-ycbcr2rgb
-if {16==1}
-mul[0] 256
-apply_curve[0] 0,0,0,{32*256},{32*256},{$point1*256},{96*256},{$point2*256},{160*256},{$point3*256},{223*256},{$point4*256},{287*256}
## -n 0,{256*256}
-div[0] 256
-else
-apply_gamma $17
-endif
-c 0,255
ms_patch_smoothing:
-ac "-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done",$8,0 -c 0,255
ms_patch_2:
--resize[0] 50%,50%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch_3:
--resize[0] 25%,25%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch_4:
--resize[0] 12.5%,12.5%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch_5:
--resize[0] 6.125%,6.125%,1,{s},2
--ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
--resize[1] {0,w},{0,h},1,{s},5
--sub[0] [3]
-resize[2] {0,w},{0,h},1,{s},5
--add[2] [4]
-keep[-1]
-c 0,255
ms_patch:
-apply_gamma {1/$14}
-repeat $15
-if {$13==1}
-ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
-endif
-if {$9>0.1}
-ms_patch_2 $1,$9,$3,$4,$5,$6,$7,$8
-endif
-if {$10>0.1}
-ms_patch_3 $1,$10,$3,$4,$5,$6,$7,$8
-endif
-if {$11>0.1}
-ms_patch_4 $1,$11,$3,$4,$5,$6,$7,$8
-endif
-if {$12>0.1}
-ms_patch_5 $1,$12,$3,$4,$5,$6,$7,$8
-endif
-done
-apply_gamma $14
-c 0,255
msmed2:
medlvl2=2
medlvl3=3
medlvl4=4
medlvl5=6
medlvl6=6
medlvl7=7
-median $1
-median $1
-name[0] full
--resize[full] {full,w/$medlvl2},{full,h/$medlvl2},1,{s},2
-name[-1] level2
--resize[level2] {0,w},{0,h},1,{s},3,1
-name[-1] low2
--compose_grainextract[full,low2]
-name[-1] level2high
-remove[low2]
-median[level2] $1
-median[level2] $1
-name[1] level2
--resize[level2] {full,w/$medlvl3},{full,h/$medlvl3},1,{s},2
-name[-1] level3
--resize[level3] {level2,w},{level2,h},1,{s},3,1
-name[-1] low3
--compose_grainextract[level2,low3]
-name[-1] level3high
-remove[1,low3]
-median[2] $1
-median[2] $1
-name[2] level3
--resize[level3] {full,w/$medlvl4},{full,h/$medlvl4},1,{s},2
-name[-1] level4
--resize[level4] {level3,w},{level3,h},1,{s},3,1
-name[-1] low4
--compose_grainextract[level3,low4]
-name[-1] level4high
-remove[2,low4]
-median[-2] $1
-median[-2] $1
-name[-2] base
-resize[base] {level4high,w},{level4high,h},1,{s},3,1
-compose_grainmerge[-1,-2]
-name[-1] base
-resize[base] {level3high,w},{level3high,h},1,{s},3,1
-compose_grainmerge[-1,-2]
-resize[-1] {full,w},{full,h},1,{s},3,1
-compose_grainmerge[-1,-2]
-keep[-1]
nr5_preview:
-if {$-1==0}
-nr5 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
-endif
-if {$-1==1}
--nr5 $1,$2,$3,$4,$5,0,$7,$8,0,$10,$11,$12,$13,$14,$15,$16,$17
-sub[0] [1]
-keep[0]
-mul 2
-add 128
-endif
iain_savenoiseprint_p:
-if {$1==0}
-text "creating noiseprint",0,0,50,1,255
-elif {$1==1}
-iain_savenoiseprint[0,1] $1,$2,$3
-endif
iain_savenoiseprint:
-remove_opacity
-rgb2yuv8
-split c
-remove[-1,-2]
-l[0,3]
-apply_parallel_overlap[0] "-mul {1/255} -pow $3 -mul 255 ",0,0
-apply_parallel_overlap[1] "-mul {1/255} -pow $3 -mul 255 ",0,0
--sub[1] [0]
-add[-1] 128
-l[-1]
-if {$1==0}
--l
size=48
cropwidth={w}
cropheight={h}
-resize[0] {w+($size-w%$size)},{h+($size-h%$size)},1,{s},0,1
tc={round(w/$size)} tr={round(h/$size)}
-l[0]
-split_tiles $tc,$tr
-repeat $! -local[$>]
-fftpolar[0]
-append[0,1] z
-endl -done
-median_median
-endl
-o noiseprint.cimg
-rm
-endl
-elif {$1==1}
size=48
cropwidth={w}
cropheight={h}
-resize[0] {w+($size-w%$size)},{h+($size-h%$size)},1,{s},0,1
tc={round(w/$size)} tr={round(h/$size)}
-i noiseprint.cimg
-mul[-1] $2
--l[0,1]
-split_tiles[0] $tc,$tr
-repeat {$!-1}
-l[$>,-1]
[-1]
-l[0,1]
-fftpolar[0]
-l[0,-1]
-split[1] z
-rm[-1]
--gt[0] [1]
-circle[-1] 50%,50%,1%,1,1
-mul[0] [-1]
-keep[0]
-endl
-ifftpolar
-endl
-endl
-done
-rm[-1]
-append_tiles $tc,$tr
-endl
--l[0,1]
-shift[0] 16,16,0,0
-split_tiles[0] $tc,$tr
-repeat {$!-1}
-l[$>,-1]
[-1]
-l[0,1]
-fftpolar[0]
-l[0,-1]
-split[1] z
-rm[-1]
--gt[0] [1]
-circle[-1] 50%,50%,1%,1,1
-mul[0] [-1]
-keep[0]
-endl
-ifftpolar
-endl
-endl
-done
-rm[-1]
-append_tiles $tc,$tr
-shift[0] -16,-16,0,0
-endl
-l[0,1]
-shift[0] 32,32,0,0
-split_tiles[0] $tc,$tr
-repeat {$!-1}
-l[$>,-1]
[-1]
-l[0,1]
-fftpolar[0]
-l[0,-1]
-split[1] z
-rm[-1]
--gt[0] [1]
-circle[-1] 50%,50%,1%,1,1
-mul[0] [-1]
-keep[0]
-endl
-ifftpolar
-endl
-endl
-done
-rm[-1]
-append_tiles $tc,$tr
-shift[0] -32,-32,0,0
-endl
-iain_fast_median_stack
-crop 0,0,{$cropwidth-1},{$cropheight-1}
-c 0,255
-endif
-endl
-sub[-1] 128
-add[0] [-1]
-keep[0]
-apply_parallel_overlap[0] "-mul {1/255} -pow {1/$3} -mul 255 ",0,0
-endl
-append c
-yuv82rgb
-c 0,255
-if {$1==0}
-rm
-endif
median_median:
-repeat {$!/3-($!%3)}
-l[$>,{$>+1},{$>+2}]
-iain_fast_median_stack
-endl
-done
-repeat {$!/3-($!%3)}
-l[$>,{$>+1},{$>+2}]
-iain_fast_median_stack
-endl
-done
-repeat {$!/3-($!%3)}
-l[$>,{$>+1},{$>+2}]
-iain_fast_median_stack
-endl
-done
num=$!
-add
-div $num
iain_gimp_skin_mask_pr:
-if {$6==0}
-iain_skin_mask $1,$2,$3,$4,$5
-elif {$6==1}
--iain_skin_mask $1,$2,$3,$4,1
-n[-1] 0.6,1
-mul
-endif
iain_gimp_skin_mask:
-tic
-apply_parallel_overlap[0] "-iain_skin_mask[0] ${1--1}",0,0
-toc
iain_skin_mask:
dark={$1}
pale={255-$2}
red={255-$3}
yellow={255-$4}
-to_rgb
[0]
[0]
[0]
-l[1]
-if {$3>0}
red={255-$3}
-fill if(i(x,y,z,0)-i(x,y,z,1)<{$red},i,0)
-gt 0
-else
-fill 1
-endif
-endl
-l[2]
-rgb2cmyk
dark={$1}
pale={255-$2}
-fill if(i(x,y,z,2)>i(x,y,z,1),if(i(x,y,z,2)-i(x,y,z,1)<{$dark},if((i(x,y,z,0)+{$pale})<i(x,y,z,2),i,255),255),255)
-cmyk2rgb
-gt 0
-endl
-l[3]
-if {$4>0}
yellow={255-$4}
-rgb2hsv
-split c
-keep[0]
-add[0] 180
-mod[0] 360
-lt[0] $yellow
-else
-fill 1
-endif
-endl
-mul[1,2,3]
-mul[1] 255
-channels[1] 0
-if {$5}
-keep[1]
-else
-append c
-endif
iain_smartdemos:
cropwidth={w}
cropheight={h}
-resize[0] {w+(64-w%64)},{h+(64-h%64)},{d},{s},0,2
-apply_parallel_overlap "
-to_rgb
-add 1000
-rgb2bayer[0] $1,1
--l[0]
--l[0]
-split c
-l[0,2]
(0,0,.5;0,1,0;0.5,0,0)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
(0,0,.25;0,.5,0;0.25,0,0)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
-endl
-endl
-split[0] c
-name[0] red -name[1] green -name[2] blue
-name[3] redblur -name[4] greenblur -name[5] blueblur
--div[redblur] [blueblur]
-replace_nan 0
--mul[blue] [-1]
-add[-1] [red]
--div[blueblur] [redblur]
-replace_nan 0
--mul[red] [-1]
-add[-1] [blue]
-keep[1,-1,-3]
-reverse[0,1]
-append c
-endl
-l[0]
--l[0]
-split c
-l[0,2]
(0.5,0,0;0,1,0;0,0,0.5)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
(0.25,0,0;0,.5,0;0,0,0.25)
-convolve[0] [-1]
-convolve[1] [-1]
-rm[-1]
-endl
-endl
-split[0] c
-name[0] red -name[1] green -name[2] blue
-name[3] redblur -name[4] greenblur -name[5] blueblur
--div[redblur] [blueblur]
-replace_nan 0
--mul[blue] [-1]
-add[-1] [red]
--div[blueblur] [redblur]
-replace_nan 0
--mul[red] [-1]
-add[-1] [blue]
-keep[1,-1,-3]
-reverse[0,1]
-append c
-endl
--l[0]
(.33,0,0,0,0;0,.66,0,0,0;0,0,-2,0,0;0,0,0,.66,0;0,0,0,0,.33)
-convolve[0] [1]
-rm[1]
-abs
-split c
-rm[1]
-max
-endl
--l[1]
(0,0,0,0,.33;0,0,0,.66,0;0,0,-2,0,0;0,.66,0,0,0;.33,0,0,0,0)
-convolve[0] [1]
-rm[1]
-abs
-split c
-rm[1]
-max
-endl
-blur[-1,-2] 2
-sub[-1,-2]
-gt[-1] 0
-mul[-1] 255
-append[1,2] c
-blend alpha,1,0
--l[0]
-split[0] c
-add[0,2]
-mul[0] 0.5
-reverse
## -remove[-2,-4]
-nm[0] green -nm[1] magenta
[0] [1]
-nm[-2] greenblur -nm[-1] mblur
(0.25;.5;0.5;.5;0.25)
-convolve[mblur] [-1] -rm[-1]
(0.5;1;0.5)
-convolve[greenblur] [-1]
-rm[-1]
--div[greenblur] [mblur]
-replace_nan 0
-nm[-1] mmul
-rm[greenblur,mblur]
-mul[magenta] [mmul]
-keep[green,magenta]
-add
-endl
--l[0]
-split[0] c
-add[0,2]
-mul[0] 0.5
-reverse
## -remove[-2,-4]
-nm[0] green -nm[1] magenta
[0] [1]
-nm[-2] greenblur -nm[-1] mblur
(0.25,.5,0.5,.5,0.25)
-convolve[mblur] [-1] -rm[-1]
(0.5,1,0.5)
-convolve[greenblur] [-1]
-rm[-1]
--div[greenblur] [mblur]
-replace_nan 0
-nm[-1] mmul
-rm[greenblur,mblur]
-mul[magenta] [mmul]
-keep[green,magenta]
-add
-endl
-sub 1000
-c 0,255
--l[0,1]
-rgb2bayer[0] $1,1
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
-convolve[0] [-1]
-convolve[2] [-1]
-remove[-1]
-add[0] [3]
-add[2] [3]
-remove[1,4,5,6]
-reverse[1,2]
-append c
-endl
-l[0,2]
-rgb2bayer[0] $1,1
--to_rgb[1]
-rgb2bayer[-1] $1,1
-split[0] c
-split[-1] c
-sub[0] [4]
-sub[2] [6]
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
-convolve[0] [-1]
-convolve[2] [-1]
-remove[-1]
-add[0] [3]
-add[2] [3]
-remove[1,4,5,6]
-reverse[1,2]
-append c
-endl
-rm[1]
-replace_inf 255
-replace_nan 0
-reverse
-l[0]
--blur $2
-sub[0] [1]
-add[0] 128
-endl
-l[2]
--blur $2
-sub[0] [1]
-add[0] 128
-endl
-l[0,2]
-nozip $3
-endl
-l[-1,-2]
--l[0]
--l
-split c
-add
-div 3
-endl
-sub
--blur 3
-sub
-abs
-split c
-max
-endl
--l[1]
--l
-split c
-add
-div 3
-endl
-sub
--blur 3
-sub
-abs
-split c
-max
-endl
-l[-1,-2]
-blur 2
-sub
-gt 0
-mul 255
-endl
-append[1,2] c
-blend alpha,1,0
-endl
-sub[0] 128
-add
-c 0,255
",16,0
-crop 0,0,{$cropwidth-1},{$cropheight-1}
time=$|
spot_mask:
-to_gray[-1]
--resize[0] {w/$1},{h/$1},1,3,2
--iain_pixel_denoise[-1] 1,0
-sub[-1] [-2]
-abs[-1]
-remove[1]
-threshold[-1] $2%
-to_gray[-1]
-dilate_circ[-1] $3
-n 0,255
-resize[-1] {0,w},{0,h},1,3,3
-keep[-1]
spot_mask_preview:
--spot_mask $1,$2,$3
-n[-1] 0,255
-add[0] [1]
-keep[0]
-n 0,255
star_tone:
sx1=50
sx2=194
sx3=281
sx4=511
sx5=742
sx6=829
sx7=972
sx8=829
sx9=742
sx10=511
sx11=281
sx12=192
sy1=450
sy2=633
sy3=849
sy4=817
sy5=849
sy6=633
sy7=450
sy8=267
sy9=50
sy10=83
sy11=50
sy12=267
level=10
-luminance
--l
-rm
2000,2000,1,1,0
-repeat 8
-polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level
sx2={$sx2+40}
sx6={$sx6-40}
sx8={$sx8-40}
sx12={$sx12+40}
sy2={$sy2-23}
sy4={$sy4-47}
sy6={$sy6-23}
sy8={$sy8+23}
sy10={$sy10+47}
sy12={$sy12+23}
level={$level+25}
-done
-n 0,255
-resize 200,200,1,1,3
--shift[0] -69,-40,0,0
--shift[0] -69,40,0,0
--shift[0] 69,-40,0,0
--shift[0] 69,40,0,0
-add
-crop 5,5,142,84
-endl
-resize[-1] $1,$1,1,1,2
width={w}
height={h}
w_tiles={0,round(w/$width)}
h_tiles={0,round(h/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
-append_tiles[1--1] $w_tiles,$h_tiles
-equalize[-1] 256
-blend alpha,0.5,1
-gt 128
-mul 255
iain_turbulent_halftone:
-if {$8>0}
--iain_fast_denoise $8,0,1,0,0
-sub[1] [0]
-mul[1] -1
-add
-endif
-if {$7==1}
-rgb2cmyk
-endif
-if {$7==2}
-luminance
-endif
-split c
-repeat $! -local[$>]
--l[0]
-channels 0
tsize={min($5,w,h)}
xtile={(round(w/$tsize))+1}
ytile={(round(h/$tsize))+1}
$tsize,$tsize
-gimp_seamless_turbulence[-1] $1,$2,$3,$4,.25,0
[-1]x{$xtile*$ytile}
-append_tiles[1--1] $xtile,$ytile
-remove[-1]
-crop[-1] 0,0,{0,w},{0,h}
-keep[-1]
-endl
-blur[-1] $6
-equalize[-1] 256
-blend alpha,0.5,1
-gt 128
-mul 255
-endlocal -done
-append c
-if {$7==1}
-cmyk2rgb
-endif
iain_turbulent_halftone_preview:
-iain_turbulent_halftone $1,$2,$3,$4,{0,w},$6,$7,$8
jeje_render3d:
W={0,w}
1,2,1,4 -f[-1] $9,$13,$10,$14,$11,$15,$12,$16 -resize[-1] {0,w},{0,h},1,4,5
-blend alpha
-i "$1" -a[1--1] z
-l[-1]
-if $17 -display_volume $2,$3,$4 -else  -boundingbox3d 20 -endif
-rotate3d 0,0,1,$7
-rotate3d 0,1,0,$6
-rotate3d 1,0,0,$5
-c3d -n3d -*3d {3*$W*$8/4}
-endl
-object3d[0] [1],50%,50%,0,1
-n 0,255
-rm[1]
jeje_render3d_preview:
-jeje_render3d $"*"
jeje_deconvolve:
-if {$2==1}
-deconvolve_goldmeinel[0] [1],$1 -n[0] 0,255
-else
-deconvolve_richardsonlucy[0] [1],$1 -n[0] 0,255
-endif
jeje_deconvolve_preview:
-gimp_split_preview "-jeje_deconvolve $1,$2,$3",$4
jpr_about : -gimp_logo "@jayprich filters"
#@gmic jpr_colourillusion :
#@gmic : Use -d0 ( or -w -1,-1,0 -d ) to avoid normalisation of colours
#@gmic : optical illusion involving color spirals
#@gmic : visual "green arm" and "blue arm" contain the same color
jpr_colourillusion :
-v -
arm={$1*1.5-1}
{w},{h},1,1,A=10+atan2(x-{w/2},y-{h/2})*$arm/pi;R=sqrt((x-{w/2})^2+(y-{h/2})^2)/$2+A;(int(A+R/$arm)+int(R*6-A/$arm)%2)%3
(250,200,0^20,200,190^160,100,150)
-map[-2] [-1]
-k[-2]
-v +
#@gmic jpr_coltexindex :
#@gmic : Enrich colour with local analysis of luminance and index the image.
#@gmic : $ -jpr_coltexindex
jpr_coltexindex : -skip ${7=1}
-e[^-1] "Index colour and texture of image$? with $1 types ($2,$3) v ($4,$5) x $6 and Smoothness $8 Black $9 Mid $10 White $11"
-v -
-repeat $!
-l[$<]
-rgb2yuv -s c
--b[-3] $8
--ge[-1] $10
--le[-2] $11
-ge[-3] $9
-b[-5,-4] $12
-if $13
-gradient[-6] xy,4
-a[-7,-6] c
-norm[-6]
-b[-6] $14
-else
--b[-6] {$14*0.5}
--[-7,-1]
-sqr[-6]
-b[-6] {$14}
-sqrt[-6]
-endif
-n[-6] 0,1
-*[-6] $15
---[-6] {-6,i(0.01*w*$2,0.01*h*$3)}
-*[-1] {i(0.01*w*$4,0.01*h*$5)}
---[-6] {-6,i(0.01*w*$2,0.01*h*$3)}
-*[-1] {i(0.01*w*$4,0.01*h*$5)}
-+[-2,-1]
---[-5] {-5,i(0.01*w*$2,0.01*h*$3)}
-*[-1] {i(0.01*w*$4,0.01*h*$5)}
-+[-2,-1]
-/[-1] {i(0.01*w*$4,0.01*h*$5)+0.00001}
-c[-1] 0,1
-*[-1] $6
-a[-7--5,-1] c
--[-4] 2
-*[-4,-1]
-+[-3] 2
-*[-3,-2]
--colormap[-2] $1,1,1
-index[-3] [-1]
-rm[-1]
-*[-2] 2
-+[-2,-1]
-n 0,255
-to_rgb
-if $7
-circle $2%,$3%,1%,1,,64,128,255
-circle $4%,$5%,1%,1,,255,64,128
-endif
-endl
-done
-v +
#@gmic jpr_decimate :
#@gmic : Rescale in linear RGB space by cropping the frequency domain weighted
#@gmic : to decrease high frequency akin to Lanczos window on Sinc lobes
#@gmic : This filter discards the alpha channel
#@gmic : High sharpness just crops frequency and gives bad halo
#@gmic : $ -jpr_decimate 0.375,2
jpr_decimate : -skip ${1=0.375},${2=5}
-e[^-1] "Decimate scale $1 sharpness $2"
-v -
-srgb2rgb
-repeat $!
-l[$<]
nw={round($1*w/2)}
nh={round($1*h/2)}
sc={4*$nw/w*$nh/h}
mid={round(0.5/$1-0.5)}
-shift -$mid,-$mid
-fft
-shift $nw,$nh,0,0,2
-z 0,0,{2*$nw-1},{2*$nh-1}
-shift -$nw,-$nh,0,0,2
-f i*min(1,abs(2*x/w-1)*$2)*min(1,abs(2*y/h-1)*$2)
-ifft
-rm[-1]
-* $sc
-endl
-done
-rgb2srgb
-v +
blend_shapeaverage : -blend shapeaverage0
#@gmic :: Input/Output
#@gmic tiff3d
#@gmic : Input a 3D tif as a 3D image
#@gmic : Note: This is useful for loading several 3D image stack
tiff3d : -e[^-1] "Load the file $1 as a 3D image"
-v - n=$!
-i $1 -a[{$n}--1] z
-v +
#@gmic toff3d
#@gmic : Output a 3D tif as a 3D image
toff3d : -e[^-1] "Save the 3D image as a tiff file"
-v -
-repeat $!
-o[$>] ${"-filename \"$1\","$>}
-done
-v +
#@gmic :: 3D Rendering
#@gmic boundingbox3d : _separation
#@gmic : Bounding box of a 3D volume
#@gmic : $ 100,100,100 -boundingbox3d
boundingbox3d : -skip ${1=10}
-e[^-1] "3D Bounding box"
-v - -repeat $! -l[$>]
-box3d {0,w},{0,h},{0,d} -primitives3d[-1] 1  -opacity3d[-1] 1
-if {$1>0}
-plane3d {0,w},{0,h},$1,{round({0,h}/{0,w}*$1)} -primitives3d[-1] 1 -opacity3d[-1] .1
-endif
-rm[0] -+3d
-endl -done -v +
#@gmic render_volume  : _size,_quality,_opacity
#@gmic : Pseudo volumic rendering
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -render_volume
render_volume: -check "${1=8}>3&${2=5}>2&${3=.1}>0"
-v - -repeat $! -l[$>]
-mirror x
--tones {$2+1} -rm[1,2] -r[1--1] 100%,100%,100%,{0,s} -*[1--1] [0] -rm[0]
-reverse
-repeat $! i=$< -l[$<]
-if {im!=iM}
-pointcloud3d -gaussians3d $1,{$3*($i+1)/$2}
-else
-rm
-endif
-endl -done
-+3d -md3d -1 -+3d {.5},{.5},{.5}
-endl -done -v +
#@gmic display_volume : _size,_quality,_opacity
#@gmic : Display the volume with black background, a bounding box
#@gmic : and a volumic rendering of the data.
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -display_volume 8,5,.1
display_volume: -check "${1=8}>3&${2=5}>2&${3=.1}>0"
-e[^-1] "display_volume with size $1 quality $2 and opactiy $3"
-v - -repeat $! -l[$>]
--boundingbox3d 20
-render_volume[0] $1,$2,$3
-+3d
-endl -done -v +
d3d_black : 1 -d3d[0--2] [-1] -rm[-1]
#@gmic view3d : _angle1,_angle2
#@gmic : Apply a 3D view defined by two angles
#@gmic : $ 50,50,50,3 -noise 10 -blur 5 -max 0 -n 0,255 -display_volume 32,5,1 -view3d
view3d : -skip ${1=25},${2=-120}
-e[^-1] "Apply 3D view"
-v - -repeat $! -l[$>]
-rotate3d 0,0,1,$1 -rotate3d 1,0,0,$2
-endl -done -v +
#@gmic colordepth
#@gmic : Color depth coding
#@gmic : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -colordepth 5
colordepth: -skip ${1=5}
-e "colordepth coding with lut $1"
-v - -repeat $! -l[$>]
-colordepth_volume $1 -s z -+
-endl -done -v +
#@gmic colordepth_volume
#@gmic : Make a 3D volume of the same size, color it, resize orignal in color and multiply
colordepth_volume: -skip ${1=5}
-v - -repeat $! -l[$>]
-i [0] -f[-1] 'z/(d-1)*255' -map[-1] $1 -resize[0] 100%,100%,100%,3 -*
-endl -done -v +
colordepth_scale: -skip ${1=5}
10,{0,h-10} -f[-1] '(h-y)/(h-1)*255' -map[-1] $1 -frame[-1] 5,5,0,0,0
#@gmic make_axis: _xmin,_xmax,_ymin,_ymax
#@gmic : Display an axis around an image
#@gmic : $ image.jpg -make_axis 0,1,0,1
make_axis:
-e[^-1] "Add axis"
-v - -repeat $! -l[$>]
-frame 1,1,0
100%,24,1,3,255 -axes[-1] $1,$2,{-1},{-1}
24,{0,h},1,3,255 -axes[-1] {w},{w},$4,$3 24,24,1,3,255 -a[-1,-2] y
-a[0,1] y -reverse -a[0,1] x
-frame 12,12,255 100%,5,1,3,255,255,255 -reverse -a y
-endl -done -v +
#@gmic xlabel: _label
#@gmic : Add a label to the x-axis (see make_axis)
#@gmic : $ image.jpg -make_axis 0,1,0,1 -xlabel "x-axis"
xlabel:
-e[^-1] "Add a x label"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negative[-1] --lt[-1] 90%
-image[0] [-2],{{0,w}/2+12-{1,w}/2},{{0,h}-{1,h}},0,0,1,[-1] -k[0]
-endl -done -v +
#@gmic ylabel: _label
#@gmic : Add a label to the y-axis (see make_axis)
#@gmic : $ image.jpg -make_axis 0,1,0,1 -ylabel "y-axis"
ylabel:
-e[^-1] "Add a y label"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negative[-1]
-rotate[-1] -90 --lt[-1] 90%
-image[0] [-2],0,{{0,h}/2-12-{1,h/2}},0,0,1,[-1] -k[0]
-endl -done -v +
#@gmic title: _label
#@gmic : Add a title (see make_axis)
#@gmic : $ image.jpg -make_axis 0,1,0,1 -title "title"
title:
-e[^-1] "Add a title"
-v - -repeat $! -l[$>]
0 -text[-1] "$1",0,0,18,1,255,255,255 -negative[-1] --lt[-1] 90%
-image[0] [-2],{{0,w}/2-{1,w}/2},0,0,0,1,[-1] -k[0]
-endl -done -v +
#@gmic :: Feature detections
#@gmic quiver2d
#@gmic : Display a sequence 2D vector field on a 2D image sequence
#@gmic : both being represented az a 3D stack
quiver2d:
-e[^-1] "Cumulative sum along z-axis"
-s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1],10,1,1,1,255 -endl -done -rm[{$!/2}--1] -a z
#@gmic warp2d :
#@gmic : Warp a 2D image stack using a vector field
#@gmic : $ movie.cimg  -a z -resize 50%,50% --l[0] --lucas_kanade 5,1 -cumulate[-1] z -frame 30,30,0 -warp2d -endl -frame[0] 30,30,0 -a x
warp2d:
-s z -repeat {$!/2} -l[$>,{$>+$!/2}] -warp[0] [1],1,1,1 -endl -done -rm[{$!/2}--1] -a z
#@gmic lucas_kanade: scale,smoothing
#@gmic : Motion estimation using lucas and kanade approach
#@gmic : Works on 2D+t image stacks/ has side effect
#@gmic : [vx vy] = [Ixx Ixy; Ixy Iyy]^-1 [Ixt Iyt]
#@gmic : $ image.jpg -repeat 20 --shift[-1] 1,0,0,0,2 -done -a z --lucas_kanade 2 -n 0,255 -frame 2 -a x
#@gmic : $ image.jpg -repeat 20 --shift[-1] 1,1,0,0,2 -done -a z --lucas_kanade 2  -s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1] -endl -done -rm[{$!/2}--1] -a z
lucas_kanade: -skip ${1=2},${2=1}
-e[^-1] "Motion estimation with Lucas et Kanade algorithm"
-v - -repeat $! -l[$>]
-blur_xy $2 -structuretensors 0 -blur_xy $1,$1,0
--l -s c -rm[0,-1] -*[1,2] -*[0,2] -reverse -- -endl
--l[0] -s c -rm[3,5] -*[0,3] -*[1,2] -- -endl
-l[0] -s c -rm[2,4,5] -*[0,2] -sqr[1] -- -endl
-/[1,2] [0]  -rm[0] -a c
-endl -done -v +
#@gmic unwarp : _iteration,_smoothness,is_multi_scale
#@gmic : Unwarp a 2D+T volume using a motion estimation
#@gmic : $ image.jpg -repeat 20 --shift[-1] 1,0,0,0,2 -done -a z -unwarp 10,20
unwarp: -skip ${3=1}
-e[^-1] "Unwarp an 2d+t volume"
-v - -repeat $! -l[$>]
[0] 100%,100%,100%,2,0
-repeat $1
-if {$3==0} s=1 -else  s={($>+1)/$1} -endif  scale={$s*100}%
--l[1]
-luminance -r $scale,$scale,100%,1,2 -lucas_kanade {max(.75,$2*$s)}
-* {1/$s} -cumulate z
-endl
-r[-1] [-2],5  -+[-1,-2]
--l[0,-1] -warp2d -endl -rm[1] -reverse[-1,-2]
-done -rm[0,2]
-endl -done -v +
#@gmic estimate_shift_core [image]
#@gmic : Estimate a translation with a reference images with sub-pixel accuray
#@gmic : image.jpg  -luminance --shift {u},{u},0,0,2 -estimate_shift[1] [0]
estimate_shift_core:
-e[^-1] "Translation estimation with Lucas et Kanade algorithm"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
-blur_xy 1 --gradient[0] xy,0 --[0,1] --sqr[1,2] --*[1,2] [0] -*[1,2] -rm[0]
Ixy={0,ia} Ixx={1,ia} Iyy={2,ia} Ixt={3,ia} Iyt={4,ia}
vx={-($Iyy*$Ixt-$Ixy*$Iyt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
vy={-($Ixx*$Iyt-$Ixy*$Ixt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
-rm 1,2,1,1,$vx,$vy
-endl -done -v +
#@gmic multi_resolution_pyramide : _number_of_scales
#@gmic : Build a multi-resolution pyramid
multi_resolution_pyramide:
-v - -repeat $! -l[$<]
-repeat {$1-1} --resize[-1] 50%,50%,50%,100%,2 -done -reverse
-endl -done -v +
#@gmic shift_subpixel : [image]
#@gmic : Shift an image with subpixel translation
#@gmic : $ image.jpg 1,2,1,1,5,10.1 --shift_subpixel[0] [1]
shift_subpixel :
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
{0,w},{0,h},1,2 -f[-1] 'if(c==0,{1,i(0)},{1,i(0,1)})'
-warp[0] [2],1,2,1 -rm[1,2]
-endl -done -v +
#@gmic estimate_shift [image]
#@gmic : Estimate a translations between image and ref image [image]
#@gmic : using a multi-resolution scheme
#@gmic : $ image.jpg -luminance --shift 2,3 -crop 5%,5%,95%,95% -estimate_shift[1] [0],3
estimate_shift:
-e[^-1] "Estimate translation between images and image [$1]"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
N={round(log2(min({0,w},{0,h}))-2,1,-1)}
-multi_resolution_pyramide $N
1,2
-repeat 3 -repeat $N
--*[-1] {-2.0^(-($N-$>-1))} --shift_subpixel[{$N+$>}] [-1] -rm[-2]
-estimate_shift_core[-1] [$>]
-*[-1] {2.0^($N-$>-1)}
-+[-1,-2]
-done -done
-k[-1] -*[-1] -1
-endl -done -v +
#@gmic unshift : iterations,number_of_scales
#@gmic : Correct drift along Z in a 3D volume (video stabilization)
#@gmic : $ image.jpg  -luminance -repeat  10 --shift[-1] {2*u},{2*u},0,0,2 -done -a z --unshift 1 -a x
unshift: -skip ${1=1}
-e[^-1] "unshift image stack"
-v - -repeat $! -l[$>]
-repeat $1
-s z -repeat {$!-1} -l[$>,{$>+1}]
--estimate_shift[1] [0] -*[-1] -1
-shift_subpixel[1] [-1] -rm[-1]
-endl -done -a z
-done
-endl -done -v +
#@gmic register_lucas_kanade : _iterations, _scale
#@gmic : Register images using lucas kanade motion estimation
#@gmic : $ movie.cimg -luminance -resize 50%,50% -a z -register_lucas_kanade 5,10
register_lucas_kanade : -skip ${1=10},${2=10}
--lucas_kanade $2 -cumulate[-1] z --warp2d
-repeat $1
-lucas_kanade[-1] $2 -cumulate[-1] z -+[-1,-2] --warp2d
-done
#@gmic detect_events : _scale_xy,_scale_t,_threshold
#@gmic : Detect space time events using space time interest points
#@gmic : $ 100,100,100 -noise 1 -blur 2 --detect_events , -pointscoordinates[-1] -resize[0] 100%,100%,100%,3,1 -n[0] 0,255 -circles[0] [1] -k[0]
detect_events : -skip ${1=1},${2=1},${3=9}
-e[^-1] "detect events with scale_xy $1 scale_z $2 and threshold $3"
-v - -repeat $! -l[$>]
-blur_xy $1 -blur_z $2 -structuretensors -blur_xy $1 -blur_z $2
-s z -apply_parallel "-eigen -k[0] -s c -k[2]" -a z
-sqrt
thres={{0,ia}+$3*sqrt({0,iv})}
--max_patch[0] 8 -threshold[0] $thres -*
-endl -done -v +
#@gmic detect_spots : _scale,_threshold
#@gmic : Detect spots in the image
#@gmic : $ 100,100 -noise .2,2 -blur 1 -n 0,255 -noise 5 --detect_spots , -pointscoordinates[-1] -resize[0] 100%,100%,1,3,1 -circles[0] [1] -k[0]
detect_spots : -skip ${1=1},${2=4}
-e[^-1] "detect events with scale $1 and threshold $2"
-v - -repeat $! -l[$>]
-blur $1 --blur $1 -- thres={$2*${-mad[0]}}
--max_patch[0] 3 --threshold[0] $thres -*
-endl -done -v +
#@gmic measure_colocalization:
#@gmic : Colocalization analysis
#@gmic : Overlap RG/R RG/G RG/R+G MOC M1 and M2
#@gmic : $ 256,256,1,2 -noise 3 -blur 5 -measure_colocalization
measure_colocalization:
-v - -repeat $! -l[$>]
-if {{0,s}==2}
-s c --gt 0 --sqr[0,1] --*[0] [1] --*[2] [3] --or[2] [3]
O1={{7,is}/{2,is}}
O2={{7,is}/{3,is}}
O={{7,is}/{8,is}}
-*[2] [1] -*[3] [0]
MOC={{6,is}/sqrt({4,is}*{5,is})}
M1={{3,is}/{0,is}}
M2={{2,is}/{1,is}}
-rm  1,6,1,1,$O1,$O2,$O,$MOC,$M1,$M2
-else
-echo "needs images with two channels"
1,6,1,1,0,0
-endif
-endl -done -v +
#@gmic measure_colocalization_object:
#@gmic : Compute the number of intersecting objects
#@gmic : in each channels versus the number of objects
#@gmic : $ 256,256,1,2 -noise 3 -blur 5 -gt 0 -measure_object_colocalization
measure_object_colocalization:
-v - -repeat $! -l[$>]
-if {{0,s}==2}
-gt 0 -s c -label_fg .1
n1=0 -repeat {0,iM}
--eq[0] {$>+1} -*[-1] [1]
-if  {iM>0} n1={$n1+1} -endif
-rm[-1]
-done
n1={0,100*$n1/iM}
n2=0 -repeat {1,iM}
--eq[1] {$>+1} -*[-1] [0]
-if  {iM>0} n2={$n2+1} -endif
-rm[-1]
-done
n2={1,100*$n2/iM}
-rm
1,2,1,1,$n1,$n2
-else
-echo "needs images with two channels"
1,6,1,1,0,0
-endif
-endl -done -v +
#@gmic local_moments : _scale
#@gmic : Compute local second order moments tensor
#@gmic : http://en.wikipedia.org/wiki/Image_moment
#@gmic : $ image.jpg --local_moments 1
local_moments : -skip ${1=1}
-v - -repeat $! -l[$>]
-norm
-if {d==1}
--mul[0] 'x'   --mul[0] 'y'   --mul[0] 'x*x'
--mul[0] 'x*y' --mul[0] 'y*y' -blur $1
--sqr[1] -/[-1] [0] --[3,-1] -/[3] [0]
--*[1,2] -/[-1] [0] --[4,-1] -/[4] [0]
--sqr[2] -/[-1] [0] --[5,-1] -/[5] [0]
-k[3-5] -a c
-else
--mul[0] 'x'   --mul[0] 'y'   --mul[0] 'z'   --mul[0] 'x*x'
--mul[0] 'x*y' --mul[0] 'x*z' --mul[0] 'y*y' --mul[0] 'y*z'
--mul[0] 'z*z' -blur $1
--sqr[1] -/[-1] [0] --[4,-1] -/[4] [0]
--*[1,2] -/[-1] [0] --[5,-1] -/[5] [0]
--*[1,3] -/[-1] [0] --[6,-1] -/[6] [0]
--sqr[2] -/[-1] [0] --[7,-1] -/[7] [0]
--*[2,3] -/[-1] [0] --[8,-1] -/[8] [0]
--sqr[3] -/[-1] [0] --[9,-1] -/[9] [0]
-k[4-9] -a c
-endif
-endl -done -v +
#@gmic smooth_moments : _scale,_iterations,_dt
#@gmic : Anisotropic diffusion using local moment tensors
#@gmic : $ image.jpg --noise 10 --smooth_moments[-1] 1,10,1 -print_psnr
smooth_moments: -check "${1=1}>0&${2=100}>0&${3=1}>0"
-v - -repeat $! -l[$>]
--local_moments[-1] $1 -smooth[0] [1],$2,$3,0 -k[0]
-endl -done -v +
#@gmic pointscoordinates
#@gmic : Return the list of points in the image as 3xN or 2xN columns vector
#@gmic : $ 100,100 -noise .1,2 --pointscoordinates
pointscoordinates :
-e[^-1] "return the list of points in the image"
-v - -repeat $! -l[$>]
-if {d>1}
-if {iM>0} -pointcloud3d -s3d -k[2] -split y,{h/3} -a x -else 0 -endif
-else
-if {iM>0} -pointcloud3d -s3d -k[2] -split y,{h/3} -a x -else 0 -endif
-rows 0,1
-endif
-endl -done -v +
#@gmic circles : [x,y,radius,opacity,color,..] ||  [x,y,z,radius,opacity,color,..]
#@gmic : Draw circles on an image
#@gmic : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 -circles[0] [1] -k[0]
circles: -skip ${2=3},${3=1}
-e[^-1] "Draw circles on the image."
-v -  -pass$1 0 -repeat {$!-1} -l[$>,-1]
-if {{0,d}>1}
-if {1,h<4} -r[1] 100%,{5+{0,s}},1,1,0 -l[1] -s y -f[3] $2 -f[4] $3 -f[5--1] 255 -a y -endl -endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} o={1,i($>,4)} i=$>
-repeat {0,s}
-if {$z>=0&$z<{0,d}-1}
-sh[0] $z,$z,$> -ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,5+$>)}
-rm[-1]
-endif
-done
-done
-else
-if {1,h<3} -r[1] 100%,{4+{0,s}},1,1,0 -l[1] -s y -f[2] $2 -f[3] $3 -f[4--1] 255 -a y -endl -endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} o={1,i($>,3)} i=$> col={1,i($>,4)}
-repeat {0,s}
-sh[0] 0,0,$> -ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,{4+$>})}
-rm[-1]
-done
-done
-endif
-endl -done -rm[-1] -v +
#@gmic labels: [image]
#@gmic : Draw labels on the image
#@gmic : The labels are defined by image as
#@gmic : in 2D [x,y,label,font_size,opacity,color]
#@gmic : in 3D [x,y,z,label,font_size,opacity,color]
#@gmic : $ 512,512,1,3 10,2 -noise[-1] 1 -n[-1] 0,512 -labels[0] [1]
labels:
-e[^-1] "Draw labels on the image."
-v -  -pass$1 0 -repeat {$!-1} -l[$>,-1]
-if {{0,d}>1}
-if {1,h<4}
-r[1] 100%,{6+{0,s}},1,1,0
-l[1] -s y -f[3] 'x' -f[4] 13 -f[5] 1 -f[6--1] 255 -a y -endl
-endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} f={1,i($>,4)} o={1,i($>,5)} i=$>
-repeat {0,s}
-if {$z>=0&$z<{0,d}}
-sh[0] $z,$z,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,6+$>)}
-rm[-1]
-endif
-done
-done
-else
-if {1,h<3}
-r[1] 100%,{5+{0,s}},1,1,0 -l[1] -s y -f[2] 'x' -f[3] 13 -f[4] 1 -f[5--1] 255 -a y -endl
-endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} f={1,i($>,3)} o={1,i($>,4)} i=$>
-repeat {0,s}
-sh[0] 0,0,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,5+$>)}
-rm[-1]
-done
-done
-endif
-rm[-1]
-endl -done -v +
#@gmic : croparound : [x,y,dx,dy] || [x,y,z,dx,dy,dz]
#@gmic : Draw circles on an image
#@gmic : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 -circles[0] [1] -k[0]
croparound: -skip ${2=3},${3=3},${4=3}
-e[^-1] "Crop image at coordinates "
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
-if {0,d>1}
-if {1,h<6}
-r[1] 100%,6,1,1,0
-l[1] -s y -f[3] $2 -f[4] $3 -f[5] $4 -a y -endl
-endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} dx={1,i($>,3)} dy={1,i($>,4)} dz={1,i($>,5)} i=$>
--crop[0] {$x-$dx},{$y-$dy},{$z-$dz},{$x+$dx},{$y+$dy},{$z+$dz}
-done
-else
-if {1,h<4} -r[1] 100%,4,1,1,0 -l[1] -s y -f[2] $2 -f[3] $3 -a y -endl -endif
-repeat {1,w}
x={1,i($>,0)} y={1,i($>,1)} dx={1,i($>,2)} dy={1,i($>,3)} i=$>
--crop[0] {$x-$dx},{$y-$dy},{$x+$dx},{$y+$dy}
-done
-endif
-endl -done -rm[0,1] -v +
#@gmic random_walks : width,height,length,number,speed
#@gmic : Generate random walks tracks (list of coordinates x,y,t as a Nx3 image.)
#@gmic : $ 100,100,20 -random_walks 100,100,20,5,1 -circles[0] [1] -k[0] -blur_xy 1 -s z -max
#@gmic : $ 100,100,20 -random_walks 100,100,20,10,1 -circles[0] [1] -k[0] -blur 1 -n 0,255 -display_volume 8,10,1 -rotate3d 0,0,1,25 -rotate3d 1,0,0,-120 -snapshot3d 600,1,0,0,0 -autocrop
random_walks :
number=$4 width=$1 height=$2 length=$3 speed=$5
$number,3
-l[-1]
-noise 1,1
-sh 0,0,0,0 -n[-1] 1,{$width-1} -rm[-1]
-sh 1,1,0,0 -n[-1] 1,{$height-1} -rm[-1]
-sh 2,2,0,0 -f[-1] 0 -rm[-1]
-repeat {$length-1} --l[-1]
-noise 1
-sh 0,0,0,0 -c[-1] 1,{$width-2} -rm[-1]
-sh 1,1,0,0 -c[-1] 1,{$height-2} -rm[-1]
-sh 2,2,0,0 -f[-1] '$>+1' -rm[-1]
-endl -done -a x
-endl
#@gmic fibers: number,length,curvature
#@gmic : Draw a serie of fibers in 2D or 3D
#@gmic : $ 600,400 -pelotte 10,200,10
fibers :
-repeat $! -l[$>]
$2,$1,1,{if(d>1,3,2)}
-l[-1] -noise[-1] 10 -blur_x[-1] $3 --norm -/ -endl
-if {0,d>1} -s[-1] c -*[3] {0,2*d/(w+h)} -a[1--1] c -endif
-cumulate[-1] x -s[-1] y
-repeat {$!-1}
-l[0,{$>+1}]
-s c
-+[1] {0,w/2}
-+[2] {0,h/2}
-if {$!>3} -+[3] {0,d/2} -endif
-a[1--1] y
-circles[0] [1],0,-1
-endl
-done
-k[0]
-endl -done
#@gmic :: Filtering and deconvolution
#@gmic movavg : _size>=1
#@gmic : moving average of image list with a box filter of size _size
#@gmic : $ 11 -f 'x>w/2' --l[-1] -s x -movavg 9 -a x -endl  --blur[0] 1.2 -a c -display_graph
movavg : -check "$1>=1"
-e[^-1] "moving average with size "$1 -v -
n={$1-1}
-repeat $n
-repeat {{$!}-1} --+[{$>},{$>+1}] -*[-1] .5 -rm[$>] -mv[-1] $> -done
-reverse
-done
-if {$n%2!=0} -reverse -endif
-v +
#@gmic zmean
#@gmic : average along z-axis
zmean :
-v - -repeat $! -l[$>]
n={0,d} -s z -+ -/ $n
-endl -done -v +
#@gmic zstd
#@gmic : standard deviation along z-axis
zstd :
-v - -repeat $! -l[$>]
--zmean -sqr[-1]
-l[0] -sqr -zmean -endl
-- -sqrt
-endl -done -v +
#@gmic zmax
#@gmic : maximum along z-axis
zmax :
-v - -repeat $! -l[$>] -s z -max -endl -done -v +
#@gmic zmin
#@gmic : maximum along z-axis
zmin :
-v - -repeat $! -l[$>]  -s z -min -endl -done -v +
#@gmic kymoline:
#@gmic : interactively select a line and extract a line profile
kymoline:
--select 1
x1={i(0,0)} y1={i(0,1)} x2={i(0,3)} y2={i(0,4)}
d={sqrt(($x2-$x1)^2+($y2-$y1)^2)}
u={($x2-$x1)/$d} v={($y2-$y1)/$d}
-rm[-1]
-f 'if(x<=$d&&y==0,i($x1+x*$u,$y1+x*$v,z,c,1),5)'
-crop 0,0,{int($d-1)},0
#@gmic fftshift
#@gmic : Shift a image so that the fft has it center in the middle
#@gmic : $ image.jpg -fftshift
fftshift :
-v - -repeat $! -l[$>]
-shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
-endl -done -v +
#@gmic whiten_frequency : _alpha
#@gmic : Whitening filter (equalize the frequency of the image; nothing todo with color)
#@gmic : $ image.jpg -whiten_frequency
whiten_frequency : -check "${1=.25}>=0"
-e[^-1] "Whiten the frequency with parameter "$1
-v - -repeat $! -l[$>]
-fft --a c -norm[-1] -pow[-1] $1 -max[-1] 1e-12 -/[-1] {ia} -/[0-1] [2] -rm[2] -ifft -k[0]
-endl -done -v +
#@gmic deblur_goldmeinel2 : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur and zoom x2 selected images using Gold-Meinel algorithm
#@gmic : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_goldmeinel2[-1] 1
deblur_goldmeinel2 : -check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1} -skip ${5=1}
-e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${-arg\ 1+!$4,"",quasi-}"gaussian kernel."
-v - -repeat $! -l[$>]
[0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
--b[-1] $1,1,$4 -r[-1] 50%,50%,50% --/[0,-1] -rm[-2] -^[-1] $3 -r[-1] 200%,200%,200%,100%,5 -*[-1,-2]
-done -rm[0]
-endl -done -v +
#@gmic deblur_richardsonlucy2 : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur and zoom selected images using Richardson-Lucy algorithm.
#@gmic : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_richardsonlucy2[-1] 1
deblur_richardsonlucy2 : -check "$1>=0 && ${2=50}>=0" -skip ${3=1} -skip ${4=1}
-e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${-arg\ 1+!$3,"",quasi-}"gaussian kernel."
-v - -repeat $! -l[$>]
[0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
--b[-1] $1,1,{$3!=0} -r[-1] 50%,50%,50%,100%,5 --/[0,-1] -rm[-2] -r[-1] 200%,200%,200%,100%,5 -b[-1] $1,1,{$3!=0}  -*[-1,-2]
-done -rm[0]
-endl -done -v +
#@gmic correlate_fft
#@gmic : Convolve selected images with image [$1]
#@gmic : $ image.jpg 100%,100% -gaussian[-1] 20,1,45 --correlate_fft[0] [1]
correlate_fft :
-e[^-1] "Correlate image with image [$1]"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
w2={int({0,w}/2)} h2={int({0,h}/2)} d2={int({0,d}/2)}
-r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5  -shift[1] -$w2,-$h2,-$d2,0,2
-fft[0] -fft[2] -*[3] -1
--*[-4] [-1] --*[-4] [-3] -+[-2,-1]
-*[-5,-3] -*[-3,-2] --[-3,-2]
-ifft -rm[-1]
-endl -done -v +
#@gmic deconvolve_richardsonlucy : filter,nb_iter>=1, acceletation>=0
#@gmic : Deconvolve images using the first one as a blur operator (PSF)
#@gmic : $ image.jpg 16,16 -gaussian[-1] 2,1,45 --convolve_fft[0] [1] -deconvolve_richardsonlucy[-1] [1],100
deconvolve_richardsonlucy : -check ${-is_image_arg\ $1}" && ${2=5}>=1"
-e[^-1] "Deblur image using Richardson-Lucy algorithm with filter [$1]."
-v - -pass$1 0
-repeat {$!-1} -l[$>,-1]
-r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1] [0]
-repeat $2
--convolve_fft[-1] [1] -max[-1] 1e-6 --/[0] [-1] -rm[-2]
-correlate_fft[-1] [1] -*[-1,-2]
-done -rm[0,1]
-endl -done -v +
#@gmic deconvolve_goldmeinel : filter,nb_iter>=1,acceleration>=0
#@gmic : Deblur and zoom selected images using Gold-Meinel algorithm
#@gmic : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@gmic : $ image.jpg 100%,100% -gaussian[-1] 5,1,45 --convolve_fft[0] [1] --deconvolve_goldmeinel[-1] [2],5
deconvolve_goldmeinel : -check ${-is_image_arg\ $1}" && ${2=5}>=1 && ${3=1}>=1"
-e[^-1] "Deblur image using Gold-Meinel algorithm with filter $1, $2 iterationsand acceleration $3."
-v - -pass$1 0
-repeat {$!-1} -l[$>,-1]
-r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1] [0]
-repeat $2
--convolve_fft[-1] [1] -max[-1] 1e-6 --/[0] [-1] -rm[-2]
-^[-1] $3 -*[-1,-2]
-done -rm[0,1]
-endl -done -v +
#@gmic blend_sharpness
#@gmic : Blend images in the list according to their sharpness
blend_sharpness:
-e[^-1] "Blend images according to their sharpness"
-v -
N=$! --gradient_norm
--+[$N--1] -max[$N--1] .01 -/[$N--2] [-1] -rm[-1] -a[$N--1] z -d[-1] -s[-1] z
-a[0-{$N-1}] x -a[1--1] x -* -s x,$N -+
-v +
#@gmic reconstruct_laplacian : param
#@gmic : Reconstruct an image from its laplacian
#@gmic : $ image.jpg --laplacian -reconstruct_laplacian[-1] ,
reconstruct_laplacian: -skip ${1=0}
-e[^-1] "Reconstruct an image from its laplacian"
-v - -repeat $! -l[$>]
-s c -repeat $! -l[$>]
-fft a={0,i(0,0)} b={1,i(0,0)}
100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
-=[-1] 1 -+[-1] $1
-/[0,1] [-1] -k[0,1] -=[0] $a -=[1] $b -ifft -k[0]
-endl -done -a c
-endl -done -v +
#@gmic local_variance : _radius,_robust
#@gmic : Local variance filter
#@gmic : $ image.jpg  --local_variance
local_variance: -skip ${1=2},${2=0}
-e[^-1] "Estimate local variance with scale "$1" and robustness "$2
-v - -repeat $! -l[$>]
-if {$2==0}
--blur $1,1,1 -- -sqr -blur $1,1,1
-else
--median {2*$1+1} -- -abs -median {2*$1+1} -* 1.4826 -sqr
-endif
-endl -done -v +
#@gmic local_noise_variance : _radius,_robust
#@gmic : Local noise variance filter
#@gmic : $ image.jpg  --local_variance
local_noise_variance: -skip ${1=2},${2=0}
-e[^-1] "Estimate local variance with scale "$1" and robustness "$2
-v - -repeat $! -l[$>]
-laplacian -if {d==1} -* {1/sqrt(20)} -else -* {1/sqrt(42)} -endif -local_variance $1,$2
-endl -done -v +
#@gmic normalize_local_variance : _amplitude,_radius,_threshold,_repeat
#@gmic : Local variance normalization
#@gmic : $ image.jpg  --normalize_local_variance
normalize_local_variance: -skip ${1=50},${2=2},${3=25},${4=1}
-e[^-1] "Normalize local variance with amplitude $1, scale $2, threshold $3 (x$4 times)."
-v - -repeat $! -l[$>]
-repeat $4
--local_variance $2 -sqrt[-1] -max[-1] $3
--blur[0] $2,1,1 ---[0,-1] -/[-1] [1] -*[-1] $1 -+[-2,-1] -k[-1]
-done
-endl -done -v +
#@gmic local_wiener : _radius
#@gmic : Local Wiener filtering
#@gmic : http://en.wikipedia.org/wiki/Wiener_filter
#@gmic : $ image.jpg --noise 10 --local_wiener[-1] 1 -print_psnr
local_wiener : -skip ${1=2}
-e[^-1] "Local Wiener filtering"
-v - -repeat $! -l[$>]
sigma=${-noise_std}
--blur $1
--local_variance[0] $1 ---[-1] {$sigma*$sigma} -reverse[-1,-2] -/[-1,-2]
---[0,1]
-*[-1,-2] -+[-1,-2] -k[-1]
-endl -done -v +
#@gmic periodize
#@gmic : Periodization of the image
#@gmic : $ image.jpg -periodize
periodize :
-e[^-1] "periodize"
-v - -repeat $! -l[$>]
-if {w>1} --mirror x -a x -endif
-if {h>1} --mirror y -a y -endif
-if {d>1} --mirror z -a z -endif
-endl -done -v +
#@gmic tape
#@gmic : Apply a Hann window (e.g. to compute a power spectrum)
#@gmic : $ image.jpg -tape
tape :
-e[^-1] "apply a Hann tapering window"
-v - -repeat $! -l[$>]
-if {w>1} -f 'i*sin(pi*x/(w-1))^2' -endif
-if {h>1} -f 'i*sin(pi*y/(h-1))^2' -endif
-if {d>1} -f 'i*sin(pi*z/(d-1))^2' -endif
-endl -done -v +
#@gmic powerspectrum :
#@gmic : Compute power spectrum
#@gmic : $ image.jpg -powerspectrum
powerspectrum :
-e[^-1] "Compute power spectrum"
-v - -repeat $! -l[$>] -display_fft -k[0] -endl -done -v +
#@gmic fouriermix : [image],_cut_of_frequency
#@gmic :  Mix two images using their respectives low and high frequencies
#@gmic : $ image1.jpg image2.jpg  --fouriermix .5
fouriermix : -skip ${2=10%}
-e[^-1] "fourier mix images."
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
-fft[0] -fft[2] -fftshift
100%,100% -circle[-1] 50%,50%,$2,1,1 -blur[-1] 1,1,1 -n[-1] 0,1 -d
-*[0,1] [-1] -negative[-1] -*[2,3] [-1] -rm[-1] -+[0,2] -+[1,2] -fftshift
-ifft
-endl -done -rm[-1] -v +
#@gmic blend_fft: [image]
#@gmic : blend images using strongest frequencies
blend_fft : -skip ${2=2}
-v - -pass$1 0
--l[-1]
-tape -powerspectrum -blur 1 --blur 2 --
-max '{ia+$2*sqrt(iv)}' -circle 50%,50%,20,1,@{0,im} -n 0,1 -d
-fftshift
-endl -fft[-2] -*[-2,-3] [-1] -negative[-1]
-repeat {$!-3} -l[$>,-1,-2,-3]
-fft[0] -*[0,1] [-1] -+[0] [2] -+[1] [3] -ifft[0,1] -rm[1]
-endl -done -rm[-1,-2,-3] -v +
#@gmic denoise_fft : _threshold
#@gmic : Illustrate the thresholding of Fourier coefficients
#@gmic : $ 256,256 -f '128+128*sin(x+y)' --noise 50 --denoise_fft[-1] 70%
denoise_fft : -skip ${1=1}
-e[^-1] "Threshold Fourier coefficients with threshold "$1"."
-v - -repeat $! -l[$>]
--l[-1] -tape -powerspectrum -threshold $1 -fftshift -endl
-fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft -k[0]
-n 0,255
-endl -done -v +
#@gmic unstrip : _smoothness,_scale,_threshold
#@gmic : Remove stripes in an image
#@gmic : $ image.jpg -f '.5*i*(1+.25*sin(x))' --unstrip
unstrip : -skip ${1=25},${2=20},${3=4}
-e[^-1] "Remove stripes"
-v - -repeat $! -l[$>]
--l[-1]
-tape -powerspectrum -norm -detect_spots 1,$3 -dilate_circ $2 -gt 0
-n 0,1 -negative -circle 50%,50%,$2,1,1
-if {im<.9}
active=1 -blur $1 -n 0,1 -fftshift -if {iM==0} -f 1 -endif
-else
active=0
-endif
-endl
-if {$active==1}
-fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft
-endif
-k[0]
-endl -done -v +
#@gmic autocorrelate
#@gmic : Autocorrelation using fourier transform
#@gmic : $ image.jpg -autocorrelate
autocorrelate :
-e[^-1] "Compute autocorrelation"
-v - -repeat $! -l[$>] -fft -sqr -+ -sqrt -ifft -k[0] -fftshift -endl -done -v +
#@gmic spotify : _scale>0,_nb_iter>0,
#@gmic : Make everything look like a spot
#@gmic : Default values '_nb_iter=1, _scale=1'
#@gmic : $ image.jpg --spotify 1,10
#@gmic : $ image.jpg --spotify 1,20 -norm[-1] -gt[-1] 5% -blur 1 -*
spotify : -check "${1=1}>0 && ${2=1}>0"
-e[^-1] "Spotify with scale $1 with $2 iterations"
-v - -repeat $! -l[$>]
-if {0,im!=iM}
s={0,ia}
-repeat $2
-b $1 --b {2*$1} -- -max 0 -* '{0,$s/ia}'
-done
-endif
-endl -done -v +
#@gmic mapblur : _levels
#@gmic : Blur the image with a map
#@gmic : $ image.jpg --f '10*x/w' -mapblur
mapblur: -check "${1=10}>0"
-e[^-1] "Blur images using a blur map (works using pairs of images)."
-v - -repeat {$!/2} -l[{2*$>},{2*$>+1}]
smin={1,im} smax={1,iM}
-l[0] -repeat $1 --blur[0] {$smin+$>*($smax-$smin)/($1)} -done -rm[0] -a z -endl
-l[1] -tones $1 -gt 0 -blur 1 -a z -endl
-* -s z -+
-endl -done -v +
#@gmic vesselness : _scale>0,coefA,coefB,coefC
#@gmic : Frangi's vesselness filter based on the eigen value of the Hessian
#@gmic : Reference:
#@gmic : A. F. Frangi, W. J. Niessen, K. . L. Vincken, M. A. Viergever,
#@gmic : "Multiscale vessel enhancement filtering"
#@gmic : Medical Image Computing and Computer Assisted Intervention MICCAI'98,
#@gmic : vol. 1496, pp. 130 137, 1998.
#@gmic : $ vessel.png --negative -vesselness[-1] 3
vesselness : -skip ${1=1},${2=1},${3=1},${4=1}
-e[^-1] "Tubeness with scale $1."
-v - -repeat $! -l[$>]
-blur $1
-s c -repeat $! -l[$>]
-hessian -a c -eigen -k[0] --sign -abs[-2] -sort[-2] +,c -* --norm -a c
-if {d>1}
-f 'if(i(x,y,z,1)<0&&i(x,y,z,2)<0,exp(-0.5/$2^2*(i(x,y,z,1)/i(x,y,z,2))^2)*exp(-0.5/$3^2*(i(x,y,z,0)^2/abs(i(x,y,z,1)*i(x,y,z,2))))*(1-exp(-0.5/$4^2*i(x,y,z,3)^2)),0)'
-else
-f 'if(i(x,y,z,1)<0,exp(-0.5/($2)^2*(i(x,y,z,0)/i(x,y,z,1))^2)*(1-exp(-0.5/($3)^2*i(x,y,z,2)^2)),0)'
-endif
-endl -done -a c
-endl -done -v +
#@gmic bgsubstract : _length>0
#@gmic : Substract the background using a temporal top-hat filter
#@gmic : $ 100,100,100 -noise 1 -blur 1 --bgsubstract 10
bgsubstract:  -check "${1=5}>0"
-e[^-1] "Temporal background substraction with length $1."
-v - -repeat $! -l[$>]
1,1,$1 -f[-1] 1 --erode[0] [1] --[0] [-1] -rm[1,-1]
-endl -done -v +
#@gmic schizo : _amplitude,_amplitude_normal,_nb_iterations,_strength
#@gmic : Schizo filter gives either a furry image or a smoothed image
#@gmic : Default values '_amplitude=100,amplitude_normal=-50 _nb_iter=5,_strength=.75'
#@gmic : $ image.jpg --schizo 100,-50 --schizo[0] -50,100 -max 0
schizo : -skip ${1=100},${2=-50},${3=5},${4=.75}
-e[^-1] "Schizo filter smoothing with // $1 and T $2 and $3 iterations."
-v - -repeat $! -l[$>]
[0]
-repeat $3
-l[-1]
--iee -*[-1] {$1/(0.0001+max(abs(im),abs(iM)))}
--inn[0] -*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}
-+
-endl
-*[-1] $4  --*[0] {1-$4} -+[-1,-2]
-done -rm[0]
-endl -done -v +
#@gmic scandoc : _smooth,_background,_black,_white
#@gmic : improve scanned document
#@gmic : $ image.jpg -scandoc
scandoc: -skip ${1=3},${2=100},${3=10%},${4=90%}
-v - -repeat $! -l[$>] -split_opacity -l[0]
-median $1 --blur $2 -- -min 0
-s c -n 0,1 -a c -c $3,$4 -n 0,255
-endl -a c -endl -done -v +
#@gmic warp_affine [3x3 affine matrix]
#@gmic : Warp the image [0] using an 2D affine field defined by a 3x3 matrix
#@gmic : $ image.jpg 3,1,1,1,1 -diagonal[-1] -noise[-1] .1 --warp_affine[0] [1]
warp_affine :
-e[^-1] "Warp image using affine transform defined by 3x3 image ["$1"]"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
params=({1,i(0,0)},{1,i(1,0)},{1,i(2,0)};\
{1,i(0,1)},{1,i(1,1)},{1,i(2,1)};\
{1,i(0,2)},{1,i(1,2)},{1,i(2,2)})
{0,w},{0,h},1,1,1 --f[-1] x --f[-1] y -a[-3--1] c
-mix_channels[-1] $params
-channels[-1] 1,2
-warp[0] [-1],0,2,0 -rm[-1]
-endl -done -rm[-1] -v +
#@gmic solve_least_square: X
#@gmic : Solves $|Ax-b|^2$
#@gmic : $  (1,1,1,1;1,2,1,2;1,1,2,2) (-1,1,0;-2,0,1) -mmul[1] [0] -solve_least_square[0] [1]
solve_least_square:
-e[^-1] "Solves least square"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
--transpose --mmul[0,2] --mmul[0,3]
-k[-1,-2] -invert[0] -mmul -transpose
-endl -done -v +
#@gmic calibrate_affine_transform : image
calibrate_affine_transform :
-e[] "Interactive affine transformation calibration between image and image $1"
-e[] "- Use mouse button 1 to select matching points on the two images."
-e[] "- Use mouse button 2 to remove points in the list"
-e[] "- Press Space to re-init the list of points"
-e[] "- Close the window to finish\n"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1] -reverse
0 0 (1,0,0;0,1,0;0,0,1) Z=0
-do
x1={*1,x} y1={*1,y}
x2={*2,x} y2={*2,y}
-if {$x1>=0}
-if {{*1,b}&1}
(1;{$x1/{*1,w}*{0,w}};{$y1/{*1,h}*{0,h}})
-if {2,h>1} -a[2,-1] x -else -rm[2] -mv[-1] 2 -endif
-else
-if {{*1,b}&2}
-if {2,w>1} -columns[2] 0,{2,w-2} -else -rm[2] 0 -mv[-1] 2 -endif
-endif
-endif
-endif
-if {$x2>=0}
-if {{*2,b}&1}
(1;{$x2/{*2,w}*{1,w}};{$y2/{*2,h}*{1,h}})
-if {3,h>1} -a[3,-1] x -else -rm[3] -mv[-1] 3 -endif
-else
-if {{*2,b}&2}
-if {3,w>1} -columns[3] 0,{3,w-2} -else -rm[3] 0 -mv[-1] 3 -endif
-endif
-endif
-endif
-if {{*0,SPACE}" || "{*1,SPACE}" || "{*2,SPACE}} -rm[2,3,4] 0 0 (1,0,0;0,1,0;0,0,1) -endif
-if {*1,o} Z={max(0,min({0,d}-1,$Z+{*1,o}))} -wait -1 -endif
-if {*2,o} Z={max(0,min({0,d}-1,$Z+{*2,o}))} -wait -1 -endif
-if {*3,o} Z={max(0,min({0,d}-1,$Z+{*3,o}))} -wait -1 -endif
N={min({2,w},{3,w})}
-if {{2,h}>1" && "{3,h}>1}
-if {$N<=3}
-rm[4] --l[2,3]
-rows 1,2 -columns 0,{$N-1} -- -s x -+ -/ $N
(1,0,0;{-i(0,0)},1,0;{-i(0,1)},0,1) -rm[-2]
-endl
-else
-rm[4] --l[2,3] -columns 0,{$N-1} -solve_least_square[0] [1] -rm[1] -endl
-endif
-endif
--l[0,2]
-if {{0,d}>1} -slices[0] $Z -endif
-r[0] 200%,200%,1,1,5
-r[0] 100%,100%,1,3,0 -grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
-if {1,h>1} -rows[1] 1,2  -*[1] 2
1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  -circles[0] [1]
-labels[0] [1] -endif -w1[0] -1,-1,-1,-1,"First image (n="{1,w}")" -rm
-endl
--l[1,3]
-if {{0,d}>1} -slices[0] $Z -endif
-r[0] 200%,200%,1,1,5
-r[0] 100%,100%,1,3,0  -shift[0] 0,0,0,1 -grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
-if {1,h>1} -rows[1] 1,2 -*[1] 2
1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  -circles[0] [1]
-labels[0] [1] -endif -w2[0] -1,-1,-1,-1,"Second image (n="{1,w}")" -rm
-endl
--l[0,1,4]
-if {{0,d}>1} -slices[0,1] $Z -endif
-warp_affine[1] [2] -rm[2] -a c
-r[0] 200%,200%,1,100%,5
-grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
-w3 -1,-1,-1,-1,"merge "$N" Z="$Z -rm
-endl
-wait
-while {{*1}" && "!{*1,Q}" && "!{*1,ESC}" && "{*2}}
-w1[] 0 -w2[] 0 -w3[] 0
-k[-1]
-endl -done -v +
#@gmic vobs : _scale
#@gmic : Motion quantity (Normal motion)  h * (|Ixy|^2 |It|/|Ixy|) / h * Ixy^2
#@gmic : Irani, Michal and Rousso, Benny and Peleg, Shmuel, Detecting and tracking multiple moving objects using temporal integration, ECCV'92.
#@gmic : $ 100,100,10 -noise 1 -blur 1 --vobs
vobs : -check "${1=1}>0 && ${2=3}>0"
-e[^-1] "Motion quantity with scale $1"
-v - -repeat $! -l[$>]
-gradient -a[0,1] c -norm[0] -abs[1] -*[1] [0] -sqr[0] -blur $1,1,1 -reverse -max[1] 5% -/
-endl -done -v +
#@gmic display_vobs
#@gmic : Display local diffusion coefficient
#@gmic : $ 200,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_vobs
display_vobs :
--vobs 1 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1] 100%,{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Vobs ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x
#@gmic display_pseudocolor : predefined_palette
#@gmic : Display an indexed image in pseudocolors using a palette
#@gmic : $ image.jpg -luminance -display_pseudocolor
display_pseudocolor : -skip ${1=5}
-e[^-1] "Display an indexed image in pseudocolors using map "$1
-v - -repeat $! -l[$>]
A={round(im,0.0001)} B={round(iM,0.0001)}
-n[-1] 0,255 -map[-1] $1
-rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
-add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},$A,$B,6,255
-endl -done -v +
#@gmic display_colordepth : _dz
display_colordepth :
-e[^-1] "display the 3D image with a depth color coded."
-v - -repeat $! -l[$>]
H={d*$1} -colordepth , -a z -min {ia+10*sqrt(iv)} -n 0,255 -s z
-rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
-add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},0,$H,6,255
-endl -done -v +
#@gmic map_hilo
#@gmic : Map a grascale image to a RGB with maw in red and min in blue
#@gmic : This help to check if images are saturated
map_hilo:
-v - -repeat $! -l[$>]
-round m={0,im} -- $m
1,1,1,3,0,0,{0,iM} {0,iM-1},1,1,3,'x+1' 1,1,1,3,{0,iM},0,0 -a[1,2,3] x
-map[0] [1]
-+ $m -rm[1]
-endl -done -v +
#@gmic add_colorbar : x0,y0,x1,y1,_min,_max,_ntics,color,colormap
#@gmic : Add a colorbar
#@gmic : $ image.jpg -luminance -map 5 -add_colorbar {w-40},20,{w-30},{h-20},0,255,6,255,5
add_colorbar : -skip ${5=0},${6=255},${7=6},${8=255},${9=""},${10=5}
-e[^-1] "Add a colorbar"
-v - -repeat $! -l[$>]
{$3-$1},{$4-$2} -l[-1] -f 'h-y' -n 0,255 -map $10 -endl
-frame[1] 1,1,$8 -image[0] [1],$1,$2,0,0,1 -k[0]
-repeat $7
val={round($5+$>/($7-1)*($6-$5),.001)}
-text "- "$val" "$9,{$3+1},{$4-$>*($4-$2-5)/($7-1)-10},13,1,$8
-done
-endl -done -v -
#@gmic local_diffusion_coefficient : _scale,_threshold
#@gmic : Estimate local diffusion coefficient It - D (Ixx+Iyy)=0 using D=It/(Ixx+Iyy)
#@gmic : $ 100,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -local_diffusion_coefficient 2,.5
local_diffusion_coefficient : -check "${1=2}>0 && ${2=.5}>=0"
-e[^-1] "Local diffusion coefficient estimation using scale $1 and threshold $2"
-v - -repeat $! -l[$>]
--l[0] -s z -laplacian -a z -endl
--l[0] -s z -gradient_norm -a z -sqr -endl
-gradient[0] z,1
-l[0,1]
R={1,ia+$2*sqrt(iv)}
-a c -f 'b=i(x,y,z,0);a=i(x,y,z,1);if(abs(a)>abs(b),b/a,if(abs(b)>$R,1/(b/a),0))'
-channels 0
-endl
-*[0] [1] -blur $1,1,1 -max[1] {1,ia+$2*sqrt(iv)}  -/
-channels 0
-v + -endl -done
ldc :
-local_diffusion_coefficient $*
ldc_residuals :
--l[0] -s z -laplacian -a z -endl
-gradient[0] z,1
-*[1,2]
-- -abs -blur 1
#@gmic display_ldc :
#@gmic : Display local diffusion coefficient
#@gmic : $ 200,100 -noise .7,2 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_ldc
display_ldc :
--ldc 2,3 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1]
100%,{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Local diffusion coefficient ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x
#@gmic print_psnr : _max_value
#@gmic : Display the psnr on the image list taking the first one as a reference
#@gmic : $ image.jpg --noise 20 --blur[-1] 1 -print_psnr
print_psnr : -skip ${1=255}
-e[^-1] "Compute PSNR with image 0 and print it on the other images."
-v - --psnr $1
-repeat {$!-2} -text_outline[{$>+1}] "PSNR:"{round(i(0,$>+1),.01)}"dB",5,5,30,1 -done
-rm[-1] -v +
#@gmic noise_std
#@gmic : Estimate the noise variance
#@gmic : $ image.jpg -noise 10 sigma={round(${-noise_std},.1)} -text_outline "Noise std:"$sigma,5,5,30,1
noise_std :
-e[^-1] "Compute noise std."
-v - --laplacian -if {{0,d}==1}  -u {${-mad[-1]}/sqrt(20.0)} -else -u {${-mad[-1]}/sqrt(42.0)} -endif -rm[-1]
-v +
#@gmic pca
#@gmic : Principal component analysis
#@gmic : $ image2.jpg --l -split_tiles 64,64 -y y -a x -pca -k[-1] -s x -r 8,8,1,1,-1 -n 0,255 -frame 1,1,255 -append_tiles , -r[-1] 400%,400% -frame 0,20 -title dictionary -endl
pca :
-e[^-1] "Principal component analysis"
-v - -repeat $! -l[$>]
n={w} -- {ia} --transpose[-1] -**[-2,-1] -/ $n -eigen
-endl -done -v +
spca: -skip ${2=20}
-v - -repeat $! -l[$>]
-repeat $2
p={sqrt(h)}
--l --pca -k[0,-1]  -reverse -transpose[0] --** -threshold[-1] $1,1 -rm[1] -transpose[0] -** -endl
-*[0] .25 -*[1] .75 -+
-done
-pca
-endl -done -v +
#@gmic denoise_karmuen_loeve : _number_of_components
#@gmic : Denoise with a bloc Karumen-Loeve transform
#@gmic : http://en.wikipedia.org/wiki/Karhunen%E2%80%93Lo%C3%A8ve_theorem
#@gmic : $ image2.jpg --noise 10 --denoise_karmuen_loeve[-1] 8 -print_psnr
denoise_karmuen_loeve:
-v - -repeat $! -l[$>]
-split_tiles 64,64 oW={0,w} oH={0,h} oS={0,s}
-y y -a x --pca -k[0,-1] -reverse -crop[0] 0,$1
-transpose[0] --** -rm[1] -transpose[0] -** -s x
-resize $oW,$oH,1,$oS,-1 -append_tiles ,
-endl -done -v +
#@gmic denoise_patch_dict : _patch_size,_nb_of_shifts,_thres_comp,_thres_coef
#@gmic : Denoising using a dictionnary of patches learned on the image
#@gmic : $ image.jpg --noise 10 --denoise_patch_dict[1] , -print_psnr
denoise_patch_dict: -skip ${1=8},${2=8},${3=1.1},${4=1.1}
-e[^-1] "Denoising using a dictionnary of "$1"x"$1" patches with "$2" shifts, threshold $3x(noise std) for components and $4x(std) for coefficients."
-v - -repeat $! -l[$>]
Sigma=${-noise_std[0]}
--crop 0,0,$1,100% -mirror[-1] x -reverse --crop[-1] {w-$1-1},0,100%,100% -mirror[-1] x -a x
--crop 0,0,100%,$1 -mirror[-1] y -reverse --crop[-1] 0,{h-$1-1},100%,100% -mirror[-1] y -a y
oW={0,w} oH={0,h} oS={0,s} nW={$1*round($oW/$1,1,1)} nH={$1*round($oH/$1,1,1)}
--crop {2*$oW-$nW},0,100%,100% -mirror[-1] x -a x
--crop 0,{2*$oH-$nH},100%,100% -mirror[-1] y -a y
NtileX={round($nW/$1)}  NtileY={round($nH/$1)}
--l[-1]
-repeat $2
-if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} -else dx=0 dy=0 -endif
--shift[0] $dx,$dy,0,0,2
-split_tiles[-1] $NtileX,$NtileY pW={1,w} pH={1,h}
-done -rm[0]
-y y -a x n={w} -- 'ia' --transpose[-1] -**[-2,-1] -/ $n -eigen
-l[-2] -unroll x -sqrt -gt {$3*$Sigma} -f 'abs(i(x+1)-i(x))'
T={[xM,yM,zM,cM]} 4 -f[-1] $T T={i(0)} -endl
-if {$T==0} T=100% -endif -k[-1] -columns 0,$T
-endl
-repeat $2
-if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} -else dx=0 dy=0 -endif
--shift[0] $dx,$dy,0,0,2
-l[1,-1]
-l[1] -split_tiles $NtileX,$NtileY -unroll y -a x -endl
-transpose[0] --**
t=${-mad[-1]}
-f[-1] 'if(abs(i)<$4*$t,0,i)'
-rm[1] -transpose[0] --** -rm[-2]
-endl
-l[-1]
-s x -resize $pW,$pH,1,$oS,-1
-append_tiles $NtileX,$NtileY
-shift {-$dx},{-$dy},0,0,2
-endl
-done
-rm[0,1]
-+ -/ $2
-crop {$1+1},{$1+1},{$oW-$1-2},{$oH-$1-2}
-endl -done -v +
std_noise :
-v - --laplacian[-1] -u {${-mad[-1]}/sqrt(if(d==1,20,42))} -rm[-1] -v +
#@gmic iuwt : _nlevels>2,_spline>1
#@gmic : Compute the "isotropic undecimated wavelet transform" using
#@gmic : a trou algorithm for the B3-Spline wavelet.
#@gmic : The inverse is obtained as the sum of all coefficients
#@gmic : $ image.jpg -iuwt 4,1 -n 0,255 -append_tiles
#@gmic : $ image.jpg -iuwt 3,1 -+
iuwt: -skip ${1=3},${2=3}
-e[^-1] "Compute isotropic undecimated wavelet transform"
-v - -repeat $! -l[$<]
50
-l[-1]
-f 'if(x==w/2|x==w/2-1,1,0)' -i [0]
-repeat $2 -convolve[-1] [0] -done
-k[-1] -autocrop 0 -/ {ia*w}
-endl
-repeat {$1-1}
-l[-1,-2]
--convolve[0] [1]
-y[1] y -convolve[-1] [1]
---[0] [-1] -rm[0] -reverse
-endl
-l[-1] -y y 100% -a x -s y -s x -rm[-1] -a x -endl
-done
-rm[-1] -reverse
-endl -done -v +
#@gmic iuwt_std : _nlevels>2,_spline>1
#@gmic : Compute noise at each level of the iuwt
#@gmic : $ image.jpg -iuwt_std 10,10
iuwt_std:
-v - -repeat $! -l[$>]
sigma=${-noise_std}
-if 1
-f 1 -noise $sigma -iuwt $1,$2
-repeat $! -l[$>]
x={sqrt(iv)} -rm 1 -f $x
-endl -done -a x
-else -rm
50
-l[-1]
-f 'if(x==w/2|x==w/2-1,1,0)' -i [0]
-repeat $2 -convolve[-1] [0] -done
-k[-1] -autocrop 0 -/ {ia*w}
-endl
-sqr
alpha={is} -rm
$1,1,1,1,'$sigma*sqrt((1+$alpha)*$alpha^(w-x-1))'
-endif
-endl -done -v +
#@gmic denoise_iuwt:_threshold>0,_nlevels>2,_spline>1
#@gmic : Denoising by thresholding the coefficients of the
#@gmic : "isotropic undecimated wavelet transform"
#@gmic : $ image.jpg --noise 10 --denoise_iuwt[-1] , -print_psnr
denoise_iuwt: -check "${1=1.4}>0&&${2=4}>1&&${3=1}>0"
-e[^-1] "Denoise using the isotropic undecimated B"$3" spline wavelet transform"
-v - -repeat $! -l[$>]
--iuwt_std[0] $2,$3 -reverse
-iuwt[-1] $2,$3
-repeat {$!-2} -threshold[{$>+2}] {0,$1*i($>+1)},1 -done
-+[1--1]
-rm[0]
-endl -done  -v +
#@gmic noise_poisson_gaussian : gain,offset,noise_std
camera_noise:
-v - -repeat $! -l[$>]
-noise 0,3 -* $1 -+ $2 -noise $3
-endl -done -v +
#@gmic analyze_camera_noise :
analyze_camera_noise:
-v - -repeat $! -l[$>]
--local_noise_variance $1 -blur[0] $1 -y -a c
-display_parametric 800,600,.0,1,1,0,signal,noise
-endl -done -v +
#@gmic :: Segmentation
#@gmic contour2d: _tolerance
#@gmic : Draw a 2D contour of regions with tolerance _tolerance
#@gmic : Default value _tolerance=.1
#@gmic : $ image.jpg -norm -blur 1 -gt 50% --contour2d
contour2d: -skip ${1=.1}
-v - -f 'if(abs(i-j(1,1))>$1||abs(i-j(1,0))>$1,1,0)' -v +
#@gmic segment_snake : _nb_iter,_time_step,_lambda,_threshold,_smoothness
#@gmic : Segment an image using an adaptation of Chan and Vese's method.
#@gmic : Default values _nb_iter=10,_time_step=1,_smoothness=100,_threshold=50%
#@gmic : Reference Chan and L. Vese,Active contours without edges, IEEE transactions on image processing 10(2) (2001), pp. 266-277
#@gmic : $ 256,128 -text "GMIC",40,10,100,1,255 -blur 1 -noise 20 --segment_snake , -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_snake: -skip ${1=100},${2=1},${3=.1},${4=.1},${5=10},${6=0}
-e[^-1] "Segment the image using active contours without edges using $1 iterations and time step $2, smoothness $3 and initialize with threshold of $4."
-v - -repeat $! -l[$>]
-if {s>1} -luminance -endif
--blur $5 -gt[-1] {ia+$4*sqrt(iv)}
-l[-1] --distance 0 -negative[0] -distance[0] 0 -*[0] -1 -+ -endl
-repeat $1
--lt[-1] 0 -blur[-1] 1 --*[0,-1] swx={ia} sw={-2,ia} M1={$swx/$sw}
-sqr[-1] swx2={ia}  S1={max(1e-3,$swx2/$sw^2-$M1^2)} -rm[-1,-2]
--gt[-1] 0 -blur[-1] 1 --*[0,-1] swx={ia} sw={-2,ia} M2={$swx/$sw}
-sqr[-1] swx2={ia}  S2={max(1e-3,$swx2/$sw^2-$M2^2)} -rm[-1,-2]
--iee[-1]
--f[0] '(1.0/$3)*(((i(x,y)-$M1)^2)/$S1-((i(x,y)-$M2)^2)/$S2)'
-+[-2,-1]
-*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}
-+[-2,-1]
-if {$6==1}
--l -gt[1] 0 -contour2d[1] , -n 0,1 -a c -text $>,0,0,13,1,{iM} -w -wait 10  -rm -endl
-endif
-done
-blur[-1] 1 -gt[-1] 0 -rm[0]
-endl -done -v +
#@gmic segment_cells: scale1,scale2,threshold,size_threshold
#@gmic : Cell segmentation using watershed
#@gmic : $ 256,256 -noise .05,2 -blur 10,1,1 -min 80% -noise 5% --segment_cells 2,10% -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_cells: -skip ${1=3},${2=10},${3=1},${4=3}
-e[^-1] "Cell segmentation using difference of Gaussians and watershed"
-v - -repeat $! -l[$>]
-blur $1 --blur $2 -- --gt {ia+$3*${-mad}} -area_fg 0 -gt $4 --distance[1] 0
-max_patch[0] {round($4,1,1)} -*[0] [1] -label[0] 0 -watershed[0] [2] -rm[-1] -*
-endl -done -v +
#@gmic :: Patterns
_challenge:
108,86,1,3 -l[-1] -fractional_brownian_motion .25  -n 0,128 --norm -gt[-1] 60% -* -resize 1080,860,1,3,1  --l[-1] -blur 10 -shift[-1] 10,10 -endl -max -crop 10,10,100%,100% -negative -endl -n 0,255
#@gmic periodic_dots : _nb_angles,_scale,_start_angle
#@gmic : Generate a peridic dot pattern with 'nb angles', 'scale' and 'start angle'.
#@gmic : Default values 'nb angle=6', 'scale=4' and 'start_angle=0'
#@gmic : $ 64,64 -periodic_dots 3,6,.1 -repeat 34 -i [0] -done -append_tiles
periodic_dots : -skip ${1=6},${2=4},${3=.5}
-e[^-1] "Generate a periodic dot pattern with "$1" angles, scale "$2", and orientation "$3"."
-v - -repeat $! -l[$>]
-s c -repeat $! -l[$>]
--resize {max(w,h)},{max(w,h)},100%,100%,0
-l[-1]
-f 0
-repeat $1
-circle {w*(.5+.5/$2*cos(2*pi*($>+$3/180*pi)/$1))},{w*(.5+.5/$2*sin(2*pi*($>+$3/180*pi)/$1))},0,1,255
-done
-fft -a c -norm -fftshift -n 0,255
-endl
-resize[-1] [0],0
-k[-1]
-endl -done -a c
-endl -done -v +
#@gmic turing_pattern : iter,dt,a,b,q,r,D
#@gmic : Generate Turing pattern using a rection-diffusion equation
#@gmic : du/dt = au(1-qv) + v(1-ru)
#@gmic : dv/dt =  v(b-aquv) + u(-a+rv)
#@gmic : the two parameters q and r are dictating the pattern final shape
#@gmic : the diffusivity parameter influcences the scale
#@gmic : http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf
#@gmic : http://eprints.maths.ox.ac.uk/430/1/102.pdf
turing_pattern: -skip ${1=2000},${2=.1},${3=0.855},${4=-0.95},${5=2},${6=.1},${7=.5},${8=0}
-v - -repeat $! -l[$>]
-r 100%,100%,100%,2 -blur 1 -n 0,1
-repeat $1
-progress {$>/$1*100}
--laplacian[0] -mix_channels[-1] ($7,0;0,1)
--f[0] 'u=i(x,y,z,0);v=i(x,y,z,1);a=$3;b=$4;q=$5;r=$6;if(c==0,a*u*(1-q*v*v)+v*(1-r*u),v*(b+a*q*u*v)+u*(-a+r*v))'
-+[-1,-2]
-*[-1] {$2/(0.001+max(abs(im),abs(iM)))}
-+
-if {$8==1} --l -s c -n 0,1 -a c -text $> -w -rm -endl -endif
-done
-s c -n 0,1 -a c
-endl -done -v +
#@gmic rays : _center_x,_center_y,_scale,_phase
#@gmic : Generate rays patterns
#@gmic : $ image.jpg --rays 155,127,10,10 -n[-1] 0,1 -mul
rays :
-e[^-1] "Generate a ray pattern centered in ($1,$2)"
-f 't=atan2(y-$2,x-$1);sin($3*t+$4)'
#@gmic fractional_brownian_motion : 0<=_hurst_index<=1,_epsilon>0
#@gmic : Generate fractional brownian motion nd signal
#@gmic : Using a power low of the form (eps+|f|)^(-2^H-1)
#@gmic : where f is the module of the frequency, H the husrt index and eps _epsilon.
#@gmic : (see also -clouds)
#@gmic : $ 400,300 -fractional_brownian_motion
fractional_brownian_motion : -skip ${1=.5},${2=1} -check "$1>=0&&$1<=1" -check "$2>0"
-e[^-1] "Generate pseudo fractional brownian motion"
-v - -repeat $! -l[$>]
-f 0 -noise 1
-fft -fftshift
-if {{0,d}==1}
-f 'rx=x-w/2;ry=y-h/2;i*($2+sqrt(rx*rx+ry*ry))^(-2*$1-1)'
-else
-f 'rx=x-w/2;ry=y-h/2;rz=z-d/2;i*($2+sqrt(rx*rx+ry*ry+rz*rz))^(-2*$1-1)'
-endif
-fftshift -ifft
-k[0]
-endl -done -v +
#@gmic clouds : _density_of_blue_sky>0,_amplitude,0<=_hurst_index<=1,_epsilon>0
#@gmic : Generate clouds on the image (see also 'frational_brownian_motion')
#@gmic : $ 64,64 -repeat 3 --clouds {10+20*$>}% -done -rm[0]
clouds : -skip ${1=50%},${2=1},${3=.5},${4=1}
-e[^-1] "Generate a cloud"
-v - -repeat $! -l[$>]
-channels 0
-fractional_brownian_motion $3,$4 -negative -min $1 -negative -resize 100%,100%,1,4
-n 0,255 -s c -n[0-2] 190,255  -n[3] 0,255 -a c
-endl -done -v +
#@gmic clearbluesky:
#@gmic : Generate a Clear Blue Sky
#@gmic : $ 400,300,1,3 -clearbluesky --clouds 50% -blend alpha
clearbluesky :
-e[^-1] "Generate a blue sky"
-v - -repeat $! -l[$>]
1,2,1,3 -f[-1] '63,70,120,144,190,215' -resize[-1] [0],5 -k[-1]
-endl -done -v +
#@gmic ::  Colors
#@gmic wavelength_color: _wavelength
#@gmic : Convert a wavelength [380,780] to RGB color
#@gmic : from http://scienceprimer.com
#@gmic : $ 1,1,1,1,1 -repeat 100 --wavelength_color[0] {380+3*$>} -done -rm[0] -a x
wavelength_color:
-v -
-if {$1>=380&$1<440}
R={-1*($1-440)/(440-380)}
G=0
B=1
-elif {$1>=440&$1<490}
R=0
G={($1-440)/(490-440)}
B=1
-elif {$1>=490&$1<510}
R=0
G=1
B={-1*($1-510)/(510-490)}
-elif {$1>=510&$1<580}
R={($1-510)/(580-510)}
G=1
B=0
-elif {$1>=580&$1<645}
R=1
G={-1*($1-645)/(645-580)}
B=0
-elif {$1>=645&$1<780}
R=1
G=0
B=0
-else
R=0
G=0
B=0
-endif
-repeat $! -l[$>]
-mix_channels ($R;$G;$B)
-endl -done
#@gmic ::  GIMP
#@gmic jpr_gradient_smooth :
#@gmic : image and its gradient in x y are treated as solid angles
#@gmic : and locally smoothed on the surface of a sphere
#@gmic : which can retain bright/dark/bright sequences
jpr_gradient_smooth:
-v -
-repeat $!
-l[$>]
-norm
--g xy,0
-n[0] {$1-1},{$1+1}
-a c
-repeat 25
--norm
-/[0,1]
-b {w*$2/500}
-done
-f atan2(i,abs(i(x,y,0,0)))
-channels 1,2
-endl
-r 100%,100%,1,3,0,1
-n 0,255
-done
-v +
#@gmic jpr_line_edges : Angles,Blurring,AntiAlias
#@gmic : Similar in concept to a Hough Transform and voting
#@gmic : here multiple orientations are blurred a little
#@gmic : this augments line segments along the blur and suppresses
#@gmic : noise improving edge detection by finding
#@gmic : max gradient orthogonal to each linear blur
#@gmic : $ -jpr_line_edges 5,5,1
jpr_line_edges : -skip ${1=5},${2=5},${3=1}
-e[^-1] "Find edges in image$? using $1 angles per quadrant with $2 blurring and $3 anti-alias"
-v -
-repeat $! -l[$>]
-norm
-fft
100%,100%,1,1,x-w/2
100%,100%,1,1,y-h/2
-shift[2,3] {-round(w/2)},{-round(h/2)},0,0,2
100%,100%,1,1
-repeat {$1}
ac={3*cos(($>+0.5)*pi/$1/2)/sqrt(pi)*$2/w}
as={3*sin(($>+0.5)*pi/$1/2)/sqrt(pi)*$2/w}
--*[2] $ac
--*[3] $as
-+[-2,-1]
--sqr[-1]
-*[-1] -1
-exp[-1]
-*[-2,-1]
--mirror[-1] x
-*[-1] -1
[1]x1
-*[-1] -1
[0]x1
-*[-2,-1] [-4]
-rm[-4]
-ifft[-2,-1]
-rm[-1]
[1]x1
-*[-1] -1
[0]x1
-*[-2,-1] [-4]
-rm[-4]
-ifft[-2,-1]
-rm[-1]
-abs[-2,-1]
-max[-2,-1] $3
ac={round(1.45*cos(($>+0.5)*pi/$1/2))}
as={round(1.45*sin(($>+0.5)*pi/$1/2))}
--shift[-2] {-$ac},{-$as}
--shift[-3] {$ac},{$as}
--shift[-3] {$ac},{-$as}
--shift[-4] {-$ac},{$as}
-if $4
--max[-6,-4,-3]
--min[-7,-5,-4]
--[-2,-1]
-+[-5,-4]
-*[-4] 0.5
--[-6,-4]
-/[-5,-1]
--[-4] 0.1
-max[-4] 0
-*[-4] 2
--[4,-4]
--max[-3,-2,-1]
--min[-4,-3,-2]
--[-2,-1]
-+[-3,-2]
-*[-2] 0.5
--[-3,-2]
-/[-2,-1]
--[-1] 0.1
-max[-1] 0
-*[-1] 2
--[4,-1]
-else
-max[-4,-3]
-gt[-5,-3]
--[4,-4]
-max[-2,-1]
-gt[-2,-1]
--[4,-1]
-endif
-done
-rm[0,1,2,3]
-n 0,255
-endl -done
-v +
#@gmic jpr_orientedthinning:
#@gmic : Skeleton of a shape against a zero-value (pure-black) background using locally oriented local maxima to find only relevant ridges - not micro ridges from a noisy boundary.
#@gmic : $ -jpr_orientedthinning
jpr_orientedthinning :
-e[^-1] "Oriented Thinning image$? with Pre-Smooth $1, Propagate Direction $2, Threshold Width $3"
-repeat $!
-l[$<]
-norm
--b $1
-structuretensors[-1] 0
-mix_channels[-1] (1,0,-1)
-b[-1] $2
-le[-1] 0
-if $4
-rm[-2]
-* 255
-else
(1.1,0^0,1.1)
-map[-2] [-1]
-rm[-1]
-distance[-2] 0,$5
-max[-2] $3
--warp[-2] [-1],1
-*[-2] -1
--warp[-3] [-2],1
-rm[-3]
-max[-2,-1]
-gt[-2,-1]
-* 255
-endif
-endl
-done
-v +
#@gmic jpr_phasecongruence :
#@gmic : Edge detection via Phase Congruence method relies on low noise source and uses FFT to compute Local Energy.  This could be extended to apply to each channel in multiple orientations but for now we apply one orientation, ignore colour and delete the alpha channel.
#@gmic : $ -jpr_phasecongruence
jpr_phasecongruence :
-e[^-1] "Phase Congruence image$? with StartAngle $1, Directions $2, Threshold $3, IsLines $4"
-v -
-repeat $!
-l[$<]
-norm
100%,100%,1,1,0
-repeat $2
[0]x1
t={($1/180+$</$2)*pi}
a={cos($t)}
b={sin($t)}
-fft[2]
-mv[3] 2
100%,100%,1,1,sx=if(x>w/2,x-w,x);sy=if(y>h/2,y-h,y);if(abs($a*sx+$b*sy)>0.7,sign($a*sx+$b*sy),0)
-*[3] -1
-*[2,3] [4]
-rm[4]
-ifft[2,3]
-rm[3]
c={max(abs($a),abs($b))*.8}
-abs[2]
-max[2] $3
-if $4
a={$a/$c}
b={$b/$c}
-f[2] i>i(x+$a,y+$b)&i>i(x-$a,y-$b)
-endif
-+[1,2]
-done
-rm[0]
-n 0,255
-endl
-done
-v +
#@gmic jpr_remove_blocks1 : _spatial,_amplitude,_strength
#@gmic : remove block artefacts from smooth areas
#@gmic : spatial drives the size of blocks to try and fit
#@gmic : amplitude set to a minimum to catch only noise blocks
#@gmic : strength expect 70 but fine tune up or down
jpr_remove_blocks1 :
-v -
-repeat $! -l[$<]
-keep[0]
spatial=$1
amplitude=$2
strength=$3
--b[0] {$spatial*1.2} --b[0] {$spatial*0.8} --[1,2] [0]
-c[1,2] {-$amplitude},{$amplitude}
--==[1,2] {-$amplitude}
--==[1,2] {$amplitude} -or[3,4,5,6]
wh={w},{h}
-shift[1] 2,2
-r[1,2] {w/$spatial},{h/$spatial},1,3,2
-r[1,2] $wh
-shift[1] -2,-2
-c[1,2] {-$amplitude/2},{$amplitude/2}
--==[1,2] {-$amplitude/2}
--==[1,2] {$amplitude/2} -or[3,4,5,6,7]
-compose_channels[3] or
-blur[3] {2*$spatial} -threshold[3] 0.1
-blur[3] {2*$spatial}
--[3] 1
-+[1] [2] -rm[2]
-*[1] [2] -rm[2]
-*[1] {0.01*$strength}
--[0] [1] -rm[1]
-endl -done
-v +
#@gmic jpr_shapes_gradient :
#@gmic : lots of local regressions using shapeaverage
#@gmic : suppress noise in the gradients of small areas
#@gmic : random areas chosen by watershed
jpr_shapes_gradient:
-v -
-repeat $! -l[$<]
100%,100%,1,1,0.1*(x-w/2)
--norm[0]
-b[-1] $1
-segment_watershed[-1] $2,0
-gt[-1] 0
-*[1] [-1]
--blend_shapeaverage[1,-1]
--[1,-1]
--sqr[1]
[-2]x1
-blend_shapeaverage[-2,-1]
-+[-1] $3
-sqrt[-1]
-/[1,-1]
--blend_shapeaverage[0,-1]
-*[0] [-3]
-blend_shapeaverage[0,-2]
-c[0] -$4,$4
-*[0,1]
-+[0,1]
-c 0,255
-endl -done
-v +
#@gmic jpr_specularbumps :
#@gmic : Specular highlights as if the image has bumps based on luminance.  Ignores and deletes alpha channel.
#@gmic : $ -jpr_specularbumps
jpr_specularbumps :
-e[^-1] "Specular highlights image$? with GradientAngle $1, Pre-Smooth $2, GradientRange $3, AdjustAngle $4, IlluminationOffset $5, HighlightSize $6, Roughness $7, OutputType $8"
-v -
t={$1*pi/180}
a={cos($t)}
b={sin($t)}
-repeat $!
-l[$<]
-to_rgb
--b $2
-l[-1]
-norm
-gradient xy
-a c
-mix_channels ($a,$b;{-$b},$a)
-div $3
-c 0,1
--norm
-f[-1] "0.1/(0.1+i)"
-a c
--norm
-div[-2,-1]
-b 2
--norm
-div[-2,-1]
wh={w},{h},1,3
({cos((45+$4)*pi/180)*sin($5*pi/180)}^{sin((45+$4)*pi/180)*sin($5*pi/180)}^{cos($5*pi/180)})
-r $wh
--
-norm
-c $6,{$6+$7}
-* -1
-n 0,255
-endl
-if {$8==0}
-rm[-2]
-else
-if {$8==1}
-rm[-2]
100%,100%,1,3,255
-mv[-1] -2
-a[-2,-1] c
-else
-blend dodge
-endif
-endif
-endl
-done
-v +
#@gmic jpr_warpfromthreshold :
#@gmic : test trying to create a patch local warp effect
jpr_warpfromthreshold:
-v -
-repeat $!
-l[$>]
-norm
--g xy
-a[1,2] c
-ge[0] $1
-b[0] $2
-ge[0] 0.5
-f[0] i!=i(x+1,y)|i!=i(x,y+1)
-repeat $3
--norm[1]
-*[2] [0]
-a[1,2] c
-f[1] if(i(x,y,0,2)==0,i,i/i(x,y,0,2))
-channels[1] 0,1
-b[1] $4
-done
-rm[0]
-s c
-n 0,100
-a c
100,100,1,3,((x/2)%4)==0|(c==2&((y/2)%4)==0)
-warp[1] [0]
-rm[0]
-n 0,255
-endl
-done
-v +
karos_about :
-gimp_logo_version{round(u(0.5,3.49))} $_version [0] -*[-1] 0 -text[-1] "KaRo's",10%,22%,57,1,255 -text[-1] "Tests",40%,60%,57,1,200 --to_gray[-1] -skeleton[-1] , -n[-1--2] 0,255 -dilate[-2] 2 --[-1--2] -+ -n 0,255
#@gmic :: KaRo's Tests
#@gmic pseudo_c : Pseudo coloring of greyscale image
pseudo_c : -v - {iM},1,1,3,u(255) -round[-1] -map[-2] [-1] -rm[-1] -v +
#@gmic sincos : _w(512), _h(512)
#@gmic : testimage
#@gmic : Ex: -sincos , --shift. 50%,0,0,0,2 --shift.. 0,50%,0,0,2 -a c
sincos :
-skip "${1=512},${2=512}" -v - -l[]
$1,$2,1,1,'init(a=pi*w;b=pi*h);sin(a/(x+1))*cos(b/(y+1))'
--f. 'sign(i)' -eq. 1 --neq. 1 -*[1] [-3] -*. [-3] -n[-1,-2] 0,255
-f. 'if(i==255,0,i)' -or[-1,-2] -rm.. -nm. sincos -endl -v +
#@gmic karo_luminance : _type = [itur1990 | itur1990-2 | gmic | gmic-2]
#@gmic : Compute luminance of selected RGB images according
#@gmic :   itur1990 | itur1990-2 sqr/sqrt | gmic -luminance | sqr/sqrt gmic -luminance.
#@gmic : sRGB RGB and back only with gmic!
#@gmic : Default _type=itur1990
#@gmic : $ image.jpg --karo_luminance ,
karo_luminance : -skip ${1=itur1990}
-e[^-1] "Compute luminance $1 of image$?."
-v - -remove_opacity -if {['"$1"']=='gmic'" || "['"$1"']=='gmic-2'} -srgb2rgb -endif
-repeat $! -l[$>]
-if {s==3} -sh 0,0 -sh[0] 1,1 -sh[0] 2,2
-if   {['"$1"']=='gmic'} -*[1] 0.299 -*[2] 0.587 -*[3] 0.114 -+[1-3] -rm[1]
-elif {['"$1"']=='gmic-2'} -sqr -*[1] 0.299 -*[2] 0.587 -*[3] 0.114 -+[1-3] -sqrt -rm[1]
-elif {['"$1"']=='itur1990-2'} -sqr -*[1] 0.212655 -*[2] 0.715158 -*[3] 0.072187 -+[1-3] -sqrt -rm[1]
-else -*[1] 0.212655 -*[2] 0.715158 -*[3] 0.072187 -+[1-3] -rm[1] -endif
-elif {s!=1} -norm -n 0,255
-endif -endl -done
-channels 0
-if {['"$1"']=='gmic'" || "['"$1"']=='gmic-2'} -rgb2srgb -endif
-v +
#@gmic karo_close : '_size>0','_shape=0|1|2' (square|octagon|circle),'_invert=0|1','_scale=0|1',
#@gmic : '_channel=0..22' (All|RGBA|RGB|Luminance|Blue/red chrominances|Blue chrominance|Red chrominance|Lightness
#@gmic : |ab-components|a-component|b-component|Hue|Saturation|Value|Key|Green chrominance|ch-components|c-component|h-component|Red|Green|Blue|Alpha)
#@gmic : Morphological closing (dilate and erode) of given size (only 2d)
#@gmic :  with -gimp_morpho and implicitly apply_channels!
#@gmic : $ image.jpg  --karo_close 15 --karo_close[0] 15,1 --karo_close[0] 15,2 -rm[0]
karo_close :
-e "Compute closing image$?, with size $1 (only 2d)."
-skip ${1=5},${2=0},${3=0},${4=0},${5=0}
-gimp_morpho 3,$1,$3,$2,$5,$4
#@gmic karo_open : '_size>0','_shape=0|1|2' (square|octagon|circle),'_invert=0|1','_scale=0|1',
#@gmic : '_channel=0..22' (All|RGBA|RGB|Luminance|Blue/red chrominances|Blue chrominance|Red chrominance|Lightness
#@gmic : |ab-components|a-component|b-component|Hue|Saturation|Value|Key|Green chrominance|ch-components|c-component|h-component|Red|Green|Blue|Alpha)
#@gmic : Morphological opening (erode and dilate) of given size (only 2d)
#@gmic :  with -gimp_morpho and implicitly apply_channels!
#@gmic : $ image.jpg  --karo_open 15 --karo_open[0] 15,1 --karo_open[0] 15,2 -rm[0]
karo_open :
-e "Compute opening image$?, with size $1 (only 2d)."
-skip ${1=5},${2=0},${3=0},${4=0},${5=0}
-gimp_morpho 2,$1,$3,$2,$5,$4
#@gmic karo_doc : '_size>0','_shape=0|1|2' (square|octagonal|circular),
#@gmic : '_channel=0..22' (All|RGBA|RGB|Luminance|Blue/red chrominances|Blue chrominance|Red chrominance|Lightness
#@gmic : |ab-components|a-component|b-component|Hue|Saturation|Value|Key|Green chrominance|ch-components|c-component|h-component|Red|Green|Blue|Alpha)
#@gmic  : compute difference of open+close and original (only 2d)
karo_doc :
-e "Compute difference of open/close and original image$?, with window size $1 (only 2d)." -v -
-skip ${1=5},${2=1},${3=0}
-repeat $! -l[$<]
--karo_open[0] $1,$2,0,0,$3 --karo_close[0] $1,$2,0,0,$3
-+[-2,-1] -/[-1] 2 --
-endl -done -v +
#@gmic karo_doo : _size1>0,_size2>0,_type=0..3 (ero/dil/open/close),_shape=0|1|2 (sqaure|octagon|circle),'_scale=0|1',
#@gmic : '_channel=0..22' (All|RGBA|RGB|Luminance|Blue/red chrominances|Blue chrominance|Red chrominance|Lightness
#@gmic : |ab-components|a-component|b-component|Hue|Saturation|Value|Key|Green chrominance|ch-components|c-component|h-component|Red|Green|Blue|Alpha)
#@gmic : Compute difference of mm op on selected images (only 2d).
karo_doo : -skip ${1=5},${2=7},${3=2},${4=1},${5=0},${6=0}
-e[^-1] "Compute difference of mm op on image$?, with sizes $1 and $2 (only 2d)." -v -
-repeat $! -l[$<]
--gimp_morpho[-1] $3,$1,0,$4,$6,0
-gimp_morpho[-2] $3,$2,0,$4,$6,0
-if {{${3}&1}==0} -rv[-2,-1] -endif
--[-2,-1]
-if {$5==1} -n[-1] 0,255 -endif
-endl -done -v +
#@gmic karo_label_sort :
#@gmic : Rearrange a label image (the selected image) according to the region size
#@gmic : $ 400,400 -rand 0,1 -b 3 -ge 50% -label 0,1 -karo_label_sort -threshold 50%
#@gmic : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label_sort :
-e[^-1] "Sort labelled image [1] by region size."
-v - -repeat $! -l[$>]
nb={1+iM} mn={im} --histogram[-1] $nb,0,{$nb-1}
100%,1,1,1,x -a[-2,-1] y -sort[-1] -,x -rows[-1] 1
100%,1,1,1,x -a[-2,-1] y -sort[-1] +,x -rows[-1] 1
-map[-2] [-1] -rm[-1]
-endl -done -v +
#@gmic karo_label : tolerance>=0,is_high_connectivity={ 0 | 1 },sort={ 0 | 1} : (+)
#@gmic : Label connected components in selected images and possibly sort by region size.
#@gmic : Default values: 'tolerance=0', 'is_high_connectivity=0' and 'sort=0'.
#@gmic : $ image.jpg -luminance -threshold 60% -label 0 -normalize 0,255 -map 0
#@gmic : $ 400,400 -set 1,50%,50% -distance 1 -mod 16 -threshold 8 -karo_label 0,,1 -mod 255 -map 2
#@gmic : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label : -check "$1>=0" -skip ${2=0} -skip ${3=0}
-e[^-1] "Label connected components on image [1], with tolerance $1, "${-arg\ 1+!$2,high,low}" connectivity and "${-arg\ 1+!$3,sorted,unsorted}
-v - -repeat $! -l[$>]
-label[-1] $1,$2
-if {$3}
nb={1+iM} --histogram[-1] $nb,0,{iM}
100%,1,1,1,x -a[-2,-1] y -sort[-1] -,x -rows[-1] 1
100%,1,1,1,x -a[-2,-1] y -sort[-1] +,x -rows[-1] 1
-map[-2] [-1] -rm[-1]
-endif
-endl -done -v +
#@gmic karo_threshold : _method={ triangle | yen | otsu | _otsu | bgt | intera | rats | fixnnn},_delclass>0,_smooth>0
#@gmic : Calculate threshold (from ImageJ) in range [0,255], evtl. normalization necessary.
#@gmic : For each method user function _karo_"_method" is called!
#@gmic : If _delclass > 0 delete cluster _delclass-1. blur_x histogram with amplitude _smooth.
#@gmic : If _smooth > 0 blur_x histogram with amplitude _smooth.
#@gmic : No histogram processing for otsu, rats and intera!
#@gmic : $ image.jpg -luminance -karo_threshold[-1] ,
karo_threshold : -skip ${1="triangle"} -skip ${2=0} -skip ${3=0}
-e[^-1] "Calculate "$1" thresholded mask from images$? with histogram in range [0,255] and binsize 1."
-v -
-if ${-strcontains\ $1,fix} meth=fix
-else meth=$1 -endif
-if {['$meth']=='otsu'} -otsu 256
-elif {['$meth']=='rats'} -karo_rats ,
-elif {['$meth']=='intera'} -threshold
-else -repeat $!
-l[$>]
-if {['$meth']=='fix'} -_karo_fix ,,$1
-else --histogram[-1] 256,0,255
-if {$2>0} -=[-1] 0,{$2-1} -endif
-if {$3!=0} tot={is} -/[-1] $tot -blur_x[-1] $3 -/[-1] {is} -*[-1] $tot -round[-1] -endif
--_karo_$meth[-1] 0,1 -rm[-1]
-endif
th=${}
-threshold[0] $th
-if {$>==0} sres=$th -else sres=$sres,$th -endif
-endl -done -u $sres -endif
-v +
#@gmic _karo_fix : 0,1,fixnnn
#@gmic : fix threshold nnn returned in status
_karo_fix :
-skip "${1=0} ${2=1} ${3=fix005}"
-u ${-strreplace\ $3,fix,\ }
#@gmic _karo_triangle : _minval,_bins
#@gmic : Calculate triangle threshold (from ImageJ auto thresholder)
#@gmic : tested only with 256 classes from 0 to 255
#@gmic : $ image.jpg -luminance --histogram 256,0,255 -_karo_triangle[-1] , --threshold[0] ${}
_karo_triangle : -skip "${1=0} ${2=1}"
-e[^-1] "Calculate triangle threshold from 1d histogram$? in range ["$1","{$1+(w-1)*$2}"]."
-v -
-repeat $!
-l[$>]
ac=${-autocrop_coords[-1]} wd={w}
min={${-arg\ 1,$ac}} -if {$min==1&&{@0}!=0} min=0 -endif
-if {$min>0} min={$min-1} -endif
min2={${-arg\ 4,$ac}} -if {$min2<{$wd-1}} min2={$min2+1} -endif
dmax={iM} max={xM}
-if {($max-$min)<($min2-$max)}
inverted=1 -mirror[0] x min={$wd-1-$min2} max={$wd-1-$max}
-else inverted=0 -endif
-if {$min==$max} split=$min -else
nx={i($max)} ny={$min-$max}
d={sqrt($nx*$nx+$ny*$ny)}
nx={$nx/$d} ny={$ny/$d}
d={$nx*$min+$ny*i($min)}
--f[-1] x -*[-1] $nx -*[-2] $ny -+[-1,-2] --[-1] $d
-crop[-1] {$min+1},$max
-if {$inverted} split={$wd-(xM+$min)} -else split={xM+$min+1} -endif
-endif
res={$1+$split*$2}
-if {$>==0} sres=$res -else sres=$sres\,$res -endif
-rm[0] -endl
-done -u $sres -v +
#@gmic _karo_yen : _minval,_bins
#@gmic : Calculate yen threshold (from ImageJ auto thresholder)
#@gmic : tested only with 256 classes from 0 to 255
_karo_yen :  -skip "${1=0} ${2=1}" -v -
-repeat $! -l[$>]
total={0,is}
-*[0] {1/$total}
--cumulate[0]
--sqr[0] -cumulate[-1]
--mirror[0] x -sqr[-1] -cumulate[-1] -mirror[-1] x
--*[-1,-2]
--gt[-1] 0 -c[-2] 0.000001%,100 -log[-2] -*[-2,-1] -*[-1] -1
--*[1] -1 -+[-1] 1 -*[1,-1] --gt[1] 0 -c[1] 0.000001%,100 -log[1] -*[1,-1] -*[1] 2
-+[-1,1] -k[1]
res={${-karo_nth_max\ 2,1}*$2+$1}
-rm[0]
-if {$>==0} -u $res -else -u ${},$res -endif
-endl -done -v +
#@gmic _karo__otsu : _minval,_bins
#@gmic : Calculate otsu threshold (from gmic -otsu)
#@gmic : tested only with 256 classes from 0 to 255
_karo__otsu : -skip "${1=0} ${2=1}" -v -
-repeat $! -l[$>]
im=$1 iM={$im+(w+1)*$2} total={is}
--*[-1] 'x' sum={is} -rm[-1]
sumB=0 wB=0 wF=0 varMax=0 threshold=0
-repeat {w}
wB={$wB+{@$>}}
-if {$wB==0} -continue -endif
wF={$total-$wB}
-if {$wF==0} -break -endif
sumB={$sumB+$>*{@$>}}
mB={$sumB/$wB}
mF={($sum-$sumB)/$wF}
varBetween={$wB*$wF*($mB-$mF)^2}
-if {$varBetween>$varMax} varMax=$varBetween threshold=$> -endif
-done -rm[-1]
res={$threshold*$2+$1} -u $res
-endl -done -v +
_karo_bgt: -skip "${1=0} ${2=1}" -v - fact=1.5
-l[-1]
hft=${-hist_feature\ -2} mn=${-arg\ 5,$hft} mx=${-arg\ 6,$hft} sd=${-arg\ 4,$hft} md=${-arg\ 1,$hft}
-if {($mx-$md)<=($md-$mn)} res={$md-$fact*$sd}
-else res={$md+$fact*$sd} -endif
-u {$res*$2+$1} -rm
-endl -v +
#@gmic karo_rats : _pow(0.5)
#@gmic : Robust automatic threshold selection (Kittler et al. 1985)
#@gmic : Input image (not histogram similar -otsu!)
karo_rats :
-check ${1=0.5}>0
-e[^-1] "Calculate rats from image$? with power "$1"." -v -
-repeat $! -l[$>]
--gradient_norm. -pow. $1 gr={is} -*[-1] [-2] gri={is} res={$gri/$gr} -rm.
-threshold. $res
-if {$>==0} sres=$res -else sres=$sres\,$res -endif
-endl -done
-u $sres -v +
#@gmic hist_percentile : _nth[%],_zero,_min0,_stepw
#@gmic : Estimation of _nth percentiles (lower & upper) from histogram and returning value(s) in status (${})
#@gmic : _zero Class 0 is zeroed if !=0
#@gmic : _min0 value of class 0
#@gmic : _stepw value of class width (bin size)
#@gmic : Def. val.: 'nth=25%', '_zero=0', '_min0=0', '_stepw=1'
#@gmic : $ image.jpg -luminance --dh ,,256,0,255 -histogram.. 256,0,255 -hist_percentile.. , -rm.. t=${} -text $t,40,5,23,1,128
hist_percentile :
-check "${1=25%}>0"
-skip ${2=0},${3=0},${4=1}
-e[^-1] "Calculate $1 percentile from 1d histogram$?."
-v - -repeat $!
-l[$>]
-if {h>1||d>1||s>1} -v + -e[^-1] "Image "$>" seemingly not 1d!" -v - -continue -endif
-if {$2!=0} -set[-1] 0,0 -endif
m0={is}
N={if(${"-is_percent $1"},$m0*$1,$1)}
--cumulate[-1]
--ge[-1] $N mn={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} -rm[-1]
--ge[-1] {iM-$N} mx={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} -rm[-1,-2]
res=$mn\,$mx
-if {$>==0} sres=$res -else sres=$sres\,$res -endif
-endl
-done -u $sres -v +
#@gmic hist_feature : _moment,_nth,_zero,_min0,_stepw
#@gmic : Estimation of features mode,sum,mean,SD,min,max,median from histogram
#@gmic : _moment=-2/mode,m0,m1,m2,min,max,med -1/mode 0/sum 1/mean 2/SD 3/min 4/max 5/median
#@gmic : _nth extreme value
#@gmic : _zero Class 0 is zeroed if !=0
#@gmic : _min0 value of class 0
#@gmic : _stepw value of class width (bin size)
#@gmic : Def. val.: '_moment=-2', 'nth=1', '_zero=0', '_min0=0', '_stepw=1'
#@gmic : Updated 140314 (smoothing replaced by nth selection)
#@gmic : $ image.jpg -luminance --histogram 256,0,255 -dh.. ,,256,0,255 -hist_feature , -repeat 7 t={_arg($>+1${})} -text $t,40,{$>*25+5},23,1,128 -done -rm.
hist_feature :
-check "${1=-2}>=-2&&$1<=5&&isint($1)&&isint(${2=1})&&$2>0"
-skip ${3=0},${4=0},${5=1}
-e[^-1] "Calculate md,m0,m1,m2,$2th-min,$2th-max,med from 1d histogram$?."
-v -
-repeat $!
-l[$>]
-if {h>1||d>1||s>1} -v + -e[^-1] "Image "$>" seemingly not 1d!" -v - -continue -endif
-if {$3!=0} -set[-1] 0,0 -endif
md={xM*$5+$4}
m0={is}
--*[-1] 'x*$5+$4' m1={is/$m0} -rm[-1]
--*[-1] '(x*$5+$4)^2' m2={sqrt(is/$m0-$m1^2)} -rm[-1]
--cumulate[-1]
--ge[-1] $2 mn={${-arg\ 1,{[xM,yM,zM,cM]}}*$5+$4} -rm[-1]
-if {$2>1} --ge[-1] {iM-$2} mx=${-arg\ 1,{[xM,yM,zM,cM]}} -rm[-1] -else  mx=${-arg\ 1,{[xM,yM,zM,cM]}} -endif
mx={$mx*$5+$4}
--ge[-1] {iM/2} med1=${-arg\ 1,{[xM,yM,zM,cM]}} -rm[-1]
--le[-1] {iM/2} med2=${-arg\ 1,{[xm,ym,zm,cm]}} -rm[-1,-2]
med={($med1+$med2)/2*$5+$4}
res=$md\,$m0\,$m1\,$m2\,$mn\,$mx\,$med
-if {$1>-2} res=${-arg\ {$1+2},$res} -endif
-if {$>==0} sres=$res -else sres=$sres\,$res -endif
-endl
-done -u $sres -v +
#@gmic karo_nth_max : _n(1),_ind(=0)
#@gmic : Return in the status the n-th max or the index of the n-th max of an image
#@gmic : Possibility to fetch the index instead of the value (_ind=1)
karo_nth_max : -check "isint(${1=1}) && $1>0" -skip ${2=0}
-e[^-1] "Return in the status the $1-th max of image$?."
-v - -repeat $! -l[$>]
[0] -repeat {$1-1} -set[-1] {im},{[xM,yM,zM,cM]} -done
-if $2 mx={xM} -else mx={iM} -endif -rm[-1]
-if {$>==0} -u $mx -else -u ${},$mx -endif
-endl -done -v +
#@gmic karo_nth_min : _n(1),_ind(=0)
#@gmic : Return in the status the n-th min of an image
#@gmic : Possibility to fetch the index instead of the value (_ind=1)
karo_nth_min : -check "isint(${1=1}) && $1>0" -skip ${2=0}
-e[^-1] "Return in the status the $1-th min of image$?."
-v - -repeat $! -l[$>]
[0] -repeat {$1-1} -set[-1] {iM},{[xm,ym,zm,cm]} -done
-if $2 mn={xm} -else mn={-im} -endif -rm[-1]
-if {$>==0} -u $mn -else -u ${},$mn -endif
-endl -done -v +
#@gmic karo_xcimg : programname ,parameterlist :
#@gmic : Call external CImg Example 'programname'
#@gmic : which has to be found in PATH by external call by
#@gmic : 'programname' image_in 'parameterlist' image_out
#@gmic : with writing image_in and reading after execution image_out
karo_xcimg :
filename=${-file_rand}
-if {!${-is_windows}}
-x "which "$1" >/dev/null 2>&1"
-if ${} -v + -e "executable \"$1\" not found in PATH, status = "${}"!! Returning!!\n" -v -
{w},{h} -gimp_logo "exec Error !!" -return -endif
-endif
-o ${filename}.cimg
-x "$1 -i "${filename}".cimg $2 -o "${filename}".cimg"
-if ${} -v + -e "Status is "${}"." -v - {w},{h} -gimp_logo "exec Error !!"
-else -i ${filename}.cimg -endif
-file_rm ${filename}.cimg
#@gmic karo_li2st : p1,p2,...,pn
#@gmic : Convert comma separated list to space separated string.
karo_li2st :
-v - -u "" -if {$#>=1} ({"'${1--1}'"}) -replace[-1] {','},{"' '"} -u {t} -rm[-1] -endif -v +
#@gmic karo_skeleton : _p1,..,p2n : (-median,0,-inv,0|1,-t,-0.3,-curve,0|1,-corr,0|1,-dlt,1)
#@gmic : Execute use_skeleton (CImg demo) external.
karo_skeleton : -v - -if {$#>0} -karo_li2st ${1--1} p=${} -else p="" -endif -v +
-e "Compute use_skeleton exec with options "$p" on$?" -v -
-repeat $! -l[$>]
s={s} -if {$s>1} -s[-1] c -endif
-repeat $! -l[$>] -karo_xcimg use_skeleton,${p}" -visu 0" -mv[-1] 0 -k[0] -endl -done
-if {$s>1} -a[-$s--1] c -endif
-endl -done -v +
#@gmic karo_nlmeans : _p1,..,pn=-zoom,1,-ng,0|1,-nu,0|1,-ns,0|1,-p,1,-lambda,-1,-sigma,-1,-alpha,3,-sampling,1
#@gmic : Execute use_nlmeans  (CImg demo) external. (see also q-nlmeans p=4,lambda=4,sigma=10)
karo_nlmeans : -v - -if {$#>0} -karo_li2st ${1--1} p=${} -else p="" -endif -v +
-e "Compute use_nlmeans exec with options "${p}" on$?" -v -
-repeat $! -l[$>]
s={s} -if {$s>1} -s[-1] c -endif
-repeat $! -l[$>] -karo_xcimg use_nlmeans,${p}" -visu 0" -mv[-1] 0 -k[0] -endl -done
-if {$s>1} -a[-$s--1] c -endif
-endl -done -v +
#@gmic karo_VST : _inverse(=0)
#@gmic : Variance Stabilizing Transformation
#@gmic : following http://hal.archives-ouvertes.fr/docs/00/51/08/66/PDF/Burst_Hal.pdf
#@gmic : $ image.jpg -e ${-std_noise} -karo_VST 0 -e ${-std_noise} --karo_VST 1
karo_VST :
-v - -skip ${1=0} -if $1 inv=" (inverse)." -else inv="." -endif -v +
-e[^-1] "Variance Stabilizing Transformation"$inv -v -
-repeat $! -l[$>]
-if $1 -/[0] 2 -sqr[0] --[0] {3/8} -else -+[0] {3/8} -sqrt[0] -*[0] 2 -endif
-endl -done -v +
#@gmic pearson_correlation
#@gmic : Compute pearson-correlation using two-by-two selected images.
#@gmic : $ image.jpg --shift -30,-20 -pearson_correlation -e ${}
pearson_correlation :
-e[^-1] "Compute pearson-correlation using two-by-two image$?."
-v - -repeat {int($!/2)} -l[{$>*2},{$>*2+1}]
---[0] {0,ia} ---[1] {1,ia} --*[2,3]
-sqr[2,3]
r={ia/sqrt({2,ia}*{3,ia})}
-if {$>==0} -u $r -else -u ${},$r -endif
-rm[2-4]
-endl -done -v +
#@gmic karo_extinction : _whitevalue[%]
#@gmic : Convert (integer) transmission image into extinction with _whitevalue.
#@gmic : Def. val.: '_whitevalue=100%'
karo_extinction : -check "${1=100%}>0"
-e[^-1] "Convert transmission image$? into extinction with white value $1." -v -
-repeat $! -l[$>]
-if ${-is_percent\ $1} WW={iM*$1} -else WW=$1 -endif
-c[-1] 1,{iM} -/[-1] $WW -log10[-1] -*[-1] -1
-endl -done -v +
#@gmic karo_rndbit0 :
#@gmic : Randomize in [0..255] image$? bit level 0."
karo_rndbit0 :
-e[^-1] "Randomize in [0..255] image$? bit level 0." -v -
-repeat $! -l[$>] -and 254 --rand 0,1 -round[-1] -or -endl -done -v +
#@gmic karo_dtpread : filename,_bit0
#@gmic : Read dtp image file format
#@gmic :   (512 byte header, col[22-24] x row[25-27] byte image)
#@gmic : with _bit0 != 0 bit level 1 is extracted as binary mask
#@gmic :   and bit level 1 in the gray image is randomized with -karo_rndbit0
#@gmic : Ex.: -karo_dtpread Images/Beispiele/tra005.cel,1
karo_dtpread : -check $1 -check "${2=0}>=0"
-e[^-1] "Read dtp image file from $1." -v -
-i raw:$1,uchar
({@22-24}) x={t} -rm[-1]
({@25-27}) y={t} -rm[-1]
({@0-79}) _dtph={t} -rm[-1]
-crop[-1] 0,512,0,{h}
-resize[-1] $x,$y,1,1,-1
-if $2
--and[-1] 1 -karo_rndbit0[-2]
-endif
-v +
#@gmic _kr_ch2ch : number
#@gmic : return alpha channel mode from number in status
#@gmic : Ex. -v - -repeat 51 -_kr_ch2ach $> -v + -echo_stdout $>,${} -done
_kr_ch2ch :
-if {isval("$1")} -if {isint("$1")}
-u ${-arg\ 1+$1,all,rgba,rgba_r,rgba_g,rgba_b,rgba_a,rgb,rgb_r,rgb_g,rgb_b,\
lrgb,lrgb_r,lrgb_g,lrgb_b,ycbcr,ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
lab,lab_l,lab_ab,lab_a,lab_b,lch,lch_l,lch_ch,lch_c,lch_h,\
hsv,hsv_h,hsv_s,hsv_v,hsi,hsi_h,hsi_s,hsi_i,hsl,hsl_h,hsl_s,hsl_l,\
cmy,cmy_c,cmy_m,cmy_y,cmyk,cmyk_c,cmyk_m,cmyk_y,cmyk_k}
-else -u "$1" -endif -else -u "$1" -endif
#@gmic gimp_karo_cimg_nlmeans : add_Gauss_noise(0),add_uniform_noise(0),add_salt_pepper(0),patch_size(0),lambda(-1),noise_sd(-1),alpha(3),steps(2)
#@gmic : Execute use_nlmeans (CImg demo) external.
gimp_karo_cimg_nlmeans :
-skip "${1=0}","${2=0}","${3=0}","${4=1}","${5=-1}","${6=-1}","${7=2}"
-karo_nlmeans -ng,$1,-nu,$2,-ns,$3,-p,$4,-lambda,$5,-sigma,$6,-alpha,$7,-sampling,$8
gimp_karo_cimg_nlmeans_preview :
-gimp_split_preview "-gimp_karo_cimg_nlmeans ${1-8}",$9
#@gmic gimp_karo_cimg_skel : auto_thresh(1),thresh(50\%),median(0),invert(0),thresh_flux(-0.3),medial_curve(0),Torsello corr(0),steps(1)
#@gmic : Execute use_skeleton (CImg demo) external.
gimp_karo_cimg_skel :
-if $1 -otsu 256 -else -threshold ${2}% -endif
-karo_skeleton -median,$3,-inv,$4,-t,$5,-curve,$6,-corr,$7,-dlt,$8 -n 0,255
gimp_karo_cimg_skel_preview :
-gimp_split_preview "-gimp_karo_cimg_skel ${1-8}",$9
#@gmic gimp_karo_mm_diff : Compute difference of mm op on selected images.
#@gmic : Size = int(5,1,25)
#@gmic : Size2 = int(7,1,25)
#@gmic : Operation = choice(2,"Erosion","Dilation","Open","Close")
#@gmic : Shape = choice(1,"Square","Octagon","Circle")
#@gmic : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gmic : Scale = bool(true)
#@gmic : sep = separator(), Preview type = choice(1,"Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gmic : Best with odd sizes!
#@gmic : sep = separator(), note = note("Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.")
#@gmic : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2013/07/09</i>.</small>")
gimp_karo_mm_diff :
-skip "${1=5}","${2=7}","${3=2}","${4=1}","${5=0}","${6=1}"
-if {$2<=$1} s2={$1+2} -else s2=$2 -endif
-karo_doo $1,${s2},$3,$4,$6,$5
gimp_karo_mm_diff_preview :
-gimp_split_preview "-gimp_karo_mm_diff ${1-6}",$7
gimp_karo_oc_diff :
-apply_channels "-karo_doc $1,$2,0",$3,$4
gimp_karo_oc_diff_preview :
-gimp_split_preview "-gimp_karo_oc_diff ${1-4}",$5
#@gmic gimp_pink : Pink example, _operator(=11), _connect(=0), _smooth(=0), _param(=5), _channel(=0)
#@gmic : _operator = 0..19 ("wshedtopo","wshedtopo inv","minima","maxima","heightminima","heightmaxima","grayskel","htkern","htkernu","lvkern","lvkernu","asf","asflin","asfr","asft","asftmed","asftndg","dilatballnum","erosballnum","lintophat")
#@gmic : _connect = 0..1 ("Four/x","Eight/y")
#@gmic : _smooth = 0..
#@gmic : _param = 0..25
#@gmic : _channel = 0..22 ("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gmic : $ image.jpg --gimp_pink , ---
#@gmic : $ image.jpg --gimp_pink[-1] 12,1,0.582524,10,0,0 --gimp_pink[-2] 12,0,0.582524,10,0,0 -+[-1,-2] # asflin in x and y
gimp_pink :
-skip ${1=11},${2=0},${3=0},${4=5},${5=0} -v -
-if   {$1==0}  -apply_channels "-b $3 -pink heightminima,{($2+1)*4},$4 -pink wshedtopo,{($2+1)*4}",$5,0
-elif {$1==1}  -apply_channels "-b $3 -pink heightmaxima,{($2+1)*4},$4 -pink wshedtopo,{($2+1)*4},i",$5,0
-elif {$1==2}  -apply_channels "-b $3 -pink minima,{($2+1)*4}",$5,0
-elif {$1==3}  -apply_channels "-b $3 -pink maxima,{($2+1)*4}",$5,0
-elif {$1==4}  -apply_channels "-b $3 -pink heightminima,{($2+1)*4},$4",$5,0
-elif {$1==5}  -apply_channels "-b $3 -pink heightmaxima,{($2+1)*4},$4",$5,0
-elif {$1==6}  -apply_channels "-b $3 -pink grayskel,null,4,$4",$5,0
-elif {$1==7}  -apply_channels "-b $3 -pink htkern,null,{($2+1)*4}",$5,0
-elif {$1==8}  -apply_channels "-b $3 -pink htkernu,null,{($2+1)*4}",$5,0
-elif {$1==9}  -apply_channels "-b $3 -pink lvkern,null,{($2+1)*4}",$5,0
-elif {$1==10} -apply_channels "-b $3 -pink lvkernu,null,{($2+1)*4}",$5,0
-elif {$1==11} -apply_channels "-b $3 -pink asf,$4",$5,0
-elif {$1==12}
-if {$2==0} -apply_channels "-b $3 [0]x2 -a z -pink asflin,x,$4 -s z -k[-1]",$5,0
-else -apply_channels "-b $3 [0]x2 -a z -pink asflin,y,$4 -s z -k[-1]",$5,0 -endif
-elif {$1==13} -apply_channels "-b $3 -pink asfr,$4",$5,0
-elif {$1==14} -apply_channels "-b $3 -pink asft,null,null,{($2+1)*4},$4",$5,0
-elif {$1==15} -apply_channels "-b $3 -pink asftmed,{($2+1)*4},$4",$5,0
-elif {$1==16} -apply_channels "-b $3 -pink asftndg,null,null,{($2+1)*4},$4",$5,0
-elif {$1==17} -apply_channels "-b $3 -pink dilatballnum,$4",$5,0
-elif {$1==18} -apply_channels "-b $3 -pink erosballnum,$4",$5,0
-elif {$1==19} -apply_channels "-b $3 -pink lintophat,$4",$5,0
-else          -apply_channels "-b $3 -pink heightminima,{($2+1)*4},$4 -pink wshedtopo,{($2+1)*4}",$5,0
-endif -v +
gimp_pink_preview :
-gimp_split_preview "-gimp_pink ${1-5}",$6
gimp_karo_pink_bin :
-if   {$3==0}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink_skelpar $6,$5 -n 0,255",$7,0
-elif {$3==1}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink_skelend {($4+1)*4},$5 -n 0,255",$7,0
-elif {$3==2}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink_skelcurv $6,{($4+1)*4} -n 0,255",$7,0
-elif {$3==3}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink_skeleton $6,{($4+1)*4} -n 0,255",$7,0
-elif {$3==4}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink barycentre,{($4+1)*4} -n 0,255",$7,0
-elif {$3==5}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink border,{($4+1)*4} -n 0,255",$7,0
-elif {$3==6}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink closeball,$5,$6 -n 0,255",$7,0
-elif {$3==7}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink openball,$5,$6 -n 0,255",$7,0
-elif {$3==8}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink convexhull,3 -n 0,255",$7,0
-elif {$3==9}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink dist,$6 -n 0,255",$7,0
-elif {$3==10}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink distc,$6 -n 0,255",$7,0
-elif {$3==11}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink label,{($4+1)*4},pla",$7,0
-elif {$3==12}  -apply_channels "-if $1 -otsu 256 -else -threshold ${2}% -endif -pink lantuejoul,$6 -n 0,255",$7,0
-else
-endif
gimp_karo_pink_bin_preview :
-gimp_split_preview "-gimp_karo_pink_bin ${1-7}",$8
#@gmic gimp_karo_pink_bianca : Pink test operator bianca
#@gmic : ASF smooth size = int(5,1,10)
#@gmic : Threshold \% = int(60,0,100)
#@gmic : Watershed height min = int(5,0,20)
#@gmic : Opening radius = int(1,0,10)
#@gmic : Invert = bool(0)
#@gmic : Use G instead of B = bool(0)
#@gmic : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gmic : sep = separator(), note = note(Pink test operator Bianca for RGB image; only B used.)
#@gmic : note = note{"Pink executables in search PATH or C:\\Pink\\bin\\ for Windows"}
#@gmic : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2012/10/26</i>.</small>")
#@gmic : note = link("http://pinkhq.com/")
gimp_karo_pink_bianca :
-skip "${1=5}","${2=60}","${3=5}","${4=1}","${5=0}","${6=0}"
-if $5 -negative -endif
-if {!${-is_windows}} exe="label" -else exe="C:\Pink\bin\label" -endif
-s c -if $6 -k[-2] -else -k[-1] -endif
--pink asf,$1 --- -k[-1,-3] -t[-1] ${2}%
--pink_wshed[-2] ,1,$3
-pink[-1] $exe,4,max -t[-1] 1
-erode_oct[-2] {$4*2+1} -dilate_oct[-2] {$4*2+1}
--*[-1,-2] -negative[-2] -n[-1,-2] 0,255 -a[-1,-2,-4] c -k[0]
gimp_karo_pink_bianca_preview :
-gimp_split_preview "-gimp_karo_pink_bianca ${1-6}",$7
gimp_blend_shapeaverage :
-if ${3=0} -_gimp_revert_layers -endif
-to_rgb
-repeat {int($!/2)}
-rv[-2,-1]
-if $1 -i[0] [-1] -endif
-blend[-2,-1] shapeaverage0
-if $1 -*[0,-1] -/[0] 255 -mv[0] $! -endif
-if $2 -to_rgba[-1] -replace_color[-1] 0,0,0,0,0,255,0,0,0,0 -endif
-mv[-1] 0 -done
gimp_lylejk_stencil :
-apply_channels "-repeat $1 -b $3 -unsharp $3,$2 -c 0,255 -mv[-1] 0 -done",$4,0
gimp_AbstractFlood :
Prep=$1
SpatialVariance=$2
ValueVariance=$3
Iterations=$4
ActivateFlood=$5
Repeats=$6
Tolerance=$7
FloodBaseStep=$8
CanvasR=$9
CanvasG=$10
CanvasB=$11
Opacity=$12
ActivateCubism=$13
CubismIterations=$14
Blocsize=$15
Angle=$16
CubismOpacity=$17
Smoothness=$18
StepThreshold={$19+0.1}
Step=$FloodBaseStep
Delta=1
DeltaOrg=$Delta
-to_rgba[0]
-if {$Prep==1}
-gimp_bilateral[0] $SpatialVariance,$ValueVariance,$Iterations,0,0
-endif
({$CanvasR}^{$CanvasG}^{$CanvasB}^0)
-to_rgba[1]
-r[1] [0]
X={(w)/2}
Y={(h)/2}
ImageH={(h)}
ImageW={(w)}
DoLoop=0
IsGood=0
-if {$ActivateFlood==1}
#A comment here is needed
-repeat $Repeats
-flood[0] {100*$X/w}%,{100*$Y/h}%,0,$Tolerance,0,1,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)}
--gimp_select_color[0] 0,1,0,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)},0,0
-if {$ActivateCubism==1}
-cubism[2] $CubismIterations,$Blocsize,$Angle,$CubismOpacity,$Smoothness
-endif
-blend[1,2] alpha
-do
Rstep={$Step+$Delta}
theta={u(360)}
Xnew={int($X+$Rstep*cos($theta))}
Ynew={int($Y+$Rstep*sin($theta))}
-if {{$Xnew>0}" && "{$Xnew<$ImageW}" && "{$Ynew>0}" && "{$Ynew<$ImageH}}
X=$Xnew
Y=$Ynew
-if {1,i($X,$Y,0,3)>$StepThreshold}
Delta={min({$Delta+$Delta*2},{max($ImageW,$ImageH)/5})}
-endif
-if {1,i($X,$Y,0,3)<$StepThreshold}
IsGood=10
-endif
-if {$DoLoop>100}
IsGood=10
-endif
-endif
DoLoop=$DoLoop+1
-while {$IsGood<1}
IsGood=0
DoLoop=0
Delta=$DeltaOrg
-done
-endif
({$CanvasR}^{$CanvasG}^{$CanvasB}^{$Opacity})
-r[2] [0]
-reverse[1,2]
-blend[1,2] alpha
-if {$ActivateFlood==1}
-keep[1]
-elif  {$ActivateFlood==0}
-keep[0]
-endif
gimp_AbstractFlood_Preview :
-gimp_split_preview "-gimp_AbstractFlood ${1--2}",$-1
gimp_bwfilmsimulate :
Choice=$1
P1=$2
P2=$3
P3=$4
P4=$5
P5=$6
P6=$7
P7=$8
P8=$9
P9=$10
P10=$11
P11=$12
P12=$13
P13=$14
P14=$15
P15=$16
P16=$17
P17=$18
P18=$19
P19=$20
P20=$21
-if {$Choice==1} P1={18/255} P3={41/255} P5={41/255} -endif
-if {$Choice==2} P1={25/255} P3={39/255} P5={36/255} -endif
-if {$Choice==3} P1={21/255} P3={40/255} P5={39/255} -endif
-if {$Choice==4} P1={20/255} P3={41/255} P5={39/255} -endif
-if {$Choice==5} P1={21/255} P3={42/255} P5={37/255} -endif
-if {$Choice==6} P1={22/255} P3={42/255} P5={36/255} -endif
-if {$Choice==7} P1={31/255} P3={36/255} P5={33/255} -endif
-if {$Choice==8} P1={28/255} P3={41/255} P5={31/255} -endif
-if {$Choice==9} P1={23/255} P3={37/255} P5={40/255} -endif
-if {$Choice==10} P1={33/255} P3={36/255} P5={31/255} -endif
-if {$Choice==11} P1={36/255} P3={31/255} P5={33/255} -endif
-if {$Choice==12} P1={21/255} P3={42/255} P5={37/255} -endif
-if {$Choice==13} P1={24/255} P3={37/255} P5={39/255} -endif
-if {$Choice==14} P1={37/255} P3={36/255} P5={37/255} -endif
-if {$Choice==15} P1={25/255} P3={35/255} P5={40/255} -endif
-repeat $!
-l[-1] -split_opacity -rv -to_rgb[-1] -s[-1] c
-*[-3] $P1 -b[-3] $P2%
-*[-2] $P3 -b[-2] $P4%
-*[-1] $P5 -b[-1] $P6%
-+[-3--1] -/[-1] {$P1+$P3+$P5} -c[-1] 0,255
-apply_gamma[-1] $P7
--[-1] 128 -*[-1] $P8 -+[-1] 128 -+[-1] $P9 -c[-1] 0,255
100%,100% [-1]x2
-noise[-3] 100,$P17 -b[-3] $P16% -n[-3] -$P12,$P12
-noise[-2] 100,$P17 -b[-2] $P16% -n[-2] -$P13,$P13
-noise[-1] 100,$P17 -b[-1] $P16% -n[-1] -$P14,$P14
--tones[-4] 3 -b[-3--1] $P15%
-*[-6,-3] -*[-4,-2] -*[-2,-1]
-+[-4--1] -c[-1] 0,255
-if {$P10||$P11}
-/[-1] 255
-i[-2] 100%,100%,1,1,$P11
-i[-3] 100%,100%,1,1,$P10
-a[-3--1] c -hsv2rgb[-1]
-endif
-rv -a c -endl -mv[-1] 0 -done
-normalize_local $P18,$P19,$P20,2%,1,0,255
gimp_bwfilmsimulate_preview :
-gimp_split_preview "-gimp_bwfilmsimulate ${1--2}",$-1
sub_thumbnailabstraction :
-to_rgb[0]
IWidth={0,w}
IHeight={0,w}
-if {$IWidth>=$IHeight}
ScaleByWidth=1
-endif
-if {$ScaleByWidth==1}
--resize2dx[0] 200,5
-blur[-1] 2
#Resize to 1024 px
-resize2dx[-1] 1024,5
#Segmentation
-gimp_segment_watershed[-1] 0.5,5,0,0
-elif
--resize2dy[0] 200,5
-blur[-1] 2
#Resize to 1024 px
-resize2dy[-1] 1024,5
#Segmentation
-gimp_segment_watershed[-1] 0.5,5,0,0
-endif
-resize[-1] [0]
--rgb2lab[0]
-split[-1] c
-rm[-1,-2]
-blur[-1] 10%
-normalize[-1] 0,255
-blend[-1,-2] hardlight,1,1
-keep[-1]
sub_colors_and_lines :
image_width={0,w}
image_height={0,h}
-resize2dx 1024
-luminance[0]
-normalize 0,255
-to_rgb[0]
-gimp_bilateral[0] 2,15,2,0,0,24,0
-gimp_colormap[0] 0,0,3,3,0,0,0,255,255,255,255,0,0,0,255,0,0,0,255,255,255,0,255,0,255,0,255,255,0
--gimp_anisotropic_smoothing[0] 300,0.1,1,0,10,1,1,1,0,1,1,0,0,24,0
-gimp_gradient_norm[-1] 0,0.5,0,100,1,0
-blend[0,1] multiply,1
-resize[-1] $image_width,$image_height,1,3,5,1
gimp_CompositionAnalysis :
method=$1
-if {$method==0} -sub_thumbnailabstraction -endif
-if {$method==1} -sub_colors_and_lines -endif
gimp_dodgesketch:
-to_rgb[0]
Power=$1
SpatialVariance=$2
ValueVariance=$3
Iterations=$4
Colored=$5
--gimp_mix_hsv[0] 1,0,0,0,-1,0,1,0,0,0,2,0
--gimp_bilateral[-1] $SpatialVariance,$ValueVariance,$Iterations,0,0
-negative[-1]
-blend[-1,-2] alpha,0.5,0
[-1]
--blend[-1,-2] dodge,1,0
-keep[0,-1]
-repeat $Power
[-1]
-blend[-1,-2] multiply
-done
-if {$Colored==1}
--blend[-1,-2] hardlight
-remove[-2]
-gimp_transfer_colors[-1,-2] 0,0
-endif
-keep[-1]
gimp_dodgesketchpreview :
-gimp_split_preview "-gimp_dodgesketch ${1--2}",$-1
Sub_Contrast_Bias:
-div[-1] 255
-to_gray[-1]
-laplacian[-1]
-abs[-1]
Sub_Saturation_Bias:
-div[-1] 255
--split[0] c
-blend[-1,-2,-3] average
-split[0] c
--sub[0] [1]
-rm[1]
--sub[0] [1]
-rm[1]
--sub[0] [1]
-rm[1]
-rm[0]
-pow[0] 2
-pow[1] 2
-pow[2] 2
-add[1] [2]
-rm[2]
-add[0] [1]
-rm[1]
-div[0] 3
-sqrt[0]
Sub_Exposure_Bias :
-div[0] 255
-sub[0] 0.5
-pow[0] 2
-div[0] {2*$1*$1}
-mul[0] -1
-exp[0]
-split[0] c
-mul[0] [2]
-rm[2]
-mul[0] [1]
-rm[1]
Sub_BlurPyramid :
size={0,min(w,h)}
levels={round(log($size)/log(5))}
Deviation=1
-blur[0] $Deviation,1,1
-repeat {$levels-1}
--resize[-1] 50%,50%,5,1
-blur[-1] $Deviation,1,1
-done
blndalpha=0.5
-repeat {$levels-1}
index={-($<+1)}
-resize[$index] [0],5,1
-blend[0,$index] alpha,$blndalpha,0
blndalpha={$blndalpha/2}
-done
gimp_ExposureWeightMap :
wc=$1
ws=$2
sigma=$3
we=$4
BlurMap=$5
-to_rgb[0]
--Sub_Contrast_Bias[0]
--Sub_Saturation_Bias[0]
--Sub_Exposure_Bias[0] $sigma
-rm[0]
-pow[0] $wc
-pow[1] $ws
-pow[2] $we
-add[0] [1]
-add[0] [2]
-keep[0]
-normalize[0] 0,255
-if {$BlurMap==1}
-Sub_BlurPyramid[0]
-endif
gimp_ExposureWeightMapPreview :
-gimp_split_preview "-gimp_ExposureWeightMap ${1--2}",$-1
gimp_StructureTensors:
-structuretensors -abs -pow $1
-normalize 0,255
gimp_StructureTensorsPreview :
-gimp_split_preview "-gimp_StructureTensors ${1--2}",$-1
gimp_import_image_16_info:
intersect_images:
--lt[0] [1]
-mul[-1] 255
--lt[1] [0]
-mul[-1] 255
-sub[0] [-1]
-sub[1] [-2]
-remove[-1,-2]
-cut[0] 0,255
-cut[1] 0,255
-add[0] [1]
-remove[1]
create_base_levels:
Levels=$1
-repeat {$Levels-1}
#Multiply D level with loop index+1
--mul[2] {$>+1}
#Subtract i*D from L
--sub[1] [-1]
-remove[-2]
-cut[-1] 0,255
-done
-repeat {$Levels-1}
#Multiply L with loop index + 1
--mul[1] {$>+1}
#Subtract i*L from D
--sub[2] [-1]
-remove[-2]
-cut[-1] 0,255
-done
reorder_stack :
Levels=$1
-move[3] 1
-if {$Levels>1}
-reverse[2,3]
-move[2] {-$Levels+1}
-endif
reduce_overlap :
Levels=$1
-repeat {$Levels-1}
-sub[{2+$>}] [{3+$>}]
-cut[{2+$>}] 0,255
-done
-repeat {$Levels-1}
-sub[{-$Levels+$>}] [{-$Levels+$>+1}]
-cut[{-$Levels+$>}] 0,255
-done
-sub[1] [{-$Levels-1}]
-sub[1] [-1]
-cut[1] 0,255
gimp_split_luminance:
Levels=$1
AlphaOutput=$2
ReduceOverlap=$3
KeepCustom=$4
KeepText=$5
-to_rgb
--rgb2lab
-split[-1] c
-rm[-1,-2]
-normalize[-1] 0,255
--negative[-1]
--intersect_images[-1,-2]
-if {$ReduceOverlap==0}
-normalize[-1] 0,255
-endif
-create_base_levels $Levels
-reorder_stack $Levels
-if {{$ReduceOverlap==1}" && "{$Levels>1}}
-reduce_overlap $Levels
-endif
-repeat {$!-1}
#add 1 to alpha  and cut 0,225 to avoid cutting of colour channels
#no idea why this is necessary, it yields correct results
#Ma and ma are already 0 and even though 1 is added the output is still
#0 for transparent areas of the mask.
-add[{$>+1}] 1
-cut[$>] 0,255
-done
-if $AlphaOutput
-repeat {$!-1}
--append[0,1] c
-remove[1]
-done
-endif
-if {{$ReduceOverlap==1}" && "{$Levels>1}}
#D and L are now equal, remove first
-remove[2]
-endif
-remove[0]
-if $KeepCustom
$KeepText
-endif
gimp_OldSquiggly :
--gimp_spread[0] $1,$1,0,0
-gimp_segment_watershed[1] $2,$3,0,0
--gimp_gradient_norm[1] $4,$5,0,100,0,0
--blend[2,1] multiply
-gimp_mix_ycbcr[3] 1,0,0,$6,0,0,$6,0,0,0,2,0
-gimp_map_tones[0] $7,$8,0.1,30,0,0
-blend[0,3] darken
-remove[1,2]
--gimp_plasma 0.5,10,8,0
-gimp_blackandwhite[1] 0.299,0,0.587,0,0.114,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0
-gimp_apply_curve[1] $9,-1,128,-1,128,-1,128,-1,128,-1,128,$10,1,3,0,0,0
-gimp_apply_curve[0] 0,$11,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
-mul[0] {0.5*(1+$12)}
-mul[1] {0.5*(1-$12)}
--add[0] [1]
--blend[0,2] softlight
-remove[0,1,2]
gimp_MappedSmooth :
MapType=$1
fi={$2*3.1415/180}
ZeroOffset=$3
Amplitude=$4
LMult=$5
ShowQuiver=$6
-if {$MapType==0}
--gimp_local_orientation 0.5,0,100,0,4,0
-endif
cosfi={cos($fi)}
sinfi={sin($fi)}
-to_rgb[-2,-1]
--[-1] {128+$ZeroOffset}
-split[-1] c
-mul[3] 0
--mul[1] $cosfi
--mul[2] $sinfi
-sub[4] [5]
-rm[5]
--mul[1] $sinfi
--mul[2] $cosfi
-add[5] [6]
-rm[6]
-rm[1,2]
-rm[1]
100%,100%,100%,1,0
-append[1,2,3] c
-/[-1] {128/$LMult}
-channels[-1] 0,1
-if {$ShowQuiver==0}
-vector2tensor[-1]
-smooth[-2] [-1],$Amplitude
-endif
-if {$ShowQuiver==1}
-quiver[-2] [-1],10,{$Amplitude/20},1,0.8,255
-endif
-rm[-1]
gimp_fix_HDR_black:
-to_rgb[0]
X1=$1
Y1=$2
X2=$3
Y2=$4
ShowMask=$5
--gimp_bilateral[-1] 4,8,6,4,0
-gimp_haar_smoothing[-1] 0.6,5,2,3,1,24
--rgb2lab[-1]
-split[-1] c
-rm[-1,-2]
-gimp_apply_curve[-1] 0,$X1,$Y1,$X2,$Y2,-1,128,-1,128,-1,128,255,1,0,0,21,0
-if {$ShowMask==0}
-negative[-1]
-append[-2,-1] c
-to_rgba[-1]
-blend[0,-1] alpha
-keep[0]
-endif
gimp_fix_HDR_black_preview :
-gimp_split_preview "-gimp_fix_HDR_black ${1--2}",$-1
gimp_noisepainting :
DegrLarge=$1
DegrSmall=$2
Channel=$3
Abstr=$4
Details=$5
Color=$6
Smooth=$7
Sharp=$8
-to_rgb[0]
-if {$Channel} Channel=3 -elif Channel=0 -endif
-if $PreProcess -gimp_segment_watershed $EdgeThresh,$WaterSmooth,0,0 -endif
-if {$DegrLarge!=0} -gimp_spread $DegrLarge,$DegrLarge,0,0 -endif
-if {$DegrSmall!=0} -gimp_noise $DegrSmall,2,$Channel,0,0 -endif
-gimp_painting $Abstr,$Details,$Color,$Smooth,$Sharp,0
gimp_noisepainting_preview :
-gimp_split_preview "-gimp_noisepainting ${1--2}",$-1
gimp_pastell :
MasterOpacity=$1
BgTextured=$2
ReverseEffect=$3
RAmplitude=$4
RThickness=$5
RSharpness=$6
ROrientations=$7
ROffset=$8
RColormode=$9
GSmoothness=$10
GLinearity=$11
GNegativeColors=$12
ActivateShakes=$13
RiAmplitude=$14
RiSize=$15
ActivateLizards=$16
WAmplitude=$17
WSmoothness=$18
ActivatePink=$19
RDeform=$20
RChannels=0
GMinThreshold=0
GMaxThreshold=100
RiShape=3
RiAngle=135
-if {$ActivatePink==1} -deform[0] $RDeform -endif
--gimp_rodilius[0] $RAmplitude,$RThickness,$RSharpness,$ROrientations,$ROffset,$RColormode,$RChannels,0
--gimp_gradient_norm[0] $GSmoothness,$GLinearity,$GMinThreshold,$GMaxThreshold,$GNegativeColors,0
-gimp_bilateral[0] 15,10,3,3,0
-if {$ActivateLizards==1} -water[0,2] $WAmplitude,$WSmoothness -endif
-if {$ActivateShakes==1} -ripple[0,2] $RiAmplitude,$RiSize,$RiShape,$RiAngle,0 -endif
-if {$ReverseEffect==1} -reverse[0,2] -endif
--blend[0,2] divide,1,0
-reverse[1,3]
-blend[1,3] value,1,0
-if {$BgTextured==1} -gimp_ellipsionism[0] 20,2,10,0.5,1,1,0 -endif
-blend[0,1] alpha,$MasterOpacity,0
-keep[0]
gimp_pastell_preview :
-gimp_split_preview "-gimp_pastell ${1--2}",$-1
gimp_SmoothSketch :
UsmRadius=5
CreateSketch=$1
UsmAmount=$1
Sharpness=$2
Anisotropy=$3
SmScale=$4
SmAccuracy={$5}
Amplitude=$6
fi=$7
Density=$8
BlurLength=$9
Style=$10
BgOpacity=$11
PostGamma=$12
OptimizedResult=$13
-if $OptimizedResult
OriginalWidth={0,w}
#Resize to 1024 width (all in case a bottom layer is included
-resize2dx 1024
-gimp_selective_smoothing[-1] 5,0.5,5,1,0,0,24,0
-endif
-if {$CreateSketch==1}
#Unsharp to enhance edges and detail
#-unsharp[-1] $UsmRadius,$UsmAmount
-gimp_unsharp[-1] 0,$UsmRadius,30,$UsmAmount,0,1,1,1,0,0,0
#Gradient norm for lines
--gradient_norm[-1]
#Invert for white bg
-negative[-1]
#Normalize for max range
-normalize[-1] 0,255
-endif
(255;255;255)
-r[-1] [-2]
-gimp_noise[-1] $Density,0,3,0,0
-if {$Style==0}
-gimp_blur_linear[-1] $BlurLength,0,135,500,1,3,0,0
-endif
-if {$Style==1}
-gimp_blur_angular[-1] $BlurLength,1.2,1.2,0,0,0
-endif
-if {$Style==2}
-gimp_blur_linear[-1] $BlurLength,0,135,500,1,3,0,0
-deform[-1] {$Density/5}
-endif
-if {$Style==3}
-gimp_blur_angular[-1] $BlurLength,1.2,1.2,0,0,0
-deform[-1] {$Density/5}
-endif
-blend[-1,-2] multiply,$BgOpacity,0
-normalize[-1] 0,255
--diffusiontensors[0] $Sharpness,$Anisotropy,0.6,1.1,0
-rotation3d 0,0,1,{$fi}
-mix_channels[-2] ({@0-2};{@3-5};{@6-8})
-rm[-1]
-mul[-1] {$SmScale/max(abs(iM),abs(im))}
-noise[-1] {$SmAccuracy*max(abs(iM),abs(im))}
-reverse[-1,-2]
-smooth[-1] [-2],$Amplitude
-keep[-1]
-apply_gamma[-1] $PostGamma
-if $OptimizedResult
-resize2dx $OriginalWidth
-endif
gimp_SmoothSketch_preview :
-gimp_split_preview "-gimp_SmoothSketch ${1--2}",$-1
gimp_DemoVecRot :
angle=$1
-to_rgb[0]
[0]
-to_rgb[-1]
-split[-1] c
--[-2] 128
--[-3] 128
-append[-3,-2,-1] c
-channels[-1] 0,1
-/[-1] 128
#200,200,1,2 200x200x1 px only two channels
-rotation3d 0,0,1,$angle
-z[-1] 0,0,1,1
-mix_channels[-2] ({@0-1};{@2-3})
-rm[-1]
-quiver[-2] [-1],10,10,1,0.8,255
-keep[-2]
gimp_WarpTest :
MapType=$1
fi={$2*3.1415/180}
ZeroOffset=$3
LMult=$4
ShowQuiver=$5
-if {$MapType==0}
--gimp_local_orientation 0.5,0,100,0,4,0
-endif
cosfi={cos($fi)}
sinfi={sin($fi)}
-to_rgb[-2,-1]
--[-1] {128+$ZeroOffset}
-split[-1] c
-mul[3] 0
--mul[1] $cosfi
--mul[2] $sinfi
-sub[4] [5]
-rm[5]
--mul[1] $sinfi
--mul[2] $cosfi
-add[5] [6]
-rm[6]
-rm[1,2]
-rm[1]
100%,100%,100%,1,0
-append[1,2,3] c
-/[-1] {128/$LMult}
-channels[-1] 0,1
-if {$ShowQuiver==0}
-warp[-2] [-1],1,1,0
-endif
-if {$ShowQuiver==1}
-quiver[-2] [-1],10,{$LMult/100},1,0.8,255
-endif
-rm[-1]
gimp_jobs_colors :
-n 0,255 -if $2 -equalize 256 -endif
-luminance -apply_gamma {10^$1} -n 0,9 -round
(22,187,20,36,235,240,245,243,247,209^18,97,147,157,79,110,121,142,170,200^19,158,192,60,67,65,64,64,64,185)
-map[^-1] [-1] -rm[-1]
gimp_jobs_colors_preview :
-gimp_split_preview "-gimp_jobs_colors $*",$-1
gimp_steampen :
-repeat $! -l[$>] -split_opacity -l[0]
-gimp_pencilbw $1,$2,0,0,0
-gimp_kuwahara $3,$4,0,0
-blur_xy $5
-if {$6==1} -gimp_normalize_local 4.8,22,6.89,20,1,3,0
-elif {$6==2} -gimp_contrast_swm 2,0,1
-elif {$6==3} -gimp_contrast_swm 2,1,1
-elif {$6==4} -gimp_map_tones_fast 3,0.5,3, -endif
-if {$7==1} -equalize 255 -endif
-if {$8==1} -gimp_anisotropic_smoothing 60,$9,$10,$11,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
gimp_steampen_preview :
-gimp_split_preview "-gimp_steampen ${1--2}",$-1
gimp_compose_boostscreen :
-repeat $! -l[$>]
-gimp_compose_screen $1,$2 [-1] -gimp_compose_grainmerge $3,0
-endl -done
gimp_compose_colordoping :
-reverse -gimp_compose_lightness 1,$2 [^] -gimp_compose_multiply $1,0
gimp_colorsketchbw :
--blur $3 -hardsketchbw[-1] $1,$2,$4,$5,$6
-if $7 -negative[-1] -endif
-quantize[-2] $8  -to_rgb  -blur_xy[-2] $9,$9
-if {$10==0} -gimp_compose_colordoping $11,0
-elif {$10==1} -gimp_compose_darken $11,0
-elif {$10==2} -gimp_compose_hardlight $11,1
-elif {$10==3} -gimp_compose_grainmerge $11,1
-elif {$10==4} -gimp_compose_lightness $11,1
-elif {$10==5} -gimp_compose_multiply $11,0
-elif {$10==6} -gimp_compose_value $11,1 -endif
gimp_colorsketchbw_preview :
-gimp_split_preview "-gimp_colorsketchbw ${1--2}",$-1
gimp_colorstamp :
-repeat $! -l[$>] -split_opacity -l[0]
--norm
-if $1 -otsu[-1] 256 -else -t[-1] $2% -endif
-n[-1] 0,255
-apply_curve[-1] 1,0,0,101,33,170,229,255,255
-if {$3==1} -quantize[-2] $4 -to_rgb -blur_xy[-2] $5
-gimp_compose_darken 1,0 -endif
-endl -a c -endl -done
gimp_colorstamp_preview :
-gimp_split_preview "-gimp_colorstamp ${1--2}",$-1
gimp_compose_comix_color :
-rv -gimp_compose_lightness $1,$2 [^] -gimp_compose_grainmerge $3,0
gimp_compose_darkedges :
-gimp_compose_edges $1,$2,$3 [^] -gimp_compose_multiply $4,0
gimp_compose_darkscreen :
-repeat $! -l[$>]
-gimp_compose_screen $1,$2 [-1] -gimp_compose_multiply $3,0
-endl -done
gimp_graphic_boost :
-repeat $! -l[$>] -split_opacity -l[0]
-gimp_unsharp 1,$1,30,3,0,$2,0.40,1,0,0,0
-if {$3==1} -break -endif
--gimp_pencilbw $4,$5,0,0,0
-if {$6==1} -keep[-1] -break -endif
-if {$7==1} -gimp_anisotropic_smoothing[1] 60,$8,$9,$10,1.1,0.8,30,2,0,1,1,0 -endif
-if {$11==1} -keep[-1] -break -endif
-if {$12==1}  -reverse -endif
-if {$13==0} -gimp_compose_hardlight $14
-elif {$13==1} -gimp_compose_grainmerge $14
-elif {$13==2} -gimp_compose_multiply $14
-elif {$13==3} -gimp_compose_colorburn $14
-elif {$13==4} -gimp_compose_overlay $14
-elif {$13==5} -gimp_compose_value $14,0
-elif {$13==6} -gimp_compose_darken $14
-elif {$13==7} -gimp_compose_stamp $14 -endif
-if {$15==1} -gimp_anisotropic_smoothing 60,$16,$17,$18,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
gimp_graphic_boost_preview :
-gimp_split_preview "-gimp_graphic_boost ${1--2}",$-1
gimp_compose_graphicolor :
-reverse --gimp_compose_luminance $1,$2, -rm[-2] -gimp_compose_softlight $3,0
gimp_novelfx :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0} -gimp_normalize_local $2,$3,$4,$5,1,3,0 -endif
-if {$6==0} --gimp_pencilbw $7,$8,0,0,0 -endif
-if {$9==1} -keep[-1] -break -endif
-if {$10==1} -gimp_anisotropic_smoothing[-1] 60,$11,$12,$13,1.1,0.8,30,2,0,1,1,0 -endif
-if {$14==1} -keep[-1] -break -endif
-if {$15==1} -reverse -endif
-if {$16==0} -gimp_compose_overlay[-1,0] $17
-elif {$16==1} -gimp_compose_multiply[-1,0] $17
-elif {$16==2} -gimp_compose_softlight[-1,0] $17
-elif {$16==3} -gimp_compose_colorburn[-1,0] $17
-elif {$16==4} -gimp_compose_darken[-1,0] $17
-elif {$16==5} -gimp_compose_stamp[-1,0] $17
-elif {$16==6} -gimp_compose_hardlight[-1,0] $17
-elif {$16==7} -reverse[1,0] -gimp_compose_value[-1,0] $17,0
-elif {$16==8} -gimp_compose_grainmerge[-1,0] $17
-elif {$16==8} -gimp_compose_freeze[-1,0] $17 -endif
-if {$18==1} -gimp_anisotropic_smoothing 60,$19,$20,$21,1.1,0.8,30,2,0,1,1,0 -endif
-endl -a c -endl -done
gimp_novelfx_preview :
-gimp_split_preview "-gimp_novelfx ${1--2}",$-1
gimp_compose_graphixcolor :
-reverse --gimp_compose_value 1,$2 -keep[-1,-3] -gimp_compose_grainmerge $1,0
gimp_compose_heavyscreen :
-repeat $! -l[$>]
-gimp_compose_screen $1,$2 [-1] -gimp_compose_colorburn $3,0
-endl -done
gimp_metalgrain :
--Couleurs_Metalliques 1,1,19.86,0,0,0,7.4,11,3.96,20,1,0,0,1,1.9,10.2,1,0,0
-gimp_compose_overlay  $1,$2
gimp_metalgrain_preview :
-gimp_split_preview "-gimp_metalgrain ${1--2}",$-1
gimp_metallicstencils :
--Couleurs_Metalliques 0,1,22,0,0,1,7.8,9,7.6,16.6,1,0,0,1,2.4,8.2,1,0
--gimp_lylejk_stencil[0] 4,26.7045,2.41477,0
-rm[0]
-if {$1==0} -gimp_compose_darken 1,0
-elif {$1==1} -gimp_compose_lighten 1,0
-elif {$1==2} -gimp_compose_overlay 1,0 -endif
gimp_metallicstencils_preview :
-gimp_split_preview "-gimp_metallicstencils ${1--2}",$-1
compose_average :
-e[^-1] "Compose image$? two-by-two, using average mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -+
-endl -done -/ 2 -v +
compose_colorburn :
-e[^-1] "Compose image$? two-by-two, using colorburn mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --[-2] 255 -+[-1] 0.1 -/
-endl -done -* 256 -+ 255 -c 0,255 -v +
compose_darken :
-e[^-1] "Compose image$? two-by-two, using darken mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -min
-endl -done -v +
compose_difference :
-e[^-1] "Compose image$? two-by-two, using difference mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --
-endl -done -abs -v +
compose_divide :
-e[^-1] "Compose image$? two-by-two, using divide mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -*[-2] 256 -+[-1] 1 -/
-endl -done -c 0,255 -v +
compose_dodge :
-e[^-1] "Compose image$? two-by-two, using dodge mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --[-1] 255.1 -/
-endl -done -* -256 -c 0,255 -v +
compose_edges : -check {$1>=0}
-e[^-1] "Compose image$? using edge mode, with smoothness $1."
-if {$!>1} -v - -to_rgb -r[^0] [0],0,0,0.5,0.5 -repeat $! -l[$>]
--gradient_norm -+[-1] 1 -b[-1] $1 -n[-1] 1,10 -sqr[-1] -s[-2] c -*[-4--2] [-1] -a[-4--1] c
-endl -done -r[^0] [0],0,0,0.5,0.5 -+ -s[-1] c -/[-4--2] [-1] -rm[-1] -a[-3--1] c -v + -endif
compose_exclusion :
-e[^-1] "Compose image$? two-by-two, using exclusion mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --*[-2] [-1] -/[-1] -128 -+
-endl -done -v +
compose_fade :
-e[^-1] "Compose image$? using fading mode."
-v - -r[^0] ${-max_whd},100%,3
-r[1--2] 100%,100%,100%,${-max_s} -channels[-1] 0
-repeat {$!-1} ---[-1] $> -abs[-1] --[-1] 1 -*[-1] -1 -max[-1] 0 -*[$>,-1] -done
-rm[-1] -+ -v +
compose_freeze :
-e[^-1] "Compose image$? two-by-two, using freeze mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --[-2] 255 -sqr[-2] -+[-1] 0.1 -/
-endl -done -- 255 -* -1 -c 0,255 -v +
compose_grainextract :
-e[^-1] "Compose image$? two-by-two, using grain extract mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 --
-endl -done -+ 128 -c 0,255 -v +
compose_grainmerge :
-e[^-1] "Compose image$? two-by-two, using grain merge mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -+
-endl -done -- 128 -c 0,255 -v +
compose_hardlight :
-e[^-1] "Compose image$? two-by-two, using hard light mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5
--ge[-1] 128 --*[-3] [-2] -/[-1] 128
--[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
-*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1] -+
-endl -done -v +
compose_hue :
-e[^-1] "Compose image$? two-by-two, using hue mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2hsv[-2,-1] -sh[-2] 0,0 -j[-2] [-1] -rm[-5,-3,-1] -hsv2rgb[-1] -rm[-1]
-endl -done -v +
compose_interpolation :
-e[^-1] "Compose image$? two-by-two, using interpolation mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -* 0.012271846 -cos -/ -4 -+
-endl -done -+ 0.5 -* 256 -v +
compose_lighten :
-e[^-1] "Compose image$? two-by-two, using lighten mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -max
-endl -done -v +
compose_lightness :
-e[^-1] "Compose image$? two-by-two, using lightness mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2lab[-2,-1] -sh[-2] 0,0 -j[-2] [-1],0,0,0,0 -rm[-5,-3,-1] -lab2rgb[-1] -rm[-1]
-endl -done -v +
compose_luminance :
-e[^-1] "Compose image$? two-by-two, using luminance mode."
-v - -repeat {int($!/2)}
-to_colormode[-2,-1] 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba[-2,-1] -sh[-2,-1] 0,2
-rgb2ycbcr[-2,-1] -sh[-2] 0,0 -j[-2] [-1],0,0,0,0 -rm[-5,-3,-1] -ycbcr2rgb[-1] -rm[-1]
-mv[-1] 0 -done -v +
compose_median :
-e[^-1] "Compose image$? using median mode."
-if {$!==1} -return -endif
-v - -r[^0] [0],0,0,0.5,0.5 -a z -permute zxyc -s y,-64
-repeat $! -l[$>]
-r 100%,{w*100}%
-s z -median {w} w={w} -columns {int(w/2)} -r 1,{h/$w} -a z
-endl -done -a y -permute yzxc -v +
compose_multiply :
-e[^-1] "Compose image$? two-by-two, using multiply mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -*
-endl -done -/ 255 -v +
compose_negation :
-e[^-1] "Compose image$? two-by-two, using negation mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -+
-endl -done -- 255 -abs -- 255 -* -1 -v +
compose_overlay :
-e[^-1] "Compose image$? two-by-two, using overlay mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5
--ge[-2] 128
--*[-3] [-2] -/[-1] 128
--[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
-*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1] -+
-endl -done -v +
compose_reflect :
-e[^-1] "Compose image$? two-by-two, using reflect mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -sqr[-2] --[-1] 255.1 -/
-endl -done -* -1 -c 0,255 -v +
compose_rgba :
-e[^-1] "Compose image$? two-by-two, using alpha blending."
-v - -to_rgb[0--1:2] -compose_alpha -v +
compose_saturation :
-e[^-1] "Compose image$? two-by-two, using saturation mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2hsv[-2,-1] -sh[-2] 1,1 -j[-2] [-1],0,0,0,1 -rm[-5,-3,-1] -hsv2rgb[-1] -rm[-1]
-endl -done -v +
compose_screen :
-e[^-1] "Compose image$? two-by-two, using screen mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -- 255 -*
-endl -done -/ 256 -- 255 -* -1 -v +
compose_shapeaverage :
-e[^-1] "Compose image$? two-by-two, using shape average mode."
-v - -repeat {int($!/2)} -l[-2,-1] nm={0,n}
-channels[-1] 0 -ge[-1] 50% -label_fg[-1] 0 nb={iM+1} -*[-1] 256
-rv[-2,-1] m={im} M={iM} -n[-1] 0,255 -s[-1] c -+[^0] [0]
-repeat {$!-1}
-histogram[-1] {$nb*256},0,{$nb*256-1}
-i[-2] 256,1,1,1,'x' -r[-2] {w},1,1,1,0,2 -*[-2] [-1] -r[-2,-1] $nb,1,1,1,2 -max[-1] 1 -/[-2,-1]
-mv[-1] 1 -done
-/[0] 256 -a[^0] c -*[-1] {($M-$m)/256} -+[-1] $m -point[-1] 0,0,0,1,0 -map[0] [-1] -rm[-1]
-nm $nm,1 -endl -mv[-1] 0 -done -v +
compose_softlight :
-e[^-1] "Compose image$? two-by-two, using soft light mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -/ 256 --*[-2] [-1] -*[-1] 2 -sqr[-3] -*[-2] [-3] -*[-2] -2 -+
-endl -done -* 256 -v +
compose_stamp :
-e[^-1] "Compose image$? two-by-two, using stamp mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -*[-1] 2 -+
-endl -done -- 255 -c 0,255 -v +
compose_value :
-e[^-1] "Compose image$? two-by-two, using value mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -to_rgba -sh 0,2
-rgb2hsv[-2,-1] -sh[-2] 2,2 -j[-2] [-1],0,0,0,2 -rm[-5,-3,-1] -hsv2rgb[-1] -rm[-1]
-endl -done -v +
compose_xor :
-e[^-1] "Compose image$? two-by-two, using xor mode."
-v - -repeat {int($!/2)} -l[$>,{$>+1}]
-to_colormode 0 -r[-1] [-2],0,0,0.5,0.5 -xor
-endl -done -v +
_gimp_compose :
-repeat {int($!/2)} --compose_$1[-2,-1] -rm[-3] -to_rgba[-1] -sh[-1] 3,3 -*[-1] $2 -rm[-1] -compose_alpha[-2,-1] -mv[-1] 0 -done
_gimp_revert_layers :
-repeat {int($!/2)} -rv[{2*$>},{2*$>+1}] -done
gimp_compose_average :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose average,$1
gimp_compose_colorburn :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose colorburn,$1
gimp_compose_darken :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose darken,$1
gimp_compose_difference :
-if ${2=0} -_gimp_revert_layers -endif
-to_rgb -_gimp_compose difference,$1
gimp_compose_divide :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose divide,$1
gimp_compose_dodge :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose dodge,$1
gimp_compose_edges :
-if ${3=0} -_gimp_revert_layers -endif
-repeat {int($!/2)} --compose_edges[-2,-1] $2 -rm[-3] -to_rgba[-1] -sh[-1] 3,3 -*[-1] $1 -rm[-1] -compose_alpha[-2,-1] -mv[-1] 0 -done
gimp_compose_exclusion :
-if ${2=0} -_gimp_revert_layers -endif
-to_rgb -_gimp_compose exclusion,$1
gimp_compose_fade :
-if {$!==1} -return -endif
-to_colormode 4
-if {$1==0} [0],[0],1,1,"$10"
-else -_gimp_compose_fade$1 $7,$8,$9 -r[-1] [0],[0],1,1,3
-endif
-n[-1] {-($!-2)*$3},{($!-2)*(1+$3)}
--[-1] {$2*(1+$3)*($!-2)}
-c[-1] 0,{$!-2}
-if $6 -rv[^-1] -endif
-if $5 -round[-1] 1
-else -roundify[-1] $4
-endif
-compose_fade
-c 0,255
_gimp_compose_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_gimp_compose_fade2 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1
_gimp_compose_fade3 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1 -*[-1] {0.01+$3/2} -cos[-1]
_gimp_compose_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"
gimp_compose_freeze :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose freeze,$1
gimp_compose_grainextract :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose grainextract,$1
gimp_compose_grainmerge :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose grainmerge,$1
gimp_compose_hardlight :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose hardlight,$1
gimp_compose_hue : -skip ${2=0}
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose hue,$1
gimp_compose_interpolation :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose interpolation,$1
gimp_compose_lighten :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose lighten,$1
gimp_compose_lightness : -skip ${2=0}
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose lightness,$1
gimp_compose_luminance : -skip ${2=0}
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose luminance,$1
gimp_compose_multiply :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose multiply,$1
gimp_compose_negation :
-if ${2=0} -_gimp_revert_layers -endif
-to_rgb -_gimp_compose negation,$1
gimp_compose_overlay :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose overlay,$1
gimp_compose_reflect :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose reflect,$1
gimp_compose_saturation : -skip ${2=0}
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose saturation,$1
gimp_compose_screen :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose screen,$1
gimp_compose_shapeaverage :
-if ${3=0} -_gimp_revert_layers -endif
-to_rgb
-repeat {int($!/2)}
-rv[-2,-1]
-if $1 -i[0] [-1] -endif
-compose_shapeaverage[-2,-1]
-if $1 -*[0,-1] -/[0] 255 -mv[0] $! -endif
-if $2 -to_rgba[-1] -replace_color[-1] 0,0,0,0,0,255,0,0,0,0 -endif
-mv[-1] 0 -done
gimp_compose_softlight :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose softlight,$1
gimp_compose_stamp :
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose stamp,$1
gimp_compose_value : -skip ${2=0}
-if ${2=0} -_gimp_revert_layers -endif
-_gimp_compose value,$1
gimp_compose_xor :
-if ${2=0} -_gimp_revert_layers -endif
-to_rgb -_gimp_compose xor,$1
jl_hsv_to_rgb :
({360*$1}^$2^$3) -hsv2rgb[-1] -u {^} -rm[-1]
levels :
_inplow={int($1)}
_inphigh={int($2)}
_gamma=$3
_outlow={int($4)}
_outhigh={int($5)}
_tmp2=""
-if {$_gamma!=1}
_tmp2="-apply_gamma "$_gamma
-apply_channels $_tmp2,$6,0
-endif
_curve1="0,"
-if {$_inplow>0}
_tmp1="0,"
_curve1=$_curve1$_tmp1$_outlow","
-endif
_curve1=$_curve1$_inplow","$_outlow","$_inphigh","$_outhigh
-if {$_inphigh<255}
_curve1=$_curve1",255,"$_outhigh
-endif
-if {['$_curve1']!='0,0,0,255,255'}
_tmp2="-apply_curve "$_curve1
-apply_channels $_tmp2,$6,0
-endif
gimp_equalize_s :
-repeat $! -l[$>] -split_opacity -l[0] -to_rgb
-rgb2hsv -sh 1,1 -*[-1] $1 -+[-1] $2 -c[-1] 0,1 -rm[-1] -hsv2rgb
-endl -a c -endl -done
gimp_phoenix :
--gimp_pencilbw $1,$2,0,0,0
-gimp_kuwahara[1] $3,$4,0,0
-to_rgb[-1] -blur_xy[1] $5
-if {$6==0} -remove[0] -return -endif
-if {$8==0} -reverse -gimp_compose_value $9,$7
-elif {$8==1} -reverse -gimp_compose_lightness $9,$7
-elif {$8==2} -reverse -gimp_compose_luminance $9,$7
-elif {$8==3} -gimp_compose_colordoping $9,$7
-elif {$8==4} -gimp_compose_comix_color $9,$7,$10
-elif {$8==5} -gimp_compose_graphicolor $9,0,$7
-elif {$8==6} -gimp_compose_graphixcolor $9,$7
-elif {$8==7} -gimp_compose_vividedges $9,0.50,$7,$10
-elif {$8==8} -gimp_compose_darkedges $9,0.50,$7,$10
-elif {$8==6} -gimp_compose_multiply $9,$7
-elif {$8==7} -gimp_compose_colorburn $9,$7
-elif {$8==8} -gimp_compose_darken $9,$7
-elif {$8==9} -gimp_compose_lighten $9,$7
-elif {$8==10} -gimp_compose_screen $9,$7
-elif {$8==11} -gimp_compose_hardlight $9,$7
-elif {$8==12} -gimp_compose_softlight $9,$7
-elif {$8==13} -gimp_compose_overlay $9,$7
-elif {$8==14} -gimp_compose_grainmerge $9,$7
-elif {$8==15} -gimp_compose_edges $9,0.80,$7
-elif {$8==16} -gimp_compose_interpolation $9,$7  -endif
gimp_phoenix_preview :
-gimp_split_preview "-gimp_phoenix ${1--2}",$-1
gimp_psyglass :
-repeat $! -l[$>] -split_opacity -l[0]
-if {$1==0}
-blur 0.1 -stained_glass $2,$3,$4 -n 0,255
-elif {$1==1}
-negative -blur 0.1 -stained_glass $2,$3,$4 -n 0,255 -negative
-endif
-if $5 -equalize 256 -endif
--blur 0.9
-if {$6==0} -gimp_compose_grainmerge $7
-elif {$6==1} -gimp_compose_hardlight $7
-elif {$6==2} -gimp_compose_softlight $7
-elif {$6==3} -gimp_compose_overlay $7
-elif {$6==4} -gimp_compose_colorburn $7
-elif {$6==5} -gimp_compose_multiply $7
-endif
-if {$8==1} -gimp_contrast_swm 2,0,1,0 -endif
-if {$9==1} -gimp_normalize_local 2,6,5,20,1,3,0 -endif
-if $10
-if {$15==1} -mirror x
-elif {$15==2} -mirror y
-elif {$15==3} -rotate 90
-elif {$15==4} -rotate 180
-elif {$15==5} -rotate 270
-endif
-array_mirror $11,$14,$16
-shift -$12%,-$13%,0,0,2
-endif
-endl -a c -endl -done
gimp_psyglass_preview :
-gimp_split_preview " -gimp_psyglass ${1--2}",$-1
gimp_scaledown3 :
-if {$1==0 && $4==0} -blur_xy {w/$5},{h/$6}
-elif {$1==0 && $4==1} -blur_xy {w/$5},{w/$6}
-elif {$1==0 && $4==2} -blur_xy {h/$5},{w/$6}
-elif {$1==1 && $4==0} -blur_xy $2 ,$3
-elif {$1==1 && $4==1} -blur_xy $2 ,$3
-elif {$1==1 && $4==2} -blur_xy $2 ,$3
-endif
-if {$4==0}
-resize $5,$6,2
-elif {$4==1}
-resize2dx $5,2
-elif {$4==2}
-resize2dy $6,2
-endif
-if {$7==0}
-gimp_unsharp 0,1.25,30,$8,0,$9,{$9/3},1,0,$10
-endif
gimp_scaledown3_preview :
-gimp_split_preview "-gimp_scaledown3 ${1--2}",$-1
gimp_viral :
-gimp_rorschach $1,1,1
--mirror y
-if {$2==0} -gimp_compose_average 1,0
-elif {$2==1} -gimp_compose_grainextract 1,0
-elif {$2==1} -gimp_compose_vividedges 1,1,0.5,1 -endif
--gimp_array_mirror 1,0,0,2,0,0
-if {$3==0} -gimp_compose_vividedges 1,1,0.5,1
-elif {$3==1} -gimp_compose_average 1,0
-elif {$3==2} -gimp_compose_difference 1,0
-elif {$3==3} -gimp_compose_negation 1,0
-elif {$3==4} -gimp_compose_negation 1,0
-elif {$3==5} -gimp_compose_darkedges 1,1,0.8,1 -endif
-if {$4==0} -gimp_graphic_novelfxl 0,2,6,5,20,0,0.62,14,0,1,0.5,0.78,1.92,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==1}-gimp_graphic_novelfxl 0,7.2,14.65,5,20,0,1.06,36.14,0,1,0.5,0.85,1.93,0,0,8,1,1,1,0.5,0.95,2.89,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==2} -gimp_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.6,36.1,0,1,0.5,0.6,3.6,0,0,11,1,1,1,0.5,0.8,2.16,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$4==3}  -gimp_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,17,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,7,1,1,1,0.5,0.45,1
-elif {$4==4} -gimp_graphic_novelfxl 0,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.855422,1.92771,0,0,8,1,1,1,0.5,0.373494,2.89157,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==5} -gimp_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,14,0,1,0.5,0.855422,1.3253,0,0,12,1,1,1,0.5,0.8,1.28,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==6} -gimp_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.06024,36.1446,0,1,0.5,0.855422,1.92771,0,0,7,1,1,1,0.5,0.951807,1.92771,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1
-elif {$4==7} -gimp_graphic_novelfxl 1,7.22892,14.6506,5,20,0,1.59036,36.1446,0,1,0.5,0.590361,3.61446,0,1,18,1,1,1,0.5,0.795181,2.16867,1.25,2,0,0.15,14,0,1,0.5,0.45,2,0,1,0,1,1,1,0.5,0.45,1 -endif
-if {$5==1} -gimp_array_mirror 1,0,0,2,0,$6
-elif {$5==2} -gimp_array_mirror 1,0,0,3,0,$6 -endif
gimp_compose_vivid_color :
-reverse -gimp_compose_lightness $1,$2 [^] -gimp_compose_softlight $3,0
gimp_compose_vividedges :
-gimp_compose_edges $1,$2,$3 [^] -gimp_compose_overlay $4,0
gimp_compose_vividscreen :
-repeat $! -l[$>]
-gimp_compose_screen $1,$2 [-1] -gimp_compose_overlay $3,0
-endl -done
gimp_m_l_unsharp2 :
--unsharp $1,$2,0
-unsharp $3,$4,0[1] -reverse -gimp_compose_darken $5
--unsharp $3,$4,0 -reverse -gimp_compose_lighten $6
-if {$7==1} -gimp_anisotropic_smoothing 60,$8,$9,$10,1.1,0.8,30,2,0,1,1,0 -endif
gimp_m_l_unsharp2_preview :
-gimp_split_preview "-gimp_m_l_unsharp2 ${1--2}",$-1
plasma_transition: -check "isint(${4=42}) && isint(${2=5}) && ${1=0.5}>=0  && $1<=1 && $2>=0 && ${3=1}>=0"
-repeat {int($!/2.0)}
-local[{$>},{$>+1}]
-if {$!<2} -return -endif
-r ${-max_whds},3
100%,100% -srand $4 -plasma[-1] 1,0,$2 -n[-1] 0,1
--le[-1] $1 -b[-1] $3
-rm[-2]
-j[-3] [-2],0,0,0,0,1,[-1]
-keep[-3]
-endlocal
-done
randomwaves:  -check  "isint(${1=84})  &&  ${2=80}>=0  &&  $2<=100  && ${3=1.2}>0. && isint(${4=42})"
-srand $4
(0,1,0;1,0,1;0,1,0) -/[-1] 2
-nm[-1] matconv
{0,w},{0,h},1,1 -set[-1] 255,{u(100)}%,{u(100)}%
[-1]
-repeat $1
[-1]
-if {${2}>=u(100)}
-circle[-1] {u(100)}%,{u(100)}%,{u(3)},,255
-endif
-convolve[-1] [matconv] -div[-1] $3 -sub[-1] [-3]
-rm[-3]
-done
-rm[-2,matconv]
-g[-1] -a[-1,-2] c -warp[0] [-1],1 -rm[-1]
gimp_adjust_orientation :
-repeat $!
M={max(w,h)}
--gradient_norm[-1] -ge[-1] $1%
--*[-1] '1+y' -*[-2] '1+x' -a[-2,-1] c
-r[-1] {w*h},2,1,1,-1 -sort[-1] +,x -autocrop[-1] 0
-/[-1] $M --r[-1] 1,2,1,1,2 -r[-1] [-2] --[-2,-1]
--transpose[-1] -**[-2,-1]
-eigen[-1] -rm[-2] -z[-1] 0,0
-if {i<0} -*[-1] -1 -endif
theta={180*atan2(i(0,1),i)/pi}
-rm[-1]
-if {w>h} -rotate[-1] {-$theta},1,0,50%,50%
-else -rotate[-1] {-$theta+90},1,0,50%,50%
-endif
-mv[-1] 0 -done
gimp_faded_mirror :
-repeat $! -l[$>]
-if {$1==0}
100%,1,1,1,"a=1/(1-w*$2%);b=-a*(w-1);a*x+b" -c[-1] 0.01,1 -*[-2] [-1]
-r[-1] 100%,[-2] -a c -r {2*w-w*$3%},100%,1,100%,0 --mirror x
-else
1,100%,1,1,"a=1/(1-h*$2%);b=-a*(h-1);a*y+b" -c[-1] 0.01,1 -r[-1] [-2],100% -*[-2] [-1]
-a c -r 100%,{2*h-h*$3%},1,100%,0 --mirror y
-endif
-+ -s[-1] c,-{s-1} -/[-2,-1]
-endl -done
gimp_gca :
channel={1+$6}
-repeat $! -l[$>] -to_color -split_opacity -l[0]
--fc $1,$2,$3
--[1] [0] -norm[1] -/[1] {1e-6+iM} -*[1] -1 -+[1] 1 -pow[1] $4
-rgb2hsl[0] -s[0] c
-if {$5==0} -*[$channel,-1]
-elif {$5==1} ($1^$2^$3) -rgb2hsl[-1] -*[$channel] {i[$channel]} -rm[-2,-1]
-else -rv[$channel,-1] -rm[-1]
-endif
-a c -hsl2rgb
-endl -a c -endl -done
gimp_gca_preview :
-gimp_split_preview "-gimp_gca $*",$-1
gimp_grain :
-repeat $! -l[$>] -apply_channels "-_gimp_grain ${1-13}",$4,0 -endl -done
_gimp_grain :
-if {!$1} -return -endif
s={s} --luminance
-if $5
100%,100%,1,$s -noise[-1] 1,$3 -b[-1] $6 -*[-1] {(1-$7)/max(abs(im),abs(iM))}
100%,100%,1,1 -noise[-1] 1,$3 -b[-1] $6 -*[-1] {$7/max(abs(im),abs(iM))}
-+[-2,-1] --ir[1] 0,85 -b[-1] $2 -n[-1] 0,1 -*[-2,-1] -*[-1] $5
-endif
-if $8
100%,100%,1,$s -noise[-1] 1,$3 -b[-1] $9 -*[-1] {(1-$10)/max(abs(im),abs(iM))}
100%,100%,1,1 -noise[-1] 1,$3 -b[-1] $9 -*[-1] {$10/max(abs(im),abs(iM))}
-+[-2,-1] --ir[1] 86,169 -b[-1] $2 -n[-1] 0,1 -*[-2,-1] -*[-1] $8
-endif
-if $11
100%,100%,1,$s -noise[-1] 1,$3 -b[-1] $12 -*[-1] {(1-$13)/max(abs(im),abs(iM))}
100%,100%,1,1 -noise[-1] 1,$3 -b[-1] $12 -*[-1] {$13/max(abs(im),abs(iM))}
-+[-2,-1] --ir[1] 170,256 -b[-1] $2 -n[-1] 0,1 -*[-2,-1] -*[-1] $11
-endif
-rm[1] -+[-3--1] -n[-1] -$1,$1 -+ -c 0,255
gimp_grain_preview :
-gimp_split_preview "-gimp_grain $*",$-1
gimp_layer_info :
-repeat $! -l[$<] nm={n}
-animate blur,0,10,$1
-nm $nm
-endl -done
-repeat $! -l[$>]
0 -t[-1] "Layer indice: ""#"$>"\nLayer name: "${-gimp_layer_name}"\nBlending mode: "${-gimp_layer_mode}"\nOpacity : "${-gimp_layer_opacity}"\nPosition: "${-gimp_layer_pos},0,0,40,1,255
-to_rgba[0] -expand_xy[-1] 8,0 --dilate[-1] 8 -to_colormode[1] {0,s} -j[0] [1],20,20,0,0,1,[2],255
-k[0]
-endl -done
gimp_layer_info_preview :
-gimp_layer_info $1
-gimp_preview
gimp_perspective_scale :
-repeat $! -l[$<] -to_rgba
w={w} h={h}
f=100 -repeat {$1-1} f={$f*$2%} --r[0] $f%,$f%,1,4,2 -done
-repeat {$!-1} -l[{$>+1}]
sx={round(($>+1)*$w*$3%/($1-1))}
sy={round(($>+1)*$h*$4%/($1-1))}
-r $w,$h,1,4,0,0,0.5,0.5 -shift[-1] $sx,$sy,0,0,0
-endl -done
-if {!$5} -repeat {$!-1} -blend[0,1] alpha,1,1 -done -endif
-endl -done
gimp_perspective_scale_preview :
-gimp_perspective_scale ${1-4},0
dt_segment_shaded :
-repeat $! -l[$>]
-b $3 -segment_watershed $1,1
--g xy,1 -a[-2,-1] c -norm[-1] -neq[-1] 0 -distance[1] 1 -normalize_local[-1] 1000
-n[-1] 0,1 -^[-1] {max(1e-5,$2)} -n[-1] 0,255
-blend value
-endl -done
samj_about :
-text_outline "Bonjour!",{{min({w},{h})}/20},{{min({w},{h})}/20},{{min({w},{h})}/5},1,255,255,255,255
at : -skip ${1=0},${2=0},${3=0}
-v - --z. ${1-3},${1-3} -u {^} -rm. -v +
samj_rien_arrays_and_tiles :
-Je_passe_l_hiver_en_Floride[-1]
Annular_Steiner_Chain_Round_Tile:
Dimension_Finale=$1
Supprimer_Calque_Origine=$2
X={round({{w}*{$3/100}})}
Y={round({{h}*{$4/100}})}
Dimension_Image=$5
Decalage_Angle_Images_Contour=$6
Image_Contour_Dimension=$7
Nb_Circles_Surrounding=$8
Angle_inclinaison=$9
Activer_Couleurs_Formes=$10
R_Contours=$11
V_Contours=$12
B_Contours=$13
A_Contours=$14
Affichage_Contours=$15
R_c=$16
V_c=$17
B_c=$18
A_c=$19
R_d=$20
V_d=$21
B_d=$22
A_d=$23
Couleurs_aleatoires=$24
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Theta={pi/$Nb_Circles_Surrounding}
# variables dimensions
Rayon_Cercle_Exterieur_Final={$Dimension_Finale/2}
Rayon_Cercle_Centre_Final={{$Rayon_Cercle_Exterieur_Final*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
Rayon_Cercles_Ext_Final={{$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final}/2}
Rayon_Centres_C_Ext_Final={$Rayon_Cercle_Centre_Final+$Rayon_Cercles_Ext_Final}
Rayon_Tang_Final={{{$Rayon_Centres_C_Ext_Final*$Rayon_Centres_C_Ext_Final}-{$Rayon_Cercles_Ext_Final*$Rayon_Cercles_Ext_Final}}^0.5}
Fin_X={round({{{w}-$X}*$Dimension_Image/{100}})}
Fin_Y={round({{{h}-$Y}*$Dimension_Image/{100}})}
-if {$Fin_X>$Fin_Y}
Rayon_Cercle_Centre_Origine={$Fin_Y/2}
-else
Rayon_Cercle_Centre_Origine={$Fin_X/2}
-endif
-to_rgb[-1]
# masque image extrieure
{$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},{$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,{{w}/2},1,0,0,0,255
# image extrieure
--Je_passe_l_hiver_en_Floride[0]
-crop[-1] $X,$Y,{$X+{$Rayon_Cercle_Centre_Origine*2}},{$Y+{$Rayon_Cercle_Centre_Origine*2}}
-resize2dy[-1] {$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100}
-blend[-1,-2] alpha
# masque image centrale
{$Rayon_Cercle_Centre_Final*2},{$Rayon_Cercle_Centre_Final*2},1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,{{w}/2},1,0,0,0,255
# image centrale
--Je_passe_l_hiver_en_Floride[0]
-crop[-1] $X,$Y,{$X+{$Rayon_Cercle_Centre_Origine*2}},{$Y+{$Rayon_Cercle_Centre_Origine*2}}
-resize2dy[-1] {$Rayon_Cercle_Centre_Final*2}
-blend[-1,-2] alpha,1,1
-expand_xy[-1] {$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final},0
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Dimension_Img_pivotee=0
X_Deplacement=0
Y_Deplacement=0
-repeat $Nb_Circles_Surrounding
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{cos({pi/180*{$Angle+$Angle_inclinaison}})}}}
Y_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{sin({pi/180*{$Angle+$Angle_inclinaison}})}}}
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
-endif
-if {$Activer_Couleurs_Formes==1}
-if {{($Nb_Circles_Surrounding%2)}==0}
-if {{($Nb_boucles%2)}==0}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_c,$V_c,$B_c,$A_c
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_d,$V_d,$B_d,$A_d
-endif
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_c,$V_c,$B_c,$A_c
-endif
-if {$Affichage_Contours>0}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
--Je_passe_l_hiver_en_Floride[-2]
-rotate[-1] {$Angle+$Decalage_Angle_Images_Contour}
-crop[-1] {{{w}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{{w}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}},{{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}}
X_Deplacement={$X_ext-$Rayon_Cercles_Ext_Final}
Y_Deplacement={$Y_ext-$Rayon_Cercles_Ext_Final}
-crop[-1] {-$X_Deplacement},{-$Y_Deplacement},{{2*$Rayon_Cercle_Exterieur_Final}-$X_Deplacement-1},{{2*$Rayon_Cercle_Exterieur_Final}-$Y_Deplacement-1},0
-blend[-1,-2] alpha,1,1
-done
-if {$Activer_Couleurs_Formes==1}
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-ellipse[-1] 50%,50%,$Rayon_Cercle_Exterieur_Final,$Rayon_Cercle_Exterieur_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-ellipse[-1] 50%,50%,$Rayon_Cercle_Centre_Final,$Rayon_Cercle_Centre_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==2}||{$Affichage_Contours==3}}
-ellipse[-1] 50%,50%,$Rayon_Centres_C_Ext_Final,$Rayon_Centres_C_Ext_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==3}||{$Affichage_Contours==4}}
-ellipse[-1] 50%,50%,$Rayon_Tang_Final,$Rayon_Tang_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
-rm[-2]
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-else
-reverse[0,-1]
-endif
#-text_outline[-1] {2*$Rayon_Cercle_Exterieur_Final},10,10,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercles_Ext_Final},10,60,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Centres_C_Ext_Final},10,110,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Tang_Final},10,160,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercle_Centre_Final},10,210,64,1,1,255,255,255
Cercles_Concentriques_A:
Dimension_Finale=$1
Supprimer_Calque_Origine=$2
Nb_Circles={$3+1}
Type_Variation_Dimensions_Cercles=$4
Angle_Variation_Origine=$5
Angle_Variation_Fin=$6
Coef_Variation=$7
Sens_Rotation_Horaire=$8
Decalage_Cercles={$9-50}
Conserver_Exterieur_Cercles=$10
Activer_Rayons_De_Couleurs=$11
R_Contours=$12
V_Contours=$13
B_Contours=$14
A_Contours=$15
Affichage_Contours=$16
Dilate_Contours=$17
Flou_Contours=$18
Sharpen_Contours=$19
Repetition_Couleurs=$20
Angle_Decalage_Couleurs=$21
R_a=$22
V_a=$23
B_a=$24
A_a=$25
R_b=$26
V_b=$27
B_b=$28
A_b=$29
R_c=$30
V_c=$31
B_c=$32
A_c=$33
R_d=$34
V_d=$35
B_d=$36
A_d=$37
R_e=$38
V_e=$39
B_e=$40
A_e=$41
Couleurs_aleatoires=$42
Melange_Couleurs_Contours=$43
Filtre_Symmetrizoscope=$44
Iterations_Symmetrizoscope=$45
Angle_Symmetrizoscope=$46
Symmetry_Sides=$47
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Rayon_Cercle_Final={round({{$Dimension_Finale/2}-1})}
Rayon_Cercle_En_Cours=0
Rayon_Cercle_Precedent=0
Rayon_Dernier_Cercle=0
Rayon_De_Couleur={round({1+{$Dimension_Finale*{2^0.5}}})}
Decrement_Rayon=0
Angle_Rayon_De_Couleur={72/$Repetition_Couleurs}
Angle_Rayon_De_Couleur_En_Cours=0
Angle_Rayon_De_Couleur_En_Cours_Fin=0
Nb_De_Rayon_De_Couleur=0
# 2 nouvelles images contours
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-if {$Activer_Rayons_De_Couleurs==0}
--Je_passe_l_hiver_en_Floride[0]
-if {$Largeur_Origine>$Hauteur_Origine}
-crop[-1] {{$Largeur_Origine-$Hauteur_Origine}/2},0,{{{$Largeur_Origine-$Hauteur_Origine}/2}+$Hauteur_Origine-1},$Hauteur_Origine
-elif {$Largeur_Origine<$Hauteur_Origine}
-crop[-1] 0,{{$Hauteur_Origine-$Largeur_Origine}/2},$Largeur_Origine,{{{$Hauteur_Origine-$Largeur_Origine}/2}+$Largeur_Origine-1}
-endif
-resize[-1] $Dimension_Finale,$Dimension_Finale
-to_rgba[-1]
-endif
-if {$Activer_Rayons_De_Couleurs==1}
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,255
-endif
-if {$Sens_Rotation_Horaire==1}
Angle_Decalage_Couleurs_En_Cours={$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
-else
Angle_Decalage_Couleurs_En_Cours={{$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}+{$Angle_Rayon_De_Couleur/2}}
-endif
-repeat $Repetition_Couleurs
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_a,$V_a,$B_a,$A_a
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_b,$V_b,$B_b,$A_b
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_c,$V_c,$B_c,$A_c
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_d,$V_d,$B_d,$A_d
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
-if {$Activer_Rayons_De_Couleurs==1}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_e,$V_e,$B_e,$A_e
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-done
Rayon_Cercle_En_Cours=$Rayon_Cercle_Final
Rayon_Cercle_Precedent=$Rayon_Cercle_Final
Nb_boucles=0
# Rotation des cercles concentriques
-repeat $Nb_Circles
-if {$Type_Variation_Dimensions_Cercles==0}
-if {{$Nb_Circles-$Nb_boucles}>1}
Decrement_Rayon={abs({{{$Rayon_Cercle_Precedent*{cos({pi/180*{$Angle_Variation_Fin}})}}-{$Rayon_Cercle_Precedent*{cos({pi/180*{$Angle_Variation_Origine}})}}}/$Nb_Circles})}
-else
Decrement_Rayon={$Rayon_Cercle_Final-$Rayon_Cercle_En_Cours}
-endif
-elif {$Type_Variation_Dimensions_Cercles==1}
-if {{$Nb_Circles-$Nb_boucles}>1}
Decrement_Rayon={abs({{{$Rayon_Cercle_Precedent*{-1+{cos({pi/180*{$Angle_Variation_Fin}})}}}-{$Rayon_Cercle_Precedent*{1+{cos({pi/180*{$Angle_Variation_Origine}})}}}}/$Nb_Circles})}
-else
Decrement_Rayon={$Rayon_Cercle_Final-$Rayon_Cercle_En_Cours}
-endif
-elif {$Type_Variation_Dimensions_Cercles==2}
Decrement_Rayon={abs({{{$Rayon_Cercle_Final*{1+{cos({pi/180*{$Angle_Variation_Fin}})}}}-{$Rayon_Cercle_Final*{1+{cos({pi/180*{$Angle_Variation_Origine}})}}}}/$Nb_Circles})}
-endif
-if {$Sens_Rotation_Horaire==1}
Angle_Decalage_Couleurs_En_Cours={{$Decalage_Cercles*$Angle_Rayon_De_Couleur/100}+$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
-else
Angle_Decalage_Couleurs_En_Cours={{$Decalage_Cercles*$Angle_Rayon_De_Couleur/100*-1}+$Angle_Decalage_Couleurs_En_Cours-{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
-endif
-if {$Coef_Variation>0}
Rayon_Cercle_En_Cours={$Rayon_Cercle_En_Cours-{$Decrement_Rayon*$Coef_Variation}}
-else
Rayon_Cercle_En_Cours={$Rayon_Cercle_En_Cours-{$Decrement_Rayon*{abs($Coef_Variation)}/{$Nb_boucles+1}}}
-endif
--Je_passe_l_hiver_en_Floride[-1]
-rotate[-1] {$Angle_Decalage_Couleurs_En_Cours}
-crop[-1] {{{w}-$Dimension_Finale}/2},{{{h}-$Dimension_Finale}/2},{{{{w}-$Dimension_Finale}/2}+$Dimension_Finale-1},{{{{h}-$Dimension_Finale}/2}+$Dimension_Finale-1}
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_Precedent,1,255,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_En_Cours,1,0,0,0,255
-replace_color[-1] 100%,0,255,0,0,255,0,0,0,0
-blend[-1,-2] alpha,1,1
-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
-blend[-1,-2] alpha,1,1
-if {$Affichage_Contours>0}
-reverse[-1,-2]
$Dimension_Finale,$Dimension_Finale,1,4
--Je_passe_l_hiver_en_Floride[-2]
-rotate[-1] $Angle_Decalage_Couleurs_En_Cours
-crop[-1] {{{w}-$Dimension_Finale}/2},{{{h}-$Dimension_Finale}/2},{{{{w}-$Dimension_Finale}/2}+$Dimension_Finale-1},{{{{h}-$Dimension_Finale}/2}+$Dimension_Finale-1}
-circle[-1] 50%,50%,$Rayon_Cercle_En_Cours,1,0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_Precedent,1,0,0,0,0
-blend[-1,-2] alpha,1,1
-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
-blend[-1,-2] alpha,1,1
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}}
-ellipse[-1] 50%,50%,$Rayon_Cercle_En_Cours,$Rayon_Cercle_En_Cours,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-blend[-1,-4] alpha,1,0
-reverse[-1,-2]
-endif
Rayon_Dernier_Cercle=$Rayon_Cercle_Precedent
Rayon_Cercle_Precedent=$Rayon_Cercle_En_Cours
Nb_boucles={$Nb_boucles+1}
-done
-rm[-2]
# contour cercle
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}}
-ellipse[-2] 50%,50%,$Rayon_Cercle_Final,$Rayon_Cercle_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilate_Contours>1} -dilate_circ[-2] $Dilate_Contours -endif
-if {$Flou_Contours>0} -blur[-2] $Flou_Contours,0 -endif
-if {$Sharpen_Contours>0} -sharpen[-2] $Sharpen_Contours -endif
-if {$Filtre_Symmetrizoscope==1}
-gimp_symmetrizoscope[-1,-2] $Iterations_Symmetrizoscope,$Angle_Symmetrizoscope,0,$Symmetry_Sides
Conserver_Exterieur_Cercles=0
-endif
-if {$Conserver_Exterieur_Cercles==0}
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 255,0,0,255
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
-replace_color[-1] 100%,0,255,0,0,255,0,0,0,0
-reverse[-1,-2]
-blend[-2,-1] add,1,0
-endif
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-if {$Melange_Couleurs_Contours==1}
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-else
-reverse[-1,-2]
-endif
-else
-if {$Melange_Couleurs_Contours==1}
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-reverse[-1,-2]
-else
-reverse[-1,-2,-3]
-endif
-endif
samj_en_Coeurs_Hearts_002 :
-samj_Coeurs_Hearts_002 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15
samj_Bulles_Colorees :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Variation_L=$6
Variation_H=$7
Grossissement_A=$8
Grossissement_B=$9
Angle_Validation=$10
Angle_Variation=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Angle_Origine=$Angle_Variation
KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution+$Resolution}}
-repeat {$Hauteur_Origine/{$Resolution+$Resolution}}
couleur_pixel=${-at[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}
KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}
-if {$Angle_Validation==0}
Angle_Variation=$Angle_Origine
-else
Angle_Variation={$Angle_Origine+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}*180}}
-endif
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
Hauteur={$Hauteur+$Resolution+$Resolution}
-done
Largeur={$Largeur+$Resolution+$Resolution}
Hauteur=$Resolution
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
samj_Coeurs_Hearts_002 :
Resolution=$1
Remplissage=$2
Angle_Rotation_Motif=$3
flou=$4
Coeurs_Hearts=$5
Interpolation=$6
R_Couleur=$7
V_Couleur=$8
B_Couleur=$9
A_Couleur=$10
Gris=$11
Boost=$12
Type_Avant_Plan=$13
Mode_blend=$14
Opacity_blend=$15
-if {$Type_Avant_Plan==1}
--Je_passe_l_hiver_en_Floride[-1]
-to_rgb[-2]
-negative[-2]
-endif
-to_rgb[-1]
-negative[-1]
-if {$Interpolation==0}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution}
-c[-1] 0,255
-elif {$Interpolation==1}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution},1,3,3
-c[-1] 0,255
-elif {$Interpolation==2}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution}
-n[-1] 0,255
-elif {$Interpolation==3}
-resize[-1] {{w}/$Resolution},{{h}/$Resolution},1,3,3
-n[-1] 0,255
-endif
-if {$Type_Avant_Plan==1}
-resize[-2] {{w}*$Resolution},{{h}*$Resolution}
-rm[-1]
-else
-resize[-1] {{w}*$Resolution},{{h}*$Resolution}
-endif
-if {$Gris==1}
-to_gray[-1]
-endif
-c[-1] 0,255
-if {$Boost==1}
-gimp_balance_gamma[-1] 128,128,128,1
-endif
-negative[-1]
-to_rgba[-1]
$Resolution,$Resolution,1,4
-fill_color[-1] 0,0,0,0
-if {$Coeurs_Hearts==1}
(0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0;0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0;0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0;0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0;0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0;0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0;0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0)
-else
(1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0;1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1;0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1)
-endif
-if {$Angle_Rotation_Motif>0}
-rotate[-1] $Angle_Rotation_Motif,0,0
-autocrop[-1] 0
-endif
-resize[-1] {$Resolution*$Remplissage/100},{$Resolution*$Remplissage/100}
-blend[-1,-2] alpha
-resize[-1] [-2],[-2],1,1,0,2
-to_rgba[-1]
#-replace_color[-1] 100%,0,0,0,0,255,0,0,0,0
#-replace_color[-1] 100%,0,0,0,0,255,255,255,255,255
-replace_color[-1] 100%,0,0,0,0,255,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-replace_color[-1] 100%,0,1,1,1,255,0,0,0,0
-gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0
-if {$flou>0}
-blur[-1] $flou,0
-endif
samj_rien_atistic :
-Je_passe_l_hiver_en_Floride[-1]
samj_Ellipses_Colorees :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Rayon_L=$5
Rayon_H=$6
Rendu=$7
Flou_Contours=$8
Couleur_Fond_r=$9
Couleur_Fond_v=$10
Couleur_Fond_b=$11
Couleur_Fond_a=$12
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Hauteur=$Rayon_H
Largeur=$Rayon_L
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Rayon_L+$Rayon_L}}
-repeat {$Hauteur_Origine/{$Rayon_H+$Rayon_H}}
couleur_pixel=${-at[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
Hauteur={$Hauteur+$Rayon_H+$Rayon_H}
-done
Largeur={$Largeur+$Rayon_L+$Rayon_L}
Hauteur=$Rayon_H
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
samj_Losanges_Colores :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Inclinaison_Quadrilataire=$6
Variation_L=$7
Variation_H=$8
Grossissement_A=$9
Grossissement_B=$10
Dimension_Variation=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17
Contours_Polygones=$18
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Dimension_Origine={$Dimension_Variation*$Resolution}
KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution
X_a=0
Y_a=0
X_b=0
Y_b=0
X_c=0
Y_c=0
X_d=0
Y_d=0
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution+$Resolution}}
-repeat {$Hauteur_Origine/{$Resolution+$Resolution}}
couleur_pixel=${-at[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}
KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}
Dimension_Variation={$Dimension_Origine*{1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}}}}
-if {$Inclinaison_Quadrilataire==0}
X_a={$Largeur-{$Dimension_Variation*$KL}}
Y_a=$Hauteur
X_b=$Largeur
Y_b={$Hauteur+{$Dimension_Variation*$KH}}
X_c={$Largeur+{$Dimension_Variation*$KL}}
Y_c=$Hauteur
X_d=$Largeur
Y_d={$Hauteur-{$Dimension_Variation*$KH}}
-else
X_a={$Largeur-{$Dimension_Variation*$KL}}
Y_a={$Hauteur+{$Dimension_Variation*$KH}}
X_b={$Largeur+{$Dimension_Variation*$KL}}
Y_b={$Hauteur+{$Dimension_Variation*$KH}}
X_c={$Largeur+{$Dimension_Variation*$KL}}
Y_c={$Hauteur-{$Dimension_Variation*$KH}}
X_d={$Largeur-{$Dimension_Variation*$KL}}
Y_d={$Hauteur-{$Dimension_Variation*$KH}}
-endif
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
-if {$Contours_Polygones==1}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-elif {$Contours_Polygones==2}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,255,255,255,$alpha_pixel
-elif {$Contours_Polygones==3}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},$alpha_pixel
-elif {$Contours_Polygones==4}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{$rouge_pixel*0.5},{$vert_pixel*0.5},{$bleu_pixel*0.5},$alpha_pixel
-endif
Hauteur={$Hauteur+$Resolution+$Resolution}
-done
Largeur={$Largeur+$Resolution+$Resolution}
Hauteur=$Resolution
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
samj_Moirage_Spline :
Couleur_Ar=$1
Couleur_Av=$2
Couleur_Ab=$3
Couleur_Aa=$4
Resolution_A=$5
Decalage_A=$6
Spline_A_u0=$7
Spline_A_v0=$8
Spline_A_u1=$9
Spline_A_v1=$10
Spline_A_vertices=$11
Orientation_A=$12
Dilate_A={round({$13/100*$Resolution_A})}
Couleur_Br=$14
Couleur_Bv=$15
Couleur_Bb=$16
Couleur_Ba=$17
Resolution_B=$18
Decalage_B=$19
Spline_B_u0=$20
Spline_B_v0=$21
Spline_B_u1=$22
Spline_B_v1=$23
Spline_B_vertices=$24
Orientation_B=$25
Dilate_B={round({$26/100*$Resolution_B})}
Largeur_Origine={w}
Hauteur_Origine={h}
Nouvelle_Dimension={round({{{{$Largeur_Origine^2}+{$Hauteur_Origine^2}}^0.5}+1})}
Nouvelle_Dimension={$Nouvelle_Dimension+{max({abs({$Nouvelle_Dimension/100*$Spline_A_u0})},{abs({$Nouvelle_Dimension/100*$Spline_B_u0})})}+{max({abs({$Nouvelle_Dimension/100*$Spline_A_u1})},{abs({$Nouvelle_Dimension/100*$Spline_B_u1})})}}
XA_origine={round({$Resolution_A/100*$Decalage_A})}
YA_origine=0
XA_fin=$XA_origine
YA_fin=$Nouvelle_Dimension
XB_origine=0
YB_origine={round({$Resolution_B/100*$Decalage_B})}
XB_fin=$Nouvelle_Dimension
YB_fin=$XB_origine
$Nouvelle_Dimension,$Nouvelle_Dimension,1,4
-repeat {$Nouvelle_Dimension/$Resolution_A}
-spline[-1] $XA_origine,$YA_origine,{$Nouvelle_Dimension/100*$Spline_A_u0},{$Nouvelle_Dimension/100*$Spline_A_v0},$XA_fin,$YA_fin,{$Nouvelle_Dimension/100*$Spline_A_u1},{$Nouvelle_Dimension/100*$Spline_A_v1},$Spline_A_vertices,1,$Couleur_Ar,$Couleur_Av,$Couleur_Ab,$Couleur_Aa
XA_origine={$XA_origine+$Resolution_A}
YA_origine=0
XA_fin=$XA_origine
YA_fin=$Nouvelle_Dimension
-done
-if {$Orientation_A>0} -rotate[-1] {$Orientation_A} -endif
-crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{{{{w}-$Largeur_Origine}/2}+$Largeur_Origine-1},{{{{h}-$Hauteur_Origine}/2}+$Hauteur_Origine-1}
-if {$Dilate_A>1} -dilate_circ[-1] $Dilate_A -endif
$Nouvelle_Dimension,$Nouvelle_Dimension,1,4
-repeat {$Nouvelle_Dimension/$Resolution_B}
-spline[-1] $XB_origine,$YB_origine,{$Nouvelle_Dimension/100*$Spline_B_u0},{$Nouvelle_Dimension/100*$Spline_B_v0},$XB_fin,$YB_fin,{$Nouvelle_Dimension/100*$Spline_B_u1},{$Nouvelle_Dimension/100*$Spline_B_v1},$Spline_B_vertices,1,$Couleur_Br,$Couleur_Bv,$Couleur_Bb,$Couleur_Ba
XB_origine=0
YB_origine={$YB_origine+$Resolution_B}
XB_fin=$Nouvelle_Dimension
YB_fin=$YB_origine
-done
-if {$Orientation_B>0} -rotate[-1] {$Orientation_B} -endif
-crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{{{{w}-$Largeur_Origine}/2}+$Largeur_Origine-1},{{{{h}-$Hauteur_Origine}/2}+$Hauteur_Origine-1}
-if {$Dilate_B>1} -dilate_circ[-1] $Dilate_B -endif
-blend[-1,-2] alpha,1,1
-reverse[-1,-2]
samj_Moirage_Spline_XY :
Couleur_Ar=$1
Couleur_Av=$2
Couleur_Ab=$3
Couleur_Aa=$4
Resolution_A=$5
Decalage_A=$6
Spline_A_u0=$7
Spline_A_v0=$8
Spline_A_u1=$9
Spline_A_v1=$10
Spline_A_vertices=$11
Dilate_A={round({$12/100*$Resolution_A})}
Couleur_Br=$13
Couleur_Bv=$14
Couleur_Bb=$15
Couleur_Ba=$16
Resolution_B=$17
Decalage_B=$18
Spline_B_u0=$19
Spline_B_v0=$20
Spline_B_u1=$21
Spline_B_v1=$22
Spline_B_vertices=$23
Dilate_B={round({$24/100*$Resolution_B})}
Choix_Calques_Visibles=$25
Largeur_Origine={w}
Hauteur_Origine={h}
XA_origine={round({{$Resolution_A/100*$Decalage_A}-{$Largeur_Origine/2}})}
YA_origine=0
XA_fin={round({{$Resolution_A/100*$Decalage_A}+{$Largeur_Origine*1.5}})}
YA_fin=$Hauteur_Origine
Iterations_A={round({{{abs($XA_origine)}+$XA_fin}/$Resolution_A})}
XB_origine=0
YB_origine={round({{$Resolution_B/100*$Decalage_B}-{$Hauteur_Origine/2}})}
XB_fin=$Largeur_Origine
YB_fin={round({{$Resolution_B/100*$Decalage_B}+{$Hauteur_Origine*1.5}})}
Iterations_B={round({{{abs($YB_origine)}+$YB_fin}/$Resolution_B})}
-if {{$Choix_Calques_Visibles==0}||{$Choix_Calques_Visibles==1}}
$Largeur_Origine,$Hauteur_Origine,1,4
-repeat $Iterations_A
XA_origine={$XA_origine+$Resolution_A}
XA_fin=$XA_origine
-spline[-1] $XA_origine,$YA_origine,{$Largeur_Origine/100*$Spline_A_u0},{$Largeur_Origine/100*$Spline_A_v0},$XA_fin,$YA_fin,{$Largeur_Origine/100*$Spline_A_u1},{$Largeur_Origine/100*$Spline_A_v1},$Spline_A_vertices,1,$Couleur_Ar,$Couleur_Av,$Couleur_Ab,$Couleur_Aa
-done
-if {$Dilate_A>1} -dilate_circ[-1] $Dilate_A -endif
-endif
-if {{$Choix_Calques_Visibles==0}||{$Choix_Calques_Visibles==2}}
$Largeur_Origine,$Hauteur_Origine,1,4
-repeat $Iterations_B
YB_origine={$YB_origine+$Resolution_B}
YB_fin=$YB_origine
-spline[-1] $XB_origine,$YB_origine,{$Hauteur_Origine/100*$Spline_B_u0},{$Hauteur_Origine/100*$Spline_B_v0},$XB_fin,$YB_fin,{$Hauteur_Origine/100*$Spline_B_u1},{$Hauteur_Origine/100*$Spline_B_v1},$Spline_B_vertices,1,$Couleur_Br,$Couleur_Bv,$Couleur_Bb,$Couleur_Ba
-done
-if {$Dilate_B>1} -dilate_circ[-1] $Dilate_B -endif
-endif
-if {$Choix_Calques_Visibles==0}
-blend[-1,-2] alpha,1,1
-endif
-reverse[-1,-2]
samj_Pointes_De_Diamants_Colorees :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Variation_L=$6
Variation_H=$7
Grossissement_A=$8
Grossissement_B=$9
Angle_Variation=$10
Rendu=$11
Flou_Contours=$12
Couleur_Fond_r=$13
Couleur_Fond_v=$14
Couleur_Fond_b=$15
Couleur_Fond_a=$16
Contours_Polygones=$17
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Angle_Origine={45+$Angle_Variation}
KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution
X_a=0
Y_a=0
X_b=0
Y_b=0
X_c=0
Y_c=0
X_d=0
Y_d=0
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution+$Resolution}}
-repeat {$Hauteur_Origine/{$Resolution+$Resolution}}
couleur_pixel=${-at[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}
KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}
Angle_Variation={$Angle_Origine+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}*180}}
X_a={$Largeur-{{$Resolution*$KL}*{cos({pi/180*$Angle_Variation})}}}
Y_a=$Hauteur
X_b=$Largeur
Y_b={$Hauteur+{{$Resolution*$KH}*{sin({pi/180*$Angle_Variation})}}}
X_c={$Largeur+{{$Resolution*$KL}*{cos({pi/180*$Angle_Variation})}}}
Y_c=$Hauteur
X_d=$Largeur
Y_d={$Hauteur-{{$Resolution*$KH}*{sin({pi/180*$Angle_Variation})}}}
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-endif
-if {$Contours_Polygones==1}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-elif {$Contours_Polygones==2}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,255,255,255,$alpha_pixel
-elif {$Contours_Polygones==3}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},$alpha_pixel
-elif {$Contours_Polygones==4}
-polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{$rouge_pixel*0.5},{$vert_pixel*0.5},{$bleu_pixel*0.5},$alpha_pixel
-endif
Hauteur={$Hauteur+$Resolution+$Resolution}
-done
Largeur={$Largeur+$Resolution+$Resolution}
Hauteur=$Resolution
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
samj_reptile :
Texture_Forme=$1
Texture_Resolution=$2
Texture_Spread=$3
Texture_Color=$4
Texture_Orientation=$5
Texture_Light=$6
Opacity=$7
Largeur_Origine={w}
Hauteur_Origine={h}
Coeff_Echelle_L=1
Coeff_Echelle_H=1
--Je_passe_l_hiver_en_Floride[-1]
-gimp_isophotes[-1] 8,2,1,0
-if {$Largeur_Origine<{10*$Texture_Resolution}}
Coeff_Echelle_L={{10*$Texture_Resolution}/$Largeur_Origine}
-endif
-if {$Hauteur_Origine<{10*$Texture_Resolution}}
Coeff_Echelle_H={{10*$Texture_Resolution}/$Hauteur_Origine}
-endif
-if {{$Coeff_Echelle_L+$Coeff_Echelle_H}>2}
-if {$Coeff_Echelle_L>$Coeff_Echelle_H}
-resize[-1,-2] {round({$Largeur_Origine*$Coeff_Echelle_L})},{round({$Hauteur_Origine*$Coeff_Echelle_L})}
-else
-resize[-1,-2] {round({$Largeur_Origine*$Coeff_Echelle_H})},{round({$Hauteur_Origine*$Coeff_Echelle_H})}
-endif
-endif
-to_rgb[-1,-2]
-if {$Texture_Forme==0}
-gimp_imagegrid_hexagonal[-1] $Texture_Resolution,0.1,1
-elif {$Texture_Forme==1}
-gimp_imagegrid[-1] {round({{w}/$Texture_Resolution})},{round({{h}/$Texture_Resolution})}
-elif {$Texture_Forme==2}
-gimp_imagegrid_triangular {round({{w}/$Texture_Resolution})},{round({1.8*{w}/$Texture_Resolution})},0,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-elif {$Texture_Forme==3}
-gimp_imagegrid_triangular {round({{h}/{1.8*$Texture_Resolution}})},{round({{h}/$Texture_Resolution})},0,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-elif {$Texture_Forme==4}
-gimp_imagegrid_triangular {round({{w}/$Texture_Resolution})},{round({1.8*{w}/$Texture_Resolution})},1,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-elif {$Texture_Forme==5}
-gimp_imagegrid_triangular {round({{h}/{1.8*$Texture_Resolution}})},{round({{h}/$Texture_Resolution})},1,0,0,0,255
Texture_Spread={$Texture_Spread/2}
-endif
-gimp_spread {{{w}*$Texture_Spread}/{100*$Texture_Resolution}},{{{h}*$Texture_Spread}/{100*$Texture_Resolution}},0,0,0
-gimp_boost_fade[-1] $Texture_Color,0
--Je_passe_l_hiver_en_Floride[-1]
-gimp_local_orientation[-1] $Texture_Orientation,0,100,0,16,0
-gimp_blend[-1,-2] 14,0,1,1
-gimp_lightglow[-1] $Texture_Light,0.5,8,0.8,0,0
-blend[-1,-2] grainmerge,1,$Opacity
samj_Scintillements_Colores :
Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution_L=$5
Resolution_H=$6
Dimension_Variation=$7
Variation_Couleur=$8
Scintillement=$9
Angle_Decalage=$10
Variation_Aleatoire=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Hauteur=$Resolution_H
Largeur=$Resolution_L
Rayon_Scintillement_Origine={{$Resolution_H+$Resolution_L}*$Dimension_Variation}
Rayon_Scintillement=0
Angle_Variation={360/$Scintillement}
Angle_Variation_En_Cours=0
Coeff_Variation_Aleatoire=0
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution_L+$Resolution_L}}
-repeat {$Hauteur_Origine/{$Resolution_H+$Resolution_H}}
couleur_pixel=${-at[0]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
Moyenne_couleur={1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Variation_Couleur}}
Rayon_Scintillement={$Rayon_Scintillement_Origine*$Moyenne_couleur}
Angle_Variation_En_Cours=0
-if {$Rendu==0}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-elif {$Rendu==1}
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-elif {$Rendu==2}
-if {{{$rouge_pixel-$Couleur_Limite_r}>=0}&&{{$vert_pixel-$Couleur_Limite_v}>=0}&&{{$bleu_pixel-$Couleur_Limite_b}>=0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-if {{{$rouge_pixel-$Couleur_Limite_r}<0}&&{{$vert_pixel-$Couleur_Limite_v}<0}&&{{$bleu_pixel-$Couleur_Limite_b}<0}}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
-endif
Hauteur={$Hauteur+$Resolution_H+$Resolution_H}
-done
Largeur={$Largeur+$Resolution_L+$Resolution_L}
Hauteur=$Resolution_H
-done
-rm[0]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
samj_chalkitup :
#gimp_painting
Abstraction=$1
Details_scale=$2
Color=$3
Smoothness=$4
Sharpen_shades=$5
#gimp_morpho
Action=$6
Size=$7
Invert_colors=$8
Shape=$9
Channel_morpho=$10
#gimp_spread
X_variations=$11
Y_variations=$12
Channel_spread=$13
-repeat $! -l[$>]
-remove_opacity[-1]
-gimp_painting[-1] $Abstraction,$Details_scale,$Color,$Smoothness,$Sharpen_shades
-gimp_morpho[-1] $Action,$Size,$Invert_colors,$Shape,$Channel_morpho,0
-gimp_spread[-1] $X_variations,$Y_variations,$Channel_spread,0
-endl -done
samj_chalkitup_preview :
-gimp_split_preview "-samj_chalkitup ${1--2}",$-1
Engrave_colore_en :
-Engrave_colore $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
samj_en_Texture_Granuleuse :
-samj_Texture_Granuleuse $1,$2,$3,$4,$5
samj_en_Texture_Granuleuse_preview :
-gimp_split_preview "-samj_en_Texture_Granuleuse $*",$-1
samj_Texture_Granuleuse :
-repeat $! -l[$>]
Smoothness_Gradient_RGB=$1
Max_threshold_Gradient_RGB=$2
Amplitude_Noise=$3
Colors=$4
Automatic_color_balance=$5
--Je_passe_l_hiver_en_Floride[-1]
-gimp_gradient2rgb[-1] $Smoothness_Gradient_RGB,0,$Max_threshold_Gradient_RGB,0,0
{w},{h},1,3
-fill_color[-1] 255,255,255
-to_rgb[-1]
-gimp_noise[-1] $Amplitude_Noise,0,2,0
-blend[-1,-2] negation,1,1
-gimp_tk_colortemp[-1] $Colors,$Automatic_color_balance
-gimp_local_orientation[-1] 0,0,100,0,11
-gimp_normalize_local[-1] 0,6,5,20,1,2
-blend[0,-1] grainmerge,1,1
-endl -done
samj_Texture_Granuleuse_preview :
-gimp_split_preview "-samj_Texture_Granuleuse $*",$-1
samj_rien_black_and_white :
-Je_passe_l_hiver_en_Floride[-1]
samj_Angoisse :
iterations=$1
dog_sigma1=$2
dog_sigma2={$3/10}
sw_threshold=$4
smooth_amplitude=$5
noise_amplitude=$6
noise_type=$7
opacite=$8
sharpen_amplitude=$9
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-repeat $iterations
-dog[-1] $dog_sigma1%,$dog_sigma2%
-segment_watershed[-1] $sw_threshold,1
-smooth[-1] $smooth_amplitude,0,1,1,3
-n[-1] 0,255
-if {$noise_amplitude>0} -noise[-1] $noise_amplitude,$noise_type -endif
-to_rgb[-1]
-gimp_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-done
-to_rgb[-1]
-gimp_blend_1651[-1,-2] 28,0,$opacite,0,1
-if {$sharpen_amplitude>0} -sharpen[-1] $sharpen_amplitude -endif
samj_Barbouillage_Paint_Daub :
iterations=$1
amplitude=$2
sharpness=$3
anisotropy=$4
sigma=$5
dl=$6
egaliser=$7
Couleurs_Plasma=$8
Scale_Plasma=$9
-to_rgb[-1]
-if {$Couleurs_Plasma>0}
{w},{h},1,3
-fill_color[-1] 0,0,0
-plasma[-1] 1,1,$Scale_Plasma
-n[-1] 0,255
-if {$Couleurs_Plasma==1}
-gimp_decompose_channels[-1,-2] 2,0,1,0 -remove[-2,-3,-4] -gimp_decompose_channels 2,1,1,0
-elif {$Couleurs_Plasma==2}
-gimp_decompose_channels[-1,-2] 2,0,1,0 -remove[-1,-5,-6] -gimp_decompose_channels[-3,-2,-1] 2,1,1,0
-endif
-n[-1] 0,255
-to_rgb[-1]
-endif
--Je_passe_l_hiver_en_Floride[-1]
-repeat $iterations
-gradient_norm[-1]
-n[-1] 0,255
-equalize[-1]
-done
-engrave_modifie[-1] 4,0.5,4,0,8,40,0,25,1
-blend[-1,-2] add
-repeat $amplitude
-smooth[-1] $sharpness,$anisotropy,1,$sigma,$dl
-done
-n[-1] 0,255
-if {$egaliser==1} -equalize[-1] -endif
samj_Color_EdgesO_Engrave :
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-pow[-2]  $12
-gimp_edge_offsets[-2] $1,$2,$3,$4,0
-gimp_engrave[-1,-2] $5,$6,$7,$8,$9,$10,$11,0,10,1,0,0,0,1
-blend[-1,-2] multiply,1,1
-if {$13==1} -negative[-1] -endif
-if {$14>0} -gimp_segment_watershed[-2] $14,1,16,0,0 -endif
-blend[-1,-2] multiply,1,1
-if {$15==1} --Je_passe_l_hiver_en_Floride[-1] -blend[-1,-2] add,1,1 -endif
samj_fond_broderie :
Levels_topographic_map=$1
Smoothness_topographic_map=$2
Curviness_gimp_skeleton=$3
Activer_gimp_LCE=$4
Activer_gimp_frame_blur=$5
-topographic_map[0] $Levels_topographic_map,$Smoothness_topographic_map
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-gimp_local_orientation[-1] 0,0,100,0,0,0
-gimp_color_abstraction[-1] 2,10,0.5,0
-gimp_skeleton[-1] 0,$3,0,0,0
-gimp_skeleton[-2] 0,$3,0,0,0
-blend[-2,-1] add,1,0
-blend[-2,-1] and,1,0
-if {$Activer_gimp_LCE==1}
-gimp_LCE[-1] 80,0.5,1,1,3,0
-endif
-if {$Activer_gimp_frame_blur==1}
-gimp_frame_blur[-1] 30,30,0,5,0,0,128,128,128,0,5,255,255,255,2,2,1,0,0.5,0.5,0
-endif
samj_Fond_Brosse :
Brosse=$1
Couleur=$2
-repeat $Brosse
-gimp_local_orientation[-1] 0,0,100,0,25,0
-pow[-1]  $Couleur
-done
-gimp_anisotropic_smoothing[-1] 60,0.7,0.3,4,10,2,180,2,1,1,1,2,0
-gimp_normalize_local[-1] 2,6,5,20,1,11,0
samj_Impressions :
Spread_fond=$1
X_amplitude=$2
Y_amplitude=$3
X_smoothness=$4
Y_smoothness=$5
Edge_attenuation=$6
Edge_influence=$7
Noise_scale=$8
iterations=$9
dog_sigma1=$10
dog_sigma2={$11/10}
sw_threshold=$12
smooth_amplitude=$13
noise_amplitude=$14
noise_type=$15
opacite=$16
sharpen_amplitude=$17
Couleurs=$18
-spread[-1] $Spread_fond
-gimp_textured_glass[-1] $X_amplitude,$Y_amplitude,$X_smoothness,$Y_smoothness,$Edge_attenuation,$Edge_influence,$Noise_scale
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-repeat $iterations
-dog[-1] $dog_sigma1%,$dog_sigma2%
-segment_watershed[-1] $sw_threshold,1
-smooth[-1] $smooth_amplitude,0,1,1,3
-n[-1] 0,255
-if {$noise_amplitude>0} -noise[-1] $noise_amplitude,$noise_type -endif
-to_rgb[-1]
-gimp_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-done
-to_rgb[-1]
-gimp_blend_1651[-1,-2] 28,0,$opacite,0,1
-if {$sharpen_amplitude>0} -sharpen[-1] $sharpen_amplitude -endif
-gimp_custom_transform[-1] "i",i*$Couleurs,"i","i","i","i",0
samj_texture_coloree :
Type=$1
sharpness=$2
rf=$3
vf=$4
bf=$5
AmplitudeA=$6
AmplitudeB=$7
Angle=$8
AmplitudeS=$9
Iterations_Blend=$10
Opacite_Blend=$11
-if {$Type==0}
anisotropy=0
alpha=0
sigma=0
is_sqrt=1
-elif {$Type==1}
anisotropy=0
alpha=4
sigma=0
is_sqrt=1
-elif {$Type==2}
sharpness=0.5
anisotropy=0.3
alpha=4
sigma=2
is_sqrt=1
-elif {$Type==3}
anisotropy=0
alpha=0
sigma=0
is_sqrt=0
-elif {$Type==4}
anisotropy=0
alpha=4
sigma=0
is_sqrt=0
-elif {$Type==5}
sharpness=0.5
anisotropy=0.3
alpha=4
sigma=2
is_sqrt=0
-endif
-diffusiontensors[-1] $sharpness,$anisotropy,$alpha,$sigma,$is_sqrt
-n[-1] 0,255
-equalize[-1]
-gimp_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-to_rgb[-1]
-gimp_8bits[-1] 100,10000,256
{w},{h},1,3
-fill_color[-1] $rf,$vf,$bf
-blend[-1,-2] add
-to_rgb[-1]
-repeat $Iterations_Blend
--Je_passe_l_hiver_en_Floride[-1]
-done
-blur_linear[-1] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},$Angle,1
-sharpen[-1] $AmplitudeS
-to_rgb[-1]
-repeat $Iterations_Blend
-gimp_blend_edges[-1,-2] $Opacite_Blend,5,0
-done
samj_texture_coloree_en :
-samj_texture_coloree $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11
-if {$13>0}
-deblur_richardsonlucy[-1] $12,$13,$14
-if $15 -c[-1] 0,255 -else -n[-1] 0,255 -endif
-endif
Engrave_colore :
Examples=$1
Radius=$2
Densite_A=$3
Edges=$4
Coherence=$5
Threshold=$6
Minimal_Area=$7
Repetition=$8
Anti_Aliasing=$9
Choix_Couleur=$10
R_C1=$11
V_C1=$12
B_C1=$13
R_C2=$14
V_C2=$15
B_C2=$16
-if {$Examples==1}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==2}
Radius={0.275+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==3}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={7-{$Coherence/20}}
Threshold={48+{$Threshold/20}}
Minimal_Area=-100
Repetition={20-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==4}
Radius={0.175+{$Radius/20}}
Densite_A={12-{$Densite_A/2}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={30-{$Repetition/10}}
Anti_Aliasing=3
-elif {$Examples==5}
Radius={1.975+{$Radius/20}}
Densite_A={1.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={2-{$Coherence/20}}
Threshold={18+{$Threshold/20}}
Minimal_Area=-100
Repetition={55-{$Repetition/10}}
Anti_Aliasing=2
-elif {$Examples==6}
Radius={0.975+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={28+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==7}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={-5+{$Repetition/10}}
Anti_Aliasing=1
-endif
f={arg(1+$Anti_Aliasing,1,1.5,2,3)}
r={$f*$Radius}
nm=${-gimp_layer_name}
pos=${-gimp_layer_pos}
C1_blanc=0
Blend_final=0
-to_rgb[-1]
-if {$Choix_Couleur==0}
Blend_final=0
-elif {$Choix_Couleur==1}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 8,2
Blend_final=1
-elif {$Choix_Couleur==2}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 16,2
Blend_final=1
-elif {$Choix_Couleur==3}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 32,2
Blend_final=1
-elif {$Choix_Couleur==4}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 64,2
Blend_final=1
-elif {$Choix_Couleur==5}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 8,2
-dilate_circ[-2] 2
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==6}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 16,2
-dilate_circ[-2] 4
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==7}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 32,2
-dilate_circ[-2] 8
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==8}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 64,2
-dilate_circ[-2] 16
-blur[-2] 2
Blend_final=1
-elif {$Choix_Couleur==9}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 8,2
-dilate_circ[-2] 2
-blur[-2] 2
Blend_final=2
-elif {$Choix_Couleur==10}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 16,2
-dilate_circ[-2] 4
-blur[-2] 2
Blend_final=2
-elif {$Choix_Couleur==11}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 32,2
-dilate_circ[-2] 8
-blur[-2] 2
Blend_final=2
-elif {$Choix_Couleur==12}
--Je_passe_l_hiver_en_Floride[-1]
-topographic_map[-2] 64,2
-dilate_circ[-2] 16
-blur[-2] 2
Blend_final=2
-endif
-if {{$R_C1+$V_C1+$B_C1}==765}
C1_blanc=1
B_C1=254
-endif
-l[-1]
-split_opacity[-1]
-l[-1]
wh={w},{h}
-norm[-1]
-if $Anti_Aliasing
-r[-1] {100*$f}%,{100*$f}%,1,1,3
-endif
-l[-1]
-repeat $Repetition
-b[-1] $r
-unsharp[-1] $r,{$Densite_A}
-c[-1] 0,255
-done
-smooth[-1] 100,0.1,1,{$f*$Edges},{$f*$Coherence}
->=[-1] {100-$Threshold}%
-endl
-if {$Minimal_Area<0}
-area_fg[-1] 0,0
-gt[-1] {$f*$Minimal_Area*$Minimal_Area}
-elif {$Minimal_Area>0}
-==[-1] 0
-area_fg[-1] 0,0
-gt[-1] {$f*$Minimal_Area*$Minimal_Area}
-==[-1] 0
-endif
-n[-1] 0,255
-to_rgb[-1]
-if {$Blend_final==0}
-replace_color[-1] 0,0,0,0,0,$R_C1,$V_C1,$B_C1
-replace_color[-1] 0,0,255,255,255,$R_C2,$V_C2,$B_C2
-if {$C1_blanc==1}
-replace_color[-1] 0,0,255,255,254,255,255,255
-endif
-endif
-if $Anti_Aliasing
-r[-1] $wh,1,3,2
-else
-r[-1] $wh
-endif
-endl
-a[-1] c
-endl
-if {$Blend_final==1}
-blend[-1,-2] add
-replace_color[-1] 0,0,255,255,255,$R_C2,$V_C2,$B_C2
-elif {$Blend_final==2}
$wh,1,3
-to_rgb[-1]
-replace_color[-1] 0,0,0,0,0,$R_C2,$V_C2,$B_C2
-nm[-3] mode(add),name($nm" [couleurs]"),pos($pos)
-nm[-2] name($nm" [gravure]"),pos($pos)
-endif
engrave_modifie :
Examples=$1
Radius=$2
Densite_A=$3
Edges=$4
Coherence=$5
Threshold=$6
Minimal_Area=$7
Repetition=$8
Anti_Aliasing=$9
-if {$Examples==1}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==2}
Radius={0.275+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==3}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={7-{$Coherence/20}}
Threshold={48+{$Threshold/20}}
Minimal_Area=-100
Repetition={20-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==4}
Radius={0.175+{$Radius/20}}
Densite_A={12-{$Densite_A/2}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={30-{$Repetition/10}}
Anti_Aliasing=3
-elif {$Examples==5}
Radius={1.975+{$Radius/20}}
Densite_A={1.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={2-{$Coherence/20}}
Threshold={18+{$Threshold/20}}
Minimal_Area=-100
Repetition={55-{$Repetition/10}}
Anti_Aliasing=2
-elif {$Examples==6}
Radius={0.975+{$Radius/20}}
Densite_A={2.3+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={28+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={55-{$Repetition/10}}
Anti_Aliasing=1
-elif {$Examples==7}
Radius={0.475+{$Radius/20}}
Densite_A={3.8+{$Densite_A/20}}
Edges={$Edges/20}
Coherence={10-{$Coherence/20}}
Threshold={38+{$Threshold/20}}
Minimal_Area={$Minimal_Area/20}
Repetition={-5+{$Repetition/10}}
Anti_Aliasing=1
-endif
f={arg(1+$Anti_Aliasing,1,1.5,2,3)}
r={$f*$Radius}
nm=${-gimp_layer_name}
pos=${-gimp_layer_pos}
-l[0]
-split_opacity
-l[0]
wh={w},{h}
-norm
-if $Anti_Aliasing
-r {100*$f}%,{100*$f}%,1,1,3
-endif
-l[0]
-repeat $Repetition
-b $r
-unsharp $r,{$Densite_A}
-c 0,255
-done
-smooth 100,0.1,1,{$f*$Edges},{$f*$Coherence}
->= {100-$Threshold}%
-endl
-if {$Minimal_Area<0}
-area_fg 0,0
-gt {$f*$Minimal_Area*$Minimal_Area}
-elif {$Minimal_Area>0}
-== 0
-area_fg 0,0
-gt {$f*$Minimal_Area*$Minimal_Area}
-== 0
-endif
-* 255
-if $Anti_Aliasing
-r $wh,1,1,2
-endif
-endl
-a c
-endl
XY_hardsketchbw_samj_en :
-XY_hardsketchbw_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15
XY_hardsketchbw_samj :
XY=$1
Amplitude=$2
Density=$3
Smoothness=$4
Opacity=$5
Edge=$6
Fast_approximation=$7
Negative=$8
Calques=$9
Octave_Sharpening=$10
R_Transparence=$11
V_Transparence=$12
B_Transparence=$13
A_Transparence=$14
Remplir=$15
Largeur={w}
Hauteur={h}
-to_rgba[-1]
--Je_passe_l_hiver_en_Floride[-1]
-if {$Calques==1} --Je_passe_l_hiver_en_Floride[-1] -endif
-if {$Largeur>$Hauteur}
Grande_dimension={$Largeur*1.5}
-else
Grande_dimension={$Hauteur*1.5}
-endif
Origine_X={round({{{$Grande_dimension}-$Largeur}/2})}
Origine_Y={round({{{$Grande_dimension}-$Hauteur}/2})}
-expand_x[-1] $Origine_X,2
-expand_y[-1] $Origine_Y,2
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-1] $XY,0.5,0.5,1
-gimp_hardsketchbw[-1] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-1] -$XY,0.5,0.5,1
-expand_x[-2] $Origine_X,2
-expand_y[-2] $Origine_Y,2
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-2] -$XY,0.5,0.5,1
-gimp_hardsketchbw[-2] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
-twirl_ancien_euclidean2polar_ancien_polar2euclidean[-2] $XY,0.5,0.5,1
#average
-blend[-1,-2] average,1,0
-crop[-1] $Origine_X,$Origine_Y,{$Largeur+$Origine_X-1},{$Hauteur+$Origine_Y-1}
-if {$Octave_Sharpening==1}
-gimp_unsharp_octave 4,5,3,0,0,0,24,0
-endif
-if {$Calques==1}
-gimp_hardsketchbw[-2] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
-reverse[-1,-2]
-endif
-if {$Remplir==1}
$Largeur,$Hauteur,1,4
-fill_color[-1] $R_Transparence,$V_Transparence,$B_Transparence,$A_Transparence
-if {$Calques==1}
-reverse[-1,-2]
-endif
-blend[-1,-2] screen,1,1
-if {$Calques==1}
-reverse[-1,-2]
-endif
-endif
samj_rien_colors :
-Je_passe_l_hiver_en_Floride[-1]
samj_NB_EdgesO_Engrave :
--Je_passe_l_hiver_en_Floride[-1]
-pow[-2]  $12
-gimp_edge_offsets[-2] $1,$2,$3,$4,0
-gimp_engrave[-1,-2] $5,$6,$7,$8,$9,$10,$11,0,10,1,0,0,0,1
-blend[-1,-2] multiply,1,1
samj_scintillements :
Exemple=$1
dog_sigma1=$2
dog_sigma2={$3/10}
dog_Iterations=$4
Variation_noise=$5
Type_noise=$6
Amplitude_circle=$7
AmplitudeA=$8
AmplitudeB=$9
Angle=$10
Amplitude_ln=$11
Radius_ln=$12
Neighborhood_smoothness_ln=$13
Average_smoothness_ln=$14
Constrain_values_ln=$15
Channel_ln=$16
Inverser_couleur=$17
Degradation_pow={1+{$18/100}}
-to_rgb[-1]
-if {$Exemple==1}
Variation_noise=70
Amplitude_circle=3
Angle=0
-elif {$Exemple==2}
Variation_noise=70
Amplitude_circle=3
Angle=40
-elif {$Exemple==3}
Variation_noise=70
Amplitude_circle=3
Angle=80
-elif {$Exemple==4}
-fill_color[-1] 0,0,0
-noise[-1] $Variation_noise,$Type_noise
-norm[-1]
-elif {$Exemple==5}
Variation_noise=2
-fill_color[-1] 0,0,0
-noise[-1] $Variation_noise,$Type_noise
-norm[-1]
-elif {$Exemple==6}
-fill_color[-1] 0,0,0
-noise[-1] $Variation_noise,$Type_noise
-norm[-1]
Amplitude_circle={$Amplitude_circle+25}
-endif
-repeat $dog_Iterations
-dog[-1] $dog_sigma1%,$dog_sigma2%
-done
#filtre sponge (par David Tschumperl) adapt
{w},{h},1
-noise[-1] $Variation_noise,$Type_noise
-r[-1] [-2]
-n[-1] 0,1
-*[-1,-2]
-_circle_1610 $Amplitude_circle
-dilate[-2] [-1]
-rm[-1]
#fin filtre sponge adapt
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-blur_linear[-1] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},$Angle,1
-blur_linear[-2] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},{$Angle+120},1
-blur_linear[-3] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},{$Angle+240},1
-n[-1,-2,-3] 0,255
-gimp_blend_average_all[-1,-2,-3] 2
-gimp_normalize_local[-1] $Amplitude_ln,$Radius_ln,$Neighborhood_smoothness_ln,$Average_smoothness_ln,$Constrain_values_ln,$Channel_ln
-if {$Degradation_pow!=1}
-pow[-1] $Degradation_pow
-n[-1] 0,255
-endif
-if {$Inverser_couleur==1} -negative[-1] -endif
_circle_1610 :
-if {$1%2==0}
-i 2,2
-else
-i 1
-endif
-+[-1] 1
-r[-1] $1,$1,1,1,0,0,0.5,0.5
-distance[-1] 1
-n[-1] 0,1
-sqrt[-1]
-c[-1] 0.85,0.86
-*[-1] -1
-n[-1] 0,1
Couleurs_Metalliques_samj_en :
-Couleurs_Metalliques $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18
Couleurs_Metalliques_samj_en_preview :
-gimp_split_preview "-Couleurs_Metalliques_samj_en ${1--2}",$-1
Couleurs_Metalliques :
Transparence=$1
Rendu=$2
Amplitude=$3
Noise_type=$4
Noise_Channel=7
Value_range=$5
Double_effet=$6
Local_normalization_Amplitude=$7
Radius=$8
Neighborhood_smoothness=$9
Average_smoothness=$10
Constrain_values=$11
Local_normalization_Channel=$12
boost_fade_Amplitude=$13
Utiliser_Photocomix_Options=$14
Pencilbw_Size=$15
Pencilbw_Amplitude=$16
Blend_soft_light_Opacity=$17
Blend_soft_light_Revert_layers=$18
-repeat $! -l[$>]
-if {$Rendu==0}
Rendu_local_orientation_channels=11
-elif {$Rendu==1}
Rendu_local_orientation_channels=16
-elif {$Rendu==2}
Rendu_local_orientation_channels=25
-elif {$Rendu==3}
Rendu_local_orientation_channels=27
-elif {$Rendu==4}
Rendu_local_orientation_channels=7
-elif {$Rendu==5}
Rendu_local_orientation_channels=2
-elif {$Rendu==6}
Rendu_local_orientation_channels=2
-endif
-if {$Transparence==1}
-remove_opacity[-1]
-endif
-if {$Utiliser_Photocomix_Options==1}
--pencilbw[-1] $Pencilbw_Size,$Pencilbw_Amplitude
-if {$Double_effet==1}
-gimp_normalize_local[-2] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-endif
-gimp_noise[-2] $Amplitude,$Noise_type,$Noise_Channel,$Value_range
-gimp_local_orientation[-2] 0,0,100,0,$Rendu_local_orientation_channels
-gimp_normalize_local[-2] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-if {$boost_fade_Amplitude>0}
-gimp_boost_fade[-2] $boost_fade_Amplitude
-endif
-blend[-2,-1] softlight,$Blend_soft_light_Opacity,$Blend_soft_light_Revert_layers
-else
-if {$Double_effet==1}
-gimp_normalize_local[-1] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-endif
-gimp_noise[-1] $Amplitude,$Noise_type,$Noise_Channel,$Value_range
-gimp_local_orientation[-1] 0,0,100,0,$Rendu_local_orientation_channels
-gimp_normalize_local[-1] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
-if {$boost_fade_Amplitude>0}
-gimp_boost_fade[-1] $boost_fade_Amplitude
-endif
-endif
-endl -done
Couleurs_Metalliques_preview :
-gimp_split_preview "-Couleurs_Metalliques ${1--2}",$-1
samj_rien_contours :
-Je_passe_l_hiver_en_Floride[-1]
samj_Colored_Outlines :
Axe_blur=$1
Valeur_blur=$2
Valeur_isophotes=$3
Iterations_smooth=$4
Valeur_dilate=$5
Couleur_Fond_r=$6
Couleur_Fond_v=$7
Couleur_Fond_b=$8
Couleur_Fond_a=$9
Largeur_Origine={w}
Hauteur_Origine={h}
-to_rgba[-1]
-if {$Axe_blur==0}
-blur[-1] xy,{$Valeur_blur}
-elif {$Axe_blur==1}
-blur[-1] x,{$Valeur_blur}
-elif {$Axe_blur==2}
-blur[-1] y,{$Valeur_blur}
-endif
-isophotes[-1] $Valeur_isophotes
-if {$Iterations_smooth>0} -gimp_diffusion_smoothing[-1] 0.7,0.3,0.6,1.1,15,$Iterations_smooth,2,0,24 -endif
-dilate_circ[-1] $Valeur_dilate
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-gimp_blend_1651[-2,-1] 1,0,1,0,1
samj_Contours_Arrondis :
Iterations=$1
Val_Quantize=$2
Val_Blur=$3
Val_Isophotes=$4
RGBA=$5
Val_Dilate_Circ=$6
-to_rgb[-1]
-repeat $Iterations
-quantize[-1] $Val_Quantize
-blur[-1] {$Val_Blur/10}
-n[-1] 0,255
-done
-isophotes[-1] $Val_Isophotes
-if {$RGBA==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Val_Dilate_Circ>1} -dilate_circ[-1] $Val_Dilate_Circ -endif
samj_rien_deformations :
-Je_passe_l_hiver_en_Floride[-1]
samj_Contours_Colores :
Puissance=$1
Edge_threshold=$2
Couper_Cut=$3
Dilate_Contours=$4
Degradation_Spread=$5
-pow[-1] $Puissance
-c[-1] 0,255
-gimp_segment_watershed[-1] $2,1,0,2,0
--Je_passe_l_hiver_en_Floride[-1]
-gimp_gradient_norm[-1] 0,0.5,0,100,0,0
-c[-1] $Couper_Cut,255
-n[-1] 0,255
-if {$Dilate_Contours>1} -dilate_circ[-1,-2] $Dilate_Contours -endif
-if {$Degradation_Spread>1} -spread[-1,-2] $Degradation_Spread -endif
-blend[-2,-1] darken,1,0
samj_Scintillements_Colores_Contours :
Val_Flou=$1
Val_Isophotes=$2
Val_Dilate=$3
Resolution_L=$4
Resolution_H=$5
Dimension_Variation=$6
Variation_Couleur=$7
Scintillement=$8
Angle_Decalage=$9
Variation_Aleatoire=$10
Flou_Contours=$11
Mode_Overlay=$12
Couleur_Fond_r=$13
Couleur_Fond_v=$14
Couleur_Fond_b=$15
Couleur_Fond_a=$16
Largeur_Origine={w}
Hauteur_Origine={h}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0
Hauteur=$Resolution_H
Largeur=$Resolution_L
Rayon_Scintillement_Origine={{$Resolution_H+$Resolution_L}*$Dimension_Variation}
Rayon_Scintillement=0
Angle_Variation={360/$Scintillement}
Angle_Variation_En_Cours=0
Coeff_Variation_Aleatoire=0
-blur[-1] $Val_Flou
-to_rgba[-1]
-isophotes[-1] $Val_Isophotes
-dilate_circ[-1] $Val_Dilate
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
-repeat {$Largeur_Origine/{$Resolution_L+$Resolution_L}}
-repeat {$Hauteur_Origine/{$Resolution_H+$Resolution_H}}
couleur_pixel=${-at[-2]\ {$Largeur},{$Hauteur}}
rouge_pixel=${-arg\ 1,$couleur_pixel}
vert_pixel=${-arg\ 2,$couleur_pixel}
bleu_pixel=${-arg\ 3,$couleur_pixel}
alpha_pixel=${-arg\ 4,$couleur_pixel}
Moyenne_couleur={1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Variation_Couleur}}
Rayon_Scintillement={$Rayon_Scintillement_Origine*$Moyenne_couleur}
Angle_Variation_En_Cours=0
-if {$alpha_pixel>1}
-repeat $Scintillement
Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
-if {$Variation_Aleatoire==0}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-else
Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
-line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
-endif
-done
-endif
Hauteur={$Hauteur+$Resolution_H+$Resolution_H}
-done
Largeur={$Largeur+$Resolution_L+$Resolution_L}
Hauteur=$Resolution_H
-done
-rm[-2]
-if {$Flou_Contours>0} -blur[-1] $Flou_Contours,0 -endif
-if {$Mode_Overlay==1}
--Je_passe_l_hiver_en_Floride[-1]
-blend[-2,-1] overlay,1,0
-endif
samj_Skeletation :
Skeletation=$1
Variation_SmoothnessA={$2/$Skeletation/100}
Variation_SmoothnessB={$3/$Skeletation/100}
Valider_Blend=$4
Mode_blend=$5
Opacity_blend=$6
Smoothness=0
index=0
--Je_passe_l_hiver_en_Floride[-1]
-repeat $Skeletation
--Je_passe_l_hiver_en_Floride[0]
-gimp_skeleton[-1] 0,$Smoothness,0,0,0
-if {$index>0} -blend[-2,-1] add,1,0 -endif
Smoothness={$Smoothness+$Variation_SmoothnessA}
index={$index+1}
-done
-gimp_local_orientation[-2] 0,0,100,0,0,0
Smoothness=0
index=0
-repeat $Skeletation
--Je_passe_l_hiver_en_Floride[1]
-gimp_skeleton[-1] 0,$Smoothness,0,0,0
-if {$index>0} -blend[-2,-1] add,1,0 -endif
Smoothness={$Smoothness+$Variation_SmoothnessB}
index={$index+1}
-done
-blend[-2,-1] add,1,0
-rm[-2]
-if {$Valider_Blend==0}
-rm[0]
-else
-gimp_blend_1651[0,-1] $Mode_blend,2,$Opacity_blend,0
-endif
samj_Cercle_Polaire:
Repetitions=$1
Angle_Rotation=$2
Type_Raccord=$3
Iterations_AM=$4
X_offset_AM=$5
Y_offse_AM=$6
Array_mode_AM=$7
Initialization_AM=$8
Expand_size_AM=$9
Crop_AM=$10
X_center_PTE=$11
Y_center_PTE=$12
Expension=0
Securite=4000
-to_rgba[-1]
-repeat $Repetitions
-if {{$Type_Raccord==1}||{$Type_Raccord==3}}
-if {{w}>{h}}
Expension={round({{{w}-{h}}/2})}
-expand_y[-1] $Expension,1
-elif {{w}<{h}}
Expension={round({{{h}-{w}}/2})}
-expand_x[-1] $Expension,1
-endif
-endif
-repeat $Iterations_AM
-if {{{w}>$Securite}||{{h}>$Securite}}
-if {{w}>{h}}
-resize[-1] $Securite,{$Securite/{w}*{h}}
-else
-resize[-1] {$Securite/{h}*{w}},$Securite
-endif
-endif
-gimp_array_mirror[-1] 1,$X_offset_AM,$Y_offse_AM,$Array_mode_AM,$Initialization_AM,$Expand_size_AM,$Crop_AM
-done
-if {{{w}>$Securite}||{{h}>$Securite}}
-if {{w}>{h}}
-resize[-1] $Securite,{$Securite/{w}*{h}}
-else
-resize[-1] {$Securite/{h}*{w}},$Securite
-endif
-endif
-polar2euclidean[-1] $X_center_PTE%,$Y_center_PTE%,1,1
-if {{$Type_Raccord==2}||{$Type_Raccord==3}}
-if {{w}>{h}}
Expension={round({{{w}-{h}}/2})}
-expand_y[-1] $Expension,1
-elif {{w}<{h}}
Expension={round({{{h}-{w}}/2})}
-expand_x[-1] $Expension,1
-endif
-endif
-if {$Angle_Rotation>0}
-if {{$Type_Raccord==2}||{$Type_Raccord==3}||{$Type_Raccord==4}}
-rotate[-1] $Angle_Rotation,0,1
-endif
-if {{$Type_Raccord==0}||{$Type_Raccord==1}}
-rotate[-1] $Angle_Rotation,0,0
-endif
-endif
-autocrop[-1] 0
-if {{{w}>$Securite}||{{h}>$Securite}}
-if {{w}>{h}}
-resize[-1] $Securite,{$Securite/{w}*{h}}
-else
-resize[-1] {$Securite/{h}*{w}},$Securite
-endif
-endif
-done
samj_rien_degradations :
-Je_passe_l_hiver_en_Floride[-1]
samj_Zones_Grises_en :
-samj_Zones_Grises $1,$2,$3,$4,$5
samj_Zones_Grises :
Iterations_Contours=$1
Choice_Contours=$2
Variations_Contours=$3
Iterations_Blend=$4
Opacite_Blend=$5
-to_rgb[-1]
-repeat $Iterations_Blend
--Je_passe_l_hiver_en_Floride[-1]
-done
-repeat $Iterations_Contours
-if {$Choice_Contours==0}
-gimp_curvature[-1] $Variations_Contours,0,100,0,0,0
-elif {$Choice_Contours==1}
-dog[-1] {5000/$Variations_Contours},0
-elif {$Choice_Contours==2}
-gimp_edges[-1] 0,{2*$Variations_Contours},0,0
-endif
-done
-equalize[-1]
-gimp_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-to_rgb[-1]
-repeat $Iterations_Blend
-gimp_blend_edges[-1,-2] $Opacite_Blend,5,0
-done
samj_rien_details :
-Je_passe_l_hiver_en_Floride[-1]
samj_rien_frames :
-Je_passe_l_hiver_en_Floride[-1]
samj_rien_layers :
-Je_passe_l_hiver_en_Floride[-1]
samj_rien_lights_and_shadows :
-Je_passe_l_hiver_en_Floride[-1]
samj_rien_patterns :
-Je_passe_l_hiver_en_Floride[-1]
Denim_samj :
Dimension_Motif=$1
Dilatation=$2
Retourner_motif=$3
Deformation_1=$4
Deformation_2=$5
Amplitude_Bruit=$6
Amplitude_Bruit_2=$7
Nettete=$8
R_Couleur_Denim=$9
V_Couleur_Denim=$10
B_Couleur_Denim=$11
A_Couleur_Denim=$12
Largeur={w}
Hauteur={h}
$Largeur,$Hauteur,1,4
-fill_color[-1] $R_Couleur_Denim,$V_Couleur_Denim,$B_Couleur_Denim,$A_Couleur_Denim
-to_rgba[-1]
-gimp_noise[-1] $Amplitude_Bruit,0,11,0
$Dimension_Motif,$Dimension_Motif,1,4
-if {$Retourner_motif==0}
-line[-1] 0,$Dimension_Motif,$Dimension_Motif,0,1,0,0,0,255
-else
-line[-1] 0,0,$Dimension_Motif,$Dimension_Motif,1,0,0,0,255
-endif
-resize[-1] [-2],[-2],1,100%,0,2
-dilate_circ[-1] $Dilatation
#alpha
-blend[-1,-2] alpha,1,1
-water[-1] {$Deformation_1/1000},{$Deformation_2/100}
-gimp_noise[-1] $Amplitude_Bruit_2,0,26,0
-sharpen[-1] $Nettete
-reverse[-2,-1]
-rm[-1]
samj_Degrades_XYZ_CIE :
Type_Degrade=$1
Dimensions=$2
Ra=$3
Ga=$4
Ba=$5
Aa=$6
Rb=$7
Gb=$8
Bb=$9
Ab=$10
Decalage_L=$11
Decalage_a=$12
Decalage_b=$13
Variation_L=$14
Variation_a=$15
Variation_b=$16
Valider_Variations_Canal_A=$17
Trou_Noir=$18
Degrades_aleatoires=$19
L_Min_Ded_Alea=$20
L_Max_Ded_Alea=$21
a_Min_Ded_Alea=$22
a_Max_Ded_Alea=$23
b_Min_Ded_Alea=$24
b_Max_Ded_Alea=$25
Inverser_Degrade=$26
Variations_Formes=$27
Parametre_Forme_A=$28
Parametre_Forme_B=$29
Nb_Boucles=0
Inc_L=0
Inc_a=0
Inc_b=0
Inc_Alpha=0
# Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
nt_Ra={$Ra/255}
nt_Ga={$Ga/255}
nt_Ba={$Ba/255}
-if {$nt_Ra>0.04045}
nt_Ra={{{$nt_Ra+0.055}/1.055}^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={{{$nt_Ga+0.055}/1.055}^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={{{$nt_Ba+0.055}/1.055}^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2? Illuminant = D65 sRGB
Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xa
Yca=$Ya
Zca=$Za
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={$nt_Xa^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={$nt_Ya^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={$nt_Za^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_La={{116*$nt_Ya}-16}
CIE_aa={500*{$nt_Xa-$nt_Ya}}
CIE_ba={200*{$nt_Ya-$nt_Za}}
nt_Ra={$Rb/255}
nt_Ga={$Gb/255}
nt_Ba={$Bb/255}
-if {$nt_Ra>0.04045}
nt_Ra={{{$nt_Ra+0.055}/1.055}^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={{{$nt_Ga+0.055}/1.055}^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={{{$nt_Ba+0.055}/1.055}^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2? Illuminant = D65 sRGB
Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xb
Yca=$Yb
Zca=$Zb
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={$nt_Xa^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={$nt_Ya^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={$nt_Za^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_Lb={{116*$nt_Ya}-16}
CIE_ab={500*{$nt_Xa-$nt_Ya}}
CIE_bb={200*{$nt_Ya-$nt_Za}}
-if {$Variations_Formes==1}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==2}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==3}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
Valider_Variations_Canal_A=0
-elif {$Variations_Formes==4}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
Valider_Variations_Canal_A=0
-elif {$Variations_Formes==5}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==6}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==7}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==8}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==9}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==10}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-elif {$Variations_Formes==11}
-if {$Type_Degrade==0}
Type_Degrade=1
-elif {$Type_Degrade==2}
Type_Degrade=3
-elif {$Type_Degrade==4}
Type_Degrade=5
-elif {$Type_Degrade==6}
Type_Degrade=7
-endif
-elif {$Variations_Formes==12}
-if {$Type_Degrade==1}
Type_Degrade=0
-elif {$Type_Degrade==3}
Type_Degrade=2
-elif {$Type_Degrade==5}
Type_Degrade=4
-elif {$Type_Degrade==7}
Type_Degrade=6
-endif
-endif
-rm[-1]
######
-if {{$Type_Degrade==0}||{$Type_Degrade==1}||{$Type_Degrade==2}||{$Type_Degrade==3}}
-if {{$Type_Degrade==2}||{$Type_Degrade==3}}
CIE_La=$CIE_Lb
CIE_aa=$CIE_ab
CIE_ba=$CIE_bb
Aa=$Ab
-endif
Nb_Boucles=0
Inc_L={$Variation_L/$Dimensions}
Inc_a={$Variation_a/$Dimensions}
Inc_b={$Variation_b/$Dimensions}
$Dimensions,$Dimensions,1,4
-repeat $Dimensions
-if {$Degrades_aleatoires==1}
-if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0}
-if {{$L_Max_Ded_Alea}>{$L_Min_Ded_Alea}} CIE_La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} -else CIE_La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} -endif
-if {{$a_Max_Ded_Alea}>{$a_Min_Ded_Alea}} CIE_aa={round(u($a_Min_Ded_Alea,$a_Max_Ded_Alea))} -else CIE_aa={round(u($a_Max_Ded_Alea,$a_Min_Ded_Alea))} -endif
-if {{$b_Max_Ded_Alea}>{$b_Min_Ded_Alea}} CIE_ba={round(u($b_Min_Ded_Alea,$b_Max_Ded_Alea))} -else CIE_ba={round(u($b_Max_Ded_Alea,$b_Min_Ded_Alea))} -endif
-endif
-endif
-if {$Inverser_Degrade==0}
CIE_Lca={$CIE_La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a+{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b+{$Nb_Boucles*$Inc_b}}
-else
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-endif
-if {$Trou_Noir==0}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
-elif {$Trou_Noir==1}
-if {$CIE_Lca>100} Inc_L={-1*$Inc_L} CIE_Lca=100  -endif
-if {$CIE_Lca<0} Inc_L={-1*$Inc_L} CIE_Lca=0 -endif
-if {$CIE_aca>127} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_aca<-128} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_bca>127} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-if {$CIE_bca<-128} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-elif {$Trou_Noir==2}
-if {$CIE_Lca>100} CIE_Lca={$CIE_Lca-100} -endif
-if {$CIE_Lca<0} CIE_Lca={$CIE_Lca+100} -endif
-if {$CIE_aca>127} CIE_aca={$CIE_aca-255} -endif
-if {$CIE_aca<-128} CIE_aca={$CIE_aca+255} -endif
-if {$CIE_bca>127} CIE_bca={$CIE_bca-255} -endif
-if {$CIE_bca<-128} CIE_bca={$CIE_bca+255} -endif
-endif
# Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{$nt_Yca^3}>0.008856}
nt_Yca={$nt_Yca^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{$nt_Xca^3}>0.008856}
nt_Xca={$nt_Xca^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{$nt_Zca^3}>0.008856}
nt_Zca={$nt_Zca^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
# Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{$nt_R^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{$nt_G^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{$nt_B^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {{$Type_Degrade==0}||{$Type_Degrade==2}}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {{$Type_Degrade==1}||{$Type_Degrade==3}}
-line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
-endif
######
-if {{$Type_Degrade==4}||{$Type_Degrade==5}||{$Type_Degrade==6}||{$Type_Degrade==7}}
Nb_Boucles=0
Inc_L={{$CIE_La-$CIE_Lb}/$Dimensions}
Inc_a={{$CIE_aa-$CIE_ab}/$Dimensions}
Inc_b={{$CIE_ba-$CIE_bb}/$Dimensions}
Inc_Alpha={{$Ab-$Aa}/$Dimensions}
$Dimensions,$Dimensions,1,4
-repeat $Dimensions
-if {$Degrades_aleatoires==1}
-if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0}
-if {{$L_Max_Ded_Alea}>{$L_Min_Ded_Alea}} CIE_La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} -else CIE_La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} -endif
-if {{$a_Max_Ded_Alea}>{$a_Min_Ded_Alea}} CIE_aa={round(u($a_Min_Ded_Alea,$a_Max_Ded_Alea))} -else CIE_aa={round(u($a_Max_Ded_Alea,$a_Min_Ded_Alea))} -endif
-if {{$b_Max_Ded_Alea}>{$b_Min_Ded_Alea}} CIE_ba={round(u($b_Min_Ded_Alea,$b_Max_Ded_Alea))} -else CIE_ba={round(u($b_Max_Ded_Alea,$b_Min_Ded_Alea))} -endif
-endif
-endif
-if {$Inverser_Degrade==0}
CIE_Lca={$CIE_La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a+{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b+{$Nb_Boucles*$Inc_b}}
-endif
-if {$Inverser_Degrade==1||{$Type_Degrade==6}||{$Type_Degrade==7}}
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-endif
-if {$Valider_Variations_Canal_A==1}
Aa={$Aa+$Inc_Alpha}
-if {$Aa>255} Aa=255 -endif
-if {$Aa<0} Aa=0 -endif
-endif
-if {$Trou_Noir==0}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
-elif {$Trou_Noir==1}
-if {$CIE_Lca>100} Inc_L={-1*$Inc_L} CIE_Lca=$CIE_Lb  -endif
-if {$CIE_Lca<0} Inc_L={-1*$Inc_L} CIE_Lca=$CIE_La -endif
-if {$CIE_aca>127} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_aca<-128} Inc_a={-1*$Inc_a} CIE_aca=0 -endif
-if {$CIE_bca>127} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-if {$CIE_bca<-128} Inc_b={-1*$Inc_b} CIE_bca=0 -endif
-elif {$Trou_Noir==2}
-if {$CIE_Lca>100} CIE_Lca={$CIE_Lca-100} -endif
-if {$CIE_Lca<0} CIE_Lca={$CIE_Lca+100} -endif
-if {$CIE_aca>127} CIE_aca={$CIE_aca-255} -endif
-if {$CIE_aca<-128} CIE_aca={$CIE_aca+255} -endif
-if {$CIE_bca>127} CIE_bca={$CIE_bca-255} -endif
-if {$CIE_bca<-128} CIE_bca={$CIE_bca+255} -endif
-endif
# Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{$nt_Yca^3}>0.008856}
nt_Yca={$nt_Yca^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{$nt_Xca^3}>0.008856}
nt_Xca={$nt_Xca^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{$nt_Zca^3}>0.008856}
nt_Zca={$nt_Zca^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
# Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{$nt_R^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{$nt_G^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{$nt_B^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {{$Type_Degrade==4}||{$Type_Degrade==6}}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {{$Type_Degrade==5}||{$Type_Degrade==7}}
-line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
-endif
#####
-if {$Variations_Formes==1}
-gimp_custom_deformation[-1] "(w+h)/"{20+$Parametre_Forme_A}" * cos(y*"{10+$Parametre_Forme_B}"/h)","1",1,1,1
-elif {$Variations_Formes==2}
-gimp_custom_deformation[-1] "1","(w+h)/"{20+$Parametre_Forme_A}" * sin(x*"{10+$Parametre_Forme_B}"/w)",1,1,1
-elif {$Variations_Formes==3}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-gimp_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==4}
-if {$Parametre_Forme_A<50} Parametre_Forme_A={{$Parametre_Forme_A+50}/100} -else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} -endif
-if {$Parametre_Forme_B<50} Parametre_Forme_B={{$Parametre_Forme_B+50}/100} -else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} -endif
-gimp_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
-elif {$Variations_Formes==5}
-gimp_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==6}
-gimp_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
-elif {$Variations_Formes==7}
-gimp_plaid_texture[-1] 50,2,0,90,0,300
-elif {$Variations_Formes==8}
-gimp_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==9}
-gimp_symmetrizoscope[-1] 5,0,1,0
-elif {$Variations_Formes==10}
-gimp_warp_perspective[-1] 1.73,0,1,50,50,$Parametre_Forme_A,0,2
-elif {$Variations_Formes==11}
-gimp_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
-elif {$Variations_Formes==12}
-gimp_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
-endif
samj_rien_rendering :
-Je_passe_l_hiver_en_Floride[-1]
samj_Points_Aleatoires_001 :
Iterations=$1
R_Point=$2
V_Point=$3
B_Point=$4
A_Point=$5
Mode=$6
Couleurs_Aleatoires=$7
Continuite=$8
Choix=0
Cavalier=0
Largeur_Origine={w}
Hauteur_Origine={h}
Position_X={round(u(0,{$Largeur_Origine-1}))}
Position_Y={round(u(0,{$Hauteur_Origine-1}))}
{w},{h},1,4
-fill_color[-1] 0,0,0,0
-rm[-2]
-repeat $Iterations
-if {$Couleurs_Aleatoires==1}
R_Point={round(u(0,255))}
V_Point={round(u(0,255))}
B_Point={round(u(0,255))}
A_Point=255
-endif
-if {$Continuite==0}
Position_X={round(u(0,{$Largeur_Origine-1}))}
Position_Y={round(u(0,{$Hauteur_Origine-1}))}
-endif
-repeat {$Largeur_Origine+$Hauteur_Origine}
Choix={round(u(0,1))}
-if {$Mode==0}
Inc_X={{round(u(0,2))}-1}
Inc_Y={{round(u(0,2))}-1}
-elif {$Mode==1}
Inc_X={{round(u(0,2))}-1}
Inc_Y={{round(u(0,{$|}))%3}-1}
-elif {$Mode==2}
Inc_X={{round(u(0,{$|}))%3}-1}
Inc_Y={{round(u(0,2))}-1}
-elif {$Mode==3}
-if {$Choix==0}
Cavalier={round(u(0,7))}
-else
Cavalier={round(u(0,4095)%8)}
-endif
-if {$Cavalier==0}
Inc_X=-1
Inc_Y=2
-elif {$Cavalier==1}
Inc_X=1
Inc_Y=2
-elif {$Cavalier==2}
Inc_X=2
Inc_Y=1
-elif {$Cavalier==3}
Inc_X=2
Inc_Y=-1
-elif {$Cavalier==4}
Inc_X=1
Inc_Y=-2
-elif {$Cavalier==5}
Inc_X=-1
Inc_Y=-2
-elif {$Cavalier==6}
Inc_X=-2
Inc_Y=-1
-elif {$Cavalier==7}
Inc_X=-2
Inc_Y=1
-endif
-elif {$Mode==4}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
-if {$Choix==0}
Inc_Y=$Inc_X
-else
Inc_Y={0-$Inc_X}
-endif
-elif {$Mode==5}
-if {$Choix==0}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=0
-else
Inc_X=0
Inc_Y={{round(u(0,8))}-{round(u(0,8))}}
-endif
-elif {$Mode==6}
Choix={round(u(0,3))}
-if {$Choix==0}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=$Inc_X
-elif {$Choix==1}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=0
-elif {$Choix==2}
Inc_X=0
Inc_Y={{round(u(0,8))}-{round(u(0,8))}}
-elif {$Choix==3}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y={0-$Inc_X}
-endif
-endif
Position_X={$Position_X+$Inc_X}
-if {$Position_X<0}
Position_X={$Largeur_Origine-1}
-endif
-if {$Position_X>{$Largeur_Origine-1}}
Position_X=0
-endif
Position_Y={$Position_Y+$Inc_Y}
-if {$Position_Y<0}
Position_Y={$Hauteur_Origine-1}
-endif
-if {$Position_Y>{$Hauteur_Origine-1}}
Position_Y=0
-endif
-point[-1] $Position_X,$Position_Y,0,1,$R_Point,$V_Point,$B_Point,$A_Point
-done
-done
samj_Courtepointe :
Cossin=$1
Cossin_Deux=$2
Repetition=$3
Croix=$4
Texture=$5
Courbes_Interactives_Couleurs=$6
-rorschach[-1] {$Cossin}%,1
-if {$Cossin_Deux==1}
-n[-1] 64,192
-endif
-n[-1] 0,255
-repeat $Repetition
-gimp_array_mirror[-1] 1,0,0,2,0,0
-done
-if {$Croix==1}
-gimp_symmetrizoscope[-1] 5,0,1,0
-endif
-if {$Texture==1}
-samj_Texture_Granuleuse[-1] 0.5,20,80,0,0
-endif
-if {$Courbes_Interactives_Couleurs==0}
-x_color_curves[-1] rgb
-elif {$Courbes_Interactives_Couleurs==1}
-x_color_curves[-1] cmy
-elif {$Courbes_Interactives_Couleurs==2}
-x_color_curves[-1] cmyk
-elif {$Courbes_Interactives_Couleurs==3}
-x_color_curves[-1] hsi
-elif {$Courbes_Interactives_Couleurs==4}
-x_color_curves[-1] hsl
-elif {$Courbes_Interactives_Couleurs==5}
-x_color_curves[-1] hsv
-elif {$Courbes_Interactives_Couleurs==6}
-x_color_curves[-1] lab
-elif {$Courbes_Interactives_Couleurs==7}
-x_color_curves[-1] lch
-elif {$Courbes_Interactives_Couleurs==8}
-x_color_curves[-1] ycbcr
-endif
samj_en_Courtepointe :
-samj_Courtepointe $1,$2,$3,$4,$5,$6
samj_Adjacent_Annular_Steiner_Chains :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Angle_inclinaison=$3
Canal_Alpha=$4
-if {$5>0}
Rayon_Cercle_Centre={round({{w}*$5/{100}})}
-else
Rayon_Cercle_Centre={round({-{h}*$5/{100}})}
-endif
Nb_Circles_Surrounding=$6
Nb_Anneaux=$7
Angle_Decalage=$8
Variation_Increment_Anneaux=$9
R_a=$10
V_a=$11
B_a=$12
A_a=$13
R_b=$14
V_b=$15
B_b=$16
A_b=$17
R_c=$18
V_c=$19
B_c=$20
A_c=$21
R_d=$22
V_d=$23
B_d=$24
A_d=$25
R_e=$26
V_e=$27
B_e=$28
A_e=$29
R_f=$30
V_f=$31
B_f=$32
A_f=$33
R_g=$34
V_g=$35
B_g=$36
A_g=$37
#Choix_Des_Couleurs
Rendu=$38
Variations_Des_Couleurs=$39
Couleurs_aleatoires=$40
Affichage_Contours=$41
R_Contours=$42
V_Contours=$43
B_Contours=$44
A_Contours=$45
Dilate_Contours=$46
Flou_Contours=$47
Sharpen_Contours=$48
Largeur_Origine={w}
Hauteur_Origine={h}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
# 1 nouvelle image contours
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] 0,0,0,0
# 1 nouvelle image couleurs
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] 0,0,0,0
Angle_Theta={pi/$Nb_Circles_Surrounding}
-if {$Rayon_Cercle_Centre<1}
Rayon_Cercle_Centre=1
-endif
Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Angle_Decalage_En_Cours=0
Nb_boucles_anneaux=0
Rayon_Cercle_Centre_En_Cours=0
Ra_en_cours=0
Va_en_cours=0
Ba_en_cours=0
Aa_en_cours=0
Suite_Couleurs=0
-if {$Couleurs_aleatoires==1}
R_CE={round(u)*255}
V_CE={round(u)*255}
B_CE={round(u)*255}
R_PC={round(u)*255}
V_PC={round(u)*255}
B_PC={round(u)*255}
-endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-repeat $Nb_Anneaux
Nb_boucles=0
Suite_Couleurs=0
-if {$Couleurs_aleatoires==2}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage/100*$Nb_boucles_anneaux}
-if {$Nb_boucles_anneaux==0}
Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
-else
Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
-endif
Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
-repeat $Nb_Circles_Surrounding
-if {$Couleurs_aleatoires==3}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-if {$Rendu==6}
-if {{{($Nb_boucles%7)}==0}&&{$Suite_Couleurs==0}}
Ra_en_cours=$R_a
Va_en_cours=$V_a
Ba_en_cours=$B_a
Aa_en_cours=$A_a
Suite_Couleurs=1
-endif
-if {{{($Nb_boucles%7)}==1}&&{$Suite_Couleurs==1}}
Ra_en_cours=$R_b
Va_en_cours=$V_b
Ba_en_cours=$B_b
Aa_en_cours=$A_b
Suite_Couleurs=2
-endif
-if {{{($Nb_boucles%7)}==2}&&{$Suite_Couleurs==2}}
Ra_en_cours=$R_c
Va_en_cours=$V_c
Ba_en_cours=$B_c
Aa_en_cours=$A_c
Suite_Couleurs=3
-endif
-if {{{($Nb_boucles%7)}==3}&&{$Suite_Couleurs==3}}
Ra_en_cours=$R_d
Va_en_cours=$V_d
Ba_en_cours=$B_d
Aa_en_cours=$A_d
Suite_Couleurs=4
-endif
-if {{{($Nb_boucles%7)}==4}&&{$Suite_Couleurs==4}}
Ra_en_cours=$R_e
Va_en_cours=$V_e
Ba_en_cours=$B_e
Aa_en_cours=$A_e
Suite_Couleurs=5
-endif
-if {{{($Nb_boucles%7)}==5}&&{$Suite_Couleurs==5}}
Ra_en_cours=$R_f
Va_en_cours=$V_f
Ba_en_cours=$B_f
Aa_en_cours=$A_f
Suite_Couleurs=6
-endif
-if {{{($Nb_boucles%7)}==6}&&{$Suite_Couleurs==6}}
Ra_en_cours=$R_g
Va_en_cours=$V_g
Ba_en_cours=$B_g
Aa_en_cours=$A_g
Suite_Couleurs=0
-endif
-endif
-if {$Rendu<6}
-if {{($Nb_boucles%2)}==0}
Ra_en_cours=$R_a
Va_en_cours=$V_a
Ba_en_cours=$B_a
Aa_en_cours=$A_a
-endif
-if {{($Nb_boucles%2)}==1}
Ra_en_cours=$R_b
Va_en_cours=$V_b
Ba_en_cours=$B_b
Aa_en_cours=$A_b
-endif
-if {{{($Nb_boucles%3)}==2}&&{$Rendu>0}}
Ra_en_cours=$R_c
Va_en_cours=$V_c
Ba_en_cours=$B_c
Aa_en_cours=$A_c
-endif
-if {{{($Nb_boucles%4)}==3}&&{$Rendu>1}}
Ra_en_cours=$R_d
Va_en_cours=$V_d
Ba_en_cours=$B_d
Aa_en_cours=$A_d
-endif
-if {{{($Nb_boucles%5)}==4}&&{$Rendu>2}}
Ra_en_cours=$R_e
Va_en_cours=$V_e
Ba_en_cours=$B_e
Aa_en_cours=$A_e
-endif
-if {{{($Nb_boucles%6)}==5}&&{$Rendu>3}}
Ra_en_cours=$R_f
Va_en_cours=$V_f
Ba_en_cours=$B_f
Aa_en_cours=$A_f
-endif
-if {{{($Nb_boucles%7)}==6}&&{$Rendu>4}}
Ra_en_cours=$R_g
Va_en_cours=$V_g
Ba_en_cours=$B_g
Aa_en_cours=$A_g
-endif
-endif
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
Nb_boucles={$Nb_boucles+1}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Aa_en_cours
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}}
-ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{{$Affichage_Contours==4}||{$Affichage_Contours==5}}&&{{($Nb_boucles%2)}==1}}
-ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-done
Nb_boucles_anneaux={$Nb_boucles_anneaux+1}
-done
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==5}}
-ellipse[-2] $X,$Y,{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilate_Contours>1} -dilate_circ[-2] $Dilate_Contours -endif
-if {$Flou_Contours>0} -blur[-2] $Flou_Contours,0 -endif
-if {$Sharpen_Contours>0} -sharpen[-2] $Sharpen_Contours -endif
-if {$Variations_Des_Couleurs<0} -*[-1] {abs($Variations_Des_Couleurs)} -c[-1] 0,255 -endif
-blend[-2,-1] alpha,1,1
-if {$Variations_Des_Couleurs>0} -*[-1] $Variations_Des_Couleurs -c[-1] 0,255 -endif
-blend[-1,-2] alpha,1,0
samj_en_Rectangles_Adjacents :
-samj_Rectangles_Adjacents $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36
samj_Rectangles_Adjacents :
X_Haut_Gauche=$1
Y_Haut_Gauche=$2
X_Bas_Droite=$3
Y_Bas_Droite=$4
Type_Contact=$5
Position_Contact=$6
Nb_Rectangles=$7
Type_n=$8
Angle_inclinaison=$9
R_Contours=$10
V_Contours=$11
B_Contours=$12
A_Contours=$13
Affichage_Contours=$14
R_a=$15
V_a=$16
B_a=$17
A_a=$18
R_b=$19
V_b=$20
B_b=$21
A_b=$22
Couleurs_aleatoires=$23
Inversions=$24
Flou=$25
Dilatation=$26
Deformation=$27
Bruit=$28
Ombre=$29
X_Ombre=$30
Y_Ombre=$31
Smoothness_Ombre=$32
Curvature_Ombre=$33
Compensation_Decalage_Ombre_X=$34
Compensation_Decalage_Ombre_Y=$35
Canal_Alpha=$36
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Dimension_Image_Rotation={round({{{{$Largeur_Origine*$Largeur_Origine}+{$Hauteur_Origine*$Hauteur_Origine}}^0.5}+2})}
Decalage_X={round({{$Dimension_Image_Rotation-$Largeur_Origine}/2})}
Decalage_Y={round({{$Dimension_Image_Rotation-$Hauteur_Origine}/2})}
X_H_G_origine={$Decalage_X+{round({$Largeur_Origine*{$X_Haut_Gauche/100}})}}
Y_H_G_origine={$Decalage_Y+{round({$Hauteur_Origine*{$Y_Haut_Gauche/100}})}}
Largeur_Rectangle_origine={round({$Largeur_Origine*{$X_Bas_Droite/100}})}
Hauteur_Rectangle_origine={round({$Hauteur_Origine*{$Y_Bas_Droite/100}})}
Largeur_A_Imprimer=$Largeur_Rectangle_origine
Hauteur_A_Imprimer=$Hauteur_Rectangle_origine
-if {$Type_Contact==0}
X_Contact={$X_H_G_origine+{round({$Largeur_Rectangle_origine*{$Position_Contact/100}})}}
Y_Contact=$Y_H_G_origine
-elif {$Type_Contact==1}
X_Contact={$X_H_G_origine+{round({$Largeur_Rectangle_origine*{$Position_Contact/100}})}}
Y_Contact={$Y_H_G_origine+$Hauteur_Rectangle_origine}
-elif {$Type_Contact==2}
X_Contact=$X_H_G_origine
Y_Contact={$Y_H_G_origine+{round({$Hauteur_Rectangle_origine*{$Position_Contact/100}})}}
-elif {$Type_Contact==3}
X_Contact={$X_H_G_origine+$Largeur_Rectangle_origine}
Y_Contact={$Y_H_G_origine+{round({$Hauteur_Rectangle_origine*{$Position_Contact/100}})}}
-endif
X_H_G_A_Imprimer=$X_H_G_origine
Y_H_G_A_Imprimer=$Y_H_G_origine
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours==1}
$Dimension_Image_Rotation,$Dimension_Image_Rotation,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Dimension_Image_Rotation,$Dimension_Image_Rotation,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},1,0xFFFFFFFF,0,0,0,1 -endif
-repeat $Nb_Rectangles
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
-endif
-if {{($Nb_boucles%2)}==0}
-polygon[-1] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,$R_a,$V_a,$B_a,$A_a
-else
-polygon[-1] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,$R_b,$V_b,$B_b,$A_b
-endif
-if {$Affichage_Contours==1}
-polygon[-2] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Type_n==0}
Largeur_A_Imprimer={$Largeur_Rectangle_origine/{$Nb_boucles+1}}
Hauteur_A_Imprimer={$Hauteur_Rectangle_origine/{$Nb_boucles+1}}
-elif {$Type_n==1}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.9}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.9}
-elif {$Type_n==2}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.8}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.8}
-elif {$Type_n==3}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.7}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.7}
-elif {$Type_n==4}
Largeur_A_Imprimer={$Largeur_A_Imprimer*{?(0.7,0.9)}}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*{?(0.7,0.9)}}
-elif {$Type_n==5}
Largeur_A_Imprimer={$Largeur_Rectangle_origine/{$Nb_boucles+1}}
Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.9}
-elif {$Type_n==6}
Largeur_A_Imprimer={$Largeur_A_Imprimer*0.9}
Hauteur_A_Imprimer={$Hauteur_Rectangle_origine/{$Nb_boucles+1}}
-endif
-if {$Type_Contact==0}
X_H_G_A_Imprimer={$X_Contact-{$Largeur_A_Imprimer/2}}
Y_H_G_A_Imprimer=$Y_Contact
-elif {$Type_Contact==1}
X_H_G_A_Imprimer={$X_Contact-{$Largeur_A_Imprimer/2}}
Y_H_G_A_Imprimer={$Y_Contact-$Hauteur_A_Imprimer}
-elif {$Type_Contact==2}
X_H_G_A_Imprimer=$X_Contact
Y_H_G_A_Imprimer={$Y_Contact-{$Hauteur_A_Imprimer/2}}
-elif {$Type_Contact==3}
X_H_G_A_Imprimer={$X_Contact-$Largeur_A_Imprimer}
Y_H_G_A_Imprimer={$Y_Contact-{$Hauteur_A_Imprimer/2}}
-endif
-done
-if {$Affichage_Contours==1}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_inclinaison>0} -rotate[-1] $Angle_inclinaison,1,0,{{w}/2},{{h}/2} -endif
-crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{$Largeur_Origine+{{{w}-$Largeur_Origine-1}/2}-1},{$Hauteur_Origine+{{{h}-$Hauteur_Origine-1}/2}-1}
-blend[-1,-2] alpha,1,0
samj_Annular_Steiner_Chains :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
-if {$3>0}
Rayon_Cercle_Exterieur={round({{w}*$3/{100}})}
-else
Rayon_Cercle_Exterieur={round({-{h}*$3/{100}})}
-endif
Nb_Circles_Surrounding=$4
Angle_inclinaison=$5
R_Contours=$6
V_Contours=$7
B_Contours=$8
A_Contours=$9
Affichage_Contours=$10
R_CE=$11
V_CE=$12
B_CE=$13
A_CE=$14
R_PC=$15
V_PC=$16
B_PC=$17
A_PC=$18
R_c=$19
V_c=$20
B_c=$21
A_c=$22
R_d=$23
V_d=$24
B_d=$25
A_d=$26
Couleurs_aleatoires=$27
Inversions=$28
Flou=$29
Dilatation=$30
Deformation=$31
Bruit=$32
Ombre=$33
X_Ombre=$34
Y_Ombre=$35
Smoothness_Ombre=$36
Curvature_Ombre=$37
Compensation_Decalage_Ombre_X=$38
Compensation_Decalage_Ombre_Y=$39
Canal_Alpha=$40
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Theta={pi/$Nb_Circles_Surrounding}
Rayon_Cercle_Centre={{$Rayon_Cercle_Exterieur*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Couleurs_aleatoires==1}
R_CE={round(u)*255}
V_CE={round(u)*255}
B_CE={round(u)*255}
R_PC={round(u)*255}
V_PC={round(u)*255}
B_PC={round(u)*255}
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-ellipse[-1] $X,$Y,$Rayon_Cercle_Centre,$Rayon_Cercle_Centre,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==2}||{$Affichage_Contours==3}}
-ellipse[-1] $X,$Y,$Rayon_Centres_C_Ext,$Rayon_Centres_C_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {{$Affichage_Contours==3}||{$Affichage_Contours==4}}
-ellipse[-1] $X,$Y,$Rayon_Tang,$Rayon_Tang,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,$R_CE,$V_CE,$B_CE,$A_CE
-ellipse[-1] $X,$Y,$Rayon_Cercle_Centre,$Rayon_Cercle_Centre,0,1,$R_PC,$V_PC,$B_PC,$A_PC
-repeat $Nb_Circles_Surrounding
Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison}})}}}
Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison}})}}}
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
-endif
-if {{($Nb_Circles_Surrounding%2)}==0}
-if {{($Nb_boucles%2)}==0}
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_c,$V_c,$B_c,$A_c
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_d,$V_d,$B_d,$A_d
-endif
-else
-ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_c,$V_c,$B_c,$A_c
-endif
-if {$Affichage_Contours>0}
-ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
#-text_outline[-1] {2*$Rayon_Cercle_Exterieur},10,10,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercles_Ext},10,60,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Centres_C_Ext},10,110,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Tang},10,160,64,1,1,255,255,255
#-text_outline[-1] {2*$Rayon_Cercle_Centre},10,210,64,1,1,255,255,255
samj_Chryzodes :
Dimension={round({{max({w},{h})}*$1/100})}
R_fond=$2
V_fond=$3
B_fond=$4
A_fond=$5
Demo=$6
X={round({$Dimension*{$7/100}})}
Y={round({$Dimension*{$8/100}})}
Rayon_Cercle={round({$Dimension*$9/100})}
Nb_Points=$10
Multiplicateur=$11
Premier_Point=$12
R_l=$13
V_l=$14
B_l=$15
A_l=$16
Angle_Inclinaison=$17
Type_De_Lignes=$18
Couleurs_aleatoires=$19
Variations_A=$20
Variations_B=$21
Variations_C=$22
Flou=$23
Dilatation=$24
Deformation=$25
Bruit=$26
Tracer_Cercle=$27
-if {$Demo==1}
Nb_Points=431
Multiplicateur=7
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==2}
Nb_Points=353
Multiplicateur=3
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==3}
Nb_Points=619
Multiplicateur=4
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==4}
Nb_Points=691
Multiplicateur=12
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==5}
Nb_Points=613
Multiplicateur=20
Variations_A=0
Variations_B=0
Variations_C=0
-elif {$Demo==6}
Nb_Points=358
Multiplicateur=13
Variations_A=0
Variations_B=0
Variations_C=1
-elif {$Demo==7}
Nb_Points=118
Multiplicateur=20
Variations_A=0
Variations_B=0
Variations_C=1
-elif {$Demo==8}
Nb_Points=699
Multiplicateur=6
Variations_A=0
Variations_B=0
Variations_C=0
Demo=8
-endif
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Base={360/$Nb_Points}
Point_Origine=0
Sortie_Boucle_Lignes=0
Nb_Boucle_Lignes=0
Nb_Boucle_Points=0
Point_A=0
Angle_A=0
X_Imp_A=0
Y_Imp_A=0
Point_B=0
Angle_B=0
X_Imp_B=0
Y_Imp_B=0
a_Ligne=0
b_Ligne=0
X_Ex_a=0
Y_Ex_a=0
X_Ex_b=0
Y_Ex_b=0
-if {$Variations_A==0}
Boucles_Rendu=1
Variations_A=1
-else
Boucles_Rendu=2
-endif
-rm[-1]
$Dimension,$Dimension,1,4
-fill_color[-1] 0,0,0,0
Point_A=$Premier_Point
Angle_A={$Angle_Base*$Point_A}
X_Imp_A={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Y_Imp_A={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Point_Origine=$Point_A
test=0
-repeat {$Boucles_Rendu+$Variations_B}
-if {$Couleurs_aleatoires==1}
R_l={round(u)*255}
V_l={round(u)*255}
B_l={round(u)*255}
-endif
-do
-if {$Couleurs_aleatoires==2}
R_l={round(u)*255}
V_l={round(u)*255}
B_l={round(u)*255}
-endif
-if {$Variations_C==0}
Point_B={{$Point_A*$Multiplicateur}%$Nb_Points}
-else
Point_B={{$Point_A*$Multiplicateur*2}%$Nb_Points}
-endif
Angle_B={$Angle_Base*$Point_B}
X_Imp_B={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_B+$Angle_Inclinaison}})}}}
Y_Imp_B={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_B+$Angle_Inclinaison}})}}}
-if {$Type_De_Lignes==1}
-if {{round({$X_Imp_A*1000000000000})}=={round({$X_Imp_B*1000000000000})}}
X_Ex_a=$X_Imp_A
Y_Ex_a=0
X_Ex_b=$X_Imp_B
Y_Ex_b={$Dimension-1}
-line[-1] $X_Ex_a,$Y_Ex_a,$X_Ex_b,$Y_Ex_b,1,$R_l,$V_l,$B_l,$A_l
-else
a_Ligne={{$Y_Imp_B-$Y_Imp_A}/{$X_Imp_B-$X_Imp_A}}
b_Ligne={$Y_Imp_B-{$a_Ligne*$X_Imp_B}}
X_Ex_a=0
Y_Ex_a=$b_Ligne
X_Ex_b={$Dimension-1}
Y_Ex_b={{$a_Ligne*$X_Ex_b}+$b_Ligne}
-line[-1] $X_Ex_a,$Y_Ex_a,$X_Ex_b,$Y_Ex_b,1,$R_l,$V_l,$B_l,$A_l
-endif
-else
-line[-1] $X_Imp_A,$Y_Imp_A,$X_Imp_B,$Y_Imp_B,1,$R_l,$V_l,$B_l,$A_l
-endif
-if {{$Point_B}=={$Point_Origine}} Sortie_Boucle_Lignes=1 -endif
-if {{$Nb_Boucle_Lignes}>{$Nb_Points*$Multiplicateur}} Sortie_Boucle_Lignes=1 -endif
-if {$Variations_C==1}
-if {{$Nb_Boucle_Lignes}>{$Nb_Points}} Sortie_Boucle_Lignes=1 -endif
-endif
Point_A=$Point_B
X_Imp_A=$X_Imp_B
Y_Imp_A=$Y_Imp_B
Nb_Boucle_Lignes={$Nb_Boucle_Lignes+1}
-while {$Sortie_Boucle_Lignes==0}
Nb_Boucle_Points={$Nb_Boucle_Points+1}
Point_A={$Premier_Point+{1/$Nb_Points*$Nb_Boucle_Points/$Variations_A}}
Angle_A={$Angle_Base*$Point_A}
X_Imp_A={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Y_Imp_A={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
Point_Origine=$Point_A
Sortie_Boucle_Lignes=0
Nb_Boucle_Lignes=0
-done
-if {$Tracer_Cercle==1}
-ellipse[-1] $X,$Y,$Rayon_Cercle,$Rayon_Cercle,0,1,0xFFFFFFFF,$R_l,$V_l,$B_l,$A_l
-endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
$Dimension,$Dimension,1,4
-fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond
-gimp_blend_1651[-2,-1] 1,0,1,0,1
samj_en_Chryzodes :
-samj_Chryzodes $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27
samj_dessiner_un_polygone:
Nombre_de_cotes=$1
X_centre_cercle_circonscrit={$2/100*w}
Y_centre_cercle_circonscrit={$3/100*h}
Angle_inclinaison=$4
-if {$5>0}
Rayon_cercle_circonscrit={round({{w}*$5/{100}})}
-else
Rayon_cercle_circonscrit={round({-{h}*$5/{100}})}
-endif
Rayon_cercle_interieur={round({$Rayon_cercle_circonscrit/100*$6})}
Remplir_polygone_exterieur=$7
## ATTENTION variables $8,$9,$10 utilises + loin dans le script
R_Couleur_polygone_exterieur=$8
V_Couleur_polygone_exterieur=$9
B_Couleur_polygone_exterieur=$10
Contour_polygone_exterieur=$11
R_Couleur_contour_polygone_exterieur=$12
V_Couleur_contour_polygone_exterieur=$13
B_Couleur_contour_polygone_exterieur=$14
Remplir_polygone_interieur=$15
## ATTENTION variables $16,$17,$18 utilises + loin dans le script
R_Couleur_polygone_interieur=$16
V_Couleur_polygone_interieur=$17
B_Couleur_polygone_interieur=$18
Contour_polygone_interieur=$19
R_Couleur_contour_polygone_interieur=$20
V_Couleur_contour_polygone_interieur=$21
B_Couleur_contour_polygone_interieur=$22
Variation_de_couleur=$23
Remplir_cercle_interieur=$24
R_CI_plein=$25
V_CI_plein=$26
B_CI_plein=$27
Contour_cercle_interieur=$28
R_CI_contour=$29
V_CI_contour=$30
B_CI_contour=$31
Remplir_cercle_exterieur=$32
R_CE_plein=$33
V_CE_plein=$34
B_CE_plein=$35
Contour_cercle_exterieur=$36
R_CE_contour=$37
V_CE_contour=$38
B_CE_contour=$39
Valeur_dilate_circ=$40
Transparence_des_couleurs=$41
Flou_polygone=$42
Spread_polygone=$43
Deform_polygone=$44
blend=$45
{w},{h},1,4
-fill_color[-1] 0,0,0,0
#
-if {$Remplir_cercle_exterieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_circonscrit,$Rayon_cercle_circonscrit,0,1,$R_CE_plein,$V_CE_plein,$B_CE_plein,$Transparence_des_couleurs
-endif
#
-if {$Contour_cercle_exterieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_circonscrit,$Rayon_cercle_circonscrit,0,1,0xFFFFFF,$R_CE_contour,$V_CE_contour,$B_CE_contour,$Transparence_des_couleurs
-endif
#
Increment_angle={360/$Nombre_de_cotes}
Nb_boucle=$Nombre_de_cotes
-do
-if {$Variation_de_couleur==0}
X_point_exterieur={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
Y_point_exterieur={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
X_point_interieur={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
Y_point_interieur={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
-if {$Nb_boucle==$Nombre_de_cotes}
Points_polygone_exterieur=$X_point_exterieur,$Y_point_exterieur
Points_polygone_interieur=$X_point_interieur,$Y_point_interieur
-else
Points_polygone_exterieur=$Points_polygone_exterieur,$X_point_exterieur,$Y_point_exterieur
Points_polygone_interieur=$Points_polygone_interieur,$X_point_interieur,$Y_point_interieur
-endif
-if {$Nb_boucle==1}
-if {$Remplir_polygone_exterieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_exterieur,1,$R_Couleur_polygone_exterieur,$V_Couleur_polygone_exterieur,$B_Couleur_polygone_exterieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_exterieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_exterieur,1,0xFFFFFF,$R_Couleur_contour_polygone_exterieur,$V_Couleur_contour_polygone_exterieur,$B_Couleur_contour_polygone_exterieur,$Transparence_des_couleurs
-endif
-if {$Remplir_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
-endif
-if {$Contour_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
-endif
-if {$Remplir_polygone_interieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_interieur,1,$R_Couleur_polygone_interieur,$V_Couleur_polygone_interieur,$B_Couleur_polygone_interieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_interieur==1}
-polygon[-1] $Nombre_de_cotes,$Points_polygone_interieur,1,0xFFFFFF,$R_Couleur_contour_polygone_interieur,$V_Couleur_contour_polygone_interieur,$B_Couleur_contour_polygone_interieur,$Transparence_des_couleurs
-endif
-endif
-endif
-if {$Variation_de_couleur==1}
X_point_exterieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_exterieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
-if {$Contour_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,0xFFFFFF,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
X_point_interieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_interieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
-if {$Contour_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,0xFFFFFF,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
-endif
-if {$Nb_boucle==1}
-if {$Remplir_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
-endif
-if {$Contour_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
-endif
-endif
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_polygone_exterieur={round({$8+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_polygone_exterieur>255}
R_Couleur_polygone_exterieur=$8
-endif
-if {$R_Couleur_polygone_exterieur<0}
R_Couleur_polygone_exterieur=$8
-endif
V_Couleur_polygone_exterieur={round({$9+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_polygone_exterieur>255}
V_Couleur_polygone_exterieur=$9
-endif
-if {$V_Couleur_polygone_exterieur<0}
V_Couleur_polygone_exterieur=$9
-endif
B_Couleur_polygone_exterieur={round({$10+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_polygone_exterieur>255}
B_Couleur_polygone_exterieur=$10
-endif
-if {$B_Couleur_polygone_exterieur<0}
B_Couleur_polygone_exterieur=$10
-endif
R_Couleur_polygone_interieur={round({$16+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_polygone_interieur>255}
R_Couleur_polygone_interieur=$16
-endif
-if {$R_Couleur_polygone_interieur<0}
R_Couleur_polygone_interieur=$16
-endif
V_Couleur_polygone_interieur={round({$17+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_polygone_interieur>255}
V_Couleur_polygone_interieur=$17
-endif
-if {$V_Couleur_polygone_interieur<0}
V_Couleur_polygone_interieur=$17
-endif
B_Couleur_polygone_interieur={round({$18+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_polygone_interieur>255}
B_Couleur_polygone_interieur=$18
-endif
-if {$B_Couleur_polygone_interieur<0}
B_Couleur_polygone_interieur=$18
-endif
X_point_exterieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_exterieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_exterieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,$R_Couleur_polygone_exterieur,$V_Couleur_polygone_exterieur,$B_Couleur_polygone_exterieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_exterieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,0xFFFFFF,$R_Couleur_contour_polygone_exterieur,$V_Couleur_contour_polygone_exterieur,$B_Couleur_contour_polygone_exterieur,$Transparence_des_couleurs
-endif
X_point_interieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
X_point_interieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
Y_point_interieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
-if {$Remplir_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,$R_Couleur_polygone_interieur,$V_Couleur_polygone_interieur,$B_Couleur_polygone_interieur,$Transparence_des_couleurs
-endif
-if {$Contour_polygone_interieur==1}
-polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,0xFFFFFF,$R_Couleur_contour_polygone_interieur,$V_Couleur_contour_polygone_interieur,$B_Couleur_contour_polygone_interieur,$Transparence_des_couleurs
-endif
-if {$Nb_boucle==1}
-if {$Remplir_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
-endif
-if {$Contour_cercle_interieur==1}
-ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
-endif
-endif
-endif
Increment_angle={$Increment_angle+{360/$Nombre_de_cotes}}
Nb_boucle={$Nb_boucle-1}
-while {$Nb_boucle>0}
-if {$Valeur_dilate_circ>1}
-dilate_circ[-1] $Valeur_dilate_circ
-endif
-blur[-1] $Flou_polygone
-spread[-1] $Spread_polygone
-deform[-1] $Deform_polygone
-gimp_blend_1651[-2,-1] $blend,1,1,1
samj_Egg_Oeuf_Granville :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Decalage_X={round({{min({w},{h})}*$3/100})}
Valeur_A={round({{min({w},{h})}*$4/40})}
Valeur_B={round({{min({w},{h})}*$5/40})}
Valeur_R={round({{min({w},{h})}*$6/40})}
Angle_Rotation=$7
R_Contours=$8
V_Contours=$9
B_Contours=$10
A_Contours=$11
Affichage_Contours=$12
R_a=$13
V_a=$14
B_a=$15
A_a=$16
Couleurs_aleatoires=$17
Inversions=$18
Flou=$19
Dilatation=$20
Deformation=$21
Bruit=$22
Ombre=$23
X_Ombre=$24
Y_Ombre=$25
Smoothness_Ombre=$26
Curvature_Ombre=$27
Compensation_Decalage_Ombre_X=$28
Compensation_Decalage_Ombre_Y=$29
Canal_Alpha=$30
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Oeuf_A_Imprimer=0
Y_Oeuf_A_Imprimer=0
# X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{     }}}
# Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{     }}}
X_Oeuf_A_Imprimer_Precedent={{$X-{$Valeur_B+{$Valeur_R/2}}}+{$Decalage_X+{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}
Y_Oeuf_A_Imprimer_Precedent={$Y+{{{$Valeur_A*$Valeur_R*{sin({pi/180*$Angle})}}/{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-if {$Affichage_Contours==2}
-ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_B,$Valeur_B,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_R,$Valeur_R,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Oeuf_A_Imprimer={{$X-{$Valeur_B+{$Valeur_R/2}}}+{$Decalage_X+{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}
Y_Oeuf_A_Imprimer={$Y+{{{$Valeur_A*$Valeur_R*{sin({pi/180*$Angle})}}/{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}}
-polygon[-1] 3,{$X+$Decalage_X},$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
samj_Egg_Oeuf_Hugelschaffer :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Dimension={round({{min({w},{h})}*$3/5000})}
Valeur_A=$4
Valeur_B=$5
Valeur_D=$6
Angle_Rotation=$7
R_Contours=$8
V_Contours=$9
B_Contours=$10
A_Contours=$11
Affichage_Contours=$12
R_a=$13
V_a=$14
B_a=$15
A_a=$16
Couleurs_aleatoires=$17
Inversions=$18
Flou=$19
Dilatation=$20
Deformation=$21
Bruit=$22
Ombre=$23
X_Ombre=$24
Y_Ombre=$25
Smoothness_Ombre=$26
Curvature_Ombre=$27
Compensation_Decalage_Ombre_X=$28
Compensation_Decalage_Ombre_Y=$29
Canal_Alpha=$30
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Oeuf_A_Imprimer=0
Y_Oeuf_A_Imprimer=0
X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{{{{$Valeur_A*$Valeur_A}-{$Valeur_D*$Valeur_D*{sin({pi/180*$Angle})}*{sin({pi/180*$Angle})}}^0.5}+{$Valeur_D*{cos({pi/180*$Angle})}}}*{cos({pi/180*$Angle})}}}}
Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{$Valeur_B*{sin({pi/180*$Angle})}}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-if {$Affichage_Contours==2}
-ellipse[-2] $X,$Y,{$Dimension*$Valeur_A},{$Dimension*$Valeur_A},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] $X,$Y,{$Dimension*$Valeur_B},{$Dimension*$Valeur_B},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Oeuf_A_Imprimer={$X+{$Dimension*{{{{$Valeur_A*$Valeur_A}-{$Valeur_D*$Valeur_D*{sin({pi/180*$Angle})}*{sin({pi/180*$Angle})}}^0.5}+{$Valeur_D*{cos({pi/180*$Angle})}}}*{cos({pi/180*$Angle})}}}}
Y_Oeuf_A_Imprimer={$Y+{$Dimension*{$Valeur_B*{sin({pi/180*$Angle})}}}}
-polygon[-1] 3,$X,$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
samj_Egg_Oeuf_Rosillo :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Valeur_A={round({{{w}+{h}}*$3/200})}
Valeur_B={$Valeur_A*$4/100}
Valeur_C={$Valeur_A*$5/100}
Angle_Rotation=$6
R_Contours=$7
V_Contours=$8
B_Contours=$9
A_Contours=$10
Affichage_Contours=$11
R_a=$12
V_a=$13
B_a=$14
A_a=$15
Couleurs_aleatoires=$16
Inversions=$17
Flou=$18
Dilatation=$19
Deformation=$20
Bruit=$21
Ombre=$22
X_Ombre=$23
Y_Ombre=$24
Smoothness_Ombre=$25
Curvature_Ombre=$26
Compensation_Decalage_Ombre_X=$27
Compensation_Decalage_Ombre_Y=$28
Canal_Alpha=$29
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Oeuf_A_Imprimer=0
Y_Oeuf_A_Imprimer=0
# X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{     }}}
# Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{     }}}
X_Oeuf_A_Imprimer_Precedent={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
Y_Oeuf_A_Imprimer_Precedent={$Y+{{$Valeur_B-{$Valeur_A*{cos({pi/180*$Angle})}}}/{$Valeur_C-{$Valeur_A*{cos({pi/180*$Angle})}}}*{$Valeur_A*{sin({pi/180*$Angle})}}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-if {$Affichage_Contours==2}
-ellipse[-2] $X,$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] $X,$Y,$Valeur_B,$Valeur_B,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-2] $X,$Y,$Valeur_C,$Valeur_C,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Oeuf_A_Imprimer={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
Y_Oeuf_A_Imprimer={$Y+{{$Valeur_B-{$Valeur_A*{cos({pi/180*$Angle})}}}/{$Valeur_C-{$Valeur_A*{cos({pi/180*$Angle})}}}*{$Valeur_A*{sin({pi/180*$Angle})}}}}
-polygon[-1] 3,$X,$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
samj_Etoiles_Remplies_Triangles_Sierpinski :
Nombre_de_sommets=$1
X={round({{w}*{$2/100}})}
Y={round({{h}*{$3/100}})}
-if {$4>0}
Rayon_cercle_exterieur={round({{w}*$4/{100}})}
-else
Rayon_cercle_exterieur={round({-{h}*$4/{100}})}
-endif
Rayon_cercle_interieur={round({$Rayon_cercle_exterieur*$5/100})}
Angle_inclinaison=$6
Pourcentage_excentricite=$7
Angle_excentricite=$8
R_Contours=$9
V_Contours=$10
B_Contours=$11
A_Contours=$12
Affichage=$13
Recursions_Sierpinski=$14
R_Centre=$15
V_Centre=$16
B_Centre=$17
A_Centre=$18
R_Centreb=$19
V_Centreb=$20
B_Centreb=$21
A_Centreb=$22
R_Sommet=$23
V_Sommet=$24
B_Sommet=$25
A_Sommet=$26
R_Sommetb=$27
V_Sommetb=$28
B_Sommetb=$29
A_Sommetb=$30
R_Cercle=$31
V_Cercle=$32
B_Cercle=$33
A_Cercle=$34
Couleurs_aleatoires=$35
Inversions=$36
Flou=$37
Dilatation=$38
Deformation=$39
Bruit=$40
Ombre=$41
X_Ombre=$42
Y_Ombre=$43
Smoothness_Ombre=$44
Curvature_Ombre=$45
Compensation_Decalage_Ombre_X=$46
Compensation_Decalage_Ombre_Y=$47
Canal_Alpha=$48
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_Boucle=0
Angle=0
Increment_angle={360/$Nombre_de_sommets}
Longueur_excentricite={$Pourcentage_excentricite/100*{$Rayon_cercle_exterieur-$Rayon_cercle_interieur}}
Decalage_X_excentricite={round({$Longueur_excentricite*{cos(pi/180*$Angle_excentricite)}})}
Decalage_Y_excentricite={round({$Longueur_excentricite*{sin(pi/180*$Angle_excentricite)}})}
X_centre_cercle_interieur={$X+$Decalage_X_excentricite}
Y_centre_cercle_interieur={$Y+$Decalage_Y_excentricite}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
#Couleurs alatoires
-if {$Couleurs_aleatoires==1}
R_Centre={round(u)*255}
V_Centre={round(u)*255}
B_Centre={round(u)*255}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Sommet={round(u)*255}
V_Sommet={round(u)*255}
B_Sommet={round(u)*255}
R_Sommetb={round(u)*255}
V_Sommetb={round(u)*255}
B_Sommetb={round(u)*255}
R_Sommetb_Deux={round(u)*255}
V_Sommetb_Deux={round(u)*255}
B_Sommetb_Deux={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
-if {$Affichage>3}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {{$Affichage==2}||{$Affichage==3}||{$Affichage==6}||{$Affichage==7}}
-ellipse[-1] $X,$Y,$Rayon_cercle_exterieur,$Rayon_cercle_exterieur,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-endif
-repeat $Nombre_de_sommets
-if {$Couleurs_aleatoires==1}
R_Centre={round(u)*255}
V_Centre={round(u)*255}
B_Centre={round(u)*255}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Sommet={round(u)*255}
V_Sommet={round(u)*255}
B_Sommet={round(u)*255}
R_Sommetb={round(u)*255}
V_Sommetb={round(u)*255}
B_Sommetb={round(u)*255}
R_Sommetb_Deux={round(u)*255}
V_Sommetb_Deux={round(u)*255}
B_Sommetb_Deux={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
Nb_Boucle={$Nb_Boucle+1}
X_point_exterieur={$X+{round({$Rayon_cercle_exterieur*{cos({pi/180*{$Angle+$Angle_inclinaison}})}})}}
Y_point_exterieur={$Y+{round({$Rayon_cercle_exterieur*{sin({pi/180*{$Angle+$Angle_inclinaison}})}})}}
X_point_interieur_a={$X_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Angle+$Angle_inclinaison+{180/$Nombre_de_sommets}}})}})}}
Y_point_interieur_a={$Y_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Angle+$Angle_inclinaison+{180/$Nombre_de_sommets}}})}})}}
X_point_interieur_b={$X_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Angle+$Angle_inclinaison-{180/$Nombre_de_sommets}}})}})}}
Y_point_interieur_b={$Y_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Angle+$Angle_inclinaison-{180/$Nombre_de_sommets}}})}})}}
-if {{($Nombre_de_sommets%2)}==0}
-if {{($Nb_Boucle%2)}==0}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-endif
-if {{($Affichage%2)}==1}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-endif
-endif
-else
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommetb,$V_Sommetb,$B_Sommetb,$A_Sommetb
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommetb,$V_Sommetb,$B_Sommetb,$A_Sommetb
-endif
-if {{($Affichage%2)}==1}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-endif
-endif
-endif
-else
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
-endif
-if {{($Affichage%2)}==1}
-if {$Recursions_Sierpinski==0}
-polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-endif
-endif
-endif
-if {$Affichage>3}
-polygon[-2] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Angle={$Increment_angle*$Nb_Boucle}
-done
-if {$Affichage>5}
-ellipse[-2] $X,$Y,$Rayon_cercle_exterieur,$Rayon_cercle_exterieur,0,1,0xFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Affichage>3}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
samj_Etoile_De_Pompei_Triangles_Sierpinski :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Angle_inclinaison=$3
-if {$4>0}
Dimension={round({{w}*$4/{400*{2^0.5}}})}
-else
Dimension={round({-{h}*$4/{400*{2^0.5}}})}
-endif
R_Cadre=$5
V_Cadre=$6
B_Cadre=$7
A_Cadre=$8
Afficher_Cadre=$9
Recursions_Sierpinski=$10
R_Centre=$11
V_Centre=$12
B_Centre=$13
A_Centre=$14
R_Centreb=$15
V_Centreb=$16
B_Centreb=$17
A_Centreb=$18
R_Triangle=$19
V_Triangle=$20
B_Triangle=$21
A_Triangle=$22
R_Demi_Losange=$23
V_Demi_Losange=$24
B_Demi_Losange=$25
A_Demi_Losange=$26
R_Demi_Losange_Deux=$27
V_Demi_Losange_Deux=$28
B_Demi_Losange_Deux=$29
A_Demi_Losange_Deux=$30
R_Cercle=$31
V_Cercle=$32
B_Cercle=$33
A_Cercle=$34
Couleurs_aleatoires=$35
Inversions=$36
Flou=$37
Dilatation=$38
Deformation=$39
Bruit=$40
Ombre=$41
X_Ombre=$42
Y_Ombre=$43
Smoothness_Ombre=$44
Curvature_Ombre=$45
Compensation_Decalage_Ombre_X=$46
Compensation_Decalage_Ombre_Y=$47
Canal_Alpha=$48
Largeur_Origine={w}
Hauteur_Origine={h}
Rayon_Cercle_1=$Dimension
Rayon_Cercle_2={{{2*$Dimension*$Dimension}-{2*$Dimension*$Dimension*{cos(pi/180*150)}}}^0.5}
Rayon_Cercle_3={$Dimension+{$Dimension*{3^0.5}}}
#angles degrs
dephasage_point1_carre={0+$Angle_inclinaison}
dephasage_point2_carre={60+$Angle_inclinaison}
dephasage_point3_carre={45+$Angle_inclinaison}
dephasage_point4_carre={15+$Angle_inclinaison}
dephasage_point5_triangle={30+$Angle_inclinaison}
Nb_Boucle=0
H_X_a=0
H_Y_a=0
H_X_b=0
H_Y_b=0
H_X_c=0
H_Y_c=0
H_X_d=0
H_Y_d=0
H_X_e=0
H_Y_e=0
H_X_f=0
H_Y_f=0
xca=0
yca=0
Angle_C=0
xcb=0
ycb=0
xcc=0
ycc=0
xcd=0
ycd=0
xce=0
yce=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
#Couleurs alatoires
-if {$Couleurs_aleatoires==1}
R_Centre={round(u)*255}
V_Centre={round(u)*255}
B_Centre={round(u)*255}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Triangle={round(u)*255}
V_Triangle={round(u)*255}
B_Triangle={round(u)*255}
R_Demi_Losange={round(u)*255}
V_Demi_Losange={round(u)*255}
B_Demi_Losange={round(u)*255}
R_Demi_Losange_Deux={round(u)*255}
V_Demi_Losange_Deux={round(u)*255}
B_Demi_Losange_Deux={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
-if {$Afficher_Cadre>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Afficher_Cadre==2}
-ellipse[-2] $X,$Y,$Rayon_Cercle_3,$Rayon_Cercle_3,0,1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-ellipse[-1] $X,$Y,$Rayon_Cercle_3,$Rayon_Cercle_3,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-endif
#-point[-1] 30,30,0,1,255,255,0,255
-repeat 6
Nb_Boucle={$Nb_Boucle+1}
-if {$Couleurs_aleatoires==1}
R_Centreb={round(u)*255}
V_Centreb={round(u)*255}
B_Centreb={round(u)*255}
R_Triangle={round(u)*255}
V_Triangle={round(u)*255}
B_Triangle={round(u)*255}
R_Demi_Losange_Deux={round(u)*255}
V_Demi_Losange_Deux={round(u)*255}
B_Demi_Losange_Deux={round(u)*255}
-endif
point1_X={round({$Rayon_Cercle_1*{cos(pi/180*$dephasage_point1_carre)}})}
point1_Y={round({$Rayon_Cercle_1*{sin(pi/180*$dephasage_point1_carre)}})}
point2_X={round({$Rayon_Cercle_1*{cos(pi/180*{$dephasage_point2_carre})}})}
point2_Y={round({$Rayon_Cercle_1*{sin(pi/180*{$dephasage_point2_carre})}})}
point3_X={round({$Rayon_Cercle_2*{cos(pi/180*{$dephasage_point3_carre})}})}
point3_Y={round({$Rayon_Cercle_2*{sin(pi/180*{$dephasage_point3_carre})}})}
point4_X={round({$Rayon_Cercle_2*{cos(pi/180*{$dephasage_point4_carre})}})}
point4_Y={round({$Rayon_Cercle_2*{sin(pi/180*{$dephasage_point4_carre})}})}
-if {$Nb_Boucle==1}
H_X_a={$X+$point1_X}
H_Y_a={$Y+$point1_Y}
-elif {$Nb_Boucle==2}
H_X_b={$X+$point1_X}
H_Y_b={$Y+$point1_Y}
-elif {$Nb_Boucle==3}
H_X_c={$X+$point1_X}
H_Y_c={$Y+$point1_Y}
-elif {$Nb_Boucle==4}
H_X_d={$X+$point1_X}
H_Y_d={$Y+$point1_Y}
-elif {$Nb_Boucle==5}
H_X_e={$X+$point1_X}
H_Y_e={$Y+$point1_Y}
-elif {$Nb_Boucle==6}
H_X_f={$X+$point1_X}
H_Y_f={$Y+$point1_Y}
-endif
point5_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point5_triangle})}})}
point5_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point5_triangle})}})}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point5_X},{$Y+$point5_Y},$R_Triangle,$V_Triangle,$B_Triangle,$A_Triangle
point6_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point2_carre})}})}
point6_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point2_carre})}})}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point6_X},{$Y+$point6_Y},$R_Demi_Losange_Deux,$V_Demi_Losange_Deux,$B_Demi_Losange_Deux,$A_Demi_Losange_Deux
point7_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point1_carre})}})}
point7_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point1_carre})}})}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point1_X},{$Y+$point1_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point7_X},{$Y+$point7_Y},$R_Demi_Losange,$V_Demi_Losange,$B_Demi_Losange,$A_Demi_Losange
-if {$Afficher_Cadre>0}
-polygon[-2] 3,{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point5_X},{$Y+$point5_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-polygon[-2] 3,{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point6_X},{$Y+$point6_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-polygon[-2] 3,{$X+$point1_X},{$Y+$point1_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point7_X},{$Y+$point7_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-endif
-if {$Afficher_Cadre==2}
-polygon[-2] 4,{$X+$point1_X},{$Y+$point1_Y},{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-endif
dephasage_point1_carre={$dephasage_point1_carre+60}
dephasage_point2_carre={$dephasage_point2_carre+60}
dephasage_point3_carre={$dephasage_point3_carre+60}
dephasage_point4_carre={$dephasage_point4_carre+60}
dephasage_point5_triangle={$dephasage_point5_triangle+60}
-done
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_a,$H_Y_a,$H_X_b,$H_Y_b,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_b,$H_Y_b,$H_X_c,$H_Y_c,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_c,$H_Y_c,$H_X_d,$H_Y_d,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_d,$H_Y_d,$H_X_e,$H_Y_e,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_e,$H_Y_e,$H_X_f,$H_Y_f,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_f,$H_Y_f,$H_X_a,$H_Y_a,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
-if {$Afficher_Cadre==0}
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-elif {$Afficher_Cadre==1}
-polygon[-2] 6,$H_X_a,$H_Y_a,$H_X_b,$H_Y_b,$H_X_c,$H_Y_c,$H_X_d,$H_Y_d,$H_X_e,$H_Y_e,$H_X_f,$H_Y_f,1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
-endif
-if {$Afficher_Cadre>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
samj_Flocon_De_Neige :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Nb_Branches=$3
-if {$4>0}
Rayon_cercle_exterieur_flocon={round({{w}*$4/{100}})}
-else
Rayon_cercle_exterieur_flocon={round({-{h}*$4/{100}})}
-endif
Rayon_Cercle_Milieu={round($Rayon_cercle_exterieur_flocon*2)}
Rayon_Cercle_Milieu={round($Rayon_cercle_exterieur_flocon*$5/100)}
Angle_inclinaison=$6
Recursions_Contours=$7
R_Contours=$8
V_Contours=$9
B_Contours=$10
Opacity_Contours=$11
Affichage_Contours=$12
Recursions_Flocon=$13
R_F=$14
V_F=$15
B_F=$16
Opacity_Flocon=$17
Type_Flocon=$18
Couleurs_aleatoires=$19
Inversions=$20
Flou=$21
Dilatation=$22
Deformation=$23
Bruit=$24
Ombre=$25
X_Ombre=$26
Y_Ombre=$27
Smoothness_Ombre=$28
Curvature_Ombre=$29
Compensation_Decalage_Ombre_X=$30
Compensation_Decalage_Ombre_Y=$31
Canal_Alpha=$32
Largeur_Origine={w}
Hauteur_Origine={h}
Angle_Theta={360/$Nb_Branches}
Nb_boucles=0
X_ext=0
Y_ext=0
X_exta=0
Y_exta=0
X_extb=0
Y_extb=0
X_mil=0
Y_mil=0
Angle=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-repeat $Nb_Branches
Angle={$Nb_boucles*$Angle_Theta}
X_ext={$X+{$Rayon_cercle_exterieur_flocon*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
Y_ext={$Y+{$Rayon_cercle_exterieur_flocon*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
X_exta={$X+{$Rayon_cercle_exterieur_flocon/3*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
Y_exta={$Y+{$Rayon_cercle_exterieur_flocon/3*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
X_extb={$X+{$Rayon_cercle_exterieur_flocon/3*2*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
Y_extb={$Y+{$Rayon_cercle_exterieur_flocon/3*2*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
X_mil={$X+{$Rayon_Cercle_Milieu*{cos({pi/180*{$Angle+$Angle_inclinaison+{$Angle_Theta/2}}})}}}
Y_mil={$Y+{$Rayon_Cercle_Milieu*{sin({pi/180*{$Angle+$Angle_inclinaison+{$Angle_Theta/2}}})}}}
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_F={round(u)*255}
V_F={round(u)*255}
B_F={round(u)*255}
-endif
-if {$Type_Flocon==0}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==1}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==2}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==3}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==4}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Flocon,$R_F,$V_F,$B_F
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-elif {$Type_Flocon==5}
-if {$Affichage_Contours<2}
-samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
-endif
-if {$Affichage_Contours>0}
-samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
-endif
-endif
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
samj_Linear_Gradient_CIE_Lab :
Type_Degrade=$1
Swap_colors=$2
Ra=$3
Ga=$4
Ba=$5
Aa=$6
Rb=$7
Gb=$8
Bb=$9
Ab=$10
-if {$Swap_colors==1}
Ra=$7
Ga=$8
Ba=$9
Aa=$10
Rb=$3
Gb=$4
Bb=$5
Ab=$6
-endif
# Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
# couleur a Linear RGB
nt_Ra={$Ra/255}
nt_Ga={$Ga/255}
nt_Ba={$Ba/255}
-if {$nt_Ra>0.04045}
nt_Ra={{{$nt_Ra+0.055}/1.055}^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={{{$nt_Ga+0.055}/1.055}^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={{{$nt_Ba+0.055}/1.055}^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xa
Yca=$Ya
Zca=$Za
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={$nt_Xa^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={$nt_Ya^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={$nt_Za^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_La={{116*$nt_Ya}-16}
CIE_aa={500*{$nt_Xa-$nt_Ya}}
CIE_ba={200*{$nt_Ya-$nt_Za}}
# couleur b Linear RGB
nt_Ra={$Rb/255}
nt_Ga={$Gb/255}
nt_Ba={$Bb/255}
-if {$nt_Ra>0.04045}
nt_Ra={{{$nt_Ra+0.055}/1.055}^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={{{$nt_Ga+0.055}/1.055}^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={{{$nt_Ba+0.055}/1.055}^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xb
Yca=$Yb
Zca=$Zb
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={$nt_Xa^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={$nt_Ya^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={$nt_Za^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_Lb={{116*$nt_Ya}-16}
CIE_ab={500*{$nt_Xa-$nt_Ya}}
CIE_bb={200*{$nt_Ya-$nt_Za}}
######
{w},{h},1,4
-rm[-2]
Nb_Boucles=0
Decalage_L=0
Decalage_a=0
Decalage_b=0
-if {$Type_Degrade==0}
Dimensions={w}
Inc_L={{$CIE_La-$CIE_Lb}/{w}}
Inc_a={{$CIE_aa-$CIE_ab}/{w}}
Inc_b={{$CIE_ba-$CIE_bb}/{w}}
Inc_Alpha={{$Ab-$Aa}/{w}}
-elif {$Type_Degrade==1}
Dimensions={h}
Inc_L={{$CIE_La-$CIE_Lb}/{h}}
Inc_a={{$CIE_aa-$CIE_ab}/{h}}
Inc_b={{$CIE_ba-$CIE_bb}/{h}}
Inc_Alpha={{$Ab-$Aa}/{h}}
-endif
-repeat $Dimensions
Aa={$Aa+$Inc_Alpha}
-if {$Aa>255} Aa=255 -endif
-if {$Aa<0} Aa=0 -endif
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{$nt_Yca^3}>0.008856}
nt_Yca={$nt_Yca^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{$nt_Xca^3}>0.008856}
nt_Xca={$nt_Xca^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{$nt_Zca^3}>0.008856}
nt_Zca={$nt_Zca^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{$nt_R^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{$nt_G^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{$nt_B^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {$Type_Degrade==0}
-line[-1] $Nb_Boucles,0,$Nb_Boucles,{{h}-1},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==1}
-line[-1] 0,$Nb_Boucles,{{w}-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
samj_Shape_Linear_Gradient_CIE_Lab :
Xo={round({{w}/100*$1})}
Yo={round({{h}/100*$2})}
Xf={round({{w}/100*$3})}
Yf={round({{h}/100*$4})}
Type_Degrade=$5
Swap_colors=$6
Ra=$7
Ga=$8
Ba=$9
Aa=$10
Rb=$11
Gb=$12
Bb=$13
Ab=$14
Background=$15
Rback=$16
Gback=$17
Bback=$18
Aback=$19
Examples=$20
-if {$Swap_colors==1}
Ra=$11
Ga=$12
Ba=$13
Aa=$14
Rb=$7
Gb=$8
Bb=$9
Ab=$10
-endif
-if {$Xo>$Xf}
Xo=$3
Xf=$1
-elif {$Xo==$Xf}
Xo={$Xf-1}
-endif
-if {$Yo>$Yf}
Yo=$4
Yf=$2
-elif {$Yo==$Yf}
Yo={$Yf-1}
-endif
-if {{$Type_Degrade==4}||{$Type_Degrade==5}}
Xo={round({{w}/100*$1})}
Yo={round({{h}/100*$2})}
Xf={round({{w}/100*$3})}
Yf={round({{h}/100*$4})}
-endif
-if {$Examples==1}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=0
-elif {$Examples==2}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=1
-elif {$Examples==3}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=2
-elif {$Examples==4}
Xo={round({{w}*0.1})}
Yo={round({{h}*0.1})}
Xf={round({{w}*0.9})}
Yf={round({{h}*0.9})}
Type_Degrade=3
-elif {$Examples==5}
Xo={round({{w}*0.4})}
Yo={round({{h}*0.4})}
Xf={round({{w}*0.5})}
Yf={round({{h}*0.5})}
Type_Degrade=4
-elif {$Examples==6}
Xo={round({{w}*0.4})}
Yo={round({{h}*0.4})}
Xf={round({{w}*0.5})}
Yf={round({{h}*0.5})}
Type_Degrade=5
-elif {$Examples==7}
Xo={round({{w}*0.71})}
Yo={round({{h}*0.71})}
Xf={w}
Yf={h}
Type_Degrade=5
-endif
# Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
# Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
# couleur a Linear RGB
nt_Ra={$Ra/255}
nt_Ga={$Ga/255}
nt_Ba={$Ba/255}
-if {$nt_Ra>0.04045}
nt_Ra={{{$nt_Ra+0.055}/1.055}^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={{{$nt_Ga+0.055}/1.055}^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={{{$nt_Ba+0.055}/1.055}^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xa
Yca=$Ya
Zca=$Za
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={$nt_Xa^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={$nt_Ya^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={$nt_Za^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_La={{116*$nt_Ya}-16}
CIE_aa={500*{$nt_Xa-$nt_Ya}}
CIE_ba={200*{$nt_Ya-$nt_Za}}
# couleur b Linear RGB
nt_Ra={$Rb/255}
nt_Ga={$Gb/255}
nt_Ba={$Bb/255}
-if {$nt_Ra>0.04045}
nt_Ra={{{$nt_Ra+0.055}/1.055}^2.4}
-else
nt_Ra={$nt_Ra/12.92}
-endif
-if {$nt_Ga>0.04045}
nt_Ga={{{$nt_Ga+0.055}/1.055}^2.4}
-else
nt_Ga={$nt_Ga/12.92}
-endif
-if {$nt_Ba>0.04045}
nt_Ba={{{$nt_Ba+0.055}/1.055}^2.4}
-else
nt_Ba={$nt_Ba/12.92}
-endif
nt_Ra={$nt_Ra*100}
nt_Ga={$nt_Ga*100}
nt_Ba={$nt_Ba*100}
#Observateur. = 2, Illuminant = D65 sRGB
Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
Xca=$Xb
Yca=$Yb
Zca=$Zb
ref_Xa=95.047
ref_Ya=100.000
ref_Za=108.883
nt_Xa={$Xca/$ref_Xa}
nt_Ya={$Yca/$ref_Ya}
nt_Za={$Zca/$ref_Za}
-if {$nt_Xa>0.008856}
nt_Xa={$nt_Xa^{1/3}}
-else
nt_Xa={{7.787*$nt_Xa}+{16/116}}
-endif
-if {$nt_Ya>0.008856}
nt_Ya={$nt_Ya^{1/3}}
-else
nt_Ya={{7.787*$nt_Ya}+{16/116}}
-endif
-if {$nt_Za>0.008856}
nt_Za={$nt_Za^{1/3}}
-else
nt_Za={{7.787*$nt_Za}+{16/116}}
-endif
CIE_Lb={{116*$nt_Ya}-16}
CIE_ab={500*{$nt_Xa-$nt_Ya}}
CIE_bb={200*{$nt_Ya-$nt_Za}}
######
-if {$Background==1}
{w},{h},1,4
-rm[-2]
-elif {$Background==2}
{w},{h},1,4
-fill_color[-1] $Rback,$Gback,$Bback,$Aback
-rm[-2]
-endif
Nb_Boucles=0
-if {$Type_Degrade==0}
Dimensions={$Xf-$Xo}
-elif {$Type_Degrade==1}
Dimensions={$Yf-$Yo}
-elif {$Type_Degrade==2}
-if {{$Xf-$Xo}>{$Yf-$Yo}}
Dimensions={round({{$Yf-$Yo+1}/2})}
-else
Dimensions={round({{$Xf-$Xo+1}/2})}
-endif
-elif {$Type_Degrade==3}
-if {{$Xf-$Xo}>{$Yf-$Yo}}
Dimensions={round({{$Xf-$Xo+1}/2})}
-else
Dimensions={round({{$Yf-$Yo+1}/2})}
-endif
-elif {$Type_Degrade==4}
Dimensions=$Xo
-elif {$Type_Degrade==5}
Dimensions={$Xo+$Yo}
-endif
Inc_L={{$CIE_La-$CIE_Lb}/$Dimensions}
Inc_a={{$CIE_aa-$CIE_ab}/$Dimensions}
Inc_b={{$CIE_ba-$CIE_bb}/$Dimensions}
Inc_Alpha={{$Ab-$Aa}/$Dimensions}
Decalage_L=0
Decalage_a=0
Decalage_b=0
-repeat $Dimensions
Aa={$Aa+$Inc_Alpha}
-if {$Aa>255} Aa=255 -endif
-if {$Aa<0} Aa=0 -endif
CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
-if {$CIE_Lca>100} CIE_Lca=100 -endif
-if {$CIE_Lca<0} CIE_Lca=0 -endif
-if {$CIE_aca>127} CIE_aca=127 -endif
-if {$CIE_aca<-128} CIE_aca=-128 -endif
-if {$CIE_bca>127} CIE_bca=127 -endif
-if {$CIE_bca<-128} CIE_bca=-128 -endif
nt_Yca={{$CIE_Lca+16}/116}
nt_Xca={$CIE_aca/500+$nt_Yca}
nt_Zca={$nt_Yca-$CIE_bca/200}
-if {{$nt_Yca^3}>0.008856}
nt_Yca={$nt_Yca^3}
-else
nt_Yca={{$nt_Yca-16/116}/7.787}
-endif
-if {{$nt_Xca^3}>0.008856}
nt_Xca={$nt_Xca^3}
-else
nt_Xca={{$nt_Xca-16/116}/7.787}
-endif
-if {{$nt_Zca^3}>0.008856}
nt_Zca={$nt_Zca^3}
-else
nt_Zca={{$nt_Zca-16/116}/7.787}
-endif
ref_Xca=95.047
ref_Yca=100.000
ref_Zca=108.883
Xca={$ref_Xca*$nt_Xca}
Yca={$ref_Yca*$nt_Yca}
Zca={$ref_Zca*$nt_Zca}
vcXa=$Xca
vcYa=$Yca
vcZa=$Zca
nt_X={$vcXa/100}
nt_Y={$vcYa/100}
nt_Z={$vcZa/100}
nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
-if {$nt_R>0.0031308}
nt_R={1.055*{$nt_R^{1/2.4}}-0.055}
-else
nt_R={12.92*$nt_R}
-endif
-if {$nt_G>0.0031308}
nt_G={1.055*{$nt_G^{1/2.4}}-0.055}
-else
nt_G={12.92*$nt_G}
-endif
-if {$nt_B>0.0031308}
nt_B={1.055*{$nt_B^{1/2.4}}-0.055}
-else
nt_B={12.92*$nt_B}
-endif
Rconv={$nt_R*255}
Gconv={$nt_G*255}
Bconv={$nt_B*255}
-if {$Rconv>255} Rconv=255 -endif
-if {$Rconv<0} Rconv=0 -endif
-if {$Gconv>255} Gconv=255 -endif
-if {$Gconv<0} Gconv=0 -endif
-if {$Bconv>255} Bconv=255 -endif
-if {$Bconv<0} Bconv=0 -endif
-if {$Type_Degrade==0}
-line[-1] {$Xo+$Nb_Boucles},$Yo,{$Xo+$Nb_Boucles},$Yf,1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==1}
-line[-1] $Xo,{$Yo+$Nb_Boucles},$Xf,{$Yo+$Nb_Boucles},1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==2}
-polygon[-1] 4,{$Xo+$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yf-$Nb_Boucles},{$Xo+$Nb_Boucles},{$Yf-$Nb_Boucles},1,0xFFFFFFFF,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==3}
-polygon[-1] 4,{$Xo+$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yf-$Nb_Boucles},{$Xo+$Nb_Boucles},{$Yf-$Nb_Boucles},1,0xFFFFFFFF,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==4}
-ellipse[-1] $Xf,$Yf,{$Dimensions-$Nb_Boucles},{$Dimensions-$Nb_Boucles},0,1,$Rconv,$Gconv,$Bconv,$Aa
-elif {$Type_Degrade==5}
-ellipse[-1] $Xf,$Yf,{$Dimensions-$Nb_Boucles},{$Dimensions-$Nb_Boucles},0,1,$Rconv,$Gconv,$Bconv,$Aa
-endif
Nb_Boucles={$Nb_Boucles+1}
-done
Harmonograph_samj :
centre_origine_X={$1/100*w}
centre_origine_Y={$2/100*h}
R_Couleur_Stylo=$3
V_Couleur_Stylo=$4
B_Couleur_Stylo=$5
A_Couleur_Stylo=$6
Variation_de_couleur=$7
Dilate_Stylo=$8
Iterations=$9
Multiplier_Iterations=$10
Increment_temps=$11
-if {$12>0}
Amplitude1={{w}*$12/{1000}}
-else
Amplitude1={-{h}*$12/{1000}}
-endif
-if {$13>0}
Amplitude2={{w}*$13/{1000}}
-else
Amplitude2={-{h}*$13/{1000}}
-endif
-if {$14>0}
Amplitude3={{w}*$14/{1000}}
-else
Amplitude3={-{h}*$14/{1000}}
-endif
-if {$15>0}
Amplitude4={{w}*$15/{1000}}
-else
Amplitude4={-{h}*$15/{1000}}
-endif
Frequence1=$16
Frequence2=$17
Frequence3=$18
Frequence4=$19
Phase1=$20
Phase2=$21
Phase3=$22
Phase4=$23
Amort1=$24
Amort2=$25
Amort3=$26
Amort4=$27
Flou_Harmonograph=$28
Spread_Harmonograph=$29
Deform_Harmonograph=$30
blend=$31
opacite=$32
Revert_layers=0
-to_rgba
{w},{h},1,4
Nb_Boucle=1
temps=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
R_Couleur_origine=$R_Couleur_Stylo
V_Couleur_origine=$V_Couleur_Stylo
B_Couleur_origine=$B_Couleur_Stylo
A_Couleur_origine=$A_Couleur_Stylo
Increment_temps={$Increment_temps/10000}
Phase1={$Phase1/180*{pi}}
Phase2={$Phase2/180*{pi}}
Phase3={$Phase3/180*{pi}}
Phase4={$Phase4/180*{pi}}
-if {$Multiplier_Iterations>0}
Iterations={$Iterations*$Multiplier_Iterations*5}
-endif
-repeat $Iterations
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
Nouveau_point_X={$centre_origine_X+{{$Amplitude1*{sin({{$Frequence1*$temps}+$Phase1})}*{exp({-$Amort1*$temps})}}+{$Amplitude2*{sin({{$Frequence2*$temps}+$Phase2})}*{exp({-$Amort2*$temps})}}}}
Nouveau_point_Y={$centre_origine_Y+{{$Amplitude3*{sin({{$Frequence3*$temps}+$Phase3})}*{exp({-$Amort3*$temps})}}+{$Amplitude4*{sin({{$Frequence4*$temps}+$Phase4})}*{exp({-$Amort4*$temps})}}}}
-if {$Nb_Boucle>1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
temps={$temps+$Increment_temps}
Nb_Boucle={$Nb_Boucle+1}
-done
-if {$Dilate_Stylo>0} -dilate_circ[-1] $Dilate_Stylo -endif
-if {$Flou_Harmonograph>0} -blur[-1] $Flou_Harmonograph,0 -endif
-if {$Spread_Harmonograph>1} -spread[-1] $Spread_Harmonograph -endif
-if {$Deform_Harmonograph>0} -deform[-1] $Deform_Harmonograph -endif
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
#
#-text_outline[0] $Amplitude1,10,10,64,1,1,255,255,255
samj_Hawaiian_Earring :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Rayon_Cercle_Exterieur={round({{{w}+{h}}*$3/200})}
Nb_Circles=$4
Type_n=$5
Angle_inclinaison=$6
R_Contours=$7
V_Contours=$8
B_Contours=$9
A_Contours=$10
Affichage_Contours=$11
R_a=$12
V_a=$13
B_a=$14
A_a=$15
R_b=$16
V_b=$17
B_b=$18
A_b=$19
Couleurs_aleatoires=$20
Inversions=$21
Flou=$22
Dilatation=$23
Deformation=$24
Bruit=$25
Ombre=$26
X_Ombre=$27
Y_Ombre=$28
Smoothness_Ombre=$29
Curvature_Ombre=$30
Compensation_Decalage_Ombre_X=$31
Compensation_Decalage_Ombre_Y=$32
Canal_Alpha=$33
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
X_Cercle_A_Imprimer=$X
Y_Cercle_A_Imprimer=$Y
Rayon_Centre_Cercle_A_Imprimer=0
Rayon_Cercle_A_Imprimer=$Rayon_Cercle_Exterieur
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours==1}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-repeat $Nb_Circles
Nb_boucles={$Nb_boucles+1}
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
-endif
-if {{($Nb_boucles%2)}==0}
-ellipse[-1] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,$R_a,$V_a,$B_a,$A_a
-else
-ellipse[-1] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,$R_b,$V_b,$B_b,$A_b
-endif
-if {$Affichage_Contours==1}
-ellipse[-2] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Type_n==0}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_Exterieur/{$Nb_boucles+1}}
-elif {$Type_n==1}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.1}}
-elif {$Type_n==2}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.2}}
-elif {$Type_n==3}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.3}}
-elif {$Type_n==4}
Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*{?(0.1,0.3)}}}
-endif
Rayon_Centre_Cercle_A_Imprimer={$Rayon_Cercle_Exterieur-$Rayon_Cercle_A_Imprimer}
X_Cercle_A_Imprimer={$X-{$Rayon_Centre_Cercle_A_Imprimer*{cos(pi/180*$Angle_inclinaison)}}}
Y_Cercle_A_Imprimer={$Y-{$Rayon_Centre_Cercle_A_Imprimer*{sin(pi/180*$Angle_inclinaison)}}}
-done
-if {$Affichage_Contours==1}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
samj_en_Hawaiian_Earring :
-samj_Hawaiian_Earring $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33
Traits_Strokes_samj_en:
-Traits_Strokes_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22
samj_en_Lignes_Epaisseur_Variable :
-samj_Lignes_Epaisseur_Variable $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25
#
#
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>404 Not Found</title>
</head><body>
<h1>Not Found</h1>
<p>The requested URL /include/zonder.gmic was not found on this server.</p>
</body></html>
samj_Lignes_Epaisseur_Variable :
Motif_Sprite=$1
Resolution_Largeur=$2
Trait_Largeur=$3
R_fond=$4
V_fond=$5
B_fond=$6
A_fond=$7
R_a=$8
V_a=$9
B_a=$10
A_a=$11
Inverser_Fond_Trait=$12
Couleurs_aleatoires=$13
Resize_Image=$14
Antialiasing=$15
R_Deblur=$16
Dilatation=$17
Deformation=$18
Bruit=$19
Ombre=$20
X_Ombre=$21
Y_Ombre=$22
Smoothness_Ombre=$23
Curvature_Ombre=$24
Canal_Alpha=$25
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Nb_boucles_motif=0
Origine_Trait=0
-if {$Inverser_Fond_Trait==0}
R_F=$R_fond
V_F=$V_fond
B_F=$B_fond
A_F=$A_fond
R_M=$R_a
V_M=$V_a
B_M=$B_a
A_M=$A_a
-else
R_F=$R_a
V_F=$V_a
B_F=$B_a
A_F=$A_a
R_M=$R_fond
V_M=$V_fond
B_M=$B_fond
A_M=$A_fond
-endif
Largeur_Sprite={{7*2}+{7*$Trait_Largeur}}
Hauteur_Sprite=$Largeur_Sprite
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-resize[-1] $Resolution_Largeur,{round({$Hauteur_Origine/$Largeur_Origine*$Resolution_Largeur})}
-repeat 7
Nb_boucles={$Nb_boucles+1}
-if {$Nb_boucles==1}
-if {$Couleurs_aleatoires==1}
R_F={round(u)*255}
V_F={round(u)*255}
B_F={round(u)*255}
-endif
$Largeur_Sprite,$Hauteur_Sprite,1,4
-fill_color[-1] $R_F,$V_F,$B_F,$A_F
-endif
-if {$Couleurs_aleatoires==1}
R_F={round(u)*255}
V_F={round(u)*255}
B_F={round(u)*255}
R_M={round(u)*255}
V_M={round(u)*255}
B_M={round(u)*255}
-endif
$Largeur_Sprite,$Hauteur_Sprite,1,4
-fill_color[-1] $R_F,$V_F,$B_F,$A_F
Nb_boucles_motif=0
-if {{$Motif_Sprite==0}||{$Motif_Sprite==1}}
Origine_Trait={round({{$Largeur_Sprite-{$Trait_Largeur*$Nb_boucles}}/2})}
-repeat {$Trait_Largeur*$Nb_boucles}
-line[-1] {$Origine_Trait+$Nb_boucles_motif},0,{$Origine_Trait+$Nb_boucles_motif},{$Hauteur_Sprite-1},1,$R_M,$V_M,$B_M,$A_M
Nb_boucles_motif={$Nb_boucles_motif+1}
-done
-endif
-done
-if {$Motif_Sprite==1}
-rotate[-1,-2,-3,-4,-5,-6,-7,-8] 90,0,0
-endif
-map_sprites[-1,-2,-3,-4,-5,-6,-7,-8,-9] 8,0
-if {$Resize_Image==1}
-resize[-1] $Largeur_Origine,$Hauteur_Origine
-endif
-if {$Antialiasing>0} -apply_channels[-1] "-smooth "$Antialiasing",0.7,0.3,0.6,5,5,0",1 -endif
-if {$R_Deblur>0} -apply_channels[-1] "-deblur "$R_Deblur",10,20,0.1,1",1 -endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-endif
samj_Cercles_Tangents_Dans_Cercle :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
-if {$3>0}
Rayon_Cercle_Exterieur={round({{w}*$3/{100}})}
-else
Rayon_Cercle_Exterieur={round({-{h}*$3/{100}})}
-endif
Rayon_Premier_Cercle={round({$Rayon_Cercle_Exterieur*$4/100})}
Angle_inclinaison=$5
R_Contours=$6
V_Contours=$7
B_Contours=$8
A_Contours=$9
Affichage_Contours=$10
R_CE=$11
V_CE=$12
B_CE=$13
A_CE=$14
R_PC=$15
V_PC=$16
B_PC=$17
A_PC=$18
R_c=$19
V_c=$20
B_c=$21
A_c=$22
R_d=$23
V_d=$24
B_d=$25
A_d=$26
R_e=$27
V_e=$28
B_e=$29
A_e=$30
R_f=$31
V_f=$32
B_f=$33
A_f=$34
R_g=$35
V_g=$36
B_g=$37
A_g=$38
R_h=$39
V_h=$40
B_h=$41
A_h=$42
R_i=$43
V_i=$44
B_i=$45
A_i=$46
R_j=$47
V_j=$48
B_j=$49
A_j=$50
R_k=$51
V_k=$52
B_k=$53
A_k=$54
Couleurs_aleatoires=$55
Inversions=$56
Flou=$57
Dilatation=$58
Deformation=$59
Bruit=$60
Ombre=$61
X_Ombre=$62
Y_Ombre=$63
Smoothness_Ombre=$64
Curvature_Ombre=$65
Compensation_Decalage_Ombre_X=$66
Compensation_Decalage_Ombre_Y=$67
Canal_Alpha=$68
Largeur_Origine={w}
Hauteur_Origine={h}
X_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{cos({pi/180*$Angle_inclinaison})}}
Y_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{sin({pi/180*$Angle_inclinaison})}}
X_Cc={$Rayon_Premier_Cercle*{cos({pi/180*{$Angle_inclinaison+180}})}}
Y_Cc={$Rayon_Premier_Cercle*{sin({pi/180*{$Angle_inclinaison+180}})}}
R_Cc={$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}
#####
# Rayon Cercle rang 1 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=1
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_d={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Va={$R_Cc+$R_Cercle_d}
Vb={$Rayon_Premier_Cercle+$R_Cercle_d}
# Centres des 2 Cercles rang 1 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cb-$X_Cc}
d_y={$Y_Cb-$Y_Cc}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cc+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cc+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_da={$c_x2+$o_rx}
Y_Cercle_da={$c_y2+$o_ry}
X_Cercle_db={$c_x2-$o_rx}
Y_Cercle_db={$c_y2-$o_ry}
#####
# Rayon Cercle rang 4 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=4
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_e={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_e}
Va={$R_Cercle_d+$R_Cercle_e}
# Centres des 2 Cercles rang 4 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_da}
d_y={$Y_Cc-$Y_Cercle_da}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_da+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_da+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
## comp.  X_Cercle_ea={$c_x2+$o_rx}
## comp.  Y_Cercle_ea={$c_y2+$o_ry}
X_Cercle_eb={$c_x2-$o_rx}
Y_Cercle_eb={$c_y2-$o_ry}
# Centres des 2 Cercles rang 4 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_db}
d_y={$Y_Cc-$Y_Cercle_db}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_db+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_db+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_ea={$c_x2+$o_rx}
Y_Cercle_ea={$c_y2+$o_ry}
## comp.  X_Cercle_eb={$c_x2-$o_rx}
## comp.  Y_Cercle_eb={$c_y2-$o_ry}
#####
# Rayon Cercle rang 9 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=9
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_f={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_f}
Va={$R_Cercle_e+$R_Cercle_f}
# Centres des 2 Cercles rang 9 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_ea}
d_y={$Y_Cc-$Y_Cercle_ea}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_ea+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_ea+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_fa={$c_x2+$o_rx}
Y_Cercle_fa={$c_y2+$o_ry}
## comp.  X_Cercle_fb={$c_x2-$o_rx}
## comp.  Y_Cercle_fb={$c_y2-$o_ry}
# Centres des 2 Cercles rang 9 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_eb}
d_y={$Y_Cc-$Y_Cercle_eb}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_eb+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_eb+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
## comp.  X_Cercle_fa={$c_x2+$o_rx}
## comp.  Y_Cercle_fa={$c_y2+$o_ry}
X_Cercle_fb={$c_x2-$o_rx}
Y_Cercle_fb={$c_y2-$o_ry}
#####
# Rayon Cercle rang 16 Pappus
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=16
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_g={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_g}
Va={$R_Cercle_f+$R_Cercle_g}
# Centres des 2 Cercles rang 16 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_fa}
d_y={$Y_Cc-$Y_Cercle_fa}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_fa+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_fa+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
X_Cercle_ga={$c_x2+$o_rx}
Y_Cercle_ga={$c_y2+$o_ry}
## comp.  X_Cercle_gb={$c_x2-$o_rx}
## comp.  Y_Cercle_gb={$c_y2-$o_ry}
# Centres des 2 Cercles rang 16 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
# d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
d_x={$X_Cc-$X_Cercle_fb}
d_y={$Y_Cc-$Y_Cercle_fb}
# Determine the straight-line distance between the centers. d
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
# Determine the distance from point 0 to point 2. a
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
# Determine the coordinates of point 2. x2 y2
c_x2={$X_Cercle_fb+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_fb+{$d_y*$d_p0_p2/$d_between_centers}}
# Determine the distance from point 2 to either of the intersection points. h
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
# Now determine the offsets of the intersection points from point 2. rx  ry
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
# Determine the absolute intersection points.
## comp.  X_Cercle_ga={$c_x2+$o_rx}
## comp.  Y_Cercle_ga={$c_y2+$o_ry}
X_Cercle_gb={$c_x2-$o_rx}
Y_Cercle_gb={$c_y2-$o_ry}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Couleurs_aleatoires==1}
R_CE={round(u)*255}
V_CE={round(u)*255}
B_CE={round(u)*255}
R_PC={round(u)*255}
V_PC={round(u)*255}
B_PC={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
R_h={round(u)*255}
V_h={round(u)*255}
B_h={round(u)*255}
R_i={round(u)*255}
V_i={round(u)*255}
B_i={round(u)*255}
R_j={round(u)*255}
V_j={round(u)*255}
B_j={round(u)*255}
R_k={round(u)*255}
V_k={round(u)*255}
B_k={round(u)*255}
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cb},{$Y+$Y_Cb},$Rayon_Premier_Cercle,$Rayon_Premier_Cercle,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cc},{$Y+$Y_Cc},$R_Cc,$R_Cc,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_da},{$Y+$Y_Cercle_da},$R_Cercle_d,$R_Cercle_d,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_db},{$Y+$Y_Cercle_db},$R_Cercle_d,$R_Cercle_d,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_ea},{$Y+$Y_Cercle_ea},$R_Cercle_e,$R_Cercle_e,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_eb},{$Y+$Y_Cercle_eb},$R_Cercle_e,$R_Cercle_e,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_fa},{$Y+$Y_Cercle_fa},$R_Cercle_f,$R_Cercle_f,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_fb},{$Y+$Y_Cercle_fb},$R_Cercle_f,$R_Cercle_f,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_ga},{$Y+$Y_Cercle_ga},$R_Cercle_g,$R_Cercle_g,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-1] {$X+$X_Cercle_gb},{$Y+$Y_Cercle_gb},$R_Cercle_g,$R_Cercle_g,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,$R_CE,$V_CE,$B_CE,$A_CE
-ellipse[-1] {$X+$X_Cb},{$Y+$Y_Cb},$Rayon_Premier_Cercle,$Rayon_Premier_Cercle,0,1,$R_PC,$V_PC,$B_PC,$A_PC
-ellipse[-1] {$X+$X_Cc},{$Y+$Y_Cc},$R_Cc,$R_Cc,0,1,$R_c,$V_c,$B_c,$A_c
-ellipse[-1] {$X+$X_Cercle_da},{$Y+$Y_Cercle_da},$R_Cercle_d,$R_Cercle_d,0,1,$R_d,$V_d,$B_d,$A_d
-ellipse[-1] {$X+$X_Cercle_db},{$Y+$Y_Cercle_db},$R_Cercle_d,$R_Cercle_d,0,1,$R_e,$V_e,$B_e,$A_e
-ellipse[-1] {$X+$X_Cercle_ea},{$Y+$Y_Cercle_ea},$R_Cercle_e,$R_Cercle_e,0,1,$R_f,$V_f,$B_f,$A_f
-ellipse[-1] {$X+$X_Cercle_eb},{$Y+$Y_Cercle_eb},$R_Cercle_e,$R_Cercle_e,0,1,$R_g,$V_g,$B_g,$A_g
-ellipse[-1] {$X+$X_Cercle_fa},{$Y+$Y_Cercle_fa},$R_Cercle_f,$R_Cercle_f,0,1,$R_h,$V_h,$B_h,$A_h
-ellipse[-1] {$X+$X_Cercle_fb},{$Y+$Y_Cercle_fb},$R_Cercle_f,$R_Cercle_f,0,1,$R_i,$V_i,$B_i,$A_i
-ellipse[-1] {$X+$X_Cercle_ga},{$Y+$Y_Cercle_ga},$R_Cercle_g,$R_Cercle_g,0,1,$R_j,$V_j,$B_j,$A_j
-ellipse[-1] {$X+$X_Cercle_gb},{$Y+$Y_Cercle_gb},$R_Cercle_g,$R_Cercle_g,0,1,$R_k,$V_k,$B_k,$A_k
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
samj_en_Cercles_Tangents_Dans_Cercle :
-samj_Cercles_Tangents_Dans_Cercle $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$60,$61,$62,$63,$64,$65,$66,$67,$68
Pintograph_samj :
centre_origine_X={$1/100*w}
centre_origine_Y={$2/100*h}
R_Couleur_Stylo=$3
V_Couleur_Stylo=$4
B_Couleur_Stylo=$5
A_Couleur_Stylo=$6
Variation_de_couleur=$7
Dilate_Stylo=$8
Iterations=$9
Multiplier_Iterations=$10
Increment_temps=$11
-if {$12>0}
Amplitude1={{w}*$12/{1000}}
-else
Amplitude1={-{h}*$12/{1000}}
-endif
-if {$13>0}
Amplitude2={{w}*$13/{1000}}
-else
Amplitude2={-{h}*$13/{1000}}
-endif
-if {$14>0}
Amplitude3={{w}*$14/{1000}}
-else
Amplitude3={-{h}*$14/{1000}}
-endif
-if {$15>0}
Amplitude4={{w}*$15/{1000}}
-else
Amplitude4={-{h}*$15/{1000}}
-endif
Frequence1=$16
Frequence2=$17
Frequence3=$18
Frequence4=$19
Phase1=$20
Phase2=$21
Phase3=$22
Phase4=$23
Flou_Pintograph=$24
Spread_Pintograph=$25
Deform_Pintograph=$26
blend=$27
opacite=$28
Revert_layers=0
-to_rgba
{w},{h},1,4
Nb_Boucle=1
temps=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
R_Couleur_origine=$R_Couleur_Stylo
V_Couleur_origine=$V_Couleur_Stylo
B_Couleur_origine=$B_Couleur_Stylo
A_Couleur_origine=$A_Couleur_Stylo
Increment_temps={$Increment_temps/10000}
Phase1={$Phase1/180*{pi}}
Phase2={$Phase2/180*{pi}}
Phase3={$Phase3/180*{pi}}
Phase4={$Phase4/180*{pi}}
-if {$Multiplier_Iterations>0}
Iterations={$Iterations*$Multiplier_Iterations*5}
-endif
-repeat $Iterations
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
Nouveau_point_X={$centre_origine_X+{{$Amplitude1*{sin({{$Frequence1*$temps}+$Phase1})}}+{$Amplitude2*{sin({{$Frequence2*$temps}+$Phase2})}}}}
Nouveau_point_Y={$centre_origine_Y+{{$Amplitude3*{sin({{$Frequence3*$temps}+$Phase3})}}+{$Amplitude4*{sin({{$Frequence4*$temps}+$Phase4})}}}}
-if {$Nb_Boucle>1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
temps={$temps+$Increment_temps}
Nb_Boucle={$Nb_Boucle+1}
-done
-if {$Dilate_Stylo>0} -dilate_circ[-1] $Dilate_Stylo -endif
-if {$Flou_Pintograph>0} -blur[-1] $Flou_Pintograph,0 -endif
-if {$Spread_Pintograph>1} -spread[-1] $Spread_Pintograph -endif
-if {$Deform_Pintograph>0} -deform[-1] $Deform_Pintograph -endif
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
Pintograph_samj_en :
-Pintograph_samj $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28
samj_Poisson_D_Avril :
X={round({{w}*{$1/100}})}
Y={round({{h}*{$2/100}})}
Valeur_A={round({{{w}+{h}}*$3/500})}
Valeur_K=$4
Angle_Rotation=$5
R_Contours=$6
V_Contours=$7
B_Contours=$8
A_Contours=$9
Affichage_Contours=$10
R_a=$11
V_a=$12
B_a=$13
A_a=$14
R_b=$15
V_b=$16
B_b=$17
A_b=$18
Couleurs_aleatoires=$19
Inversions=$20
Flou=$21
Dilatation=$22
Deformation=$23
Bruit=$24
Ombre=$25
X_Ombre=$26
Y_Ombre=$27
Smoothness_Ombre=$28
Curvature_Ombre=$29
Compensation_Decalage_Ombre_X=$30
Compensation_Decalage_Ombre_Y=$31
Canal_Alpha=$32
Resolution=720
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Angle=0
X_Poisson_A_Imprimer=0
Y_Poisson_A_Imprimer=0
X_Poisson_A_Imprimer_Precedent={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer_Precedent={$Y+{$Valeur_A*{sin({pi/180*$Angle})}}}
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-if {$Affichage_Contours==2}
-ellipse[-2] $X,$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Poisson_A_Imprimer={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer={$Y+{$Valeur_A*{sin({pi/180*$Angle})}}}
-polygon[-1] 3,{$X-{2*$Valeur_A}},$Y,$X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a
-if {$Affichage_Contours>0}
-line[-2] $X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Poisson_A_Imprimer_Precedent=$X_Poisson_A_Imprimer
Y_Poisson_A_Imprimer_Precedent=$Y_Poisson_A_Imprimer
-done
Nb_boucles=0
Angle=0
X_Poisson_A_Imprimer_Precedent={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer_Precedent={$Y-{$Valeur_A*{sin({pi/180*$Angle})}}}
-if {$Couleurs_aleatoires==1}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
-endif
-repeat $Resolution
Nb_boucles={$Nb_boucles+1}
Angle={$Nb_boucles*{360/$Resolution}}
X_Poisson_A_Imprimer={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
Y_Poisson_A_Imprimer={$Y-{$Valeur_A*{sin({pi/180*$Angle})}}}
-polygon[-1] 3,{$X-{2*$Valeur_A}},$Y,$X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,$R_b,$V_b,$B_b,$A_b
-if {$Affichage_Contours>0}
-line[-2] $X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
X_Poisson_A_Imprimer_Precedent=$X_Poisson_A_Imprimer
Y_Poisson_A_Imprimer_Precedent=$Y_Poisson_A_Imprimer
-done
-if {$Affichage_Contours>0}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} -endif
-blend[-1,-2] alpha,1,0
samj_Rosace_Triangles_Sierpinski :
Nombre_de_zones=$1
Nombre_de_couches=$2
X={round({{w}*{$3/100}})}
Y={round({{h}*{$4/100}})}
-if {$5>0}
Rayon_Premier_Cecle={round({{w}*$5/{400*{2^0.5}}})}
-else
Rayon_Premier_Cecle={round({-{h}*$5/{400*{2^0.5}}})}
-endif
Decalage_Angle=$6
Hauteur_Triangle={round({{{w}+{h}}*$7/2400})}
Recouvrement_Triangle={round({{{w}+{h}}*$8/4800})}
Angle_inclinaison=$9
R_Contours=$10
V_Contours=$11
B_Contours=$12
A_Contours=$13
Affichage_Contours=$14
Type_Triangles_A=$15
Type_Triangles_B=$16
Type_Decalage=$17
Recursions_Sierpinski=$18
R_Tr=$19
V_Tr=$20
B_Tr=$21
A_Tr=$22
R_Trb=$23
V_Trb=$24
B_Trb=$25
A_Trb=$26
R_Tr_B=$27
V_Tr_B=$28
B_Tr_B=$29
A_Tr_B=$30
R_Tr_Bb=$31
V_Tr_Bb=$32
B_Tr_Bb=$33
A_Tr_Bb=$34
R_Cercle=$35
V_Cercle=$36
B_Cercle=$37
A_Cercle=$38
Afficher_Cercle=$39
Couleurs_aleatoires=$40
Inversions=$41
Flou=$42
Dilatation=$43
Deformation=$44
Bruit=$45
Ombre=$46
X_Ombre=$47
Y_Ombre=$48
Smoothness_Ombre=$49
Curvature_Ombre=$50
Compensation_Decalage_Ombre_X=$51
Compensation_Decalage_Ombre_Y=$52
Canal_Alpha=$53
Largeur_Origine={w}
Hauteur_Origine={h}
Angle=$Angle_inclinaison
Increment_angle={360/$Nombre_de_zones}
Rayon_Cercle_Origine=$Rayon_Premier_Cecle
Rayon_Cercle_A=0
Rayon_Cercle_B=0
Rayon_Cercle_C=0
Rayon_Cercle_D=0
H_Tr_A=0
H_Tr_B=0
H_Tr_C=0
H_Tr_D=0
Nb_Cercles=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage_Contours>0}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
Nb_boucles_couches=0
-repeat $Nombre_de_couches
Nb_boucles_couches={$Nb_boucles_couches+1}
H_Tr_A={$Hauteur_Triangle*$Nb_Cercles}
Nb_Cercles={$Nb_Cercles+1}
H_Tr_B={$Hauteur_Triangle*$Nb_Cercles}
Nb_Cercles={$Nb_Cercles+1}
H_Tr_C={$Hauteur_Triangle*$Nb_Cercles}
Nb_Cercles={$Nb_Cercles+1}
H_Tr_D={$Hauteur_Triangle*$Nb_Cercles}
Rayon_Cercle_A={$Rayon_Cercle_Origine+$H_Tr_A}
Rayon_Cercle_B={$Rayon_Cercle_Origine+$H_Tr_B}
Rayon_Cercle_C={$Rayon_Cercle_Origine+$H_Tr_C}
Rayon_Cercle_D={$Rayon_Cercle_Origine+$H_Tr_D}
Angle=$Angle_inclinaison
Nb_boucles_zones=0
-repeat $Nombre_de_zones
Nb_boucles_zones={$Nb_boucles_zones+1}
-if {$Couleurs_aleatoires==1}
R_Tr={round(u)*255}
V_Tr={round(u)*255}
B_Tr={round(u)*255}
R_Trb={round(u)*255}
V_Trb={round(u)*255}
B_Trb={round(u)*255}
R_Tr_B={round(u)*255}
V_Tr_B={round(u)*255}
B_Tr_B={round(u)*255}
R_Tr_Bb={round(u)*255}
V_Tr_Bb={round(u)*255}
B_Tr_Bb={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
-if {$Type_Decalage==0}
X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
-elif {$Type_Decalage==1}
X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}}})}}}
Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}}})}}}
X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}}})}}}
Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}}})}}}
X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}}})}}}
Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}}})}}}
X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
-elif {$Type_Decalage==2}
X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}}})}}}
Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}}})}}}
X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}}})}}}
Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}}})}}}
X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}}})}}}
Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}}})}}}
X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
-endif
-if {$Type_Triangles_A==0}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==1}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==2}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==3}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==4}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_A==5}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==2}||{$Affichage_Contours==4}||{$Affichage_Contours==5}}
-polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
-if {$Type_Triangles_B==0}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_B==1}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-elif {$Type_Triangles_B==2}
-if {{($Nb_boucles_couches%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
-endif
-if {{$Affichage_Contours==1}||{$Affichage_Contours==3}||{$Affichage_Contours==4}||{$Affichage_Contours==6}}
-polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
Angle={$Angle_inclinaison+{$Increment_angle*$Nb_boucles_zones}}
-done
Nb_Cercles={$Nb_Cercles-3}
H_Tr=$H_Tr_C
Rayon_Cercle_Origine=$Rayon_Cercle_D
-done
-if {$Afficher_Cercle==1}
$Largeur_Origine,$Hauteur_Origine,1,4
-polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1
-ellipse[-1] $X,$Y,$Rayon_Cercle_D,$Rayon_Cercle_D,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-blend[-2,-1] alpha,1,1
-endif
-if {$Affichage_Contours>0}
-if {$Affichage_Contours>3}
-ellipse[-2,-3] $X,$Y,$Rayon_Cercle_D,$Rayon_Cercle_D,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
samj_rien_repair :
-Je_passe_l_hiver_en_Floride[-1]
samj_Cercles_Qui_Tournent :
Dimension=$1
R_fond=$2
V_fond=$3
B_fond=$4
A_fond=$5
Exemples=$6
Cax=$7
Cbx=$8
Ccx=$9
Vbx=$10
Vcx=$11
Cay=$12
Cby=$13
Ccy=$14
Vby=$15
Vcy=$16
Egalite_Param_X_Y=$17
Theta=$18
R_a=$19
V_a=$20
B_a=$21
A_a=$22
Angle_Rotation=$23
Couleurs_aleatoires=$24
Flou=$25
Dilatation=$26
Deformation=$27
Bruit=$28
Ombre=$29
X_Ombre=$30
Y_Ombre=$31
Smoothness_Ombre=$32
Curvature_Ombre=$33
-if {$Exemples==1}
Egalite_Param_X_Y=1
Cax=1
Cbx=0.5
Ccx=0.25
Vbx=7
Vcx=21
Theta=1000
-elif {$Exemples==2}
Egalite_Param_X_Y=1
Cax=1
Cbx=5
Ccx=2
Vbx=3
Vcx=10
Theta=4693
-elif {$Exemples==3}
Egalite_Param_X_Y=0
Cax=1
Cbx=0.5
Ccx=0.33
Vbx=7
Vcx=17
Cay=1
Cby=0.5
Ccy=0.33
Vby=11
Vcy=17
Theta=4886
-elif {$Exemples==4}
Egalite_Param_X_Y=0
Cax=1
Cbx=0.5
Ccx=0.33
Vbx=7
Vcx=17
Cay=1
Cby=0.5
Ccy=0.33
Vby=7
Vcy=3
Theta=4520
-elif {$Exemples==5}
Egalite_Param_X_Y=0
Cax=1
Cbx=0.5
Ccx=0.25
Vbx=1
Vcx=6
Cay=0.8
Cby=0.2
Ccy=1
Vby=9
Vcy=12
Theta=493
-elif {$Exemples==6}
Egalite_Param_X_Y=1
Cax=1
Cbx=0.5
Ccx=0.33
Vbx=-5
Vcx=17
Theta=10
-endif
-if {$Egalite_Param_X_Y==1}
Cay=$Cax
Cby=$Cbx
Ccy=$Ccx
Vby=$Vbx
Vcy=$Vcx
-endif
-rm[-1]
$Dimension,$Dimension,1,4
-fill_color[-1] 0,0,0,0
# tracer la courbe en couleur noire sans Antialiasing , sans Decoration ,   X(t) :  cos(t)+(0.5*cos(7*t))+((cos((3.14/2)-(17*t)))/3)  ,  Y(t) :  (sin(t)+(0.5*sin(7*t))+((sin((3.14/2)-(17*t)))/3)
-gimp_equation_parametric[-1] "(cos(t)*"$Cax")+("$Cbx"*cos("$Vbx"*t))+((cos(("{pi/2}")-("$Vcx"*t)))*"$Ccx")","(sin(t)*"$Cay")+("$Cby"*sin("$Vby"*t))+((sin(("{pi/2}")-("$Vcy"*t)))*"$Ccy")",0,$Theta,$Dimension,1,1,0,0,0,0,0,0,1,0,0
-to_rgba[-1]
-replace_color[-1] 100%,0,255,255,255,255,0,0,0,0
-replace_color[-1] 100%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a
-if {$Couleurs_aleatoires==0}
-replace_color[-1] 100%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a
-else
$Dimension,$Dimension,1,4
-fill_color[-1] 0,0,0,0
-gimp_corner_gradient[-1] {round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255
-blend[-1,-2] add,1,0
-to_rgba[-1]
-endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-endif
-if {$Angle_Rotation>0} -rotate[-1] $Angle_Rotation,1,0,{$Dimension/2},{$Dimension/2} -endif
$Dimension,$Dimension,1,4
-fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond
-if {$Bruit>0} -apply_channels[-1] "-gimp_noise "$Bruit",0,22,1",1 -endif
#-blend[-2,-1] alpha,1,1
-gimp_blend_1651[-2,-1] 1,0,1,0,1
samj_Formes_Geometriques_Simples :
X_Position={round({{w}*{$1/100}})}
Y_Position={round({{h}*{$2/100}})}
R_Externe=$3
V_Externe=$4
B_Externe=$5
A_Externe=$6
R_Interne=$7
V_Interne=$8
B_Interne=$9
A_Interne=$10
R_Contour=$11
V_Contour=$12
B_Contour=$13
A_Contour=$14
Forme=$15
Dimension_Un={round({{w}*{$16/100}})}
Dimension_Deux={round({{h}*{$17/100}})}
Nb_Cotes=$18
Angle_Inclinaison=$19
Dilatation=$20
Melange=$21
Largeur_Origine={w}
Hauteur_Origine={h}
Valeur_Angle=0
Nb_Boucles=0
Rayon_Cercle_Circonscrit=0
-if {$Forme==0}
Rayon_Cercle_Circonscrit=$Dimension_Un
-elif {$Forme==1}
Rayon_Cercle_Circonscrit=$Dimension_Deux
-elif {$Forme==3}
Rayon_Cercle_Circonscrit=$Dimension_Un
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-elif {$Forme==4}
Rayon_Cercle_Circonscrit=$Dimension_Deux
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-elif {$Forme==5}
Rayon_Cercle_Circonscrit=$Dimension_Un
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-elif {$Forme==6}
Rayon_Cercle_Circonscrit=$Dimension_Deux
-if {$Nb_Cotes<5} Nb_Cotes=5 -endif
-endif
-if {$Melange==0}
-rm[-1]
-else
-to_rgba[-1]
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-fill_color[-1] $R_Externe,$V_Externe,$B_Externe,$A_Externe
-if {$Forme==2}
-ellipse[-1] $X_Position,$Y_Position,$Dimension_Un,$Dimension_Deux,$Angle_Inclinaison,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-ellipse[-1] $X_Position,$Y_Position,$Dimension_Un,$Dimension_Deux,$Angle_Inclinaison,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-else
-repeat $Nb_Cotes
Nb_Boucles={$Nb_Boucles+1}
-if {$Nb_Boucles==1}
X_a={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_a={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==2}
X_b={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_b={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==3}
X_c={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_c={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==4}
X_d={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_d={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==5}
X_e={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_e={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==6}
X_f={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_f={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==7}
X_g={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_g={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==8}
X_h={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_h={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==9}
X_i={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_i={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==10}
X_j={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_j={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==11}
X_k={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_k={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==12}
X_l={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_l={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==13}
X_m={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_m={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==14}
X_n={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_n={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==15}
X_o={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_o={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==16}
X_p={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_p={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==17}
X_q={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_q={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==18}
X_r={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_r={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==19}
X_s={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_s={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==20}
X_t={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_t={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==21}
X_u={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_u={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==22}
X_v={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_v={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==23}
X_w={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_w={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==24}
X_x={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_x={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==25}
X_y={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_y={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-elif {$Nb_Boucles==26}
X_z={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
Y_z={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
-endif
Valeur_Angle={$Valeur_Angle+{360/$Nb_Cotes}}
-done
-endif
-if {$Forme==0||$Forme==1}
-if {$Nb_Cotes==3}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==4}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==5}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==6}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==7}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==8}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==9}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==10}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==11}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==12}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==13}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==14}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==15}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==16}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==17}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==18}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==19}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==20}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==21}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==22}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==23}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==24}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==25}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==26}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-endif
-endif
-if {$Forme==3||$Forme==4}
# Etoiles Impaires
-if {$Nb_Cotes==5}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==7}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==9}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==11}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==13}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==15}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==17}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==19}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==21}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==23}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==25}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
# toiles Paires
-elif {$Nb_Cotes==6}
-polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==8}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==10}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==12}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==14}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==16}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==18}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==20}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==22}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==24}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-elif {$Nb_Cotes==26}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-endif
-endif
-if {$Forme==5||$Forme==6}
# Polygones + toiles Impaires
-if {$Nb_Cotes==5}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==7}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==9}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==11}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==13}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==15}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==17}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==19}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==21}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==23}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==25}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
# Polygones + toiles Paires
-elif {$Nb_Cotes==6}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==8}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==10}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==12}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==14}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==16}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==18}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==20}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==22}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==24}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-elif {$Nb_Cotes==26}
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
-polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
-endif
-endif
-if {$Dilatation>1}
-dilate_circ[-1] $Dilatation
-endif
#-text_outline[-1] $X_Position,10,10,32,1,1,255,255,255
#-text_outline[-1] $Y_Position,10,35,32,1,1,255,255,255
#-text_outline[-1] $Dimension_Un,10,60,32,1,1,255,255,255
#-text_outline[-1] $Dimension_Deux,10,85,32,1,1,255,255,255
#-text_outline[-1] $Nb_Cotes,10,110,32,1,1,255,255,255
#-text_outline[-1] $Angle_Inclinaison,10,135,32,1,1,255,255,255
-if {$Melange==1}
-blend[-1,-2] alpha,1,0
-endif
Spirographe_samj :
centre_origine_X={$1/100*w}
centre_origine_Y={$2/100*h}
-if {$3>0}
Rayon_1={{w}*$3/{1000}}
-else
Rayon_1={-{h}*$3/{1000}}
-endif
-if {$4>0}
Rayon_2={{w}*$4/{1000}}
-else
Rayon_2={-{h}*$4/{1000}}
-endif
-if {$5>0}
Position_Stylo={{w}*$5/{1000}}
-else
Position_Stylo={-{h}*$5/{1000}}
-endif
R_Couleur_Stylo=$6
V_Couleur_Stylo=$7
B_Couleur_Stylo=$8
A_Couleur_Stylo=$9
Variation_de_couleur=$10
Dilate_Stylo=$11
Nombre_de_tours=$12
Multiplier_tours=$13
Increment_angulaire=$14
Diviser_Increment_angulaire=$15
Type_de_rendu=$16
Points_Rayon=$17
R_Couleur_Points=$18
V_Couleur_Points=$19
B_Couleur_Points=$20
A_Couleur_Points=$21
Lignes_epaisseur=$22
R_Couleur_Lignes=$23
V_Couleur_Lignes=$24
B_Couleur_Lignes=$25
A_Couleur_Lignes=$26
Flou_Spirographe=$27
Spread_Spirographe=$28
Deform_Spirographe=$29
blend=$30
opacite=$31
Revert_layers=0
-to_rgba
{w},{h},1,4
Nb_Boucle=1
theta=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
-if {$Rayon_2==0}
Rayon_2=1
-endif
-if {$Multiplier_tours==1}
Nombre_de_tours={$Nombre_de_tours*10}
-endif
-if {$Multiplier_tours==2}
Nombre_de_tours={$Nombre_de_tours*100}
-endif
-if {$Diviser_Increment_angulaire==1}
Increment_angulaire={$Increment_angulaire/10}
-endif
-if {$Diviser_Increment_angulaire==2}
Increment_angulaire={$Increment_angulaire/100}
-endif
Nombre_de_tours={$Nombre_de_tours/$Increment_angulaire*360}
R_Couleur_origine=$R_Couleur_Stylo
V_Couleur_origine=$V_Couleur_Stylo
B_Couleur_origine=$B_Couleur_Stylo
A_Couleur_origine=$A_Couleur_Stylo
-if {$Dilate_Stylo>0}
-repeat $Nombre_de_tours
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
-if {$Type_de_rendu==0}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==1}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==2}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==3}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==4}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==5}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==6}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==7}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Nb_Boucle>1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
theta={$theta+$Increment_angulaire}
Nb_Boucle={$Nb_Boucle+1}
-done
-dilate_circ[-1] $Dilate_Stylo
Nb_Boucle=1
theta=0
Ancien_point_X=0
Nouveau_point_X=0
Ancien_point_Y=0
Nouveau_point_Y=0
-if {{$Lignes_epaisseur>0}||{$Points_Rayon>0}}
-repeat $Nombre_de_tours
-if {$Type_de_rendu==0}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==1}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==2}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==3}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==4}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==5}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==6}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==7}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Nb_Boucle>1}
-if {$Lignes_epaisseur>0}
-if {$Points_Rayon>0}
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-trait_epais_samj $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,$Lignes_epaisseur,1,$R_Couleur_Lignes,$V_Couleur_Lignes,$B_Couleur_Lignes,$A_Couleur_Lignes
-if {$Points_Rayon>0}
-circle[-1] $Nouveau_point_X,$Nouveau_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
-if {$Points_Rayon>0}
-if {$Variation_de_couleur==1}
R_Couleur_Points={round(u)*255}
V_Couleur_Points={round(u)*255}
B_Couleur_Points={round(u)*255}
-endif
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
theta={$theta+$Increment_angulaire}
Nb_Boucle={$Nb_Boucle+1}
-done
-endif
-else
-repeat $Nombre_de_tours
-if {$Variation_de_couleur==1}
R_Couleur_Stylo={round(u)*255}
V_Couleur_Stylo={round(u)*255}
B_Couleur_Stylo={round(u)*255}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur_Stylo={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur_Stylo>255}
R_Couleur_Stylo=$R_Couleur_origine
-endif
-if {$R_Couleur_Stylo<0}
R_Couleur_Stylo=$R_Couleur_origine
-endif
V_Couleur_Stylo={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur_Stylo>255}
V_Couleur_Stylo=$V_Couleur_origine
-endif
-if {$V_Couleur_Stylo<0}
V_Couleur_Stylo=$V_Couleur_origine
-endif
B_Couleur_Stylo={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur_Stylo>255}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-if {$B_Couleur_Stylo<0}
B_Couleur_Stylo=$B_Couleur_origine
-endif
-endif
-if {$Type_de_rendu==0}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==1}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==2}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==3}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==4}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==5}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==6}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Type_de_rendu==7}
Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
-endif
-if {$Nb_Boucle>1}
-if {$Lignes_epaisseur>0}
-if {$Points_Rayon>0}
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-trait_epais_samj $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,$Lignes_epaisseur,1,$R_Couleur_Lignes,$V_Couleur_Lignes,$B_Couleur_Lignes,$A_Couleur_Lignes
-if {$Points_Rayon>0}
-circle[-1] $Nouveau_point_X,$Nouveau_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
-if {$Lignes_epaisseur<1}
-line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
-endif
-if {$Points_Rayon>0}
-if {$Variation_de_couleur==1}
R_Couleur_Points={round(u)*255}
V_Couleur_Points={round(u)*255}
B_Couleur_Points={round(u)*255}
-endif
-circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
-endif
-endif
Ancien_point_X=$Nouveau_point_X
Ancien_point_Y=$Nouveau_point_Y
theta={$theta+$Increment_angulaire}
Nb_Boucle={$Nb_Boucle+1}
-done
-endif
-if {$Flou_Spirographe>0} -blur[-1] $Flou_Spirographe,0 -endif
-if {$Spread_Spirographe>1} -spread[-1] $Spread_Spirographe -endif
-if {$Deform_Spirographe>0} -deform[-1] $Deform_Spirographe -endif
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
samj_en_Des_Lignes_002 :
-samj_Des_Lignes_002 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
samj_Des_Lignes_002 :
Nombre_Lignes=$1
Random_Colors=$2
Gris=$3
R_Couleur=$4
V_Couleur=$5
B_Couleur=$6
A_Couleur=$7
Symetrie=$8
Effet=$9
Etendue=$10
point_X={{w}/100*$11}
point_Y={{h}/100*$12}
Flou=$13
Dilatation=$14
Deformation=$15
Bruit=$16
Melange=$17
Inc_L={{w}/{{$Nombre_Lignes+1}*$Etendue}}
Inc_H={{h}/{{$Nombre_Lignes+1}*$Etendue}}
Origine_L=0
Origine_H=0
-if {$Melange==1}
{w},{h},1,4
-else
-to_rgba[-1]
-fill_color[-1] 0,0,0,0
-endif
-repeat $Nombre_Lignes
Origine_L={$Origine_L+$Inc_L}
Origine_H={$Origine_H+$Inc_H}
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==1}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==3}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==5}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==9}
-line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==11}
-line[-1] $point_X,$point_Y,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-line[-1] $point_X,$point_Y,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-line[-1] $point_X,$point_Y,0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-line[-1] $point_X,$point_Y,$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==2}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==3}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==6}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==10}
-line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==1}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==4}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==7}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==10}
-line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-if {$Random_Colors==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
-endif
-if {$Gris==1}
R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
V_Couleur=$R_Couleur
B_Couleur=$R_Couleur
-endif
-if {$Effet==0}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==2}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==4}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==8}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-elif {$Effet==9}
-line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
-done
-if {$Symetrie==1}
-mirror[-1] x
-elif {$Symetrie==2}
-mirror[-1] y
-elif {$Symetrie==3}
-mirror[-1] x
-mirror[-1] y
-endif
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Melange==1}
-blend[-1,-2] alpha,1,0
-endif
# -text_outline[-1] $Effet,10,10,64,1,1,255,255,255
samj_Superposition_Triangles_Sierpinski :
Nombre_de_zones=$1
Nombre_de_superpositions=$2
X={round({{w}*{$3/100}})}
Y={round({{h}*{$4/100}})}
-if {$5>0}
Rayon_Premier_Cecle={round({{w}*$5/{200*{2^0.5}}})}
-else
Rayon_Premier_Cecle={round({-{h}*$5/{200*{2^0.5}}})}
-endif
Coeff_Superpositions=$6
Hauteur_Triangle={round({{{w}+{h}}*$7/2400})}
Angle_inclinaison=$8
R_Contours=$9
V_Contours=$10
B_Contours=$11
A_Contours=$12
Affichage=$13
Recursions_Sierpinski=$14
R_Tr=$15
V_Tr=$16
B_Tr=$17
A_Tr=$18
R_Trb=$19
V_Trb=$20
B_Trb=$21
A_Trb=$22
R_Lat=$23
V_Lat=$24
B_Lat=$25
A_Lat=$26
R_Latb=$27
V_Latb=$28
B_Latb=$29
A_Latb=$30
R_Cercle=$31
V_Cercle=$32
B_Cercle=$33
A_Cercle=$34
Afficher_Cercle=$35
Couleurs_aleatoires=$36
Inversions=$37
Flou=$38
Dilatation=$39
Deformation=$40
Bruit=$41
Ombre=$42
X_Ombre=$43
Y_Ombre=$44
Smoothness_Ombre=$45
Curvature_Ombre=$46
Compensation_Decalage_Ombre_X=$47
Compensation_Decalage_Ombre_Y=$48
Canal_Alpha=$49
Largeur_Origine={w}
Hauteur_Origine={h}
Angle=$Angle_inclinaison
Increment_angle={360/$Nombre_de_zones}
Rayon_Cercle_A=$Rayon_Premier_Cecle
H_Tr=$Hauteur_Triangle
Rayon_Cercle_B=0
Rayon_Cercle_C=0
Rayon_Contour=0
-if {$Canal_Alpha==0}
-to_rgb[-1]
-else
-to_rgba[-1]
-endif
-if {$Affichage>3}
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
-endif
$Largeur_Origine,$Hauteur_Origine,1,4
-if {$Ombre>0} -polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 -endif
Nb_boucles_superpositions=0
-repeat $Nombre_de_superpositions
Nb_boucles_superpositions={$Nb_boucles_superpositions+1}
Nb_boucles_zones=0
Angle=$Angle_inclinaison
-repeat $Nombre_de_zones
Nb_boucles_zones={$Nb_boucles_zones+1}
-if {$Couleurs_aleatoires==1}
R_Tr={round(u)*255}
V_Tr={round(u)*255}
B_Tr={round(u)*255}
R_Trb={round(u)*255}
V_Trb={round(u)*255}
B_Trb={round(u)*255}
R_Lat={round(u)*255}
V_Lat={round(u)*255}
B_Lat={round(u)*255}
R_Latb={round(u)*255}
V_Latb={round(u)*255}
B_Latb={round(u)*255}
R_Cercle={round(u)*255}
V_Cercle={round(u)*255}
B_Cercle={round(u)*255}
-endif
Rayon_Cercle_B={{{$Rayon_Cercle_A*$Rayon_Cercle_A}+{{$Rayon_Cercle_A*{tan({pi/180*{180/$Nombre_de_zones}})}}*{$Rayon_Cercle_A*{tan({pi/180*{180/$Nombre_de_zones}})}}}}^0.5}
X_A={$X+{{$Rayon_Cercle_A+$H_Tr}*{cos({pi/180*$Angle})}}}
Y_A={$Y+{{$Rayon_Cercle_A+$H_Tr}*{sin({pi/180*$Angle})}}}
X_B={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
Y_B={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
X_C={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
Y_C={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
Rayon_Cercle_C={{{{$Rayon_Cercle_A+$H_Tr}*{$Rayon_Cercle_A+$H_Tr}}+{{{$Rayon_Cercle_A+$H_Tr}*{tan({pi/180*{180/$Nombre_de_zones}})}}*{{$Rayon_Cercle_A+$H_Tr}*{tan({pi/180*{180/$Nombre_de_zones}})}}}}^0.5}
X_D={$X+{$Rayon_Cercle_A*{cos({pi/180*$Angle})}}}
Y_D={$Y+{$Rayon_Cercle_A*{sin({pi/180*$Angle})}}}
X_E={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
Y_E={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
X_F={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
Y_F={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
-if {{($Affichage%2)}==0}
Rayon_Contour={$Rayon_Cercle_A+$H_Tr}
-if {$Recursions_Sierpinski==0}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-else
-if {{($Nb_boucles_superpositions%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-endif
-if {{$Affichage==2}||{$Affichage==6}}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_E,$Y_E,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-polygon[-1] 3,$X_A,$Y_A,$X_C,$Y_C,$X_F,$Y_F,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-else
-polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_E,$Y_E,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-polygon[-1] 3,$X_A,$Y_A,$X_C,$Y_C,$X_F,$Y_F,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-endif
-endif
-if {$Affichage>3}
-polygon[-2] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-else
Rayon_Contour=$Rayon_Cercle_C
-if {$Recursions_Sierpinski==0}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-polygon[-1] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-else
-if {{($Nb_boucles_superpositions%2)}==0}
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,$R_Tr,$V_Tr,$B_Tr,$A_Tr
-else
-samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,$R_Trb,$V_Trb,$B_Trb,$A_Trb
-endif
-endif
-if {{$Affichage==3}||{$Affichage==7}}
-if {{($Nb_boucles_superpositions%2)}==0}
-polygon[-1] 3,$X_D,$Y_D,$X_B,$Y_B,$X_E,$Y_E,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-polygon[-1] 3,$X_D,$Y_D,$X_C,$Y_C,$X_F,$Y_F,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
-else
-polygon[-1] 3,$X_D,$Y_D,$X_B,$Y_B,$X_E,$Y_E,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-polygon[-1] 3,$X_D,$Y_D,$X_C,$Y_C,$X_F,$Y_F,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
-endif
-endif
-if {$Affichage>3}
-polygon[-2] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
Angle={$Angle_inclinaison+{$Increment_angle*$Nb_boucles_zones}}
-done
Rayon_Cercle_A={$Rayon_Cercle_A+$H_Tr}
H_Tr={$Hauteur_Triangle*$Nb_boucles_superpositions*$Coeff_Superpositions}
-done
-if {$Afficher_Cercle==1}
$Largeur_Origine,$Hauteur_Origine,1,4
-polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1
-ellipse[-1] $X,$Y,$Rayon_Contour,$Rayon_Contour,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
-blend[-2,-1] alpha,1,1
-if {$Affichage>3}
-ellipse[-2] $X,$Y,$Rayon_Contour,$Rayon_Contour,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-endif
-if {$Affichage>3}
-if {$Dilatation>1} -dilate_circ[-2] $Dilatation -endif
-if {$Flou>0} -blur[-1,-2] $Flou,0 -endif
-if {$Deformation>0} -deform[-1,-2] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-blend[-2,-1] alpha,1,1
-else
-if {$Dilatation>1} -dilate_circ[-1] $Dilatation -endif
-if {$Flou>0} -blur[-1] $Flou,0 -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-if {$Bruit>0} -gimp_noise[-1] {$Bruit+50},0,22,1 -endif
-if {$Ombre>0}
-drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
-shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
-endif
-endif
-if {$Inversions==1}
-mirror[-1] x
-elif {$Inversions==2}
-mirror[-1] y
-elif {$Inversions==3}
-mirror[-1] x
-mirror[-1] y
-endif
-blend[-1,-2] alpha,1,0
Traits_Strokes_samj:
Position_X={round({{w}*{$1/100}})}
Position_Y={round({{h}*{$2/100}})}
-if {$3>0}
Longueur={{w}*$3/{100}}
-else
Longueur={-{h}*$3/{100}}
-endif
Variations_Formes=$4
Variations_Longueur=$5
-if {$6>0}
Eloignement_du_centre={{w}*$6/{100}}
-else
Eloignement_du_centre={-{h}*$6/{100}}
-endif
Nombre_de_traits=$7
Angle_Depart=$8
Angle_Fin=$9
R_Couleur=$10
V_Couleur=$11
B_Couleur=$12
A_Couleur=$13
Variation_de_couleur=$14
Epaisseur=$15
Symetrie=$16
Pourcent_Longueur_Sym=$17
Flou_traits=$18
Spread_traits=$19
Deform_traits=$20
blend=$21
opacite=$22
Revert_layers=0
-to_rgba
{w},{h},1,4
Angle=$Angle_Depart
-if {$Angle_Depart>$Angle_Fin}
Angle_Fin={$Angle_Fin+360}
-endif
increment_theta={{$Angle_Fin-$Angle_Depart}/$Nombre_de_traits}
-if {$Variations_Formes==1}
Variation={{$Longueur/100*$Variations_Longueur}/$Nombre_de_traits}
-endif
-if {$Variations_Formes==2}
Variation={{-$Longueur/1000*$Variations_Longueur}/$Nombre_de_traits}
-endif
-if {$Variations_Formes==3}
Variation={{$Longueur/100*$Variations_Longueur}/{$Nombre_de_traits/2}}
-endif
-if {$Variations_Formes==4}
Variation={{-$Longueur/1000*$Variations_Longueur}/{$Nombre_de_traits/2}}
-endif
Longueur_calculee=$Longueur
Nb_Boucle=1
R_Couleur_origine=$R_Couleur
V_Couleur_origine=$V_Couleur
B_Couleur_origine=$B_Couleur
A_Couleur_origine=$A_Couleur
-repeat $Nombre_de_traits
-if {$Variation_de_couleur==1}
R_Couleur={round(u)*255}
V_Couleur={round(u)*255}
B_Couleur={round(u)*255}
A_Couleur={{round(u)*200}+55}
-endif
-if {$Variation_de_couleur>1}
Valeur_variation_couleur=16
-if {$Variation_de_couleur==3}
Valeur_variation_couleur=32
-endif
-if {$Variation_de_couleur==4}
Valeur_variation_couleur=64
-endif
R_Couleur={round({$R_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$R_Couleur>255}
R_Couleur=$R_Couleur_origine
-endif
-if {$R_Couleur<0}
R_Couleur=$R_Couleur_origine
-endif
V_Couleur={round({$V_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$V_Couleur>255}
V_Couleur=$V_Couleur_origine
-endif
-if {$V_Couleur<0}
V_Couleur=$V_Couleur_origine
-endif
B_Couleur={round({$B_Couleur_origine+{?(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
-if {$B_Couleur>255}
B_Couleur=$B_Couleur_origine
-endif
-if {$B_Couleur<0}
B_Couleur=$B_Couleur_origine
-endif
-endif
Debut_X={$Position_X+{round(cos(pi/180*$Angle)*$Eloignement_du_centre)}}
Debut_Y={$Position_Y+{round(sin(pi/180*$Angle)*$Eloignement_du_centre)}}
Extremite_X={$Position_X+{round(cos(pi/180*$Angle)*{$Longueur_calculee+$Eloignement_du_centre})}}
Extremite_Y={$Position_Y+{round(sin(pi/180*$Angle)*{$Longueur_calculee+$Eloignement_du_centre})}}
-line[-1] $Debut_X,$Debut_Y,$Extremite_X,$Extremite_Y,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-if {$Symetrie==1}
Debut_X={$Position_X+{round(cos(pi/180*{$Angle+180})*$Eloignement_du_centre)}}
Debut_Y={$Position_Y+{round(sin(pi/180*{$Angle+180})*$Eloignement_du_centre)}}
Extremite_X={$Position_X+{round(cos(pi/180*{$Angle+180})*{{$Longueur_calculee/100*$Pourcent_Longueur_Sym}+$Eloignement_du_centre})}}
Extremite_Y={$Position_Y+{round(sin(pi/180*{$Angle+180})*{{$Longueur_calculee/100*$Pourcent_Longueur_Sym}+$Eloignement_du_centre})}}
-line[-1] $Debut_X,$Debut_Y,$Extremite_X,$Extremite_Y,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
-endif
Angle={$Angle+$increment_theta}
-if {{$Variations_Formes==1}||{$Variations_Formes==2}}
Longueur_calculee={$Longueur_calculee+$Variation}
-endif
-if {{$Variations_Formes==3}||{$Variations_Formes==4}}
-if {$Nb_Boucle<{$Nombre_de_traits/2}}
Longueur_calculee={$Longueur_calculee+$Variation}
-else
Longueur_calculee={$Longueur_calculee-$Variation}
-endif
-endif
Nb_Boucle={$Nb_Boucle+1}
-done
-if {$Epaisseur>0}
-dilate_circ[-1] $Epaisseur
-endif
-blur[-1] $Flou_traits
-spread[-1] $Spread_traits
-deform[-1] $Deform_traits
-gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1
Triangles_Shades_Adjacents:
Supprimer_Calque_Origine=$1
Position_Centre_X=$2
Position_Centre_Y=$3
Nombre_De_Triangles=$4
Artefacts=$5
Angle_Decalage_Couleurs=$6
R_Centre=$7
V_Centre=$8
B_Centre=$9
R_a=$10
V_a=$11
B_a=$12
R_b=$13
V_b=$14
B_b=$15
R_c=$16
V_c=$17
B_c=$18
R_d=$19
V_d=$20
B_d=$21
R_e=$22
V_e=$23
B_e=$24
R_f=$25
V_f=$26
B_f=$27
R_g=$28
V_g=$29
B_g=$30
#Choix_Des_Couleurs
Rendu=$31
Couleurs_aleatoires=$32
Activer_Color_Balance=$33
R_Neutral_color=$34
V_Neutral_color=$35
B_Neutral_color=$36
Stretch_colors=$37
Activer_Melange=$38
Mode=$39
Opacity=$40
Revert_layers=$41
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Ra_en_cours=0
Va_en_cours=0
Ba_en_cours=0
Rb_en_cours=0
Vb_en_cours=0
Bb_en_cours=0
Rc_en_cours=0
Vc_en_cours=0
Bc_en_cours=0
Rayon_De_Couleur={round({{{{$Largeur_Origine^2}+{$Hauteur_Origine^2}}^0.5}+1})}
Angle_Rayon_De_Couleur={360/$Nombre_De_Triangles}
Angle_Artefacts=0
Angle_Rayon_De_Couleur_Ref=0
Angle_Rayon_De_Couleur_En_Cours=0
Angle_Rayon_De_Couleur_En_Cours_Fin=0
-if {$Nombre_De_Triangles==3} Rayon_De_Couleur={$Rayon_De_Couleur*3} -endif
-if {{$Nombre_De_Triangles-{$Rendu+2}}<0} Rendu={$Nombre_De_Triangles-2} -endif
-if {$Artefacts==-1} Angle_Artefacts={0.5-{0.1/$Nombre_De_Triangles}} -else Angle_Artefacts=$Artefacts -endif
-to_rgba[0]
# 1 nouvelle images couleurs
$Largeur_Origine,$Hauteur_Origine,1,3
-fill_color[-1] 0,0,0,255
-repeat $Nombre_De_Triangles
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-if {{($Nb_boucles%{$Rendu+2})}==0}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_a
Vb_en_cours=$V_a
Bb_en_cours=$B_a
Rc_en_cours=$R_b
Vc_en_cours=$V_b
Bc_en_cours=$B_b
-endif
-if {{($Nb_boucles%{$Rendu+2})}==1}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_b
Vb_en_cours=$V_b
Bb_en_cours=$B_b
-if {$Rendu==0}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_c
Vc_en_cours=$V_c
Bc_en_cours=$B_c
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==2}&&{$Rendu>0}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_c
Vb_en_cours=$V_c
Bb_en_cours=$B_c
-if {$Rendu==1}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_d
Vc_en_cours=$V_d
Bc_en_cours=$B_d
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==3}&&{$Rendu>1}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_d
Vb_en_cours=$V_d
Bb_en_cours=$B_d
-if {$Rendu==2}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_e
Vc_en_cours=$V_e
Bc_en_cours=$B_e
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==4}&&{$Rendu>2}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_e
Vb_en_cours=$V_e
Bb_en_cours=$B_e
-if {$Rendu==3}
Rc_en_cours=$R_a
Vc_en_cours=$V_a
Bc_en_cours=$B_a
-else
Rc_en_cours=$R_f
Vc_en_cours=$V_f
Bc_en_cours=$B_f
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==5}&&{$Rendu>3}}
Ra_en_cours=$R_Centre
Va_en_cours=$V_Centre
Ba_en_cours=$B_Centre
Rb_en_cours=$R_f
Vb_en_cours=$V_f
Bb_en_cours=$B_f
-if {$Rendu==4}
Rb_en_cours=$R_a
Vb_en_cours=$V_a
Bb_en_cours=$B_a
-else
Rc_en_cours=$R_g
Vc_en_cours=$V_g
Bc_en_cours=$B_g
-endif
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==6}&&{$Rendu>4}}
R_en_cours=$R_g
V_en_cours=$V_g
B_en_cours=$B_g
-endif
Angle_Rayon_De_Couleur_Ref={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs+$Angle_Artefacts}
-if {$Nb_boucles==0}
-else
-endif
Angle_Rayon_De_Couleur_En_Cours={$Angle_Rayon_De_Couleur_Ref-$Angle_Artefacts}
Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur_Ref+$Angle_Rayon_De_Couleur+$Angle_Artefacts}
-triangle_shade[-1] {$Position_Centre_X*$Largeur_Origine/100},{$Position_Centre_Y*$Hauteur_Origine/100},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*{$Angle_Rayon_De_Couleur_En_Cours}})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*{$Angle_Rayon_De_Couleur_En_Cours}})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*{$Angle_Rayon_De_Couleur_En_Cours_Fin}})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*{$Angle_Rayon_De_Couleur_En_Cours_Fin}})}}},$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Rb_en_cours,$Vb_en_cours,$Bb_en_cours,$Rc_en_cours,$Vc_en_cours,$Bc_en_cours
Nb_boucles={$Nb_boucles+1}
-done
-if {$Activer_Color_Balance==1}
-gimp_balance_gamma[-1] $R_Neutral_color,$V_Neutral_color,$B_Neutral_color,$Stretch_colors=$34
-endif
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-else
-if {$Activer_Melange==1}
-if {$Revert_layers==1}
-reverse[-1,-2]
-endif
-gimp_blend_1651[-2,-1] $Mode,0,$Opacity,0
-else
-reverse[-1,-2]
-endif
-endif
Twisted_Rays:
Dimension_Finale=$1
Supprimer_Calque_Origine=$2
Amplitude_Twirl=$3
Melanges_Rayons=$4
Rendu=$5
Nb_De_Rayon_De_Couleur=$6
Angle_Decalage_Couleurs_A=$7
Angle_Decalage_Couleurs_B=$8
R_a=$9
V_a=$10
B_a=$11
A_a=$12
R_b=$13
V_b=$14
B_b=$15
A_b=$16
R_c=$17
V_c=$18
B_c=$19
A_c=$20
R_d=$21
V_d=$22
B_d=$23
A_d=$24
R_e=$25
V_e=$26
B_e=$27
A_e=$28
R_f=$29
V_f=$30
B_f=$31
A_f=$32
R_g=$33
V_g=$34
B_g=$35
A_g=$36
Couleurs_aleatoires=$37
R_Contours=$38
V_Contours=$39
B_Contours=$40
A_Contours=$41
Affichage_Contours=$42
Dilate_Contours=$43
Flou_Contours=$44
Sharpen_Contours=$45
Filtre_Symmetrizoscope=$46
Iterations_Symmetrizoscope=$47
Angle_Symmetrizoscope=$48
Symmetry_Sides=$49
Largeur_Origine={w}
Hauteur_Origine={h}
Nb_boucles=0
Rayon_Cercle_Final={round({{$Dimension_Finale/2}-1})}
Rayon_De_Couleur={round({1+{$Dimension_Finale*{2^0.5}}})}
Angle_Rayon_De_Couleur={360/$Nb_De_Rayon_De_Couleur}
Angle_Rayon_De_Couleur_En_Cours_A=0
Angle_Rayon_De_Couleur_En_Cours_Fin_A=0
Angle_Rayon_De_Couleur_En_Cours_B=0
Angle_Rayon_De_Couleur_En_Cours_Fin_B=0
R_en_cours=0
V_en_cours=0
B_en_cours=0
A_en_cours=0
-if {$Supprimer_Calque_Origine==1}
-rm[0]
-endif
# 2 nouvelles images contours
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
# 2 nouvelles images Rayons
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-repeat $Nb_De_Rayon_De_Couleur
-if {$Couleurs_aleatoires==1}
R_a={round(u)*255}
V_a={round(u)*255}
B_a={round(u)*255}
R_b={round(u)*255}
V_b={round(u)*255}
B_b={round(u)*255}
R_c={round(u)*255}
V_c={round(u)*255}
B_c={round(u)*255}
R_d={round(u)*255}
V_d={round(u)*255}
B_d={round(u)*255}
R_e={round(u)*255}
V_e={round(u)*255}
B_e={round(u)*255}
R_f={round(u)*255}
V_f={round(u)*255}
B_f={round(u)*255}
R_g={round(u)*255}
V_g={round(u)*255}
B_g={round(u)*255}
-endif
-if {{($Nb_boucles%{$Rendu+2})}==0}
R_en_cours=$R_a
V_en_cours=$V_a
B_en_cours=$B_a
A_en_cours=$A_a
-endif
-if {{($Nb_boucles%{$Rendu+2})}==1}
R_en_cours=$R_b
V_en_cours=$V_b
B_en_cours=$B_b
A_en_cours=$A_b
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==2}&&{$Rendu>0}}
R_en_cours=$R_c
V_en_cours=$V_c
B_en_cours=$B_c
A_en_cours=$A_c
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==3}&&{$Rendu>1}}
R_en_cours=$R_d
V_en_cours=$V_d
B_en_cours=$B_d
A_en_cours=$A_d
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==4}&&{$Rendu>2}}
R_en_cours=$R_e
V_en_cours=$V_e
B_en_cours=$B_e
A_en_cours=$A_e
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==5}&&{$Rendu>3}}
R_en_cours=$R_f
V_en_cours=$V_f
B_en_cours=$B_f
A_en_cours=$A_f
-endif
-if {{{($Nb_boucles%{$Rendu+2})}==6}&&{$Rendu>4}}
R_en_cours=$R_g
V_en_cours=$V_g
B_en_cours=$B_g
A_en_cours=$A_g
-endif
Angle_Rayon_De_Couleur_En_Cours_A={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_A}
Angle_Rayon_De_Couleur_En_Cours_Fin_A={{{$Nb_boucles+1}*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_A}
Angle_Rayon_De_Couleur_En_Cours_B={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_B}
Angle_Rayon_De_Couleur_En_Cours_Fin_B={{{$Nb_boucles+1}*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_B}
-polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_A})}}},1,$R_en_cours,$V_en_cours,$B_en_cours,$A_en_cours
-polygon[-2] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_B})}}},1,$R_en_cours,$V_en_cours,$B_en_cours,$A_en_cours
-if {$Affichage_Contours==1}
-line[-3] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-line[-4] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
Nb_boucles={$Nb_boucles+1}
-done
-dilate_circ[-3,-4] 2
-twirl[-1,-3] $Amplitude_Twirl,50%,50%,0
-twirl[-2,-4] -$Amplitude_Twirl,50%,50%,0
-blend[-3,-4] alpha,1,0
# contour cercle
-if {$Affichage_Contours==1}
-ellipse[-3] 50%,50%,$Rayon_Cercle_Final,$Rayon_Cercle_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-3] 50%,50%,{$Rayon_Cercle_Final-1},{$Rayon_Cercle_Final-1},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-ellipse[-3] 50%,50%,{$Rayon_Cercle_Final-2},{$Rayon_Cercle_Final-2},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
-endif
-if {$Dilate_Contours>1} -dilate_circ[-3] $Dilate_Contours -endif
-if {$Flou_Contours>0} -blur[-3] $Flou_Contours,0 -endif
-if {$Sharpen_Contours>0} -sharpen[-3] $Sharpen_Contours -endif
-if {$Filtre_Symmetrizoscope==1}
-gimp_symmetrizoscope[-1,-2,-3] $Iterations_Symmetrizoscope,$Angle_Symmetrizoscope,0,$Symmetry_Sides
-endif
# creation masque temporaire rond
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 255,255,255,255
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,0
# mlanges
-blend[-4,-1] alpha,1,0
-replace_color[-3] 100%,0,255,255,255,255,0,0,0,0
# creation masque temporaire rond
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
# mlanges
-reverse[-1,-3]
-blend[-3,-1] add,1,0
# creation masque temporaire rond
$Dimension_Finale,$Dimension_Finale,1,4
-fill_color[-1] 0,0,0,0
-circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
# mlanges
-reverse[-1,-2]
-blend[-2,-1] add,1,0
-if {$Melanges_Rayons==0}
-blend[-1,-2] add,1,0
-elif {$Melanges_Rayons==1}
-blend[-1,-2] and,1,0
-elif {$Melanges_Rayons==2}
-blend[-1,-2] average,1,0
-elif {$Melanges_Rayons==3}
-blend[-1,-2] darken,1,0
-elif {$Melanges_Rayons==4}
-blend[-1,-2] difference,1,0
-elif {$Melanges_Rayons==5}
-blend[-1,-2] edges,1,0
-elif {$Melanges_Rayons==6}
-blend[-1,-2] grainextract,1,0
-elif {$Melanges_Rayons==7}
-blend[-1,-2] grainmerge,1,0
-elif {$Melanges_Rayons==8}
-blend[-1,-2] multiply,1,0
-elif {$Melanges_Rayons==9}
-blend[-1,-2] negation,1,0
-elif {$Melanges_Rayons==10}
-blend[-1,-2] or,1,0
-elif {$Melanges_Rayons==11}
-blend[-1,-2] screen,1,0
-elif {$Melanges_Rayons==12}
-blend[-1,-2] softburn,1,0
-elif {$Melanges_Rayons==13}
-blend[-1,-2] softdodge,1,0
-elif {$Melanges_Rayons==14}
-blend[-1,-2] subtract,1,0
-elif {$Melanges_Rayons==15}
-blend[-1,-2] xor,1,0
-elif {$Melanges_Rayons==16}
-endif
-c[-1,-2] 0,255
-if {$Supprimer_Calque_Origine==1}
-if {$Melanges_Rayons==16}
-reverse[-3,-2,-1]
-else
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-endif
-else
-if {$Melanges_Rayons==16}
-reverse[-3,-2,-1,0]
-else
-reverse[-1,-2]
-blend[-1,-2] alpha,1,0
-reverse[0,-1]
-endif
-endif
samj_CorLine:
Balance_Couleurs=$1
Chroma_Couleurs=$2
Nettete_A=$3
Nettete_B=$4
Type_Reparation=$5
Amplitude_Reparation=$6
Repetition_Reparation=$7
--Je_passe_l_hiver_en_Floride[0]
-to_rgb[-1]
-gimp_balance_gamma[-1] {127+$Balance_Couleurs},{127+$Balance_Couleurs},{127+$Balance_Couleurs},1
-gimp_boost_chroma[-1] {$Chroma_Couleurs/100},1
-gimp_unsharp_octave[-1] 1,5,$Nettete_A,0,2,0,24
-if {$Type_Reparation==0}
-repeat $Repetition_Reparation
-gimp_anisotropic_smoothing[-1] $Amplitude_Reparation,0.7,0.3,0.6,1.1,0.8,30,2,0,1,1,2
-done
-elif {$Type_Reparation==1}
-repeat $Repetition_Reparation
-gimp_diffusion_smoothing[-1] 0.7,0.3,0.6,{0.5+{$Amplitude_Reparation/100}},15,8,0,0,24
-done
-endif
-if {$Nettete_B>0} -gimp_unsharp_octave[-1] 1,5,$Nettete_B,0,2,0,24 -endif
-reverse[-1,-2]
samj_CorLine_preview :
-gimp_split_preview "-samj_CorLine $*",$-1
samj_rien_sequences :
-Je_passe_l_hiver_en_Floride[-1]
samj_rien_various :
-Je_passe_l_hiver_en_Floride[-1]
gimp_blend_1651 :
mode=${-arg\ 1+$1,add,alpha,and,average,blue,burn,darken,difference,\
divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
shapeaverage,shapeaverage0,softburn,softdodge,softlight,screen,stamp,subtract,value,\
vividlight,xor}
-if {$2==0} -repeat {int($!/2)} -l[$>,{$>+1}] -rv -blend $mode,$3,$4 -endl -done
-elif {$2==1" && "$!>1} -blend[^0] [0],$mode,$3,1 -rm[0]
-elif {$2==2" && "$!>1} -blend[^-1] [-1],$mode,$3,0 -rm[-1]
-endif
trait_epais_samj :
## Variables
-verbose -
-if {{$3-$1}==0} X1={$1-{$5/2}} Y1=$2 X2={$3-{$5/2}} Y2=$4 X3={$3+{$5/2}} Y3=$4 X4={$1+{$5/2}} Y4=$2
-else
-if {{$4-$2}==0} X1=$1 Y1={$2+{$5/2}} X2=$3 Y2={$4+{$5/2}} X3=$3 Y3={$4-{$5/2}} X4=$1 Y4={$2-{$5/2}}
-else angle_triangle={{{pi}/2}-{atan({{$4-$2}/{$3-$1}})}} X_triangle={{$5/2}*{cos($angle_triangle)}} Y_triangle={{$5/2}*{sin($angle_triangle)}}
X1={$1-$X_triangle} Y1={$2+$Y_triangle} X2={$3-$X_triangle} Y2={$4+$Y_triangle} X3={$3+$X_triangle} Y3={$4-$Y_triangle} X4={$1+$X_triangle} Y4={$2-$Y_triangle}
-endif
-endif
-polygon[-1] 4,$X1,$Y1,$X2,$Y2,$X3,$Y3,$X4,$Y4,1,$7,$8,$9,$10
-if {$6==1} -circle[-1] $1,$2,{$5/2},1,$7,$8,$9,$10 -circle[-1] $3,$4,{$5/2},1,$7,$8,$9,$10 -endif
-verbose +
samj_sierpinski_absolu : -check ${1=7}>=0 -skip ${2=0},${3=0},${4=10},${5=100},${6=150},${7=20},${8=255},${9=255},${10=0},${11=255}
-e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
-v - -_samj_sierpinski_absolu ${2-11},$1  -v +
_samj_sierpinski_absolu :
-if {$11<=0} -polygon 3,$1,$2,$3,$4,$5,$6,1,$7,$8,$9,$10 -return -endif
-_samj_sierpinski_absolu $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},$7,$8,$9,$10,{$11-1}
-_samj_sierpinski_absolu {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},$7,$8,$9,$10,{$11-1}
-_samj_sierpinski_absolu {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},$7,$8,$9,$10,{$11-1}
samj_snowflake_absolu :
-v -
-to_rgba
-polygon 3,$2,$3,$4,$5,$6,$7,${8--1},255
-_samj_snowflake_absolu $1,$2,$3,$6,$7,${8--1}
-_samj_snowflake_absolu $1,$6,$7,$4,$5,${8--1}
-_samj_snowflake_absolu $1,$4,$5,$2,$3,${8--1}
-v +
_samj_snowflake_absolu :
x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
c={cos(-pi/3)} s={sin(-pi/3)}
x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
-polygon 3,$x0,$y0,$x1,$y1,$x2,$y2,${6--1},255
-if $1
-_samj_snowflake_absolu {$1-1},$2,$3,$x0,$y0,${6--1}
-_samj_snowflake_absolu {$1-1},$x0,$y0,$x2,$y2,${6--1}
-_samj_snowflake_absolu {$1-1},$x2,$y2,$x1,$y1,${6--1}
-_samj_snowflake_absolu {$1-1},$x1,$y1,$4,$5,${6--1}
-endif
samj_snowflake_contours_absolu :
-v -
-to_rgba
-polygon 3,$2,$3,$4,$5,$6,$7,$8,0xFFFFFFFF,$9,$10,$11,255
-_samj_snowflake_contours_absolu $1,$2,$3,$6,$7,${8--1}
-_samj_snowflake_contours_absolu $1,$6,$7,$4,$5,${8--1}
-_samj_snowflake_contours_absolu $1,$4,$5,$2,$3,${8--1}
-v +
_samj_snowflake_contours_absolu :
x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
c={cos(-pi/3)} s={sin(-pi/3)}
x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
-polygon 3,$x0,$y0,$x1,$y1,$x2,$y2,$6,0xFFFFFFFF,${7--1},255
-if $1
-_samj_snowflake_contours_absolu {$1-1},$2,$3,$x0,$y0,${6--1}
-_samj_snowflake_contours_absolu {$1-1},$x0,$y0,$x2,$y2,${6--1}
-_samj_snowflake_contours_absolu {$1-1},$x2,$y2,$x1,$y1,${6--1}
-_samj_snowflake_contours_absolu {$1-1},$x1,$y1,$4,$5,${6--1}
-endif
twirl_ancien_euclidean2polar_ancien_polar2euclidean : -skip ${1=1},${2=50%},${3=50%},${4=1}
-e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center point at ($2%,$3%)."
-v - -euclidean2polar_ancien $2,$3,1,$4 -repeat $!
[$>],[$>],1,1,$1*x -channels[-1] -1,0 -warp[$>] [-1],1,1,2 -rm[-1]
-done -polar2euclidean_ancien $2,$3,1,1 -v +
euclidean2polar_ancien : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
-e[^-1] "Apply euclidean to polar transform on image$?."
-v - -repeat $! -l[$>]
({w},{h}) ($1,$2) -*[-2,-1] ({"sqrt(max("{@0}","{-2,w}"-"{@0}")^2 + max("{@1}","{-2,h}"-"{@1}")^2)"})
-a[-2,-1] x
[-2],[-2],1,1,{@2}"*(x/w)^$3*cos(y*2*pi/h)" -+[-1] {-2,@0}
[-1],[-1],1,1,{-2,@2}"*(x/w)^$3*sin(y*2*pi/h)" -+[-1] {-3,@1}
-rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
-endl -done -v +
polar2euclidean_ancien : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
-e[^-1] "Apply polar to euclidean transform on image$?."
-v - -repeat $! -l[$>]
({w},{h}) ($1,$2) -*[-2,-1] ({"sqrt(max("{@0}","{-2,w}"-"{@0}")^2 + max("{@1}","{-2,h}"-"{@1}")^2)"})
-a[-2,-1] x
[-2],[-2],1,1,"w*(sqrt((x-"{@0}")^2 + (y-"{@1}")^2)/"{@2}")^(1/$3)"
[-1],[-1],1,1,"(atan2(y-"{-2,@1}",x-"{-2,@0}")*h/(2*pi)+h)%h"
-rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
-endl -done -v +
samj_CorLine_B:
Balance_Couleurs=$1
Valeur_Gamma=$2
Chroma_Couleurs=$3
Cyan=$4
Magenta=$5
Jaune=$6
Nettete_A=$7
Nettete_B=$8
Type_Reparation=$9
Amplitude_Reparation=$10
Repetition_Reparation=$11
--Je_passe_l_hiver_en_Floride[0]
-to_rgb[-1]
-gimp_balance_gamma[-1] {127+$Balance_Couleurs},{127+$Balance_Couleurs},{127+$Balance_Couleurs},1
-gimp_boost_chroma[-1] {$Chroma_Couleurs/100},1
-gimp_unsharp_octave[-1] 1,5,$Nettete_A,0,2,0,24
-apply_gamma[-1] $Valeur_Gamma
-if {$Type_Reparation==0}
-repeat $Repetition_Reparation
-gimp_anisotropic_smoothing[-1] $Amplitude_Reparation,0.7,0.3,0.6,1.1,0.8,30,2,0,1,1,2
-done
-elif {$Type_Reparation==1}
-repeat $Repetition_Reparation
-gimp_diffusion_smoothing[-1] 0.7,0.3,0.6,{0.5+{$Amplitude_Reparation/100}},15,8,0,0,24
-done
-endif
-if {$Nettete_B>0} -gimp_unsharp_octave[-1] 1,5,$Nettete_B,0,2,0,24 -endif
-if {$Cyan!=0}
Cyan={127+$Cyan}
-apply_channels[-1] "-apply_curve 1,0,0,128,"$Cyan",255,255",cmy_c,0
-endif
-if {$Magenta!=0}
Magenta={127+$Magenta}
-apply_channels[-1] "-apply_curve 1,0,0,128,"$Magenta",255,255",cmy_m,0
-endif
-if {$Jaune!=0}
Jaune={127+$Jaune}
-apply_channels[-1] "-apply_curve 1,0,0,128,"$Jaune",255,255",cmy_y,0
-endif
-reverse[-1,-2]
samj_CorLine_B_preview :
-gimp_split_preview "-samj_CorLine_B $*",$-1
samj_CeKoaSa_001 :
-repeat $! -l[$>]
Smoothness_thin_edges=$1
Threshold_thin_edges=$2
Amplitude_ripple=$3
Boost=$4
Size_morpho=$5
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-gimp_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
--Je_passe_l_hiver_en_Floride[-1]
-ripple[-1] $Amplitude_ripple,20,2,0
-blend[-1,-2] average,1,1
-ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
-gimp_edges[-2] 0,15,0,0
-blend[-1,-2] average,1,1
-if {$Boost==1}
-gimp_balance_gamma[-1] 128,128,128,1
-endif
-gimp_morpho[-1] 0,$Size_morpho,0,2,0,1
-gimp_normalize_local[-2] 2,6,5,20,1,3
-blend[-1,-2] softlight,1,0
-gimp_LCE[-1] 80,0.5,1,1,3,0
-endl -done
samj_CeKoaSa_001_preview :
-gimp_split_preview "-samj_CeKoaSa_001 $*",$-1
samj_CeKoaSa_002 :
-repeat $! -l[$>]
Smoothness_thin_edges=$1
Threshold_thin_edges=$2
Amplitude_ripple=$3
Boost=$4
Size_morpho=$5
Valider_Otsu=$6
-to_rgba[-1]
-gimp_frame[-1] 0,100,0,100,1,1,0,0,0,255,1,255,255,255,255
-if {$Valider_Otsu==1}
-otsu[-1] 4 -n[-1] 0,255
-endif
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-gimp_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
--Je_passe_l_hiver_en_Floride[-1]
-ripple[-1] $Amplitude_ripple,20,2,0
-blend[-1,-2] average,1,1
-ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
-gimp_edges[-2] 0,15,0,0
-blend[-1,-2] average,1,1
-if {$Boost==1}
-gimp_balance_gamma[-1] 128,128,128,1
-endif
-gimp_morpho[-1] 0,$Size_morpho,0,2,0,1
-gimp_normalize_local[-2] 2,6,5,20,1,3
-blend[-1,-2] softlight,1,0
-Polygonize_GUI[-1] 10,10,10,10,10,0
-gimp_LCE[-1] 80,0.5,1,1,3,0
-endl -done
samj_CeKoaSa_002_preview :
-gimp_split_preview "-samj_CeKoaSa_002 $*",$-1
samj_CeKoaSa_003 :
-repeat $! -l[$>]
Smoothness_thin_edges=$1
Threshold_thin_edges=$2
Amplitude_ripple=$3
Boost=$4
Size_morpho=$5
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
--Je_passe_l_hiver_en_Floride[-1]
-gimp_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
--Je_passe_l_hiver_en_Floride[-1]
-ripple[-1] $Amplitude_ripple,20,2,0
-blend[-1,-2] average,1,1
-ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
-gimp_edges[-2] 0,15,0,0
-blend[-1,-2] average,1,1
-if {$Boost==1}
-gimp_balance_gamma[-1] 128,128,128,1
-endif
-gimp_morpho[-1] 0,$Size_morpho,0,2,0,1
-gimp_normalize_local[-2] 2,6,5,20,1,3
-blend[-1,-2] softlight,1,0
-gimp_LCE[-1] 80,0.5,1,1,3,0
-Polygonize_GUI[-2] 10,10,10,10,10,0
-gimp_gaussian_blur[-2] 20,0,0,1,0,0
-blend[-1,-2] average,0.5,1
-endl -done
samj_CeKoaSa_003_preview :
-gimp_split_preview "-samj_CeKoaSa_003 $*",$-1
samj_CeKoaSa_004 :
-repeat $! -l[$>]
Modulo=$1
Negatif=$2
B_W_pencil_amplitude=$3
Opacity_blend_edges=$4
Denoise_Image=$5
-to_rgb[-1]
--Je_passe_l_hiver_en_Floride[-1]
-mod[-1] {20+$Modulo}
-n[-1] 0,255
-gimp_ditheredbw[-1] 0,1,0,0,0,0
-if {$Negatif==1}
-negative[-1]
-endif
-if {$B_W_pencil_amplitude>0}
-pencilbw[-1] 0.3,$B_W_pencil_amplitude
-endif
-gimp_blend_edges[-1,-2] 1,$Opacity_blend_edges,0
-if {$Denoise_Image>0}
-denoise[-1] $Denoise_Image,$Denoise_Image,5,6,1,0
-endif
-endl -done
samj_CeKoaSa_004_preview :
-gimp_split_preview "-samj_CeKoaSa_004 $*",$-1
samj_CeKoaSa_005 :
-repeat $! -l[$>]
Grille_X=$1
Grille_Y=$2
Grille_Carree_X=$3
Grille_Carree_Y=$4
Intensite=$5
Mode_Melange=$6
Opacity_Melange=$7
Revert_layers_Melange=$8
Normaliser=$9
--Je_passe_l_hiver_en_Floride[-1]
-if {$Grille_Carree_X==1}
Grille_Y=$Grille_X
-endif
-if {$Grille_Carree_Y==1}
Grille_X=$Grille_Y
-endif
-rand[-1] 0,255
-imagegrid[-1,-2] $Grille_X,$Grille_Y
--Je_passe_l_hiver_en_Floride[-1]
-blend[-1,-2] add,$Intensite,0
-gimp_blend_1651[-1,-2]  $Mode_Melange,0,$Opacity_Melange,$Revert_layers_Melange,1
-if {$Normaliser==1}
-n[-1] 0,255
-endif
-to_colormode[-1] 4
-endl -done
samj_CeKoaSa_005_preview :
-gimp_split_preview "-samj_CeKoaSa_005 $*",$-1
Je_passe_l_hiver_en_Floride :
Polygonize_GUI :
-repeat $! -l[$>]
-polygonize[-1] $1,$2,$3,$4,$5
-if {$6==1} -to_rgba[-1] -gimp_frame[-1] 0,100,0,100,1,1,0,0,0,255,1,255,255,255,255 -otsu[-1] 4 -n[-1] 0,255 -polygonize[-1] $1,$2,$3,$4,$5 -endif
-endl -done
Polygonize_GUI_preview :
-gimp_split_preview "-Polygonize_GUI $*",$-1
gimp_recolorize_20130115_modifie :
Smoothness=$1
Nuances=$2
Normalize_A=$3
Normalize_B=$4
Degoulinade_A=$5
Degoulinade_B=$6
Precision=$7
-rv[-2,-1]
-dilate_circ[-1] $Degoulinade_A
-if {$Nuances==0}
-channels[-2] 0
-elif {$Nuances==1}
-gimp_decompose_channels[-2] 4,0,1,0 -remove[-2,-3]
-elif {$Nuances==2}
-to_rgb[-2] -rgb2hsl8[-2] -split[-2] c -rm[-3,-4]
-elif {$Nuances==3}
-to_rgb[-2] -rgb2lab8[-2] -split[-2] c -rm[-2,-3]
-elif {$Nuances==4}
-to_rgb[-2] -rgb2cmyk[-2] -split[-2] c -rm[-3,-4,-5] -negative[-2]
-endif
-to_rgb[-2] -to_rgba[-1]
-n[-2] $Normalize_A,$Normalize_B
-split_opacity[-1]
-neq[-1] 0
# il y a 3 images : -3=l'image grise  -2=les couleurs  -1=le masque
-srgb2rgb[-3,-2]
-rgb2lab8[-3,-2]
-channels[-3] 0
-channels[-2] 1,2
-+[-2] 1
-*[-2] [-1]
--gradient_norm[-3]
-blur[-1] $Degoulinade_B
-*[-1] -1
-watershed[-3] [-1]
-rm[-1]
--[-2] 1
# Get first estimate for the color interpolation.
-if {$Precision==1}
--diffusiontensors[-3] 0,1,1,1
-eq[-2] 0
-*[-1] [-2]
-rm[-2]
-smooth[-2] [-1],$Smoothness,0.8,45,2,0
-endif
-rm[-1]
-a[-2,-1] c
-lab82rgb[-1]
-rgb2srgb[-1]
samj_test_A :
-or[-1] {$1} -to_rgb[-1] -and[-1] {$2} -smooth[-1] $3 -n[-1] 0,255 -Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0
samj_test_B :
-samj_Points_Aleatoires_001[-1] $1,255,255,0,255,3,1,1 --Je_passe_l_hiver_en_Floride[-1] -gimp_flower[-1] 30,6,100,0,50,50,1 -to_rgb[-1] -smooth[-1] 500 -n[-1] 0,255 -Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0 -gimp_boost_chroma[-1] 1,0,0
samj_test_C :
-samj_Points_Aleatoires_001[-1] $1,255,255,0,255,3,1,1 --Je_passe_l_hiver_en_Floride[-1] -gimp_segment_watershed[-1] 8,0,0,0,0 -gimp_flower[-1] 10,20,0,360,50,50,1 -Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0
samj_test_D :
Var_sub=$1
Var_n=$2
Var_spread=$3
Var_dilate=$4
Var_blur=$5
Deformation=$6
Levels=$7
Smoothness=$8
Var_dilate_circ=$9
Inner_fading=$10
Outer_fading=$11
--Je_passe_l_hiver_en_Floride[-1]
-if {$Var_sub>0}
-sub[-1] $Var_sub
-abs[-1]
-endif
-n[-1] 0,$Var_n
-if {$Var_spread>0} -spread[-1] $Var_spread -endif
-if {$Var_dilate>0} -dilate[-1] $Var_dilate -endif
-if {$Var_blur>0} -blur[-1] $Var_blur -endif
-if {$Deformation>0} -deform[-1] $Deformation -endif
-gimp_isophotes[-2] $Levels,$Smoothness,0
-if {$Var_dilate_circ>0} -dilate_circ[-2] $Var_dilate_circ -endif
-gimp_blend_seamless[-2,-1] 0,$Inner_fading,$Outer_fading,0,0
samj_test_E :
exemple=$1
sharpness=$2
anisotropy=$3
alpha=$4
sigma=$5
is_sqrt=$6
rf=$7
vf=$8
bf=$9
Mode=$10
Opacity=$11
-if {$exemple==1}
anisotropy=0
alpha=0
sigma=0
-elif {$exemple==2}
anisotropy=0
alpha=4
sigma=0
-elif {$exemple==3}
sharpness=0.5
anisotropy=0.3
alpha=$4
sigma={$sigma/10}
is_sqrt=1
-endif
-diffusiontensors[-1] $sharpness,$anisotropy,$alpha,$sigma,$is_sqrt
-n[-1] 0,255
-equalize[-1]
-gimp_decompose_channels[-1] 4,0,1,0
-remove[-1,-2]
-to_rgb[-1]
-gimp_8bits[-1] 100,10000,256
{w},{h},1,3
-fill_color[-1] $rf,$vf,$bf
-gimp_blend_1651[-1,-2] $Mode,0,$Opacity,0
samj_test_F :
-repeat $3
-gimp_custom_deformation "cos(x*$1)*$2*sin(y)*(w+h)/10000","cos(y*$1)*$2*sin(x)*(w+h)/10000",1,1,1
-done
samj_test_G :
-gimp_spread $1,$1,0,0,0
-gimp_boost_fade[-1] $2,0
--Je_passe_l_hiver_en_Floride[-1]
-gimp_local_orientation[-1] $3,0,100,0,16,0
-gimp_blend[-1,-2] 14,0,1,1
-gimp_lightglow[-1] $4,0.5,8,0.8,0,0
samj_test_x_color_curves :
Utiliser=$1
Appliquer_courbes=$2
-if {$Utiliser==0}
-if {$Appliquer_courbes==0}
-blur[-1] 5
-elif {$Appliquer_courbes==1}
-x_color_curves[-1] last
-elif {$Appliquer_courbes==2}
-x_color_curves[-1] rgb
-elif {$Appliquer_courbes==3}
-x_color_curves[-1] cmy
-elif {$Appliquer_courbes==4}
-x_color_curves[-1] cmyk
-elif {$Appliquer_courbes==5}
-x_color_curves[-1] hsi
-elif {$Appliquer_courbes==6}
-x_color_curves[-1] hsl
-elif {$Appliquer_courbes==7}
-x_color_curves[-1] hsv
-elif {$Appliquer_courbes==8}
-x_color_curves[-1] lab
-elif {$Appliquer_courbes==9}
-x_color_curves[-1] lch
-elif {$Appliquer_courbes==10}
-x_color_curves[-1] ycbcr
-endif
-else
-if {$Appliquer_courbes==0}
-blur[-1] 5
-elif {$Appliquer_courbes==1}
-deform[-1] 20
-elif {$Appliquer_courbes==2}
-gimp_curves_interactive[-1] 0,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==3}
-gimp_curves_interactive[-1] 1,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==4}
-gimp_curves_interactive[-1] 2,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==5}
-gimp_curves_interactive[-1] 3,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==6}
-gimp_curves_interactive[-1] 4,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==7}
-gimp_curves_interactive[-1] 5,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==8}
-gimp_curves_interactive[-1] 6,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==9}
-gimp_curves_interactive[-1] 7,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-elif {$Appliquer_courbes==10}
-gimp_curves_interactive[-1] 8,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
-endif
-endif
samj_test_tout_interactif :
-x_paint[-1]
-threshold[-1]
-n[-1] 0,255
disco_preview :
-disco ${1--1}
disco :
-repeat $! -l[$>]
-sh. 0
-f. "
init(
rl=$1;
gl=$2;
bl=$3;
zoom=$4;
q=2*pi;
);
X=(2*x/(w-1))-1;
Y=1-(2*y/(h-1));
a=atan2(Y,X);
if (a<0,a=a+(2*pi));
r=sqrt(X*X+Y*Y);
rz=r*zoom;
RRR=abs(sin(rz/rl+q)+sin(a*rl+q));
GGG=abs(sin(rz/gl+q)+sin(a*gl+q));
BBB=abs(sin(rz/bl+q)+sin(a*bl+q));
i(#0,x,y,0,1)=GGG*255;
i(#0,x,y,0,2)=BBB*255;
RRR*255"
-rm.
-endl -done
moon2panorama_preview :
-moon2panorama ${1--1}
moon2panorama :
-repeat $! -l[$>]
--f. 0
-sh. 0
-f. "
init(
center_help=$1;
center_x=$2;
center_y=$3;
span=$4;
shift_x=$5;
shift_y=$6;
Antialias = $7;
XEdgeType = $8;
YEdgeType = $9;
AR=w/h;
if (AR>1, W=2;H=2/AR,H=2;W=2/AR);
minXY=min(W/2,H/2);
);
if (AR>1,
X=(2*x/(w-1))-1;
Y=(1-(2*y/(h-1)))/AR,
X=((2*x/(w-1))-1)/AR;
Y=1-(2*y/(h-1))
);
scaled=X/W*span;
scaledi=(Y/(1+9*center_help))/W*span;
shifted=(scaled-shift_x)*pi/180;
shiftedi=(scaledi-shift_y)*pi/180;
reshifted=shiftedi;
reshiftedi=-shifted;
remapped=-exp(reshifted)*sin(reshiftedi);
remappedi=exp(reshifted)*cos(reshiftedi);
centered=(remapped*0.8+center_x/100)*minXY;
centeredi=(remappedi*0.8+center_y/100)*minXY;
if (center_help && abs(2*Y/H)<0.01,
outR=255;
outG=255;
outB=0;
outA=255,
if (AR>1,
realx=(centered+1)*(w-1)/2;
realy=(1-AR*centeredi)*(h-1)/2,
realx=(AR*centered+1)*(w-1)/2;
realy=(1-centeredi)*(h-1)/2
);
if(realx<0 || realx>=w,
if(XEdgeType==1,
realx=realx%w;
if(realx<0,realx=w+realx)
);
if(XEdgeType==2,
realx=abs(realx%w);
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
if(XEdgeType==3,
realx=abs(realx%w);
realy=h-realy;
if(realx<w/2,realx=w-realx,realx=abs(realx-w))
);
);
if(realy<0 || realy>=h,
if(YEdgeType==1,
realy=realy%h;
if(realy<0,realy=h+realy)
);
if(YEdgeType==2,
realy=abs(realy%h);
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
if(YEdgeType==3,
realy=abs(realy%h);
realx=w-realx;
if(realy<h/2,realy=h-realy,realy=abs(realy-h))
);
);
outR=i(#0,realx,realy,0,0,Antialias);
outG=i(#0,realx,realy,0,1,Antialias);
outB=i(#0,realx,realy,0,2,Antialias);
outA=i(#0,realx,realy,0,3,Antialias);
);
i(#1,x,y,0,1)=outG;
i(#1,x,y,0,2)=outB;
i(#1,x,y,0,3)=outA;
outR"
-k..
-endl -done
gimp_souphead_filter :
-b $1
gimp_souphead_filter_preview :
-gimp_souphead_filter $1
-text_outline "Preview only",5,5,24,2,1,255,128,255
spiral_RGB_preview :
-spiral_RGB ${1--1}
spiral_RGB :
-repeat $! -l[$>]
-sh. 0
-f. "
init(
red_rotations=$1;
green_rotations=$2;
blue_rotations=$3;
if ($4==1,direction=-1,direction=1);
);
X=(2*x/(w-1))-1;
Y=1-(2*y/(h-1));
a=atan2(Y,X);
if (a<0,a=a+(2*pi));
r=sqrt(X*X+Y*Y);
RRR=sin(r*red_rotations*pi*2+a*direction+2*pi)*0.5+0.5;
GGG=sin(r*green_rotations*pi*2+a*direction+2*pi)*0.5+0.5;
BBB=sin(r*blue_rotations*pi*2+a*direction+2*pi)*0.5+0.5;
i(#0,x,y,0,1)=GGG*255;
i(#0,x,y,0,2)=BBB*255;
RRR*255"
-rm.
-endl -done
mc_flou:
-if {$4==0}
-to_rgb
-apply_gamma[0] $5
-cut[0] $6,$7 -normalize[0] 0,255
-split[0] c
-apply_gamma[0] $8
-apply_gamma[1] $9
-apply_gamma[2] $10
-append[0,1,2] c
-endif
--gimp_gradient_norm[0] 0,1.5,0,50.38,1,0
-sharpen[0] $1
-b[1] 0.5
-normalize[1] 0,255
-equalize[1] 4,0%,98%
--append[0,1] c
-blur[2] $2
-blend[0,2] alpha,$3
-remove_opacity[0]
-keep[0]
mc_flou_preview:
-gimp_split_preview "-mc_flou $*",$-1
mc_pendraw:
-repeat $! -l[$>]
-split_opacity
-l[0]
-to_rgb
-if {$10>0}
[0]
-b[0] 1
-negative[0]
-luminance[0]
-rv[0,1]
-blend[0,1] overlay,$10
-endif
--gimp_gradient_norm[0] 0,1.5,0,50.38,1,0
[0]
-smooth $1,0.2,1,3,3
-b $2
-sharpen $3
[0]
-r[0] 20,20,1,3,2
-equalize[0] 256,0%,98%
-index[3] [0],1,1
-rm[0]
-nm[0] linee
-nm[1] orig
-nm[2] pen
-if {$7==0}
-rv[pen,linee]
-blend[pen,linee] multiply,1
-elif {$7==1}
-rv[orig,linee]
-blend[orig,linee] multiply,1
-endif
-normalize[0] 5,250
-autoindex[0] $4,$5
-rv[0,1]
-blend[0,1] value,$6
-if {$8==1}
-equalize 21,30,$9
-endif
-endl -a c -endl -done
mc_pendraw_preview:
-gimp_split_preview "-mc_pendraw $*",$-1
gimp_tk_about :
-gimp_logo "Tom Keils Filters"
tk_gimp_channel_processing :
-gimp_channel_processing {log($1)},${2--1}
tk_gimp_select_color :
($4^$5^$6^$7) -_gimp_select_color[-1] $1 color={^} -rm[-1]
-repeat $!
-if {$8==0}
--_gimp_select_color[-1] $1
-select_color[-1] $2%,$color
-b[-1] $3%
-if $9 -*[-1] -1 -+[-1] 1 -endif
-to_rgba[-2] -s[-2] c -*[-2,-1] -a[-4--1] c
-else
-_gimp_select_color[-1] $1
-select_color[-1] $2%,$color
-b[-1] $3
-if $9 -*[-1] -1 -+[-1] 1 -endif
-*[-1] 255 -r[-1] 100%,100%,1,4
-endif
-mv[-1] 0 -done
tk_gimp_replace_color :
-to_rgba -replace_color $1,$2%,${3--1} -c 0,255
gimp_tk_retouch :
-repeat $! -l[$>]
-if {$8==1}
--gimp_edges $5,$4,0,0 -gimp_gaussian_blur {$5*5},0,0,1,1,0,0
-else
--to_rgba[0]  --to_gray[0] -gimp_edges[2] $5,$4,0,0
-gimp_gaussian_blur[2] {$5*5},0,0,1,1,0,0 -to_gray[2] --to_rgba[0] --negative[2]
-gimp_highpass[1] {$1},2,1,1,0
-gimp_gaussian_blur[1] $2,0,0,1,1,0,0
-to_rgba[0]
-if {$9==1}  --to_rgba[0] -channels[5] 0
-tk_gimp_channel_processing[5] 1,1,4,0,0,0,100,256,0,0,0,2,7,0
-gimp_gaussian_blur[5] {{w+h}/1000},0,0,1,0,0,0 -to_gray[5] -endif
-split[1] c  -reverse[4,5] -compose_multiply[4,5]
-if {$9==1} -reverse[4,-1] -compose_multiply[4,-1] -endif
-append[-6,-5,-4,-3] c
-reverse[0,1] -gimp_compose_softlight[0,1] {$3/5}
-gimp_unsharp[-2] 0,$6,30,$7,0.00,1.00,0.5,1,0,7,0
-split[-2] c  -reverse[-1,-2] -compose_multiply[-1,-2] -append[-4,-3,-2,-1] c
-blend[0,1] alpha
-endif
-endl -done
gimp_tk_retouch_preview :
-gimp_split_preview "-gimp_tk_retouch ${1--2}",$-1
gimp_tk_dof :
-if {{$8==0}||{$8==1}} -if {{$!}!=1} -error[] "Select input mode ACTIVE. This option is available for single layer only."
-endif -endif
-if {{$8==2}||{$8==3}} -if {{$15==3}||{$15==4}||{$17==3}} -error[] "Option not available for individual mask" -endif -endif
-if {{$8==2}||{$8==3}} -if {{$!}!=2} -error[] "For individual mask select input mode ACTIVE AND BELOW" -endif -endif
tr={$5} dfs={$6} bsi={$11} bsb={$12}
-if {$19==1} scdo=50 scup=200 tr={$5/2} dfs={$6/2} bsi={$11/2} bsb={$12/2} -endif
-if {$19==2} scdo=25 scup=400 tr={$5/4} dfs={$6/4} bsi={$11/4} bsb={$12/4} -endif
-if {{$8==0}||{$8==1}} -if {$19!=0} --r[0] $scdo%,$scdo% -else [0] -endif
-else -if {$19!=0} -r[-1] $scdo%,$scdo% -endif -endif
-if {$19!=0} --r[0] $scdo%,$scdo% -else [0] -endif
-if {{$8==2}||{$8==3}} -rv[-1,-2] -endif
-if {{$15==0}||{$15==1}||{$15==2}}
-if {$8==0} -gimp_tk_autodepth[-1]
-elif {$8==1} -gimp_tk_depthmap[-1] 1,20,0,0,0,0,0
-elif {{$8==2}||{$8==3}} -endif
-if {$18!=3} -if {$8!=2}
-if {$20==1} -to_rgb[-1]
--f[-1] if(i>={{255-$3}+{$4/2}},0,i)
--f[-1] if(i<={{255-$3}-{$4/2}},0,i) -compose_darken[-1,-2]
-n[-1] 0,255 -f[-1] if(i>=1,255,i) -rm[-2]
-else
-local_similarity_mask[-1] $1,$2,$3,$4,4,0
-endif
-blur_xy[-1] $tr
-endif -endif
-endif
-if {{$15==1}||{$15==3}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,180,100,$16
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,180,0,$17
-compose_darken[-1,-2]
-endif
-if {{$15==2}||{$15==4}}
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,1,90,100,$16
--gimp_linear_gradient[-1] 0,0,0,255,255,255,255,255,0,90,0,$17
-compose_darken[-1,-2]
-endif
-if {{$15==1}||{$15==2}} -rv[-1,-2] -compose_lighten[-1,-2] -endif
-if {{$15==3}||{$15==4}} -rm[-2] -endif
-if {{$18==0}||{$18==1}}
-if {$14==1} [-1,-2]
-blur_xy[-1] {$tr/2}
-ir[-1] 1,256 -n[-1] 0,255
-tk_gimp_replace_color[-1] 1,0,0,0,0,255,0,0,0,0
-inpaint[-2] [-1] -rm[-1,1] -rv[-1,-2]
-endif
-if {$7==0} -median[-2] $dfs
-elif {$7==1} -blur_xy[-2] $dfs
-elif {$7==2} -median[-2] {$dfs/2} -blur_xy[-1] {$dfs/5}
-endif
-if {$9!=0} -if {$19==0}  [0] -else --r[0] $scdo%,$scdo% -endif
-gimp_morpho[-1] 1,$bsi,0,{2-$13},0,1,0
-tk_gimp_replace_color[-1] {$10*1.765},0,0,0,0,255,0,0,0,0
-blur_xy[-1] $bsb
-rv[-1,-3] -gimp_compose_lighten[-1,-3] $9
-endif
-if {$19!=0} -r[1,2] $scup%,$scup% -endif
-to_rgba[0] -s[0] c -rv[3,5]
-compose_multiply[3,5] -to_gray[3]
-a[0,1,2,3] c
-if {$18==0} -rv[0,1] -compose_rgba[0,1] -endif
-endif
-if {$18!=1} -k[-1] -endif
-if {{$18==2}||{$18==3}} -if {$19!=0} -r[-1] $scup%,$scup% -endif -endif
gimp_tk_dof_preview :
-to_rgba
-if {{$8==0}||{$8==1}} -if {{$!}!=1} -error[] "Select input mode ACTIVE. This option is available for single layer only."
-endif -endif
-if {{$8!=2}&&{$8!=3}}
-gimp_split_preview "-gimp_tk_dof ${1--2}",$-1
-else -gimp_tk_dof ${1--1} -endif
-to_rgba
-if {$20==0}
-line 100%,$2%,{$1+5}%,$2%,1,255,0,0
-line 0%,$2%,{$1-5}%,$2%,1,255,0,0
-line $1%,100%,$1%,{$2+5}%,1,255,0,0
-line $1%,0%,$1%,{$2-5}%,1,255,0,0
-endif
gimp_tk_infrared :
-repeat $! -l[$>]
--gimp_hsv_equalizer 0,120,{240*$4},{if({$2==0},0,$3)},{if({$2==0},-$1,{-1+$2})},$1,240,{120*$6},$5,0,-$1,0,0,0,0,0
-blur[-1] $7 -gimp_compose_alpha $1,0
-tk_gimp_channel_processing 1,$9,$8,0,0,0,100,256,0,0,0,2,0,0
-gimp_mix_lab 1,0,0,$10,0,0,$10,0,0,0,2,0
-if {$11==1} -gimp_blackandwhite 0.299,0,0.587,0,0.114,0,1,1,0,0,0,$12,$12,$12,2,{{w+h}/60000},0,0,16,4,0,0,0 -endif
-endl -done
gimp_tk_infrared_preview :
-gimp_split_preview "-gimp_tk_infrared ${1--2}",$-1
gimp_custom_code : -skip "${1=-skip ,}"
-m "_gimp_custom_code_start : $1"
-apply_channels "-_gimp_custom_code_start",$2,$3
-uncommand _gimp_custom_code_start
gimp_custom_code_preview : -skip "${1=-skip ,}"
w={w} h={h}
-l _gcp_arg="$1" -gimp_split_preview "-gimp_custom_code $_gcp_arg,${2--2}",$-1
-onfail
error_msg=${}
-rr2d $w,$h,2,1
-gimp_print_preview "Syntax error:",,$error_msg,15,40
-endl
gimp_gmic_demos :
coms=2048,blobs,bouncing,fire,fireworks,fisheye,fourier,histogram,hough,jawbreaker,landscape,life,light,\
mandelbrot,metaballs3d,minesweeper,minimal_path,pacman,paint,plasma,quantize_rgb,reflection3d,\
rubber3d,shadebobs,spline,tetris,tictactoe,waves,whirl
com=${-arg\ {1+$1},$coms}
-if {$!>0} sel=0 -else sel= -endif
--l[$sel] -m "foo : -x_"$com -foo -rm -uncommand foo -endl
gimp_gmic_demos_preview :
-rm filename=${-path_tmp}gmic_demos.cimgz
-if $filename $filename
-else -l[] http://gmic.eu/img/gmic_demos.cimgz -o $filename -endl
-endif
-k[$1,-1] -rows. $1 -map[0] [1] -k[0]
gimp_display_histogram :
-to_rgb -if $2 -luminance -endif
-repeat $!
-display_histogram. {w},{h},$1,0,255
-mv. 0 -done
gimp_import_image_16 :
ProcessTo=$2
Gamma=$3
Brightness=$4
Contrast=$5
Equalize=$6
AB=$7
A=$8
B=$9
CutHigh=$10
CutLow=$11
-rm -i
"$1"
-to_rgb
-if {$ProcessTo!=3}
-resize2dx 520,1
-endif
-apply_gamma $Gamma
-if {0,iM>256}
-if $Equalize
--equalize 65535
-blend alpha,{$Equalize/2}
-endif
#Scale values to 0 to 1 range
-div 65535
#Separate luminance from colour
-rgb2lab
-split c
-if $Brightness
-add[-3] $Brightness
-endif
-if {$Contrast!=1}
-mul[-3] $Contrast
-endif
#Adjust saturation by multiplying both A and B channels
-if $AB
-mul[-2] $AB
-mul[-1] $AB
-endif
#Adjust colour balance by multiplying A or B channel.
-if $A
-mul[-2] {1+$A}
-endif
-if $B
-mul[-1] {1+$B}
-endif
-append c
-lab2rgb
#RGB cut and normalize
-if {$CutHigh!=100" || "$CutLow!=0}
Range=1
HighValue={$CutHigh/100*$Range}
LowValue={$CutLow/100*$HighValue}
-cut $LowValue,$HighValue
-normalize 0,1
-endif
#Scale to 255 for Gimp
-mul 255
#Cut 0,255 for Gimp
-cut 0,255
-if {$ProcessTo==1}
--display_histogram {0,w},{0,h},255,0,254,0
-blend lighten,0.7
-endif
-if {$ProcessTo==2}
--display_histogram {0,w},{0,h},255,0,254,0,log(1+i)-1
-blend lighten,0.7
-endif
-endif
gimp_import_image :
-rm -i "$1" -s z -if $2 -n 0,255 -else -c 0,255 -endif
gimp_intarsia :
-to_rgb -repeat $! nm=${-gimp_layer_name[$>]} --l[$>]
-if {max(w,h)>$3} -rr2d $3,$3,0 -endif
--colormap 0
-if {w>$4} -rm. --colormap $4,1 -endif
-round[1] -index[0] [1]
0 -nm. $nm ({'{b}'}) -f. 'if(x,i,if(i>=97&&i<=122,i-32,i))' image_basename={t} -rm[-2,-1]
({'"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\
\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\
<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n\
<head></head><body bgcolor=\"#FFFDFF\"><center><font size=\"-1\">\n\
<h2>"$image_basename" ("{0,w}x{0,h}")</h2>\n\
<table border=\"0\" cellpadding=\"8\"><tr><td>\n\
<table border=\"0\" cellpadding=\"4\">\n"'})
0 -nm. "$2" image_name={b} -rm.
nb_cols={1,w}
-repeat $nb_cols
color={1,I($>)}
R={arg(1,$color)} G={arg(2,$color)} B={arg(3,$color)}
({'${-dec2hex\ {$R*65536+$G*256+$B}}'}) --. {'0'} -r. 6,1,1,1,0,0,1,0 -+. {'0'}
-f. if(i>=_'a'" && "i<=_'z',i+_'A'-_'a',i)
hcolor={t} -rm.
48,32,1,4 -fc. $color,255 -frame. 1,1,0,0,0,255 -o. "$1/"${image_name}_$>.png -rm.
({'"<tr><td><b>Colour "$>"</b></td><td><img src=\""${image_name}_$>.png"\" /></td><td>#"$hcolor"</td></tr>\n"'})
-done
({'"</table>\n</td><td>"'})
starting=${"-arg {1+$5},\"Top left\",\"Top right\",\"Bottom left\",\"Bottom right\""}
label=${"-arg {1+$6},Row,Column"}
-if $6 dir0="T &#8594; B" dir1="B &#8594; T" -else dir0="L &#8594; R" dir1="R &#8594; L" -endif
dir={arg(1+2*$5+$6,0,0,1,0,0,1,1,1)}
--map[0] [1]
--gimp_intarsia_preview. ${1-7},63 -drgba.
-rr2d.. 200,200,1,1
-to_rgba[-2,-1] -frame[-2,-1] 1,1,0,0,0,255 -frame[-2,-1] 0,20,0,0,0,0
-t.. "Result",0,0,16,1,0,0,0,255
-t. "Ordering overview",0,0,16,1,0,0,0,255
-frame[-2,-1] 20,20,0,0,0,0
-o.. "$1/"${image_name}_A.png
-o. "$1/"${image_name}_B.png
-rm[-2,-1]
({'"<table border=\"0\"><tr><td><img src=\""${image_name}_A.png"\" /></td></tr><tr><td><img src=\""${image_name}_B.png"\" /></td></tr></table></td></tr></table>\n"'})
-if $7 ({'"<p><b>Additional comments:</b><br/><textarea cols=\"80\" rows=\"10\" placeholder=\"Enter comments here...\"></textarea></p>\n"'}) -endif
({'"<p><b>Starting point:</b> "$starting"\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Orientation:</b> "$label" by "$label"</p>\n"'})
-rm[1]
({'"<table cellspacing=\"0\" cellpadding=\"4\" border=\"1\">\n"'})
-_gimp_intarsia[0] $5,$6,0
--l[0]
-s y
-repeat $! -l[$>]
-if {$>%2} -mirror. x -endif
im={im} -compress_rle 0,0 -rows 6,100%
({'"<tr><td valign=\"top\"><b>"$label" "{1+$>}"</b></td><td valign=\"top\">"${dir$dir}"</td><td>\n"'})
i=0 n=0 -do
val={0,i[$i]} i+=1
-if {$val>=0} occ=1
-else
occ={-$val}
val={0,i[$i]}
-if {$val<0} val=0 -else i+=1 -endif
-endif
val+=$im
({'"colour:<b>"$val"</b> "$occ'})
-if {0,$i<h} ({'", "'}) -endif
n+=1
-if {!($n%8)} ({'"<br/>\n"'}) -endif
-while {0,$i<h}
({'"</td></tr>\n"'})
-rm[0] -a x
dir={!$dir}
-endl -done
-a x
-endl
-rm[0]
({'"</table>\n</font></center>\n</body>"'})
-a x -o raw:"$1/$2",uchar
-rm
-endl -done
gimp_intarsia_preview :
-to_rgb -repeat $! -l[$>]
-if {max(w,h)>$3} -rr2d $3,$3,0 -endif
-to_rgba
-_gimp_intarsia $5,$6,0
100%,100%,1,1,'if(y%2,y*w+w-1-x,y*w+x)<$8*wh/100' -*
-if {min(w,h)<140} -rr2d 140,140,1,1 -endif
-expand_xy 16,0
100%,100% -circle. 16,16,1%,1,1
-arrow3d. 0,0,0,{w/4},0,0,2%,15%,10% -col3d. 1 -j3d.. [-1],16,16,0,1,2,0,0 -rm.
--dilate. 3 -r.. 100%,100%,1,3,0,0,0,0,0,0.5 -a[-2,-1] c -*. 255
-blend alpha
-_gimp_intarsia $5,$6,1
-endl -done
_gimp_intarsia :
-if {$3" && "$2} -transpose -endif
-if {$1==0}
-elif {$1==1}
-mirror x
-elif {$1==2}
-mirror y
-elif {$1==3}
-mirror xy
-endif
-if {!$3" && "$2} -transpose -endif
gimp_solve_maze :
-repeat $!
--norm. ->=. 50%
-if {!$10} -negative. -endif
-*. 255 --b. $5% -*.. 1e10 -+[-2,-1]
-minimal_path. $1%,$2%,0,$3%,$4%,0
-pointcloud. 0 -dilate. $6 -r. [-2],[-2],1,1,0
-to_rgba.
-replace_color. 0,0,1,1,1,255,${7-9},255
-replace_color. 0,0,0,0,0,255,0,0,0,0
-ellipse. $1%,$2%,5,5,0,1,${7-9},255
-ellipse. $3%,$4%,5,5,0,1,${7-9},255
-rv[-2,-1]
-mv[-2,-1] 0 -done
gimp_solve_maze_preview :
-drgba
-line $1%,$2%,$3%,$4%,1,0xCCCCCCCC,${7-9}
-ellipse $1%,$2%,3,3,0,1,${7-9}
-ellipse $1%,$2%,3,3,0,1,0x1,0
-ellipse $3%,$4%,3,3,0,1,${7-9}
-ellipse $3%,$4%,3,3,0,1,0x1,0
gmicol_logo_en :
-gimp_logo_version{round(u(0.5,3.49))} "- Online -\n"[" "${-strver}" "]
gmicol_bokeh :
-repeat $! -l[$>] -gimp_bokeh $* -gimp_merge_layers -endl -done
gmicol_adjust_colors :
-repeat $! -l[$>]
avg={ia} -- $avg -* $1 -+ $avg
-+ {$2*256}
-if {$3!=1} -apply_gamma {10^$3} -endif
-if {$4%360}
-to_colormode {max(3,s)+1-s%2} -split_opacity -l[0]
-rgb2hsv -sh 0 -+. $4 -%. 360 -rm. -hsv2rgb
-endl
-a c -endif
-endl -done -c 0,255
gmicol_adjust_colors_preview :
-gimp_split_preview "-gmicol_adjust_colors $*",$-1
gmicol_crop :
-z $1%,$2%,$3%,$4%
gmicol_crop_preview :
-rectangle $1%,$2%,$3%,$4%,0.5,128
-rectangle $1%,$2%,$3%,$4%,1,0xFFFFFFFF,0
-circle $1%,$2%,3,1,0,255,0 -circle $1%,$2%,3,1,0xFFFFFFFF,0
-circle $3%,$2%,3,1,0,255,0 -circle $3%,$2%,3,1,0xFFFFFFFF,0
-circle $3%,$4%,3,1,0,255,0 -circle $3%,$4%,3,1,0xFFFFFFFF,0
-circle $1%,$4%,3,1,0,255,0 -circle $1%,$4%,3,1,0xFFFFFFFF,0
gmicol_equalize :
-apply_channels "-equalize 256,0,255",$1,2
gmicol_equalize_preview :
-gimp_split_preview "-gmicol_equalize $*",$-1
gmicol_flip :
-if $1 -mirror y -else -mirror x -endif
gmicol_histogram :
-to_rgb -dh 640,480,$1
gmicol_histogram_preview :
-to_rgb -dh 320,240,$1
gmicol_resize :
-if {$1==0}
-r $2%,$2%,1,100%,6
-elif {$1==1}
-resize2dx $3,6
-else
-resize2dy $4,6
-endif
-c 0,255
gmicol_rotate :
-if $2
-rotate {90*round($1/90)},0,0
-else
-to_rgba -rotate $1,1,$3
-endif
gmicol_light_leaks :
-gimp_light_leaks ${1--2},0,$-1
gmicol_light_leaks_preview :
-gimp_light_leaks_preview ${1--2},0,$-1
_gmicol_rgb_distribution :
-distribution3d -colorcube3d -p3d. 1 -+3d
-repeat 4
--snapshot3d[0] $1,0.9,255
-r3d[0] 0,1,0.2,90
-done
-rm[0] -autocrop -- 255
-r ${-max_wh},1,3,0,0,0.5,0.5 -+ 255 -frame 5,5,255 -frame 1,1,0 -append_tiles ,
gmicol_rgb_distribution :
-_gmicol_rgb_distribution 512
gmicol_rgb_distribution_preview :
-_gmicol_rgb_distribution 320
gmicol_animate_elevation3d :
-_gimp_elevation3d ${2-3}
-animate gimp_render3d,"${4-5},${7-16},$6",\
"${4-5},${17-26},$6",$1
-o $_output.gif,10
-rm
gmicol_animate_elevation3d_preview :
-gimp_animate_elevation3d_preview $1,1,0,\"\",${2--1}
gmicol_animate_extrude3d :
-gimp_animate_extrude3d $1,1,0,\"\",${2--1}
gmicol_animate_extrude3d_preview :
-gimp_animate_extrude3d_preview $1,1,0,\"\",${2--1}
gmicol_animate_imageobject3d :
-gimp_animate_imageobject3d $1,1,0,\"\",${2--1}
gmicol_animate_imageobject3d_preview :
-gimp_animate_imageobject3d_preview $1,1,0,\"\",${2--1}

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC update file)